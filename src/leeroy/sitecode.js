/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "158",
  CullFaceNone = 0,
  CullFaceBack = 1,
  CullFaceFront = 2,
  PCFShadowMap = 1,
  PCFSoftShadowMap = 2,
  VSMShadowMap = 3,
  FrontSide = 0,
  BackSide = 1,
  DoubleSide = 2,
  NoBlending = 0,
  NormalBlending = 1,
  AdditiveBlending = 2,
  SubtractiveBlending = 3,
  MultiplyBlending = 4,
  CustomBlending = 5,
  AddEquation = 100,
  SubtractEquation = 101,
  ReverseSubtractEquation = 102,
  MinEquation = 103,
  MaxEquation = 104,
  ZeroFactor = 200,
  OneFactor = 201,
  SrcColorFactor = 202,
  OneMinusSrcColorFactor = 203,
  SrcAlphaFactor = 204,
  OneMinusSrcAlphaFactor = 205,
  DstAlphaFactor = 206,
  OneMinusDstAlphaFactor = 207,
  DstColorFactor = 208,
  OneMinusDstColorFactor = 209,
  SrcAlphaSaturateFactor = 210,
  ConstantColorFactor = 211,
  OneMinusConstantColorFactor = 212,
  ConstantAlphaFactor = 213,
  OneMinusConstantAlphaFactor = 214,
  NeverDepth = 0,
  AlwaysDepth = 1,
  LessDepth = 2,
  LessEqualDepth = 3,
  EqualDepth = 4,
  GreaterEqualDepth = 5,
  GreaterDepth = 6,
  NotEqualDepth = 7,
  MultiplyOperation = 0,
  MixOperation = 1,
  AddOperation = 2,
  NoToneMapping = 0,
  LinearToneMapping = 1,
  ReinhardToneMapping = 2,
  CineonToneMapping = 3,
  ACESFilmicToneMapping = 4,
  CustomToneMapping = 5,
  UVMapping = 300,
  CubeReflectionMapping = 301,
  CubeRefractionMapping = 302,
  EquirectangularReflectionMapping = 303,
  EquirectangularRefractionMapping = 304,
  CubeUVReflectionMapping = 306,
  RepeatWrapping = 1e3,
  ClampToEdgeWrapping = 1001,
  MirroredRepeatWrapping = 1002,
  NearestFilter = 1003,
  NearestMipmapNearestFilter = 1004,
  NearestMipmapLinearFilter = 1005,
  LinearFilter = 1006,
  LinearMipmapNearestFilter = 1007,
  LinearMipmapLinearFilter = 1008,
  UnsignedByteType = 1009,
  ByteType = 1010,
  ShortType = 1011,
  UnsignedShortType = 1012,
  IntType = 1013,
  UnsignedIntType = 1014,
  FloatType = 1015,
  HalfFloatType = 1016,
  UnsignedShort4444Type = 1017,
  UnsignedShort5551Type = 1018,
  UnsignedInt248Type = 1020,
  AlphaFormat = 1021,
  RGBAFormat = 1023,
  LuminanceFormat = 1024,
  LuminanceAlphaFormat = 1025,
  DepthFormat = 1026,
  DepthStencilFormat = 1027,
  RedFormat = 1028,
  RedIntegerFormat = 1029,
  RGFormat = 1030,
  RGIntegerFormat = 1031,
  RGBAIntegerFormat = 1033,
  RGB_S3TC_DXT1_Format = 33776,
  RGBA_S3TC_DXT1_Format = 33777,
  RGBA_S3TC_DXT3_Format = 33778,
  RGBA_S3TC_DXT5_Format = 33779,
  RGB_PVRTC_4BPPV1_Format = 35840,
  RGB_PVRTC_2BPPV1_Format = 35841,
  RGBA_PVRTC_4BPPV1_Format = 35842,
  RGBA_PVRTC_2BPPV1_Format = 35843,
  RGB_ETC1_Format = 36196,
  RGB_ETC2_Format = 37492,
  RGBA_ETC2_EAC_Format = 37496,
  RGBA_ASTC_4x4_Format = 37808,
  RGBA_ASTC_5x4_Format = 37809,
  RGBA_ASTC_5x5_Format = 37810,
  RGBA_ASTC_6x5_Format = 37811,
  RGBA_ASTC_6x6_Format = 37812,
  RGBA_ASTC_8x5_Format = 37813,
  RGBA_ASTC_8x6_Format = 37814,
  RGBA_ASTC_8x8_Format = 37815,
  RGBA_ASTC_10x5_Format = 37816,
  RGBA_ASTC_10x6_Format = 37817,
  RGBA_ASTC_10x8_Format = 37818,
  RGBA_ASTC_10x10_Format = 37819,
  RGBA_ASTC_12x10_Format = 37820,
  RGBA_ASTC_12x12_Format = 37821,
  RGBA_BPTC_Format = 36492,
  RGB_BPTC_SIGNED_Format = 36494,
  RGB_BPTC_UNSIGNED_Format = 36495,
  RED_RGTC1_Format = 36283,
  SIGNED_RED_RGTC1_Format = 36284,
  RED_GREEN_RGTC2_Format = 36285,
  SIGNED_RED_GREEN_RGTC2_Format = 36286,
  LinearEncoding = 3e3,
  sRGBEncoding = 3001,
  BasicDepthPacking = 3200,
  RGBADepthPacking = 3201,
  TangentSpaceNormalMap = 0,
  ObjectSpaceNormalMap = 1,
  NoColorSpace = "",
  SRGBColorSpace = "srgb",
  LinearSRGBColorSpace = "srgb-linear",
  DisplayP3ColorSpace = "display-p3",
  LinearDisplayP3ColorSpace = "display-p3-linear",
  LinearTransfer = "linear",
  SRGBTransfer = "srgb",
  Rec709Primaries = "rec709",
  P3Primaries = "p3",
  KeepStencilOp = 7680,
  AlwaysStencilFunc = 519,
  NeverCompare = 512,
  LessCompare = 513,
  EqualCompare = 514,
  LessEqualCompare = 515,
  GreaterCompare = 516,
  NotEqualCompare = 517,
  GreaterEqualCompare = 518,
  AlwaysCompare = 519,
  StaticDrawUsage = 35044,
  GLSL3 = "300 es",
  _SRGBAFormat = 1035,
  WebGLCoordinateSystem = 2e3,
  WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(ze, Gr) {
    this._listeners === void 0 && (this._listeners = {});
    const Yr = this._listeners;
    Yr[ze] === void 0 && (Yr[ze] = []),
      Yr[ze].indexOf(Gr) === -1 && Yr[ze].push(Gr);
  }
  hasEventListener(ze, Gr) {
    if (this._listeners === void 0) return !1;
    const Yr = this._listeners;
    return Yr[ze] !== void 0 && Yr[ze].indexOf(Gr) !== -1;
  }
  removeEventListener(ze, Gr) {
    if (this._listeners === void 0) return;
    const Kr = this._listeners[ze];
    if (Kr !== void 0) {
      const Zr = Kr.indexOf(Gr);
      Zr !== -1 && Kr.splice(Zr, 1);
    }
  }
  dispatchEvent(ze) {
    if (this._listeners === void 0) return;
    const Yr = this._listeners[ze.type];
    if (Yr !== void 0) {
      ze.target = this;
      const Kr = Yr.slice(0);
      for (let Zr = 0, Jr = Kr.length; Zr < Jr; Zr++) Kr[Zr].call(this, ze);
      ze.target = null;
    }
  }
}
const _lut = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ],
  DEG2RAD = Math.PI / 180,
  RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const Wr = (Math.random() * 4294967295) | 0,
    ze = (Math.random() * 4294967295) | 0,
    Gr = (Math.random() * 4294967295) | 0,
    Yr = (Math.random() * 4294967295) | 0;
  return (
    _lut[Wr & 255] +
    _lut[(Wr >> 8) & 255] +
    _lut[(Wr >> 16) & 255] +
    _lut[(Wr >> 24) & 255] +
    "-" +
    _lut[ze & 255] +
    _lut[(ze >> 8) & 255] +
    "-" +
    _lut[((ze >> 16) & 15) | 64] +
    _lut[(ze >> 24) & 255] +
    "-" +
    _lut[(Gr & 63) | 128] +
    _lut[(Gr >> 8) & 255] +
    "-" +
    _lut[(Gr >> 16) & 255] +
    _lut[(Gr >> 24) & 255] +
    _lut[Yr & 255] +
    _lut[(Yr >> 8) & 255] +
    _lut[(Yr >> 16) & 255] +
    _lut[(Yr >> 24) & 255]
  ).toLowerCase();
}
function clamp(Wr, ze, Gr) {
  return Math.max(ze, Math.min(Gr, Wr));
}
function euclideanModulo(Wr, ze) {
  return ((Wr % ze) + ze) % ze;
}
function lerp(Wr, ze, Gr) {
  return (1 - Gr) * Wr + Gr * ze;
}
function isPowerOfTwo(Wr) {
  return (Wr & (Wr - 1)) === 0 && Wr !== 0;
}
function floorPowerOfTwo(Wr) {
  return Math.pow(2, Math.floor(Math.log(Wr) / Math.LN2));
}
function denormalize(Wr, ze) {
  switch (ze.constructor) {
    case Float32Array:
      return Wr;
    case Uint32Array:
      return Wr / 4294967295;
    case Uint16Array:
      return Wr / 65535;
    case Uint8Array:
      return Wr / 255;
    case Int32Array:
      return Math.max(Wr / 2147483647, -1);
    case Int16Array:
      return Math.max(Wr / 32767, -1);
    case Int8Array:
      return Math.max(Wr / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(Wr, ze) {
  switch (ze.constructor) {
    case Float32Array:
      return Wr;
    case Uint32Array:
      return Math.round(Wr * 4294967295);
    case Uint16Array:
      return Math.round(Wr * 65535);
    case Uint8Array:
      return Math.round(Wr * 255);
    case Int32Array:
      return Math.round(Wr * 2147483647);
    case Int16Array:
      return Math.round(Wr * 32767);
    case Int8Array:
      return Math.round(Wr * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
class Vector2 {
  constructor(ze = 0, Gr = 0) {
    (Vector2.prototype.isVector2 = !0), (this.x = ze), (this.y = Gr);
  }
  get width() {
    return this.x;
  }
  set width(ze) {
    this.x = ze;
  }
  get height() {
    return this.y;
  }
  set height(ze) {
    this.y = ze;
  }
  set(ze, Gr) {
    return (this.x = ze), (this.y = Gr), this;
  }
  setScalar(ze) {
    return (this.x = ze), (this.y = ze), this;
  }
  setX(ze) {
    return (this.x = ze), this;
  }
  setY(ze) {
    return (this.y = ze), this;
  }
  setComponent(ze, Gr) {
    switch (ze) {
      case 0:
        this.x = Gr;
        break;
      case 1:
        this.y = Gr;
        break;
      default:
        throw new Error("index is out of range: " + ze);
    }
    return this;
  }
  getComponent(ze) {
    switch (ze) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + ze);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(ze) {
    return (this.x = ze.x), (this.y = ze.y), this;
  }
  add(ze) {
    return (this.x += ze.x), (this.y += ze.y), this;
  }
  addScalar(ze) {
    return (this.x += ze), (this.y += ze), this;
  }
  addVectors(ze, Gr) {
    return (this.x = ze.x + Gr.x), (this.y = ze.y + Gr.y), this;
  }
  addScaledVector(ze, Gr) {
    return (this.x += ze.x * Gr), (this.y += ze.y * Gr), this;
  }
  sub(ze) {
    return (this.x -= ze.x), (this.y -= ze.y), this;
  }
  subScalar(ze) {
    return (this.x -= ze), (this.y -= ze), this;
  }
  subVectors(ze, Gr) {
    return (this.x = ze.x - Gr.x), (this.y = ze.y - Gr.y), this;
  }
  multiply(ze) {
    return (this.x *= ze.x), (this.y *= ze.y), this;
  }
  multiplyScalar(ze) {
    return (this.x *= ze), (this.y *= ze), this;
  }
  divide(ze) {
    return (this.x /= ze.x), (this.y /= ze.y), this;
  }
  divideScalar(ze) {
    return this.multiplyScalar(1 / ze);
  }
  applyMatrix3(ze) {
    const Gr = this.x,
      Yr = this.y,
      Kr = ze.elements;
    return (
      (this.x = Kr[0] * Gr + Kr[3] * Yr + Kr[6]),
      (this.y = Kr[1] * Gr + Kr[4] * Yr + Kr[7]),
      this
    );
  }
  min(ze) {
    return (
      (this.x = Math.min(this.x, ze.x)), (this.y = Math.min(this.y, ze.y)), this
    );
  }
  max(ze) {
    return (
      (this.x = Math.max(this.x, ze.x)), (this.y = Math.max(this.y, ze.y)), this
    );
  }
  clamp(ze, Gr) {
    return (
      (this.x = Math.max(ze.x, Math.min(Gr.x, this.x))),
      (this.y = Math.max(ze.y, Math.min(Gr.y, this.y))),
      this
    );
  }
  clampScalar(ze, Gr) {
    return (
      (this.x = Math.max(ze, Math.min(Gr, this.x))),
      (this.y = Math.max(ze, Math.min(Gr, this.y))),
      this
    );
  }
  clampLength(ze, Gr) {
    const Yr = this.length();
    return this.divideScalar(Yr || 1).multiplyScalar(
      Math.max(ze, Math.min(Gr, Yr))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(ze) {
    return this.x * ze.x + this.y * ze.y;
  }
  cross(ze) {
    return this.x * ze.y - this.y * ze.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(ze) {
    const Gr = Math.sqrt(this.lengthSq() * ze.lengthSq());
    if (Gr === 0) return Math.PI / 2;
    const Yr = this.dot(ze) / Gr;
    return Math.acos(clamp(Yr, -1, 1));
  }
  distanceTo(ze) {
    return Math.sqrt(this.distanceToSquared(ze));
  }
  distanceToSquared(ze) {
    const Gr = this.x - ze.x,
      Yr = this.y - ze.y;
    return Gr * Gr + Yr * Yr;
  }
  manhattanDistanceTo(ze) {
    return Math.abs(this.x - ze.x) + Math.abs(this.y - ze.y);
  }
  setLength(ze) {
    return this.normalize().multiplyScalar(ze);
  }
  lerp(ze, Gr) {
    return (
      (this.x += (ze.x - this.x) * Gr), (this.y += (ze.y - this.y) * Gr), this
    );
  }
  lerpVectors(ze, Gr, Yr) {
    return (
      (this.x = ze.x + (Gr.x - ze.x) * Yr),
      (this.y = ze.y + (Gr.y - ze.y) * Yr),
      this
    );
  }
  equals(ze) {
    return ze.x === this.x && ze.y === this.y;
  }
  fromArray(ze, Gr = 0) {
    return (this.x = ze[Gr]), (this.y = ze[Gr + 1]), this;
  }
  toArray(ze = [], Gr = 0) {
    return (ze[Gr] = this.x), (ze[Gr + 1] = this.y), ze;
  }
  fromBufferAttribute(ze, Gr) {
    return (this.x = ze.getX(Gr)), (this.y = ze.getY(Gr)), this;
  }
  rotateAround(ze, Gr) {
    const Yr = Math.cos(Gr),
      Kr = Math.sin(Gr),
      Zr = this.x - ze.x,
      Jr = this.y - ze.y;
    return (
      (this.x = Zr * Yr - Jr * Kr + ze.x),
      (this.y = Zr * Kr + Jr * Yr + ze.y),
      this
    );
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Matrix3 {
  constructor(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti) {
    (Matrix3.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      ze !== void 0 && this.set(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti);
  }
  set(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti) {
    const ri = this.elements;
    return (
      (ri[0] = ze),
      (ri[1] = Kr),
      (ri[2] = Qr),
      (ri[3] = Gr),
      (ri[4] = Zr),
      (ri[5] = ei),
      (ri[6] = Yr),
      (ri[7] = Jr),
      (ri[8] = ti),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(ze) {
    const Gr = this.elements,
      Yr = ze.elements;
    return (
      (Gr[0] = Yr[0]),
      (Gr[1] = Yr[1]),
      (Gr[2] = Yr[2]),
      (Gr[3] = Yr[3]),
      (Gr[4] = Yr[4]),
      (Gr[5] = Yr[5]),
      (Gr[6] = Yr[6]),
      (Gr[7] = Yr[7]),
      (Gr[8] = Yr[8]),
      this
    );
  }
  extractBasis(ze, Gr, Yr) {
    return (
      ze.setFromMatrix3Column(this, 0),
      Gr.setFromMatrix3Column(this, 1),
      Yr.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(ze) {
    const Gr = ze.elements;
    return (
      this.set(Gr[0], Gr[4], Gr[8], Gr[1], Gr[5], Gr[9], Gr[2], Gr[6], Gr[10]),
      this
    );
  }
  multiply(ze) {
    return this.multiplyMatrices(this, ze);
  }
  premultiply(ze) {
    return this.multiplyMatrices(ze, this);
  }
  multiplyMatrices(ze, Gr) {
    const Yr = ze.elements,
      Kr = Gr.elements,
      Zr = this.elements,
      Jr = Yr[0],
      Qr = Yr[3],
      ei = Yr[6],
      ti = Yr[1],
      ri = Yr[4],
      ni = Yr[7],
      ii = Yr[2],
      si = Yr[5],
      li = Yr[8],
      oi = Kr[0],
      ui = Kr[3],
      ai = Kr[6],
      hi = Kr[1],
      ci = Kr[4],
      fi = Kr[7],
      di = Kr[2],
      pi = Kr[5],
      mi = Kr[8];
    return (
      (Zr[0] = Jr * oi + Qr * hi + ei * di),
      (Zr[3] = Jr * ui + Qr * ci + ei * pi),
      (Zr[6] = Jr * ai + Qr * fi + ei * mi),
      (Zr[1] = ti * oi + ri * hi + ni * di),
      (Zr[4] = ti * ui + ri * ci + ni * pi),
      (Zr[7] = ti * ai + ri * fi + ni * mi),
      (Zr[2] = ii * oi + si * hi + li * di),
      (Zr[5] = ii * ui + si * ci + li * pi),
      (Zr[8] = ii * ai + si * fi + li * mi),
      this
    );
  }
  multiplyScalar(ze) {
    const Gr = this.elements;
    return (
      (Gr[0] *= ze),
      (Gr[3] *= ze),
      (Gr[6] *= ze),
      (Gr[1] *= ze),
      (Gr[4] *= ze),
      (Gr[7] *= ze),
      (Gr[2] *= ze),
      (Gr[5] *= ze),
      (Gr[8] *= ze),
      this
    );
  }
  determinant() {
    const ze = this.elements,
      Gr = ze[0],
      Yr = ze[1],
      Kr = ze[2],
      Zr = ze[3],
      Jr = ze[4],
      Qr = ze[5],
      ei = ze[6],
      ti = ze[7],
      ri = ze[8];
    return (
      Gr * Jr * ri -
      Gr * Qr * ti -
      Yr * Zr * ri +
      Yr * Qr * ei +
      Kr * Zr * ti -
      Kr * Jr * ei
    );
  }
  invert() {
    const ze = this.elements,
      Gr = ze[0],
      Yr = ze[1],
      Kr = ze[2],
      Zr = ze[3],
      Jr = ze[4],
      Qr = ze[5],
      ei = ze[6],
      ti = ze[7],
      ri = ze[8],
      ni = ri * Jr - Qr * ti,
      ii = Qr * ei - ri * Zr,
      si = ti * Zr - Jr * ei,
      li = Gr * ni + Yr * ii + Kr * si;
    if (li === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const oi = 1 / li;
    return (
      (ze[0] = ni * oi),
      (ze[1] = (Kr * ti - ri * Yr) * oi),
      (ze[2] = (Qr * Yr - Kr * Jr) * oi),
      (ze[3] = ii * oi),
      (ze[4] = (ri * Gr - Kr * ei) * oi),
      (ze[5] = (Kr * Zr - Qr * Gr) * oi),
      (ze[6] = si * oi),
      (ze[7] = (Yr * ei - ti * Gr) * oi),
      (ze[8] = (Jr * Gr - Yr * Zr) * oi),
      this
    );
  }
  transpose() {
    let ze;
    const Gr = this.elements;
    return (
      (ze = Gr[1]),
      (Gr[1] = Gr[3]),
      (Gr[3] = ze),
      (ze = Gr[2]),
      (Gr[2] = Gr[6]),
      (Gr[6] = ze),
      (ze = Gr[5]),
      (Gr[5] = Gr[7]),
      (Gr[7] = ze),
      this
    );
  }
  getNormalMatrix(ze) {
    return this.setFromMatrix4(ze).invert().transpose();
  }
  transposeIntoArray(ze) {
    const Gr = this.elements;
    return (
      (ze[0] = Gr[0]),
      (ze[1] = Gr[3]),
      (ze[2] = Gr[6]),
      (ze[3] = Gr[1]),
      (ze[4] = Gr[4]),
      (ze[5] = Gr[7]),
      (ze[6] = Gr[2]),
      (ze[7] = Gr[5]),
      (ze[8] = Gr[8]),
      this
    );
  }
  setUvTransform(ze, Gr, Yr, Kr, Zr, Jr, Qr) {
    const ei = Math.cos(Zr),
      ti = Math.sin(Zr);
    return (
      this.set(
        Yr * ei,
        Yr * ti,
        -Yr * (ei * Jr + ti * Qr) + Jr + ze,
        -Kr * ti,
        Kr * ei,
        -Kr * (-ti * Jr + ei * Qr) + Qr + Gr,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(ze, Gr) {
    return this.premultiply(_m3.makeScale(ze, Gr)), this;
  }
  rotate(ze) {
    return this.premultiply(_m3.makeRotation(-ze)), this;
  }
  translate(ze, Gr) {
    return this.premultiply(_m3.makeTranslation(ze, Gr)), this;
  }
  makeTranslation(ze, Gr) {
    return (
      ze.isVector2
        ? this.set(1, 0, ze.x, 0, 1, ze.y, 0, 0, 1)
        : this.set(1, 0, ze, 0, 1, Gr, 0, 0, 1),
      this
    );
  }
  makeRotation(ze) {
    const Gr = Math.cos(ze),
      Yr = Math.sin(ze);
    return this.set(Gr, -Yr, 0, Yr, Gr, 0, 0, 0, 1), this;
  }
  makeScale(ze, Gr) {
    return this.set(ze, 0, 0, 0, Gr, 0, 0, 0, 1), this;
  }
  equals(ze) {
    const Gr = this.elements,
      Yr = ze.elements;
    for (let Kr = 0; Kr < 9; Kr++) if (Gr[Kr] !== Yr[Kr]) return !1;
    return !0;
  }
  fromArray(ze, Gr = 0) {
    for (let Yr = 0; Yr < 9; Yr++) this.elements[Yr] = ze[Yr + Gr];
    return this;
  }
  toArray(ze = [], Gr = 0) {
    const Yr = this.elements;
    return (
      (ze[Gr] = Yr[0]),
      (ze[Gr + 1] = Yr[1]),
      (ze[Gr + 2] = Yr[2]),
      (ze[Gr + 3] = Yr[3]),
      (ze[Gr + 4] = Yr[4]),
      (ze[Gr + 5] = Yr[5]),
      (ze[Gr + 6] = Yr[6]),
      (ze[Gr + 7] = Yr[7]),
      (ze[Gr + 8] = Yr[8]),
      ze
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = new Matrix3();
function arrayNeedsUint32(Wr) {
  for (let ze = Wr.length - 1; ze >= 0; --ze) if (Wr[ze] >= 65535) return !0;
  return !1;
}
function createElementNS(Wr) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", Wr);
}
function createCanvasElement() {
  const Wr = createElementNS("canvas");
  return (Wr.style.display = "block"), Wr;
}
const _cache = {};
function warnOnce(Wr) {
  Wr in _cache || ((_cache[Wr] = !0), console.warn(Wr));
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  COLOR_SPACES = {
    [LinearSRGBColorSpace]: {
      transfer: LinearTransfer,
      primaries: Rec709Primaries,
      toReference: (Wr) => Wr,
      fromReference: (Wr) => Wr,
    },
    [SRGBColorSpace]: {
      transfer: SRGBTransfer,
      primaries: Rec709Primaries,
      toReference: (Wr) => Wr.convertSRGBToLinear(),
      fromReference: (Wr) => Wr.convertLinearToSRGB(),
    },
    [LinearDisplayP3ColorSpace]: {
      transfer: LinearTransfer,
      primaries: P3Primaries,
      toReference: (Wr) => Wr.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (Wr) => Wr.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3),
    },
    [DisplayP3ColorSpace]: {
      transfer: SRGBTransfer,
      primaries: P3Primaries,
      toReference: (Wr) =>
        Wr.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (Wr) =>
        Wr.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB(),
    },
  },
  SUPPORTED_WORKING_COLOR_SPACES = new Set([
    LinearSRGBColorSpace,
    LinearDisplayP3ColorSpace,
  ]),
  ColorManagement = {
    enabled: !0,
    _workingColorSpace: LinearSRGBColorSpace,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(Wr) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !Wr);
    },
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(Wr) {
      if (!SUPPORTED_WORKING_COLOR_SPACES.has(Wr))
        throw new Error(`Unsupported working color space, "${Wr}".`);
      this._workingColorSpace = Wr;
    },
    convert: function (Wr, ze, Gr) {
      if (this.enabled === !1 || ze === Gr || !ze || !Gr) return Wr;
      const Yr = COLOR_SPACES[ze].toReference,
        Kr = COLOR_SPACES[Gr].fromReference;
      return Kr(Yr(Wr));
    },
    fromWorkingColorSpace: function (Wr, ze) {
      return this.convert(Wr, this._workingColorSpace, ze);
    },
    toWorkingColorSpace: function (Wr, ze) {
      return this.convert(Wr, ze, this._workingColorSpace);
    },
    getPrimaries: function (Wr) {
      return COLOR_SPACES[Wr].primaries;
    },
    getTransfer: function (Wr) {
      return Wr === NoColorSpace ? LinearTransfer : COLOR_SPACES[Wr].transfer;
    },
  };
function SRGBToLinear(Wr) {
  return Wr < 0.04045
    ? Wr * 0.0773993808
    : Math.pow(Wr * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(Wr) {
  return Wr < 0.0031308 ? Wr * 12.92 : 1.055 * Math.pow(Wr, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(ze) {
    if (/^data:/i.test(ze.src) || typeof HTMLCanvasElement > "u") return ze.src;
    let Gr;
    if (ze instanceof HTMLCanvasElement) Gr = ze;
    else {
      _canvas === void 0 && (_canvas = createElementNS("canvas")),
        (_canvas.width = ze.width),
        (_canvas.height = ze.height);
      const Yr = _canvas.getContext("2d");
      ze instanceof ImageData
        ? Yr.putImageData(ze, 0, 0)
        : Yr.drawImage(ze, 0, 0, ze.width, ze.height),
        (Gr = _canvas);
    }
    return Gr.width > 2048 || Gr.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          ze
        ),
        Gr.toDataURL("image/jpeg", 0.6))
      : Gr.toDataURL("image/png");
  }
  static sRGBToLinear(ze) {
    if (
      (typeof HTMLImageElement < "u" && ze instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && ze instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && ze instanceof ImageBitmap)
    ) {
      const Gr = createElementNS("canvas");
      (Gr.width = ze.width), (Gr.height = ze.height);
      const Yr = Gr.getContext("2d");
      Yr.drawImage(ze, 0, 0, ze.width, ze.height);
      const Kr = Yr.getImageData(0, 0, ze.width, ze.height),
        Zr = Kr.data;
      for (let Jr = 0; Jr < Zr.length; Jr++)
        Zr[Jr] = SRGBToLinear(Zr[Jr] / 255) * 255;
      return Yr.putImageData(Kr, 0, 0), Gr;
    } else if (ze.data) {
      const Gr = ze.data.slice(0);
      for (let Yr = 0; Yr < Gr.length; Yr++)
        Gr instanceof Uint8Array || Gr instanceof Uint8ClampedArray
          ? (Gr[Yr] = Math.floor(SRGBToLinear(Gr[Yr] / 255) * 255))
          : (Gr[Yr] = SRGBToLinear(Gr[Yr]));
      return {
        data: Gr,
        width: ze.width,
        height: ze.height,
      };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        ze
      );
  }
}
let _sourceId = 0;
class Source {
  constructor(ze = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", {
        value: _sourceId++,
      }),
      (this.uuid = generateUUID()),
      (this.data = ze),
      (this.version = 0);
  }
  set needsUpdate(ze) {
    ze === !0 && this.version++;
  }
  toJSON(ze) {
    const Gr = ze === void 0 || typeof ze == "string";
    if (!Gr && ze.images[this.uuid] !== void 0) return ze.images[this.uuid];
    const Yr = {
        uuid: this.uuid,
        url: "",
      },
      Kr = this.data;
    if (Kr !== null) {
      let Zr;
      if (Array.isArray(Kr)) {
        Zr = [];
        for (let Jr = 0, Qr = Kr.length; Jr < Qr; Jr++)
          Kr[Jr].isDataTexture
            ? Zr.push(serializeImage(Kr[Jr].image))
            : Zr.push(serializeImage(Kr[Jr]));
      } else Zr = serializeImage(Kr);
      Yr.url = Zr;
    }
    return Gr || (ze.images[this.uuid] = Yr), Yr;
  }
}
function serializeImage(Wr) {
  return (typeof HTMLImageElement < "u" && Wr instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && Wr instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && Wr instanceof ImageBitmap)
    ? ImageUtils.getDataURL(Wr)
    : Wr.data
    ? {
        data: Array.from(Wr.data),
        width: Wr.width,
        height: Wr.height,
        type: Wr.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(
    ze = Texture.DEFAULT_IMAGE,
    Gr = Texture.DEFAULT_MAPPING,
    Yr = ClampToEdgeWrapping,
    Kr = ClampToEdgeWrapping,
    Zr = LinearFilter,
    Jr = LinearMipmapLinearFilter,
    Qr = RGBAFormat,
    ei = UnsignedByteType,
    ti = Texture.DEFAULT_ANISOTROPY,
    ri = NoColorSpace
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", {
        value: _textureId++,
      }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.source = new Source(ze)),
      (this.mipmaps = []),
      (this.mapping = Gr),
      (this.channel = 0),
      (this.wrapS = Yr),
      (this.wrapT = Kr),
      (this.magFilter = Zr),
      (this.minFilter = Jr),
      (this.anisotropy = ti),
      (this.format = Qr),
      (this.internalFormat = null),
      (this.type = ei),
      (this.offset = new Vector2(0, 0)),
      (this.repeat = new Vector2(1, 1)),
      (this.center = new Vector2(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Matrix3()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof ri == "string"
        ? (this.colorSpace = ri)
        : (warnOnce(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace =
            ri === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(ze = null) {
    this.source.data = ze;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(ze) {
    return (
      (this.name = ze.name),
      (this.source = ze.source),
      (this.mipmaps = ze.mipmaps.slice(0)),
      (this.mapping = ze.mapping),
      (this.channel = ze.channel),
      (this.wrapS = ze.wrapS),
      (this.wrapT = ze.wrapT),
      (this.magFilter = ze.magFilter),
      (this.minFilter = ze.minFilter),
      (this.anisotropy = ze.anisotropy),
      (this.format = ze.format),
      (this.internalFormat = ze.internalFormat),
      (this.type = ze.type),
      this.offset.copy(ze.offset),
      this.repeat.copy(ze.repeat),
      this.center.copy(ze.center),
      (this.rotation = ze.rotation),
      (this.matrixAutoUpdate = ze.matrixAutoUpdate),
      this.matrix.copy(ze.matrix),
      (this.generateMipmaps = ze.generateMipmaps),
      (this.premultiplyAlpha = ze.premultiplyAlpha),
      (this.flipY = ze.flipY),
      (this.unpackAlignment = ze.unpackAlignment),
      (this.colorSpace = ze.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(ze.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(ze) {
    const Gr = ze === void 0 || typeof ze == "string";
    if (!Gr && ze.textures[this.uuid] !== void 0) return ze.textures[this.uuid];
    const Yr = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON",
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(ze).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (Yr.userData = this.userData),
      Gr || (ze.textures[this.uuid] = Yr),
      Yr
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
  transformUv(ze) {
    if (this.mapping !== UVMapping) return ze;
    if ((ze.applyMatrix3(this.matrix), ze.x < 0 || ze.x > 1))
      switch (this.wrapS) {
        case RepeatWrapping:
          ze.x = ze.x - Math.floor(ze.x);
          break;
        case ClampToEdgeWrapping:
          ze.x = ze.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(ze.x) % 2) === 1
            ? (ze.x = Math.ceil(ze.x) - ze.x)
            : (ze.x = ze.x - Math.floor(ze.x));
          break;
      }
    if (ze.y < 0 || ze.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          ze.y = ze.y - Math.floor(ze.y);
          break;
        case ClampToEdgeWrapping:
          ze.y = ze.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(ze.y) % 2) === 1
            ? (ze.y = Math.ceil(ze.y) - ze.y)
            : (ze.y = ze.y - Math.floor(ze.y));
          break;
      }
    return this.flipY && (ze.y = 1 - ze.y), ze;
  }
  set needsUpdate(ze) {
    ze === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      warnOnce(
        "THREE.Texture: Property .encoding has been replaced by .colorSpace."
      ),
      this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding
    );
  }
  set encoding(ze) {
    warnOnce(
      "THREE.Texture: Property .encoding has been replaced by .colorSpace."
    ),
      (this.colorSpace = ze === sRGBEncoding ? SRGBColorSpace : NoColorSpace);
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(ze = 0, Gr = 0, Yr = 0, Kr = 1) {
    (Vector4.prototype.isVector4 = !0),
      (this.x = ze),
      (this.y = Gr),
      (this.z = Yr),
      (this.w = Kr);
  }
  get width() {
    return this.z;
  }
  set width(ze) {
    this.z = ze;
  }
  get height() {
    return this.w;
  }
  set height(ze) {
    this.w = ze;
  }
  set(ze, Gr, Yr, Kr) {
    return (this.x = ze), (this.y = Gr), (this.z = Yr), (this.w = Kr), this;
  }
  setScalar(ze) {
    return (this.x = ze), (this.y = ze), (this.z = ze), (this.w = ze), this;
  }
  setX(ze) {
    return (this.x = ze), this;
  }
  setY(ze) {
    return (this.y = ze), this;
  }
  setZ(ze) {
    return (this.z = ze), this;
  }
  setW(ze) {
    return (this.w = ze), this;
  }
  setComponent(ze, Gr) {
    switch (ze) {
      case 0:
        this.x = Gr;
        break;
      case 1:
        this.y = Gr;
        break;
      case 2:
        this.z = Gr;
        break;
      case 3:
        this.w = Gr;
        break;
      default:
        throw new Error("index is out of range: " + ze);
    }
    return this;
  }
  getComponent(ze) {
    switch (ze) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + ze);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(ze) {
    return (
      (this.x = ze.x),
      (this.y = ze.y),
      (this.z = ze.z),
      (this.w = ze.w !== void 0 ? ze.w : 1),
      this
    );
  }
  add(ze) {
    return (
      (this.x += ze.x),
      (this.y += ze.y),
      (this.z += ze.z),
      (this.w += ze.w),
      this
    );
  }
  addScalar(ze) {
    return (this.x += ze), (this.y += ze), (this.z += ze), (this.w += ze), this;
  }
  addVectors(ze, Gr) {
    return (
      (this.x = ze.x + Gr.x),
      (this.y = ze.y + Gr.y),
      (this.z = ze.z + Gr.z),
      (this.w = ze.w + Gr.w),
      this
    );
  }
  addScaledVector(ze, Gr) {
    return (
      (this.x += ze.x * Gr),
      (this.y += ze.y * Gr),
      (this.z += ze.z * Gr),
      (this.w += ze.w * Gr),
      this
    );
  }
  sub(ze) {
    return (
      (this.x -= ze.x),
      (this.y -= ze.y),
      (this.z -= ze.z),
      (this.w -= ze.w),
      this
    );
  }
  subScalar(ze) {
    return (this.x -= ze), (this.y -= ze), (this.z -= ze), (this.w -= ze), this;
  }
  subVectors(ze, Gr) {
    return (
      (this.x = ze.x - Gr.x),
      (this.y = ze.y - Gr.y),
      (this.z = ze.z - Gr.z),
      (this.w = ze.w - Gr.w),
      this
    );
  }
  multiply(ze) {
    return (
      (this.x *= ze.x),
      (this.y *= ze.y),
      (this.z *= ze.z),
      (this.w *= ze.w),
      this
    );
  }
  multiplyScalar(ze) {
    return (this.x *= ze), (this.y *= ze), (this.z *= ze), (this.w *= ze), this;
  }
  applyMatrix4(ze) {
    const Gr = this.x,
      Yr = this.y,
      Kr = this.z,
      Zr = this.w,
      Jr = ze.elements;
    return (
      (this.x = Jr[0] * Gr + Jr[4] * Yr + Jr[8] * Kr + Jr[12] * Zr),
      (this.y = Jr[1] * Gr + Jr[5] * Yr + Jr[9] * Kr + Jr[13] * Zr),
      (this.z = Jr[2] * Gr + Jr[6] * Yr + Jr[10] * Kr + Jr[14] * Zr),
      (this.w = Jr[3] * Gr + Jr[7] * Yr + Jr[11] * Kr + Jr[15] * Zr),
      this
    );
  }
  divideScalar(ze) {
    return this.multiplyScalar(1 / ze);
  }
  setAxisAngleFromQuaternion(ze) {
    this.w = 2 * Math.acos(ze.w);
    const Gr = Math.sqrt(1 - ze.w * ze.w);
    return (
      Gr < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = ze.x / Gr), (this.y = ze.y / Gr), (this.z = ze.z / Gr)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(ze) {
    let Gr, Yr, Kr, Zr;
    const ei = ze.elements,
      ti = ei[0],
      ri = ei[4],
      ni = ei[8],
      ii = ei[1],
      si = ei[5],
      li = ei[9],
      oi = ei[2],
      ui = ei[6],
      ai = ei[10];
    if (
      Math.abs(ri - ii) < 0.01 &&
      Math.abs(ni - oi) < 0.01 &&
      Math.abs(li - ui) < 0.01
    ) {
      if (
        Math.abs(ri + ii) < 0.1 &&
        Math.abs(ni + oi) < 0.1 &&
        Math.abs(li + ui) < 0.1 &&
        Math.abs(ti + si + ai - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      Gr = Math.PI;
      const ci = (ti + 1) / 2,
        fi = (si + 1) / 2,
        di = (ai + 1) / 2,
        pi = (ri + ii) / 4,
        mi = (ni + oi) / 4,
        Si = (li + ui) / 4;
      return (
        ci > fi && ci > di
          ? ci < 0.01
            ? ((Yr = 0), (Kr = 0.707106781), (Zr = 0.707106781))
            : ((Yr = Math.sqrt(ci)), (Kr = pi / Yr), (Zr = mi / Yr))
          : fi > di
          ? fi < 0.01
            ? ((Yr = 0.707106781), (Kr = 0), (Zr = 0.707106781))
            : ((Kr = Math.sqrt(fi)), (Yr = pi / Kr), (Zr = Si / Kr))
          : di < 0.01
          ? ((Yr = 0.707106781), (Kr = 0.707106781), (Zr = 0))
          : ((Zr = Math.sqrt(di)), (Yr = mi / Zr), (Kr = Si / Zr)),
        this.set(Yr, Kr, Zr, Gr),
        this
      );
    }
    let hi = Math.sqrt(
      (ui - li) * (ui - li) + (ni - oi) * (ni - oi) + (ii - ri) * (ii - ri)
    );
    return (
      Math.abs(hi) < 0.001 && (hi = 1),
      (this.x = (ui - li) / hi),
      (this.y = (ni - oi) / hi),
      (this.z = (ii - ri) / hi),
      (this.w = Math.acos((ti + si + ai - 1) / 2)),
      this
    );
  }
  min(ze) {
    return (
      (this.x = Math.min(this.x, ze.x)),
      (this.y = Math.min(this.y, ze.y)),
      (this.z = Math.min(this.z, ze.z)),
      (this.w = Math.min(this.w, ze.w)),
      this
    );
  }
  max(ze) {
    return (
      (this.x = Math.max(this.x, ze.x)),
      (this.y = Math.max(this.y, ze.y)),
      (this.z = Math.max(this.z, ze.z)),
      (this.w = Math.max(this.w, ze.w)),
      this
    );
  }
  clamp(ze, Gr) {
    return (
      (this.x = Math.max(ze.x, Math.min(Gr.x, this.x))),
      (this.y = Math.max(ze.y, Math.min(Gr.y, this.y))),
      (this.z = Math.max(ze.z, Math.min(Gr.z, this.z))),
      (this.w = Math.max(ze.w, Math.min(Gr.w, this.w))),
      this
    );
  }
  clampScalar(ze, Gr) {
    return (
      (this.x = Math.max(ze, Math.min(Gr, this.x))),
      (this.y = Math.max(ze, Math.min(Gr, this.y))),
      (this.z = Math.max(ze, Math.min(Gr, this.z))),
      (this.w = Math.max(ze, Math.min(Gr, this.w))),
      this
    );
  }
  clampLength(ze, Gr) {
    const Yr = this.length();
    return this.divideScalar(Yr || 1).multiplyScalar(
      Math.max(ze, Math.min(Gr, Yr))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(ze) {
    return this.x * ze.x + this.y * ze.y + this.z * ze.z + this.w * ze.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(ze) {
    return this.normalize().multiplyScalar(ze);
  }
  lerp(ze, Gr) {
    return (
      (this.x += (ze.x - this.x) * Gr),
      (this.y += (ze.y - this.y) * Gr),
      (this.z += (ze.z - this.z) * Gr),
      (this.w += (ze.w - this.w) * Gr),
      this
    );
  }
  lerpVectors(ze, Gr, Yr) {
    return (
      (this.x = ze.x + (Gr.x - ze.x) * Yr),
      (this.y = ze.y + (Gr.y - ze.y) * Yr),
      (this.z = ze.z + (Gr.z - ze.z) * Yr),
      (this.w = ze.w + (Gr.w - ze.w) * Yr),
      this
    );
  }
  equals(ze) {
    return (
      ze.x === this.x && ze.y === this.y && ze.z === this.z && ze.w === this.w
    );
  }
  fromArray(ze, Gr = 0) {
    return (
      (this.x = ze[Gr]),
      (this.y = ze[Gr + 1]),
      (this.z = ze[Gr + 2]),
      (this.w = ze[Gr + 3]),
      this
    );
  }
  toArray(ze = [], Gr = 0) {
    return (
      (ze[Gr] = this.x),
      (ze[Gr + 1] = this.y),
      (ze[Gr + 2] = this.z),
      (ze[Gr + 3] = this.w),
      ze
    );
  }
  fromBufferAttribute(ze, Gr) {
    return (
      (this.x = ze.getX(Gr)),
      (this.y = ze.getY(Gr)),
      (this.z = ze.getZ(Gr)),
      (this.w = ze.getW(Gr)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(ze = 1, Gr = 1, Yr = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = ze),
      (this.height = Gr),
      (this.depth = 1),
      (this.scissor = new Vector4(0, 0, ze, Gr)),
      (this.scissorTest = !1),
      (this.viewport = new Vector4(0, 0, ze, Gr));
    const Kr = {
      width: ze,
      height: Gr,
      depth: 1,
    };
    Yr.encoding !== void 0 &&
      (warnOnce(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (Yr.colorSpace =
        Yr.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (Yr = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: LinearFilter,
          depthBuffer: !0,
          stencilBuffer: !1,
          depthTexture: null,
          samples: 0,
        },
        Yr
      )),
      (this.texture = new Texture(
        Kr,
        Yr.mapping,
        Yr.wrapS,
        Yr.wrapT,
        Yr.magFilter,
        Yr.minFilter,
        Yr.format,
        Yr.type,
        Yr.anisotropy,
        Yr.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = Yr.generateMipmaps),
      (this.texture.internalFormat = Yr.internalFormat),
      (this.depthBuffer = Yr.depthBuffer),
      (this.stencilBuffer = Yr.stencilBuffer),
      (this.depthTexture = Yr.depthTexture),
      (this.samples = Yr.samples);
  }
  setSize(ze, Gr, Yr = 1) {
    (this.width !== ze || this.height !== Gr || this.depth !== Yr) &&
      ((this.width = ze),
      (this.height = Gr),
      (this.depth = Yr),
      (this.texture.image.width = ze),
      (this.texture.image.height = Gr),
      (this.texture.image.depth = Yr),
      this.dispose()),
      this.viewport.set(0, 0, ze, Gr),
      this.scissor.set(0, 0, ze, Gr);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(ze) {
    (this.width = ze.width),
      (this.height = ze.height),
      (this.depth = ze.depth),
      this.scissor.copy(ze.scissor),
      (this.scissorTest = ze.scissorTest),
      this.viewport.copy(ze.viewport),
      (this.texture = ze.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const Gr = Object.assign({}, ze.texture.image);
    return (
      (this.texture.source = new Source(Gr)),
      (this.depthBuffer = ze.depthBuffer),
      (this.stencilBuffer = ze.stencilBuffer),
      ze.depthTexture !== null && (this.depthTexture = ze.depthTexture.clone()),
      (this.samples = ze.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(ze = 1, Gr = 1, Yr = {}) {
    super(ze, Gr, Yr), (this.isWebGLRenderTarget = !0);
  }
}
class DataArrayTexture extends Texture {
  constructor(ze = null, Gr = 1, Yr = 1, Kr = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = {
        data: ze,
        width: Gr,
        height: Yr,
        depth: Kr,
      }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Data3DTexture extends Texture {
  constructor(ze = null, Gr = 1, Yr = 1, Kr = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = {
        data: ze,
        width: Gr,
        height: Yr,
        depth: Kr,
      }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Quaternion {
  constructor(ze = 0, Gr = 0, Yr = 0, Kr = 1) {
    (this.isQuaternion = !0),
      (this._x = ze),
      (this._y = Gr),
      (this._z = Yr),
      (this._w = Kr);
  }
  static slerpFlat(ze, Gr, Yr, Kr, Zr, Jr, Qr) {
    let ei = Yr[Kr + 0],
      ti = Yr[Kr + 1],
      ri = Yr[Kr + 2],
      ni = Yr[Kr + 3];
    const ii = Zr[Jr + 0],
      si = Zr[Jr + 1],
      li = Zr[Jr + 2],
      oi = Zr[Jr + 3];
    if (Qr === 0) {
      (ze[Gr + 0] = ei),
        (ze[Gr + 1] = ti),
        (ze[Gr + 2] = ri),
        (ze[Gr + 3] = ni);
      return;
    }
    if (Qr === 1) {
      (ze[Gr + 0] = ii),
        (ze[Gr + 1] = si),
        (ze[Gr + 2] = li),
        (ze[Gr + 3] = oi);
      return;
    }
    if (ni !== oi || ei !== ii || ti !== si || ri !== li) {
      let ui = 1 - Qr;
      const ai = ei * ii + ti * si + ri * li + ni * oi,
        hi = ai >= 0 ? 1 : -1,
        ci = 1 - ai * ai;
      if (ci > Number.EPSILON) {
        const di = Math.sqrt(ci),
          pi = Math.atan2(di, ai * hi);
        (ui = Math.sin(ui * pi) / di), (Qr = Math.sin(Qr * pi) / di);
      }
      const fi = Qr * hi;
      if (
        ((ei = ei * ui + ii * fi),
        (ti = ti * ui + si * fi),
        (ri = ri * ui + li * fi),
        (ni = ni * ui + oi * fi),
        ui === 1 - Qr)
      ) {
        const di = 1 / Math.sqrt(ei * ei + ti * ti + ri * ri + ni * ni);
        (ei *= di), (ti *= di), (ri *= di), (ni *= di);
      }
    }
    (ze[Gr] = ei), (ze[Gr + 1] = ti), (ze[Gr + 2] = ri), (ze[Gr + 3] = ni);
  }
  static multiplyQuaternionsFlat(ze, Gr, Yr, Kr, Zr, Jr) {
    const Qr = Yr[Kr],
      ei = Yr[Kr + 1],
      ti = Yr[Kr + 2],
      ri = Yr[Kr + 3],
      ni = Zr[Jr],
      ii = Zr[Jr + 1],
      si = Zr[Jr + 2],
      li = Zr[Jr + 3];
    return (
      (ze[Gr] = Qr * li + ri * ni + ei * si - ti * ii),
      (ze[Gr + 1] = ei * li + ri * ii + ti * ni - Qr * si),
      (ze[Gr + 2] = ti * li + ri * si + Qr * ii - ei * ni),
      (ze[Gr + 3] = ri * li - Qr * ni - ei * ii - ti * si),
      ze
    );
  }
  get x() {
    return this._x;
  }
  set x(ze) {
    (this._x = ze), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(ze) {
    (this._y = ze), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(ze) {
    (this._z = ze), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(ze) {
    (this._w = ze), this._onChangeCallback();
  }
  set(ze, Gr, Yr, Kr) {
    return (
      (this._x = ze),
      (this._y = Gr),
      (this._z = Yr),
      (this._w = Kr),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(ze) {
    return (
      (this._x = ze.x),
      (this._y = ze.y),
      (this._z = ze.z),
      (this._w = ze.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(ze, Gr) {
    const Yr = ze._x,
      Kr = ze._y,
      Zr = ze._z,
      Jr = ze._order,
      Qr = Math.cos,
      ei = Math.sin,
      ti = Qr(Yr / 2),
      ri = Qr(Kr / 2),
      ni = Qr(Zr / 2),
      ii = ei(Yr / 2),
      si = ei(Kr / 2),
      li = ei(Zr / 2);
    switch (Jr) {
      case "XYZ":
        (this._x = ii * ri * ni + ti * si * li),
          (this._y = ti * si * ni - ii * ri * li),
          (this._z = ti * ri * li + ii * si * ni),
          (this._w = ti * ri * ni - ii * si * li);
        break;
      case "YXZ":
        (this._x = ii * ri * ni + ti * si * li),
          (this._y = ti * si * ni - ii * ri * li),
          (this._z = ti * ri * li - ii * si * ni),
          (this._w = ti * ri * ni + ii * si * li);
        break;
      case "ZXY":
        (this._x = ii * ri * ni - ti * si * li),
          (this._y = ti * si * ni + ii * ri * li),
          (this._z = ti * ri * li + ii * si * ni),
          (this._w = ti * ri * ni - ii * si * li);
        break;
      case "ZYX":
        (this._x = ii * ri * ni - ti * si * li),
          (this._y = ti * si * ni + ii * ri * li),
          (this._z = ti * ri * li - ii * si * ni),
          (this._w = ti * ri * ni + ii * si * li);
        break;
      case "YZX":
        (this._x = ii * ri * ni + ti * si * li),
          (this._y = ti * si * ni + ii * ri * li),
          (this._z = ti * ri * li - ii * si * ni),
          (this._w = ti * ri * ni - ii * si * li);
        break;
      case "XZY":
        (this._x = ii * ri * ni - ti * si * li),
          (this._y = ti * si * ni - ii * ri * li),
          (this._z = ti * ri * li + ii * si * ni),
          (this._w = ti * ri * ni + ii * si * li);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            Jr
        );
    }
    return Gr !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(ze, Gr) {
    const Yr = Gr / 2,
      Kr = Math.sin(Yr);
    return (
      (this._x = ze.x * Kr),
      (this._y = ze.y * Kr),
      (this._z = ze.z * Kr),
      (this._w = Math.cos(Yr)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(ze) {
    const Gr = ze.elements,
      Yr = Gr[0],
      Kr = Gr[4],
      Zr = Gr[8],
      Jr = Gr[1],
      Qr = Gr[5],
      ei = Gr[9],
      ti = Gr[2],
      ri = Gr[6],
      ni = Gr[10],
      ii = Yr + Qr + ni;
    if (ii > 0) {
      const si = 0.5 / Math.sqrt(ii + 1);
      (this._w = 0.25 / si),
        (this._x = (ri - ei) * si),
        (this._y = (Zr - ti) * si),
        (this._z = (Jr - Kr) * si);
    } else if (Yr > Qr && Yr > ni) {
      const si = 2 * Math.sqrt(1 + Yr - Qr - ni);
      (this._w = (ri - ei) / si),
        (this._x = 0.25 * si),
        (this._y = (Kr + Jr) / si),
        (this._z = (Zr + ti) / si);
    } else if (Qr > ni) {
      const si = 2 * Math.sqrt(1 + Qr - Yr - ni);
      (this._w = (Zr - ti) / si),
        (this._x = (Kr + Jr) / si),
        (this._y = 0.25 * si),
        (this._z = (ei + ri) / si);
    } else {
      const si = 2 * Math.sqrt(1 + ni - Yr - Qr);
      (this._w = (Jr - Kr) / si),
        (this._x = (Zr + ti) / si),
        (this._y = (ei + ri) / si),
        (this._z = 0.25 * si);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(ze, Gr) {
    let Yr = ze.dot(Gr) + 1;
    return (
      Yr < Number.EPSILON
        ? ((Yr = 0),
          Math.abs(ze.x) > Math.abs(ze.z)
            ? ((this._x = -ze.y),
              (this._y = ze.x),
              (this._z = 0),
              (this._w = Yr))
            : ((this._x = 0),
              (this._y = -ze.z),
              (this._z = ze.y),
              (this._w = Yr)))
        : ((this._x = ze.y * Gr.z - ze.z * Gr.y),
          (this._y = ze.z * Gr.x - ze.x * Gr.z),
          (this._z = ze.x * Gr.y - ze.y * Gr.x),
          (this._w = Yr)),
      this.normalize()
    );
  }
  angleTo(ze) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(ze), -1, 1)));
  }
  rotateTowards(ze, Gr) {
    const Yr = this.angleTo(ze);
    if (Yr === 0) return this;
    const Kr = Math.min(1, Gr / Yr);
    return this.slerp(ze, Kr), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(ze) {
    return (
      this._x * ze._x + this._y * ze._y + this._z * ze._z + this._w * ze._w
    );
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let ze = this.length();
    return (
      ze === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((ze = 1 / ze),
          (this._x = this._x * ze),
          (this._y = this._y * ze),
          (this._z = this._z * ze),
          (this._w = this._w * ze)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(ze) {
    return this.multiplyQuaternions(this, ze);
  }
  premultiply(ze) {
    return this.multiplyQuaternions(ze, this);
  }
  multiplyQuaternions(ze, Gr) {
    const Yr = ze._x,
      Kr = ze._y,
      Zr = ze._z,
      Jr = ze._w,
      Qr = Gr._x,
      ei = Gr._y,
      ti = Gr._z,
      ri = Gr._w;
    return (
      (this._x = Yr * ri + Jr * Qr + Kr * ti - Zr * ei),
      (this._y = Kr * ri + Jr * ei + Zr * Qr - Yr * ti),
      (this._z = Zr * ri + Jr * ti + Yr * ei - Kr * Qr),
      (this._w = Jr * ri - Yr * Qr - Kr * ei - Zr * ti),
      this._onChangeCallback(),
      this
    );
  }
  slerp(ze, Gr) {
    if (Gr === 0) return this;
    if (Gr === 1) return this.copy(ze);
    const Yr = this._x,
      Kr = this._y,
      Zr = this._z,
      Jr = this._w;
    let Qr = Jr * ze._w + Yr * ze._x + Kr * ze._y + Zr * ze._z;
    if (
      (Qr < 0
        ? ((this._w = -ze._w),
          (this._x = -ze._x),
          (this._y = -ze._y),
          (this._z = -ze._z),
          (Qr = -Qr))
        : this.copy(ze),
      Qr >= 1)
    )
      return (
        (this._w = Jr), (this._x = Yr), (this._y = Kr), (this._z = Zr), this
      );
    const ei = 1 - Qr * Qr;
    if (ei <= Number.EPSILON) {
      const si = 1 - Gr;
      return (
        (this._w = si * Jr + Gr * this._w),
        (this._x = si * Yr + Gr * this._x),
        (this._y = si * Kr + Gr * this._y),
        (this._z = si * Zr + Gr * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const ti = Math.sqrt(ei),
      ri = Math.atan2(ti, Qr),
      ni = Math.sin((1 - Gr) * ri) / ti,
      ii = Math.sin(Gr * ri) / ti;
    return (
      (this._w = Jr * ni + this._w * ii),
      (this._x = Yr * ni + this._x * ii),
      (this._y = Kr * ni + this._y * ii),
      (this._z = Zr * ni + this._z * ii),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(ze, Gr, Yr) {
    return this.copy(ze).slerp(Gr, Yr);
  }
  random() {
    const ze = Math.random(),
      Gr = Math.sqrt(1 - ze),
      Yr = Math.sqrt(ze),
      Kr = 2 * Math.PI * Math.random(),
      Zr = 2 * Math.PI * Math.random();
    return this.set(
      Gr * Math.cos(Kr),
      Yr * Math.sin(Zr),
      Yr * Math.cos(Zr),
      Gr * Math.sin(Kr)
    );
  }
  equals(ze) {
    return (
      ze._x === this._x &&
      ze._y === this._y &&
      ze._z === this._z &&
      ze._w === this._w
    );
  }
  fromArray(ze, Gr = 0) {
    return (
      (this._x = ze[Gr]),
      (this._y = ze[Gr + 1]),
      (this._z = ze[Gr + 2]),
      (this._w = ze[Gr + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(ze = [], Gr = 0) {
    return (
      (ze[Gr] = this._x),
      (ze[Gr + 1] = this._y),
      (ze[Gr + 2] = this._z),
      (ze[Gr + 3] = this._w),
      ze
    );
  }
  fromBufferAttribute(ze, Gr) {
    return (
      (this._x = ze.getX(Gr)),
      (this._y = ze.getY(Gr)),
      (this._z = ze.getZ(Gr)),
      (this._w = ze.getW(Gr)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(ze) {
    return (this._onChangeCallback = ze), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Vector3 {
  constructor(ze = 0, Gr = 0, Yr = 0) {
    (Vector3.prototype.isVector3 = !0),
      (this.x = ze),
      (this.y = Gr),
      (this.z = Yr);
  }
  set(ze, Gr, Yr) {
    return (
      Yr === void 0 && (Yr = this.z),
      (this.x = ze),
      (this.y = Gr),
      (this.z = Yr),
      this
    );
  }
  setScalar(ze) {
    return (this.x = ze), (this.y = ze), (this.z = ze), this;
  }
  setX(ze) {
    return (this.x = ze), this;
  }
  setY(ze) {
    return (this.y = ze), this;
  }
  setZ(ze) {
    return (this.z = ze), this;
  }
  setComponent(ze, Gr) {
    switch (ze) {
      case 0:
        this.x = Gr;
        break;
      case 1:
        this.y = Gr;
        break;
      case 2:
        this.z = Gr;
        break;
      default:
        throw new Error("index is out of range: " + ze);
    }
    return this;
  }
  getComponent(ze) {
    switch (ze) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + ze);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(ze) {
    return (this.x = ze.x), (this.y = ze.y), (this.z = ze.z), this;
  }
  add(ze) {
    return (this.x += ze.x), (this.y += ze.y), (this.z += ze.z), this;
  }
  addScalar(ze) {
    return (this.x += ze), (this.y += ze), (this.z += ze), this;
  }
  addVectors(ze, Gr) {
    return (
      (this.x = ze.x + Gr.x),
      (this.y = ze.y + Gr.y),
      (this.z = ze.z + Gr.z),
      this
    );
  }
  addScaledVector(ze, Gr) {
    return (
      (this.x += ze.x * Gr), (this.y += ze.y * Gr), (this.z += ze.z * Gr), this
    );
  }
  sub(ze) {
    return (this.x -= ze.x), (this.y -= ze.y), (this.z -= ze.z), this;
  }
  subScalar(ze) {
    return (this.x -= ze), (this.y -= ze), (this.z -= ze), this;
  }
  subVectors(ze, Gr) {
    return (
      (this.x = ze.x - Gr.x),
      (this.y = ze.y - Gr.y),
      (this.z = ze.z - Gr.z),
      this
    );
  }
  multiply(ze) {
    return (this.x *= ze.x), (this.y *= ze.y), (this.z *= ze.z), this;
  }
  multiplyScalar(ze) {
    return (this.x *= ze), (this.y *= ze), (this.z *= ze), this;
  }
  multiplyVectors(ze, Gr) {
    return (
      (this.x = ze.x * Gr.x),
      (this.y = ze.y * Gr.y),
      (this.z = ze.z * Gr.z),
      this
    );
  }
  applyEuler(ze) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(ze));
  }
  applyAxisAngle(ze, Gr) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(ze, Gr));
  }
  applyMatrix3(ze) {
    const Gr = this.x,
      Yr = this.y,
      Kr = this.z,
      Zr = ze.elements;
    return (
      (this.x = Zr[0] * Gr + Zr[3] * Yr + Zr[6] * Kr),
      (this.y = Zr[1] * Gr + Zr[4] * Yr + Zr[7] * Kr),
      (this.z = Zr[2] * Gr + Zr[5] * Yr + Zr[8] * Kr),
      this
    );
  }
  applyNormalMatrix(ze) {
    return this.applyMatrix3(ze).normalize();
  }
  applyMatrix4(ze) {
    const Gr = this.x,
      Yr = this.y,
      Kr = this.z,
      Zr = ze.elements,
      Jr = 1 / (Zr[3] * Gr + Zr[7] * Yr + Zr[11] * Kr + Zr[15]);
    return (
      (this.x = (Zr[0] * Gr + Zr[4] * Yr + Zr[8] * Kr + Zr[12]) * Jr),
      (this.y = (Zr[1] * Gr + Zr[5] * Yr + Zr[9] * Kr + Zr[13]) * Jr),
      (this.z = (Zr[2] * Gr + Zr[6] * Yr + Zr[10] * Kr + Zr[14]) * Jr),
      this
    );
  }
  applyQuaternion(ze) {
    const Gr = this.x,
      Yr = this.y,
      Kr = this.z,
      Zr = ze.x,
      Jr = ze.y,
      Qr = ze.z,
      ei = ze.w,
      ti = 2 * (Jr * Kr - Qr * Yr),
      ri = 2 * (Qr * Gr - Zr * Kr),
      ni = 2 * (Zr * Yr - Jr * Gr);
    return (
      (this.x = Gr + ei * ti + Jr * ni - Qr * ri),
      (this.y = Yr + ei * ri + Qr * ti - Zr * ni),
      (this.z = Kr + ei * ni + Zr * ri - Jr * ti),
      this
    );
  }
  project(ze) {
    return this.applyMatrix4(ze.matrixWorldInverse).applyMatrix4(
      ze.projectionMatrix
    );
  }
  unproject(ze) {
    return this.applyMatrix4(ze.projectionMatrixInverse).applyMatrix4(
      ze.matrixWorld
    );
  }
  transformDirection(ze) {
    const Gr = this.x,
      Yr = this.y,
      Kr = this.z,
      Zr = ze.elements;
    return (
      (this.x = Zr[0] * Gr + Zr[4] * Yr + Zr[8] * Kr),
      (this.y = Zr[1] * Gr + Zr[5] * Yr + Zr[9] * Kr),
      (this.z = Zr[2] * Gr + Zr[6] * Yr + Zr[10] * Kr),
      this.normalize()
    );
  }
  divide(ze) {
    return (this.x /= ze.x), (this.y /= ze.y), (this.z /= ze.z), this;
  }
  divideScalar(ze) {
    return this.multiplyScalar(1 / ze);
  }
  min(ze) {
    return (
      (this.x = Math.min(this.x, ze.x)),
      (this.y = Math.min(this.y, ze.y)),
      (this.z = Math.min(this.z, ze.z)),
      this
    );
  }
  max(ze) {
    return (
      (this.x = Math.max(this.x, ze.x)),
      (this.y = Math.max(this.y, ze.y)),
      (this.z = Math.max(this.z, ze.z)),
      this
    );
  }
  clamp(ze, Gr) {
    return (
      (this.x = Math.max(ze.x, Math.min(Gr.x, this.x))),
      (this.y = Math.max(ze.y, Math.min(Gr.y, this.y))),
      (this.z = Math.max(ze.z, Math.min(Gr.z, this.z))),
      this
    );
  }
  clampScalar(ze, Gr) {
    return (
      (this.x = Math.max(ze, Math.min(Gr, this.x))),
      (this.y = Math.max(ze, Math.min(Gr, this.y))),
      (this.z = Math.max(ze, Math.min(Gr, this.z))),
      this
    );
  }
  clampLength(ze, Gr) {
    const Yr = this.length();
    return this.divideScalar(Yr || 1).multiplyScalar(
      Math.max(ze, Math.min(Gr, Yr))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(ze) {
    return this.x * ze.x + this.y * ze.y + this.z * ze.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(ze) {
    return this.normalize().multiplyScalar(ze);
  }
  lerp(ze, Gr) {
    return (
      (this.x += (ze.x - this.x) * Gr),
      (this.y += (ze.y - this.y) * Gr),
      (this.z += (ze.z - this.z) * Gr),
      this
    );
  }
  lerpVectors(ze, Gr, Yr) {
    return (
      (this.x = ze.x + (Gr.x - ze.x) * Yr),
      (this.y = ze.y + (Gr.y - ze.y) * Yr),
      (this.z = ze.z + (Gr.z - ze.z) * Yr),
      this
    );
  }
  cross(ze) {
    return this.crossVectors(this, ze);
  }
  crossVectors(ze, Gr) {
    const Yr = ze.x,
      Kr = ze.y,
      Zr = ze.z,
      Jr = Gr.x,
      Qr = Gr.y,
      ei = Gr.z;
    return (
      (this.x = Kr * ei - Zr * Qr),
      (this.y = Zr * Jr - Yr * ei),
      (this.z = Yr * Qr - Kr * Jr),
      this
    );
  }
  projectOnVector(ze) {
    const Gr = ze.lengthSq();
    if (Gr === 0) return this.set(0, 0, 0);
    const Yr = ze.dot(this) / Gr;
    return this.copy(ze).multiplyScalar(Yr);
  }
  projectOnPlane(ze) {
    return _vector$b.copy(this).projectOnVector(ze), this.sub(_vector$b);
  }
  reflect(ze) {
    return this.sub(_vector$b.copy(ze).multiplyScalar(2 * this.dot(ze)));
  }
  angleTo(ze) {
    const Gr = Math.sqrt(this.lengthSq() * ze.lengthSq());
    if (Gr === 0) return Math.PI / 2;
    const Yr = this.dot(ze) / Gr;
    return Math.acos(clamp(Yr, -1, 1));
  }
  distanceTo(ze) {
    return Math.sqrt(this.distanceToSquared(ze));
  }
  distanceToSquared(ze) {
    const Gr = this.x - ze.x,
      Yr = this.y - ze.y,
      Kr = this.z - ze.z;
    return Gr * Gr + Yr * Yr + Kr * Kr;
  }
  manhattanDistanceTo(ze) {
    return (
      Math.abs(this.x - ze.x) +
      Math.abs(this.y - ze.y) +
      Math.abs(this.z - ze.z)
    );
  }
  setFromSpherical(ze) {
    return this.setFromSphericalCoords(ze.radius, ze.phi, ze.theta);
  }
  setFromSphericalCoords(ze, Gr, Yr) {
    const Kr = Math.sin(Gr) * ze;
    return (
      (this.x = Kr * Math.sin(Yr)),
      (this.y = Math.cos(Gr) * ze),
      (this.z = Kr * Math.cos(Yr)),
      this
    );
  }
  setFromCylindrical(ze) {
    return this.setFromCylindricalCoords(ze.radius, ze.theta, ze.y);
  }
  setFromCylindricalCoords(ze, Gr, Yr) {
    return (
      (this.x = ze * Math.sin(Gr)),
      (this.y = Yr),
      (this.z = ze * Math.cos(Gr)),
      this
    );
  }
  setFromMatrixPosition(ze) {
    const Gr = ze.elements;
    return (this.x = Gr[12]), (this.y = Gr[13]), (this.z = Gr[14]), this;
  }
  setFromMatrixScale(ze) {
    const Gr = this.setFromMatrixColumn(ze, 0).length(),
      Yr = this.setFromMatrixColumn(ze, 1).length(),
      Kr = this.setFromMatrixColumn(ze, 2).length();
    return (this.x = Gr), (this.y = Yr), (this.z = Kr), this;
  }
  setFromMatrixColumn(ze, Gr) {
    return this.fromArray(ze.elements, Gr * 4);
  }
  setFromMatrix3Column(ze, Gr) {
    return this.fromArray(ze.elements, Gr * 3);
  }
  setFromEuler(ze) {
    return (this.x = ze._x), (this.y = ze._y), (this.z = ze._z), this;
  }
  setFromColor(ze) {
    return (this.x = ze.r), (this.y = ze.g), (this.z = ze.b), this;
  }
  equals(ze) {
    return ze.x === this.x && ze.y === this.y && ze.z === this.z;
  }
  fromArray(ze, Gr = 0) {
    return (
      (this.x = ze[Gr]), (this.y = ze[Gr + 1]), (this.z = ze[Gr + 2]), this
    );
  }
  toArray(ze = [], Gr = 0) {
    return (ze[Gr] = this.x), (ze[Gr + 1] = this.y), (ze[Gr + 2] = this.z), ze;
  }
  fromBufferAttribute(ze, Gr) {
    return (
      (this.x = ze.getX(Gr)),
      (this.y = ze.getY(Gr)),
      (this.z = ze.getZ(Gr)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const ze = (Math.random() - 0.5) * 2,
      Gr = Math.random() * Math.PI * 2,
      Yr = Math.sqrt(1 - ze ** 2);
    return (
      (this.x = Yr * Math.cos(Gr)),
      (this.y = Yr * Math.sin(Gr)),
      (this.z = ze),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _vector$b = new Vector3(),
  _quaternion$4 = new Quaternion();
class Box3 {
  constructor(
    ze = new Vector3(1 / 0, 1 / 0, 1 / 0),
    Gr = new Vector3(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = ze), (this.max = Gr);
  }
  set(ze, Gr) {
    return this.min.copy(ze), this.max.copy(Gr), this;
  }
  setFromArray(ze) {
    this.makeEmpty();
    for (let Gr = 0, Yr = ze.length; Gr < Yr; Gr += 3)
      this.expandByPoint(_vector$a.fromArray(ze, Gr));
    return this;
  }
  setFromBufferAttribute(ze) {
    this.makeEmpty();
    for (let Gr = 0, Yr = ze.count; Gr < Yr; Gr++)
      this.expandByPoint(_vector$a.fromBufferAttribute(ze, Gr));
    return this;
  }
  setFromPoints(ze) {
    this.makeEmpty();
    for (let Gr = 0, Yr = ze.length; Gr < Yr; Gr++) this.expandByPoint(ze[Gr]);
    return this;
  }
  setFromCenterAndSize(ze, Gr) {
    const Yr = _vector$a.copy(Gr).multiplyScalar(0.5);
    return this.min.copy(ze).sub(Yr), this.max.copy(ze).add(Yr), this;
  }
  setFromObject(ze, Gr = !1) {
    return this.makeEmpty(), this.expandByObject(ze, Gr);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(ze) {
    return this.min.copy(ze.min), this.max.copy(ze.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(ze) {
    return this.isEmpty()
      ? ze.set(0, 0, 0)
      : ze.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(ze) {
    return this.isEmpty() ? ze.set(0, 0, 0) : ze.subVectors(this.max, this.min);
  }
  expandByPoint(ze) {
    return this.min.min(ze), this.max.max(ze), this;
  }
  expandByVector(ze) {
    return this.min.sub(ze), this.max.add(ze), this;
  }
  expandByScalar(ze) {
    return this.min.addScalar(-ze), this.max.addScalar(ze), this;
  }
  expandByObject(ze, Gr = !1) {
    ze.updateWorldMatrix(!1, !1);
    const Yr = ze.geometry;
    if (Yr !== void 0) {
      const Zr = Yr.getAttribute("position");
      if (Gr === !0 && Zr !== void 0 && ze.isInstancedMesh !== !0)
        for (let Jr = 0, Qr = Zr.count; Jr < Qr; Jr++)
          ze.isMesh === !0
            ? ze.getVertexPosition(Jr, _vector$a)
            : _vector$a.fromBufferAttribute(Zr, Jr),
            _vector$a.applyMatrix4(ze.matrixWorld),
            this.expandByPoint(_vector$a);
      else
        ze.boundingBox !== void 0
          ? (ze.boundingBox === null && ze.computeBoundingBox(),
            _box$3.copy(ze.boundingBox))
          : (Yr.boundingBox === null && Yr.computeBoundingBox(),
            _box$3.copy(Yr.boundingBox)),
          _box$3.applyMatrix4(ze.matrixWorld),
          this.union(_box$3);
    }
    const Kr = ze.children;
    for (let Zr = 0, Jr = Kr.length; Zr < Jr; Zr++)
      this.expandByObject(Kr[Zr], Gr);
    return this;
  }
  containsPoint(ze) {
    return !(
      ze.x < this.min.x ||
      ze.x > this.max.x ||
      ze.y < this.min.y ||
      ze.y > this.max.y ||
      ze.z < this.min.z ||
      ze.z > this.max.z
    );
  }
  containsBox(ze) {
    return (
      this.min.x <= ze.min.x &&
      ze.max.x <= this.max.x &&
      this.min.y <= ze.min.y &&
      ze.max.y <= this.max.y &&
      this.min.z <= ze.min.z &&
      ze.max.z <= this.max.z
    );
  }
  getParameter(ze, Gr) {
    return Gr.set(
      (ze.x - this.min.x) / (this.max.x - this.min.x),
      (ze.y - this.min.y) / (this.max.y - this.min.y),
      (ze.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(ze) {
    return !(
      ze.max.x < this.min.x ||
      ze.min.x > this.max.x ||
      ze.max.y < this.min.y ||
      ze.min.y > this.max.y ||
      ze.max.z < this.min.z ||
      ze.min.z > this.max.z
    );
  }
  intersectsSphere(ze) {
    return (
      this.clampPoint(ze.center, _vector$a),
      _vector$a.distanceToSquared(ze.center) <= ze.radius * ze.radius
    );
  }
  intersectsPlane(ze) {
    let Gr, Yr;
    return (
      ze.normal.x > 0
        ? ((Gr = ze.normal.x * this.min.x), (Yr = ze.normal.x * this.max.x))
        : ((Gr = ze.normal.x * this.max.x), (Yr = ze.normal.x * this.min.x)),
      ze.normal.y > 0
        ? ((Gr += ze.normal.y * this.min.y), (Yr += ze.normal.y * this.max.y))
        : ((Gr += ze.normal.y * this.max.y), (Yr += ze.normal.y * this.min.y)),
      ze.normal.z > 0
        ? ((Gr += ze.normal.z * this.min.z), (Yr += ze.normal.z * this.max.z))
        : ((Gr += ze.normal.z * this.max.z), (Yr += ze.normal.z * this.min.z)),
      Gr <= -ze.constant && Yr >= -ze.constant
    );
  }
  intersectsTriangle(ze) {
    if (this.isEmpty()) return !1;
    this.getCenter(_center),
      _extents.subVectors(this.max, _center),
      _v0$2.subVectors(ze.a, _center),
      _v1$7.subVectors(ze.b, _center),
      _v2$4.subVectors(ze.c, _center),
      _f0.subVectors(_v1$7, _v0$2),
      _f1.subVectors(_v2$4, _v1$7),
      _f2.subVectors(_v0$2, _v2$4);
    let Gr = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ];
    return !satForAxes(Gr, _v0$2, _v1$7, _v2$4, _extents) ||
      ((Gr = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !satForAxes(Gr, _v0$2, _v1$7, _v2$4, _extents))
      ? !1
      : (_triangleNormal.crossVectors(_f0, _f1),
        (Gr = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z]),
        satForAxes(Gr, _v0$2, _v1$7, _v2$4, _extents));
  }
  clampPoint(ze, Gr) {
    return Gr.copy(ze).clamp(this.min, this.max);
  }
  distanceToPoint(ze) {
    return this.clampPoint(ze, _vector$a).distanceTo(ze);
  }
  getBoundingSphere(ze) {
    return (
      this.isEmpty()
        ? ze.makeEmpty()
        : (this.getCenter(ze.center),
          (ze.radius = this.getSize(_vector$a).length() * 0.5)),
      ze
    );
  }
  intersect(ze) {
    return (
      this.min.max(ze.min),
      this.max.min(ze.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(ze) {
    return this.min.min(ze.min), this.max.max(ze.max), this;
  }
  applyMatrix4(ze) {
    return this.isEmpty()
      ? this
      : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(ze),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(ze),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(ze),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(ze),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(ze),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(ze),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(ze),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(ze),
        this.setFromPoints(_points),
        this);
  }
  translate(ze) {
    return this.min.add(ze), this.max.add(ze), this;
  }
  equals(ze) {
    return ze.min.equals(this.min) && ze.max.equals(this.max);
  }
}
const _points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
  ],
  _vector$a = new Vector3(),
  _box$3 = new Box3(),
  _v0$2 = new Vector3(),
  _v1$7 = new Vector3(),
  _v2$4 = new Vector3(),
  _f0 = new Vector3(),
  _f1 = new Vector3(),
  _f2 = new Vector3(),
  _center = new Vector3(),
  _extents = new Vector3(),
  _triangleNormal = new Vector3(),
  _testAxis = new Vector3();
function satForAxes(Wr, ze, Gr, Yr, Kr) {
  for (let Zr = 0, Jr = Wr.length - 3; Zr <= Jr; Zr += 3) {
    _testAxis.fromArray(Wr, Zr);
    const Qr =
        Kr.x * Math.abs(_testAxis.x) +
        Kr.y * Math.abs(_testAxis.y) +
        Kr.z * Math.abs(_testAxis.z),
      ei = ze.dot(_testAxis),
      ti = Gr.dot(_testAxis),
      ri = Yr.dot(_testAxis);
    if (Math.max(-Math.max(ei, ti, ri), Math.min(ei, ti, ri)) > Qr) return !1;
  }
  return !0;
}
const _box$2 = new Box3(),
  _v1$6 = new Vector3(),
  _v2$3 = new Vector3();
class Sphere {
  constructor(ze = new Vector3(), Gr = -1) {
    (this.center = ze), (this.radius = Gr);
  }
  set(ze, Gr) {
    return this.center.copy(ze), (this.radius = Gr), this;
  }
  setFromPoints(ze, Gr) {
    const Yr = this.center;
    Gr !== void 0 ? Yr.copy(Gr) : _box$2.setFromPoints(ze).getCenter(Yr);
    let Kr = 0;
    for (let Zr = 0, Jr = ze.length; Zr < Jr; Zr++)
      Kr = Math.max(Kr, Yr.distanceToSquared(ze[Zr]));
    return (this.radius = Math.sqrt(Kr)), this;
  }
  copy(ze) {
    return this.center.copy(ze.center), (this.radius = ze.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(ze) {
    return ze.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(ze) {
    return ze.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(ze) {
    const Gr = this.radius + ze.radius;
    return ze.center.distanceToSquared(this.center) <= Gr * Gr;
  }
  intersectsBox(ze) {
    return ze.intersectsSphere(this);
  }
  intersectsPlane(ze) {
    return Math.abs(ze.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(ze, Gr) {
    const Yr = this.center.distanceToSquared(ze);
    return (
      Gr.copy(ze),
      Yr > this.radius * this.radius &&
        (Gr.sub(this.center).normalize(),
        Gr.multiplyScalar(this.radius).add(this.center)),
      Gr
    );
  }
  getBoundingBox(ze) {
    return this.isEmpty()
      ? (ze.makeEmpty(), ze)
      : (ze.set(this.center, this.center), ze.expandByScalar(this.radius), ze);
  }
  applyMatrix4(ze) {
    return (
      this.center.applyMatrix4(ze),
      (this.radius = this.radius * ze.getMaxScaleOnAxis()),
      this
    );
  }
  translate(ze) {
    return this.center.add(ze), this;
  }
  expandByPoint(ze) {
    if (this.isEmpty()) return this.center.copy(ze), (this.radius = 0), this;
    _v1$6.subVectors(ze, this.center);
    const Gr = _v1$6.lengthSq();
    if (Gr > this.radius * this.radius) {
      const Yr = Math.sqrt(Gr),
        Kr = (Yr - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, Kr / Yr), (this.radius += Kr);
    }
    return this;
  }
  union(ze) {
    return ze.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(ze), this)
      : (this.center.equals(ze.center) === !0
          ? (this.radius = Math.max(this.radius, ze.radius))
          : (_v2$3.subVectors(ze.center, this.center).setLength(ze.radius),
            this.expandByPoint(_v1$6.copy(ze.center).add(_v2$3)),
            this.expandByPoint(_v1$6.copy(ze.center).sub(_v2$3))),
        this);
  }
  equals(ze) {
    return ze.center.equals(this.center) && ze.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$9 = new Vector3(),
  _segCenter = new Vector3(),
  _segDir = new Vector3(),
  _diff = new Vector3(),
  _edge1 = new Vector3(),
  _edge2 = new Vector3(),
  _normal$1 = new Vector3();
class Ray {
  constructor(ze = new Vector3(), Gr = new Vector3(0, 0, -1)) {
    (this.origin = ze), (this.direction = Gr);
  }
  set(ze, Gr) {
    return this.origin.copy(ze), this.direction.copy(Gr), this;
  }
  copy(ze) {
    return this.origin.copy(ze.origin), this.direction.copy(ze.direction), this;
  }
  at(ze, Gr) {
    return Gr.copy(this.origin).addScaledVector(this.direction, ze);
  }
  lookAt(ze) {
    return this.direction.copy(ze).sub(this.origin).normalize(), this;
  }
  recast(ze) {
    return this.origin.copy(this.at(ze, _vector$9)), this;
  }
  closestPointToPoint(ze, Gr) {
    Gr.subVectors(ze, this.origin);
    const Yr = Gr.dot(this.direction);
    return Yr < 0
      ? Gr.copy(this.origin)
      : Gr.copy(this.origin).addScaledVector(this.direction, Yr);
  }
  distanceToPoint(ze) {
    return Math.sqrt(this.distanceSqToPoint(ze));
  }
  distanceSqToPoint(ze) {
    const Gr = _vector$9.subVectors(ze, this.origin).dot(this.direction);
    return Gr < 0
      ? this.origin.distanceToSquared(ze)
      : (_vector$9.copy(this.origin).addScaledVector(this.direction, Gr),
        _vector$9.distanceToSquared(ze));
  }
  distanceSqToSegment(ze, Gr, Yr, Kr) {
    _segCenter.copy(ze).add(Gr).multiplyScalar(0.5),
      _segDir.copy(Gr).sub(ze).normalize(),
      _diff.copy(this.origin).sub(_segCenter);
    const Zr = ze.distanceTo(Gr) * 0.5,
      Jr = -this.direction.dot(_segDir),
      Qr = _diff.dot(this.direction),
      ei = -_diff.dot(_segDir),
      ti = _diff.lengthSq(),
      ri = Math.abs(1 - Jr * Jr);
    let ni, ii, si, li;
    if (ri > 0)
      if (((ni = Jr * ei - Qr), (ii = Jr * Qr - ei), (li = Zr * ri), ni >= 0))
        if (ii >= -li)
          if (ii <= li) {
            const oi = 1 / ri;
            (ni *= oi),
              (ii *= oi),
              (si =
                ni * (ni + Jr * ii + 2 * Qr) +
                ii * (Jr * ni + ii + 2 * ei) +
                ti);
          } else
            (ii = Zr),
              (ni = Math.max(0, -(Jr * ii + Qr))),
              (si = -ni * ni + ii * (ii + 2 * ei) + ti);
        else
          (ii = -Zr),
            (ni = Math.max(0, -(Jr * ii + Qr))),
            (si = -ni * ni + ii * (ii + 2 * ei) + ti);
      else
        ii <= -li
          ? ((ni = Math.max(0, -(-Jr * Zr + Qr))),
            (ii = ni > 0 ? -Zr : Math.min(Math.max(-Zr, -ei), Zr)),
            (si = -ni * ni + ii * (ii + 2 * ei) + ti))
          : ii <= li
          ? ((ni = 0),
            (ii = Math.min(Math.max(-Zr, -ei), Zr)),
            (si = ii * (ii + 2 * ei) + ti))
          : ((ni = Math.max(0, -(Jr * Zr + Qr))),
            (ii = ni > 0 ? Zr : Math.min(Math.max(-Zr, -ei), Zr)),
            (si = -ni * ni + ii * (ii + 2 * ei) + ti));
    else
      (ii = Jr > 0 ? -Zr : Zr),
        (ni = Math.max(0, -(Jr * ii + Qr))),
        (si = -ni * ni + ii * (ii + 2 * ei) + ti);
    return (
      Yr && Yr.copy(this.origin).addScaledVector(this.direction, ni),
      Kr && Kr.copy(_segCenter).addScaledVector(_segDir, ii),
      si
    );
  }
  intersectSphere(ze, Gr) {
    _vector$9.subVectors(ze.center, this.origin);
    const Yr = _vector$9.dot(this.direction),
      Kr = _vector$9.dot(_vector$9) - Yr * Yr,
      Zr = ze.radius * ze.radius;
    if (Kr > Zr) return null;
    const Jr = Math.sqrt(Zr - Kr),
      Qr = Yr - Jr,
      ei = Yr + Jr;
    return ei < 0 ? null : Qr < 0 ? this.at(ei, Gr) : this.at(Qr, Gr);
  }
  intersectsSphere(ze) {
    return this.distanceSqToPoint(ze.center) <= ze.radius * ze.radius;
  }
  distanceToPlane(ze) {
    const Gr = ze.normal.dot(this.direction);
    if (Gr === 0) return ze.distanceToPoint(this.origin) === 0 ? 0 : null;
    const Yr = -(this.origin.dot(ze.normal) + ze.constant) / Gr;
    return Yr >= 0 ? Yr : null;
  }
  intersectPlane(ze, Gr) {
    const Yr = this.distanceToPlane(ze);
    return Yr === null ? null : this.at(Yr, Gr);
  }
  intersectsPlane(ze) {
    const Gr = ze.distanceToPoint(this.origin);
    return Gr === 0 || ze.normal.dot(this.direction) * Gr < 0;
  }
  intersectBox(ze, Gr) {
    let Yr, Kr, Zr, Jr, Qr, ei;
    const ti = 1 / this.direction.x,
      ri = 1 / this.direction.y,
      ni = 1 / this.direction.z,
      ii = this.origin;
    return (
      ti >= 0
        ? ((Yr = (ze.min.x - ii.x) * ti), (Kr = (ze.max.x - ii.x) * ti))
        : ((Yr = (ze.max.x - ii.x) * ti), (Kr = (ze.min.x - ii.x) * ti)),
      ri >= 0
        ? ((Zr = (ze.min.y - ii.y) * ri), (Jr = (ze.max.y - ii.y) * ri))
        : ((Zr = (ze.max.y - ii.y) * ri), (Jr = (ze.min.y - ii.y) * ri)),
      Yr > Jr ||
      Zr > Kr ||
      ((Zr > Yr || isNaN(Yr)) && (Yr = Zr),
      (Jr < Kr || isNaN(Kr)) && (Kr = Jr),
      ni >= 0
        ? ((Qr = (ze.min.z - ii.z) * ni), (ei = (ze.max.z - ii.z) * ni))
        : ((Qr = (ze.max.z - ii.z) * ni), (ei = (ze.min.z - ii.z) * ni)),
      Yr > ei || Qr > Kr) ||
      ((Qr > Yr || Yr !== Yr) && (Yr = Qr),
      (ei < Kr || Kr !== Kr) && (Kr = ei),
      Kr < 0)
        ? null
        : this.at(Yr >= 0 ? Yr : Kr, Gr)
    );
  }
  intersectsBox(ze) {
    return this.intersectBox(ze, _vector$9) !== null;
  }
  intersectTriangle(ze, Gr, Yr, Kr, Zr) {
    _edge1.subVectors(Gr, ze),
      _edge2.subVectors(Yr, ze),
      _normal$1.crossVectors(_edge1, _edge2);
    let Jr = this.direction.dot(_normal$1),
      Qr;
    if (Jr > 0) {
      if (Kr) return null;
      Qr = 1;
    } else if (Jr < 0) (Qr = -1), (Jr = -Jr);
    else return null;
    _diff.subVectors(this.origin, ze);
    const ei = Qr * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (ei < 0) return null;
    const ti = Qr * this.direction.dot(_edge1.cross(_diff));
    if (ti < 0 || ei + ti > Jr) return null;
    const ri = -Qr * _diff.dot(_normal$1);
    return ri < 0 ? null : this.at(ri / Jr, Zr);
  }
  applyMatrix4(ze) {
    return (
      this.origin.applyMatrix4(ze), this.direction.transformDirection(ze), this
    );
  }
  equals(ze) {
    return ze.origin.equals(this.origin) && ze.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti, ri, ni, ii, si, li, oi, ui) {
    (Matrix4.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      ze !== void 0 &&
        this.set(
          ze,
          Gr,
          Yr,
          Kr,
          Zr,
          Jr,
          Qr,
          ei,
          ti,
          ri,
          ni,
          ii,
          si,
          li,
          oi,
          ui
        );
  }
  set(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti, ri, ni, ii, si, li, oi, ui) {
    const ai = this.elements;
    return (
      (ai[0] = ze),
      (ai[4] = Gr),
      (ai[8] = Yr),
      (ai[12] = Kr),
      (ai[1] = Zr),
      (ai[5] = Jr),
      (ai[9] = Qr),
      (ai[13] = ei),
      (ai[2] = ti),
      (ai[6] = ri),
      (ai[10] = ni),
      (ai[14] = ii),
      (ai[3] = si),
      (ai[7] = li),
      (ai[11] = oi),
      (ai[15] = ui),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(ze) {
    const Gr = this.elements,
      Yr = ze.elements;
    return (
      (Gr[0] = Yr[0]),
      (Gr[1] = Yr[1]),
      (Gr[2] = Yr[2]),
      (Gr[3] = Yr[3]),
      (Gr[4] = Yr[4]),
      (Gr[5] = Yr[5]),
      (Gr[6] = Yr[6]),
      (Gr[7] = Yr[7]),
      (Gr[8] = Yr[8]),
      (Gr[9] = Yr[9]),
      (Gr[10] = Yr[10]),
      (Gr[11] = Yr[11]),
      (Gr[12] = Yr[12]),
      (Gr[13] = Yr[13]),
      (Gr[14] = Yr[14]),
      (Gr[15] = Yr[15]),
      this
    );
  }
  copyPosition(ze) {
    const Gr = this.elements,
      Yr = ze.elements;
    return (Gr[12] = Yr[12]), (Gr[13] = Yr[13]), (Gr[14] = Yr[14]), this;
  }
  setFromMatrix3(ze) {
    const Gr = ze.elements;
    return (
      this.set(
        Gr[0],
        Gr[3],
        Gr[6],
        0,
        Gr[1],
        Gr[4],
        Gr[7],
        0,
        Gr[2],
        Gr[5],
        Gr[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(ze, Gr, Yr) {
    return (
      ze.setFromMatrixColumn(this, 0),
      Gr.setFromMatrixColumn(this, 1),
      Yr.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(ze, Gr, Yr) {
    return (
      this.set(
        ze.x,
        Gr.x,
        Yr.x,
        0,
        ze.y,
        Gr.y,
        Yr.y,
        0,
        ze.z,
        Gr.z,
        Yr.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(ze) {
    const Gr = this.elements,
      Yr = ze.elements,
      Kr = 1 / _v1$5.setFromMatrixColumn(ze, 0).length(),
      Zr = 1 / _v1$5.setFromMatrixColumn(ze, 1).length(),
      Jr = 1 / _v1$5.setFromMatrixColumn(ze, 2).length();
    return (
      (Gr[0] = Yr[0] * Kr),
      (Gr[1] = Yr[1] * Kr),
      (Gr[2] = Yr[2] * Kr),
      (Gr[3] = 0),
      (Gr[4] = Yr[4] * Zr),
      (Gr[5] = Yr[5] * Zr),
      (Gr[6] = Yr[6] * Zr),
      (Gr[7] = 0),
      (Gr[8] = Yr[8] * Jr),
      (Gr[9] = Yr[9] * Jr),
      (Gr[10] = Yr[10] * Jr),
      (Gr[11] = 0),
      (Gr[12] = 0),
      (Gr[13] = 0),
      (Gr[14] = 0),
      (Gr[15] = 1),
      this
    );
  }
  makeRotationFromEuler(ze) {
    const Gr = this.elements,
      Yr = ze.x,
      Kr = ze.y,
      Zr = ze.z,
      Jr = Math.cos(Yr),
      Qr = Math.sin(Yr),
      ei = Math.cos(Kr),
      ti = Math.sin(Kr),
      ri = Math.cos(Zr),
      ni = Math.sin(Zr);
    if (ze.order === "XYZ") {
      const ii = Jr * ri,
        si = Jr * ni,
        li = Qr * ri,
        oi = Qr * ni;
      (Gr[0] = ei * ri),
        (Gr[4] = -ei * ni),
        (Gr[8] = ti),
        (Gr[1] = si + li * ti),
        (Gr[5] = ii - oi * ti),
        (Gr[9] = -Qr * ei),
        (Gr[2] = oi - ii * ti),
        (Gr[6] = li + si * ti),
        (Gr[10] = Jr * ei);
    } else if (ze.order === "YXZ") {
      const ii = ei * ri,
        si = ei * ni,
        li = ti * ri,
        oi = ti * ni;
      (Gr[0] = ii + oi * Qr),
        (Gr[4] = li * Qr - si),
        (Gr[8] = Jr * ti),
        (Gr[1] = Jr * ni),
        (Gr[5] = Jr * ri),
        (Gr[9] = -Qr),
        (Gr[2] = si * Qr - li),
        (Gr[6] = oi + ii * Qr),
        (Gr[10] = Jr * ei);
    } else if (ze.order === "ZXY") {
      const ii = ei * ri,
        si = ei * ni,
        li = ti * ri,
        oi = ti * ni;
      (Gr[0] = ii - oi * Qr),
        (Gr[4] = -Jr * ni),
        (Gr[8] = li + si * Qr),
        (Gr[1] = si + li * Qr),
        (Gr[5] = Jr * ri),
        (Gr[9] = oi - ii * Qr),
        (Gr[2] = -Jr * ti),
        (Gr[6] = Qr),
        (Gr[10] = Jr * ei);
    } else if (ze.order === "ZYX") {
      const ii = Jr * ri,
        si = Jr * ni,
        li = Qr * ri,
        oi = Qr * ni;
      (Gr[0] = ei * ri),
        (Gr[4] = li * ti - si),
        (Gr[8] = ii * ti + oi),
        (Gr[1] = ei * ni),
        (Gr[5] = oi * ti + ii),
        (Gr[9] = si * ti - li),
        (Gr[2] = -ti),
        (Gr[6] = Qr * ei),
        (Gr[10] = Jr * ei);
    } else if (ze.order === "YZX") {
      const ii = Jr * ei,
        si = Jr * ti,
        li = Qr * ei,
        oi = Qr * ti;
      (Gr[0] = ei * ri),
        (Gr[4] = oi - ii * ni),
        (Gr[8] = li * ni + si),
        (Gr[1] = ni),
        (Gr[5] = Jr * ri),
        (Gr[9] = -Qr * ri),
        (Gr[2] = -ti * ri),
        (Gr[6] = si * ni + li),
        (Gr[10] = ii - oi * ni);
    } else if (ze.order === "XZY") {
      const ii = Jr * ei,
        si = Jr * ti,
        li = Qr * ei,
        oi = Qr * ti;
      (Gr[0] = ei * ri),
        (Gr[4] = -ni),
        (Gr[8] = ti * ri),
        (Gr[1] = ii * ni + oi),
        (Gr[5] = Jr * ri),
        (Gr[9] = si * ni - li),
        (Gr[2] = li * ni - si),
        (Gr[6] = Qr * ri),
        (Gr[10] = oi * ni + ii);
    }
    return (
      (Gr[3] = 0),
      (Gr[7] = 0),
      (Gr[11] = 0),
      (Gr[12] = 0),
      (Gr[13] = 0),
      (Gr[14] = 0),
      (Gr[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(ze) {
    return this.compose(_zero, ze, _one);
  }
  lookAt(ze, Gr, Yr) {
    const Kr = this.elements;
    return (
      _z.subVectors(ze, Gr),
      _z.lengthSq() === 0 && (_z.z = 1),
      _z.normalize(),
      _x.crossVectors(Yr, _z),
      _x.lengthSq() === 0 &&
        (Math.abs(Yr.z) === 1 ? (_z.x += 1e-4) : (_z.z += 1e-4),
        _z.normalize(),
        _x.crossVectors(Yr, _z)),
      _x.normalize(),
      _y.crossVectors(_z, _x),
      (Kr[0] = _x.x),
      (Kr[4] = _y.x),
      (Kr[8] = _z.x),
      (Kr[1] = _x.y),
      (Kr[5] = _y.y),
      (Kr[9] = _z.y),
      (Kr[2] = _x.z),
      (Kr[6] = _y.z),
      (Kr[10] = _z.z),
      this
    );
  }
  multiply(ze) {
    return this.multiplyMatrices(this, ze);
  }
  premultiply(ze) {
    return this.multiplyMatrices(ze, this);
  }
  multiplyMatrices(ze, Gr) {
    const Yr = ze.elements,
      Kr = Gr.elements,
      Zr = this.elements,
      Jr = Yr[0],
      Qr = Yr[4],
      ei = Yr[8],
      ti = Yr[12],
      ri = Yr[1],
      ni = Yr[5],
      ii = Yr[9],
      si = Yr[13],
      li = Yr[2],
      oi = Yr[6],
      ui = Yr[10],
      ai = Yr[14],
      hi = Yr[3],
      ci = Yr[7],
      fi = Yr[11],
      di = Yr[15],
      pi = Kr[0],
      mi = Kr[4],
      Si = Kr[8],
      yi = Kr[12],
      Ei = Kr[1],
      Pi = Kr[5],
      Ai = Kr[9],
      Ri = Kr[13],
      wi = Kr[2],
      Ci = Kr[6],
      bi = Kr[10],
      Mi = Kr[14],
      gi = Kr[3],
      xi = Kr[7],
      Ti = Kr[11],
      vi = Kr[15];
    return (
      (Zr[0] = Jr * pi + Qr * Ei + ei * wi + ti * gi),
      (Zr[4] = Jr * mi + Qr * Pi + ei * Ci + ti * xi),
      (Zr[8] = Jr * Si + Qr * Ai + ei * bi + ti * Ti),
      (Zr[12] = Jr * yi + Qr * Ri + ei * Mi + ti * vi),
      (Zr[1] = ri * pi + ni * Ei + ii * wi + si * gi),
      (Zr[5] = ri * mi + ni * Pi + ii * Ci + si * xi),
      (Zr[9] = ri * Si + ni * Ai + ii * bi + si * Ti),
      (Zr[13] = ri * yi + ni * Ri + ii * Mi + si * vi),
      (Zr[2] = li * pi + oi * Ei + ui * wi + ai * gi),
      (Zr[6] = li * mi + oi * Pi + ui * Ci + ai * xi),
      (Zr[10] = li * Si + oi * Ai + ui * bi + ai * Ti),
      (Zr[14] = li * yi + oi * Ri + ui * Mi + ai * vi),
      (Zr[3] = hi * pi + ci * Ei + fi * wi + di * gi),
      (Zr[7] = hi * mi + ci * Pi + fi * Ci + di * xi),
      (Zr[11] = hi * Si + ci * Ai + fi * bi + di * Ti),
      (Zr[15] = hi * yi + ci * Ri + fi * Mi + di * vi),
      this
    );
  }
  multiplyScalar(ze) {
    const Gr = this.elements;
    return (
      (Gr[0] *= ze),
      (Gr[4] *= ze),
      (Gr[8] *= ze),
      (Gr[12] *= ze),
      (Gr[1] *= ze),
      (Gr[5] *= ze),
      (Gr[9] *= ze),
      (Gr[13] *= ze),
      (Gr[2] *= ze),
      (Gr[6] *= ze),
      (Gr[10] *= ze),
      (Gr[14] *= ze),
      (Gr[3] *= ze),
      (Gr[7] *= ze),
      (Gr[11] *= ze),
      (Gr[15] *= ze),
      this
    );
  }
  determinant() {
    const ze = this.elements,
      Gr = ze[0],
      Yr = ze[4],
      Kr = ze[8],
      Zr = ze[12],
      Jr = ze[1],
      Qr = ze[5],
      ei = ze[9],
      ti = ze[13],
      ri = ze[2],
      ni = ze[6],
      ii = ze[10],
      si = ze[14],
      li = ze[3],
      oi = ze[7],
      ui = ze[11],
      ai = ze[15];
    return (
      li *
        (+Zr * ei * ni -
          Kr * ti * ni -
          Zr * Qr * ii +
          Yr * ti * ii +
          Kr * Qr * si -
          Yr * ei * si) +
      oi *
        (+Gr * ei * si -
          Gr * ti * ii +
          Zr * Jr * ii -
          Kr * Jr * si +
          Kr * ti * ri -
          Zr * ei * ri) +
      ui *
        (+Gr * ti * ni -
          Gr * Qr * si -
          Zr * Jr * ni +
          Yr * Jr * si +
          Zr * Qr * ri -
          Yr * ti * ri) +
      ai *
        (-Kr * Qr * ri -
          Gr * ei * ni +
          Gr * Qr * ii +
          Kr * Jr * ni -
          Yr * Jr * ii +
          Yr * ei * ri)
    );
  }
  transpose() {
    const ze = this.elements;
    let Gr;
    return (
      (Gr = ze[1]),
      (ze[1] = ze[4]),
      (ze[4] = Gr),
      (Gr = ze[2]),
      (ze[2] = ze[8]),
      (ze[8] = Gr),
      (Gr = ze[6]),
      (ze[6] = ze[9]),
      (ze[9] = Gr),
      (Gr = ze[3]),
      (ze[3] = ze[12]),
      (ze[12] = Gr),
      (Gr = ze[7]),
      (ze[7] = ze[13]),
      (ze[13] = Gr),
      (Gr = ze[11]),
      (ze[11] = ze[14]),
      (ze[14] = Gr),
      this
    );
  }
  setPosition(ze, Gr, Yr) {
    const Kr = this.elements;
    return (
      ze.isVector3
        ? ((Kr[12] = ze.x), (Kr[13] = ze.y), (Kr[14] = ze.z))
        : ((Kr[12] = ze), (Kr[13] = Gr), (Kr[14] = Yr)),
      this
    );
  }
  invert() {
    const ze = this.elements,
      Gr = ze[0],
      Yr = ze[1],
      Kr = ze[2],
      Zr = ze[3],
      Jr = ze[4],
      Qr = ze[5],
      ei = ze[6],
      ti = ze[7],
      ri = ze[8],
      ni = ze[9],
      ii = ze[10],
      si = ze[11],
      li = ze[12],
      oi = ze[13],
      ui = ze[14],
      ai = ze[15],
      hi =
        ni * ui * ti -
        oi * ii * ti +
        oi * ei * si -
        Qr * ui * si -
        ni * ei * ai +
        Qr * ii * ai,
      ci =
        li * ii * ti -
        ri * ui * ti -
        li * ei * si +
        Jr * ui * si +
        ri * ei * ai -
        Jr * ii * ai,
      fi =
        ri * oi * ti -
        li * ni * ti +
        li * Qr * si -
        Jr * oi * si -
        ri * Qr * ai +
        Jr * ni * ai,
      di =
        li * ni * ei -
        ri * oi * ei -
        li * Qr * ii +
        Jr * oi * ii +
        ri * Qr * ui -
        Jr * ni * ui,
      pi = Gr * hi + Yr * ci + Kr * fi + Zr * di;
    if (pi === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const mi = 1 / pi;
    return (
      (ze[0] = hi * mi),
      (ze[1] =
        (oi * ii * Zr -
          ni * ui * Zr -
          oi * Kr * si +
          Yr * ui * si +
          ni * Kr * ai -
          Yr * ii * ai) *
        mi),
      (ze[2] =
        (Qr * ui * Zr -
          oi * ei * Zr +
          oi * Kr * ti -
          Yr * ui * ti -
          Qr * Kr * ai +
          Yr * ei * ai) *
        mi),
      (ze[3] =
        (ni * ei * Zr -
          Qr * ii * Zr -
          ni * Kr * ti +
          Yr * ii * ti +
          Qr * Kr * si -
          Yr * ei * si) *
        mi),
      (ze[4] = ci * mi),
      (ze[5] =
        (ri * ui * Zr -
          li * ii * Zr +
          li * Kr * si -
          Gr * ui * si -
          ri * Kr * ai +
          Gr * ii * ai) *
        mi),
      (ze[6] =
        (li * ei * Zr -
          Jr * ui * Zr -
          li * Kr * ti +
          Gr * ui * ti +
          Jr * Kr * ai -
          Gr * ei * ai) *
        mi),
      (ze[7] =
        (Jr * ii * Zr -
          ri * ei * Zr +
          ri * Kr * ti -
          Gr * ii * ti -
          Jr * Kr * si +
          Gr * ei * si) *
        mi),
      (ze[8] = fi * mi),
      (ze[9] =
        (li * ni * Zr -
          ri * oi * Zr -
          li * Yr * si +
          Gr * oi * si +
          ri * Yr * ai -
          Gr * ni * ai) *
        mi),
      (ze[10] =
        (Jr * oi * Zr -
          li * Qr * Zr +
          li * Yr * ti -
          Gr * oi * ti -
          Jr * Yr * ai +
          Gr * Qr * ai) *
        mi),
      (ze[11] =
        (ri * Qr * Zr -
          Jr * ni * Zr -
          ri * Yr * ti +
          Gr * ni * ti +
          Jr * Yr * si -
          Gr * Qr * si) *
        mi),
      (ze[12] = di * mi),
      (ze[13] =
        (ri * oi * Kr -
          li * ni * Kr +
          li * Yr * ii -
          Gr * oi * ii -
          ri * Yr * ui +
          Gr * ni * ui) *
        mi),
      (ze[14] =
        (li * Qr * Kr -
          Jr * oi * Kr -
          li * Yr * ei +
          Gr * oi * ei +
          Jr * Yr * ui -
          Gr * Qr * ui) *
        mi),
      (ze[15] =
        (Jr * ni * Kr -
          ri * Qr * Kr +
          ri * Yr * ei -
          Gr * ni * ei -
          Jr * Yr * ii +
          Gr * Qr * ii) *
        mi),
      this
    );
  }
  scale(ze) {
    const Gr = this.elements,
      Yr = ze.x,
      Kr = ze.y,
      Zr = ze.z;
    return (
      (Gr[0] *= Yr),
      (Gr[4] *= Kr),
      (Gr[8] *= Zr),
      (Gr[1] *= Yr),
      (Gr[5] *= Kr),
      (Gr[9] *= Zr),
      (Gr[2] *= Yr),
      (Gr[6] *= Kr),
      (Gr[10] *= Zr),
      (Gr[3] *= Yr),
      (Gr[7] *= Kr),
      (Gr[11] *= Zr),
      this
    );
  }
  getMaxScaleOnAxis() {
    const ze = this.elements,
      Gr = ze[0] * ze[0] + ze[1] * ze[1] + ze[2] * ze[2],
      Yr = ze[4] * ze[4] + ze[5] * ze[5] + ze[6] * ze[6],
      Kr = ze[8] * ze[8] + ze[9] * ze[9] + ze[10] * ze[10];
    return Math.sqrt(Math.max(Gr, Yr, Kr));
  }
  makeTranslation(ze, Gr, Yr) {
    return (
      ze.isVector3
        ? this.set(1, 0, 0, ze.x, 0, 1, 0, ze.y, 0, 0, 1, ze.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, ze, 0, 1, 0, Gr, 0, 0, 1, Yr, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(ze) {
    const Gr = Math.cos(ze),
      Yr = Math.sin(ze);
    return this.set(1, 0, 0, 0, 0, Gr, -Yr, 0, 0, Yr, Gr, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(ze) {
    const Gr = Math.cos(ze),
      Yr = Math.sin(ze);
    return this.set(Gr, 0, Yr, 0, 0, 1, 0, 0, -Yr, 0, Gr, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(ze) {
    const Gr = Math.cos(ze),
      Yr = Math.sin(ze);
    return this.set(Gr, -Yr, 0, 0, Yr, Gr, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(ze, Gr) {
    const Yr = Math.cos(Gr),
      Kr = Math.sin(Gr),
      Zr = 1 - Yr,
      Jr = ze.x,
      Qr = ze.y,
      ei = ze.z,
      ti = Zr * Jr,
      ri = Zr * Qr;
    return (
      this.set(
        ti * Jr + Yr,
        ti * Qr - Kr * ei,
        ti * ei + Kr * Qr,
        0,
        ti * Qr + Kr * ei,
        ri * Qr + Yr,
        ri * ei - Kr * Jr,
        0,
        ti * ei - Kr * Qr,
        ri * ei + Kr * Jr,
        Zr * ei * ei + Yr,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(ze, Gr, Yr) {
    return this.set(ze, 0, 0, 0, 0, Gr, 0, 0, 0, 0, Yr, 0, 0, 0, 0, 1), this;
  }
  makeShear(ze, Gr, Yr, Kr, Zr, Jr) {
    return this.set(1, Yr, Zr, 0, ze, 1, Jr, 0, Gr, Kr, 1, 0, 0, 0, 0, 1), this;
  }
  compose(ze, Gr, Yr) {
    const Kr = this.elements,
      Zr = Gr._x,
      Jr = Gr._y,
      Qr = Gr._z,
      ei = Gr._w,
      ti = Zr + Zr,
      ri = Jr + Jr,
      ni = Qr + Qr,
      ii = Zr * ti,
      si = Zr * ri,
      li = Zr * ni,
      oi = Jr * ri,
      ui = Jr * ni,
      ai = Qr * ni,
      hi = ei * ti,
      ci = ei * ri,
      fi = ei * ni,
      di = Yr.x,
      pi = Yr.y,
      mi = Yr.z;
    return (
      (Kr[0] = (1 - (oi + ai)) * di),
      (Kr[1] = (si + fi) * di),
      (Kr[2] = (li - ci) * di),
      (Kr[3] = 0),
      (Kr[4] = (si - fi) * pi),
      (Kr[5] = (1 - (ii + ai)) * pi),
      (Kr[6] = (ui + hi) * pi),
      (Kr[7] = 0),
      (Kr[8] = (li + ci) * mi),
      (Kr[9] = (ui - hi) * mi),
      (Kr[10] = (1 - (ii + oi)) * mi),
      (Kr[11] = 0),
      (Kr[12] = ze.x),
      (Kr[13] = ze.y),
      (Kr[14] = ze.z),
      (Kr[15] = 1),
      this
    );
  }
  decompose(ze, Gr, Yr) {
    const Kr = this.elements;
    let Zr = _v1$5.set(Kr[0], Kr[1], Kr[2]).length();
    const Jr = _v1$5.set(Kr[4], Kr[5], Kr[6]).length(),
      Qr = _v1$5.set(Kr[8], Kr[9], Kr[10]).length();
    this.determinant() < 0 && (Zr = -Zr),
      (ze.x = Kr[12]),
      (ze.y = Kr[13]),
      (ze.z = Kr[14]),
      _m1$2.copy(this);
    const ti = 1 / Zr,
      ri = 1 / Jr,
      ni = 1 / Qr;
    return (
      (_m1$2.elements[0] *= ti),
      (_m1$2.elements[1] *= ti),
      (_m1$2.elements[2] *= ti),
      (_m1$2.elements[4] *= ri),
      (_m1$2.elements[5] *= ri),
      (_m1$2.elements[6] *= ri),
      (_m1$2.elements[8] *= ni),
      (_m1$2.elements[9] *= ni),
      (_m1$2.elements[10] *= ni),
      Gr.setFromRotationMatrix(_m1$2),
      (Yr.x = Zr),
      (Yr.y = Jr),
      (Yr.z = Qr),
      this
    );
  }
  makePerspective(ze, Gr, Yr, Kr, Zr, Jr, Qr = WebGLCoordinateSystem) {
    const ei = this.elements,
      ti = (2 * Zr) / (Gr - ze),
      ri = (2 * Zr) / (Yr - Kr),
      ni = (Gr + ze) / (Gr - ze),
      ii = (Yr + Kr) / (Yr - Kr);
    let si, li;
    if (Qr === WebGLCoordinateSystem)
      (si = -(Jr + Zr) / (Jr - Zr)), (li = (-2 * Jr * Zr) / (Jr - Zr));
    else if (Qr === WebGPUCoordinateSystem)
      (si = -Jr / (Jr - Zr)), (li = (-Jr * Zr) / (Jr - Zr));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + Qr
      );
    return (
      (ei[0] = ti),
      (ei[4] = 0),
      (ei[8] = ni),
      (ei[12] = 0),
      (ei[1] = 0),
      (ei[5] = ri),
      (ei[9] = ii),
      (ei[13] = 0),
      (ei[2] = 0),
      (ei[6] = 0),
      (ei[10] = si),
      (ei[14] = li),
      (ei[3] = 0),
      (ei[7] = 0),
      (ei[11] = -1),
      (ei[15] = 0),
      this
    );
  }
  makeOrthographic(ze, Gr, Yr, Kr, Zr, Jr, Qr = WebGLCoordinateSystem) {
    const ei = this.elements,
      ti = 1 / (Gr - ze),
      ri = 1 / (Yr - Kr),
      ni = 1 / (Jr - Zr),
      ii = (Gr + ze) * ti,
      si = (Yr + Kr) * ri;
    let li, oi;
    if (Qr === WebGLCoordinateSystem) (li = (Jr + Zr) * ni), (oi = -2 * ni);
    else if (Qr === WebGPUCoordinateSystem) (li = Zr * ni), (oi = -1 * ni);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + Qr
      );
    return (
      (ei[0] = 2 * ti),
      (ei[4] = 0),
      (ei[8] = 0),
      (ei[12] = -ii),
      (ei[1] = 0),
      (ei[5] = 2 * ri),
      (ei[9] = 0),
      (ei[13] = -si),
      (ei[2] = 0),
      (ei[6] = 0),
      (ei[10] = oi),
      (ei[14] = -li),
      (ei[3] = 0),
      (ei[7] = 0),
      (ei[11] = 0),
      (ei[15] = 1),
      this
    );
  }
  equals(ze) {
    const Gr = this.elements,
      Yr = ze.elements;
    for (let Kr = 0; Kr < 16; Kr++) if (Gr[Kr] !== Yr[Kr]) return !1;
    return !0;
  }
  fromArray(ze, Gr = 0) {
    for (let Yr = 0; Yr < 16; Yr++) this.elements[Yr] = ze[Yr + Gr];
    return this;
  }
  toArray(ze = [], Gr = 0) {
    const Yr = this.elements;
    return (
      (ze[Gr] = Yr[0]),
      (ze[Gr + 1] = Yr[1]),
      (ze[Gr + 2] = Yr[2]),
      (ze[Gr + 3] = Yr[3]),
      (ze[Gr + 4] = Yr[4]),
      (ze[Gr + 5] = Yr[5]),
      (ze[Gr + 6] = Yr[6]),
      (ze[Gr + 7] = Yr[7]),
      (ze[Gr + 8] = Yr[8]),
      (ze[Gr + 9] = Yr[9]),
      (ze[Gr + 10] = Yr[10]),
      (ze[Gr + 11] = Yr[11]),
      (ze[Gr + 12] = Yr[12]),
      (ze[Gr + 13] = Yr[13]),
      (ze[Gr + 14] = Yr[14]),
      (ze[Gr + 15] = Yr[15]),
      ze
    );
  }
}
const _v1$5 = new Vector3(),
  _m1$2 = new Matrix4(),
  _zero = new Vector3(0, 0, 0),
  _one = new Vector3(1, 1, 1),
  _x = new Vector3(),
  _y = new Vector3(),
  _z = new Vector3(),
  _matrix = new Matrix4(),
  _quaternion$3 = new Quaternion();
class Euler {
  constructor(ze = 0, Gr = 0, Yr = 0, Kr = Euler.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = ze),
      (this._y = Gr),
      (this._z = Yr),
      (this._order = Kr);
  }
  get x() {
    return this._x;
  }
  set x(ze) {
    (this._x = ze), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(ze) {
    (this._y = ze), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(ze) {
    (this._z = ze), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(ze) {
    (this._order = ze), this._onChangeCallback();
  }
  set(ze, Gr, Yr, Kr = this._order) {
    return (
      (this._x = ze),
      (this._y = Gr),
      (this._z = Yr),
      (this._order = Kr),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(ze) {
    return (
      (this._x = ze._x),
      (this._y = ze._y),
      (this._z = ze._z),
      (this._order = ze._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(ze, Gr = this._order, Yr = !0) {
    const Kr = ze.elements,
      Zr = Kr[0],
      Jr = Kr[4],
      Qr = Kr[8],
      ei = Kr[1],
      ti = Kr[5],
      ri = Kr[9],
      ni = Kr[2],
      ii = Kr[6],
      si = Kr[10];
    switch (Gr) {
      case "XYZ":
        (this._y = Math.asin(clamp(Qr, -1, 1))),
          Math.abs(Qr) < 0.9999999
            ? ((this._x = Math.atan2(-ri, si)), (this._z = Math.atan2(-Jr, Zr)))
            : ((this._x = Math.atan2(ii, ti)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-clamp(ri, -1, 1))),
          Math.abs(ri) < 0.9999999
            ? ((this._y = Math.atan2(Qr, si)), (this._z = Math.atan2(ei, ti)))
            : ((this._y = Math.atan2(-ni, Zr)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(clamp(ii, -1, 1))),
          Math.abs(ii) < 0.9999999
            ? ((this._y = Math.atan2(-ni, si)), (this._z = Math.atan2(-Jr, ti)))
            : ((this._y = 0), (this._z = Math.atan2(ei, Zr)));
        break;
      case "ZYX":
        (this._y = Math.asin(-clamp(ni, -1, 1))),
          Math.abs(ni) < 0.9999999
            ? ((this._x = Math.atan2(ii, si)), (this._z = Math.atan2(ei, Zr)))
            : ((this._x = 0), (this._z = Math.atan2(-Jr, ti)));
        break;
      case "YZX":
        (this._z = Math.asin(clamp(ei, -1, 1))),
          Math.abs(ei) < 0.9999999
            ? ((this._x = Math.atan2(-ri, ti)), (this._y = Math.atan2(-ni, Zr)))
            : ((this._x = 0), (this._y = Math.atan2(Qr, si)));
        break;
      case "XZY":
        (this._z = Math.asin(-clamp(Jr, -1, 1))),
          Math.abs(Jr) < 0.9999999
            ? ((this._x = Math.atan2(ii, ti)), (this._y = Math.atan2(Qr, Zr)))
            : ((this._x = Math.atan2(-ri, si)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            Gr
        );
    }
    return (this._order = Gr), Yr === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(ze, Gr, Yr) {
    return (
      _matrix.makeRotationFromQuaternion(ze),
      this.setFromRotationMatrix(_matrix, Gr, Yr)
    );
  }
  setFromVector3(ze, Gr = this._order) {
    return this.set(ze.x, ze.y, ze.z, Gr);
  }
  reorder(ze) {
    return (
      _quaternion$3.setFromEuler(this),
      this.setFromQuaternion(_quaternion$3, ze)
    );
  }
  equals(ze) {
    return (
      ze._x === this._x &&
      ze._y === this._y &&
      ze._z === this._z &&
      ze._order === this._order
    );
  }
  fromArray(ze) {
    return (
      (this._x = ze[0]),
      (this._y = ze[1]),
      (this._z = ze[2]),
      ze[3] !== void 0 && (this._order = ze[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(ze = [], Gr = 0) {
    return (
      (ze[Gr] = this._x),
      (ze[Gr + 1] = this._y),
      (ze[Gr + 2] = this._z),
      (ze[Gr + 3] = this._order),
      ze
    );
  }
  _onChange(ze) {
    return (this._onChangeCallback = ze), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1;
  }
  set(ze) {
    this.mask = ((1 << ze) | 0) >>> 0;
  }
  enable(ze) {
    this.mask |= (1 << ze) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(ze) {
    this.mask ^= (1 << ze) | 0;
  }
  disable(ze) {
    this.mask &= ~((1 << ze) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(ze) {
    return (this.mask & ze.mask) !== 0;
  }
  isEnabled(ze) {
    return (this.mask & ((1 << ze) | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = new Vector3(),
  _q1 = new Quaternion(),
  _m1$1 = new Matrix4(),
  _target = new Vector3(),
  _position$3 = new Vector3(),
  _scale$2 = new Vector3(),
  _quaternion$2 = new Quaternion(),
  _xAxis = new Vector3(1, 0, 0),
  _yAxis = new Vector3(0, 1, 0),
  _zAxis = new Vector3(0, 0, 1),
  _addedEvent = {
    type: "added",
  },
  _removedEvent = {
    type: "removed",
  };
class Object3D extends EventDispatcher {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", {
        value: _object3DId++,
      }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Object3D.DEFAULT_UP.clone());
    const ze = new Vector3(),
      Gr = new Euler(),
      Yr = new Quaternion(),
      Kr = new Vector3(1, 1, 1);
    function Zr() {
      Yr.setFromEuler(Gr, !1);
    }
    function Jr() {
      Gr.setFromQuaternion(Yr, void 0, !1);
    }
    Gr._onChange(Zr),
      Yr._onChange(Jr),
      Object.defineProperties(this, {
        position: {
          configurable: !0,
          enumerable: !0,
          value: ze,
        },
        rotation: {
          configurable: !0,
          enumerable: !0,
          value: Gr,
        },
        quaternion: {
          configurable: !0,
          enumerable: !0,
          value: Yr,
        },
        scale: {
          configurable: !0,
          enumerable: !0,
          value: Kr,
        },
        modelViewMatrix: {
          value: new Matrix4(),
        },
        normalMatrix: {
          value: new Matrix3(),
        },
      }),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Layers()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(ze) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(ze),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(ze) {
    return this.quaternion.premultiply(ze), this;
  }
  setRotationFromAxisAngle(ze, Gr) {
    this.quaternion.setFromAxisAngle(ze, Gr);
  }
  setRotationFromEuler(ze) {
    this.quaternion.setFromEuler(ze, !0);
  }
  setRotationFromMatrix(ze) {
    this.quaternion.setFromRotationMatrix(ze);
  }
  setRotationFromQuaternion(ze) {
    this.quaternion.copy(ze);
  }
  rotateOnAxis(ze, Gr) {
    return _q1.setFromAxisAngle(ze, Gr), this.quaternion.multiply(_q1), this;
  }
  rotateOnWorldAxis(ze, Gr) {
    return _q1.setFromAxisAngle(ze, Gr), this.quaternion.premultiply(_q1), this;
  }
  rotateX(ze) {
    return this.rotateOnAxis(_xAxis, ze);
  }
  rotateY(ze) {
    return this.rotateOnAxis(_yAxis, ze);
  }
  rotateZ(ze) {
    return this.rotateOnAxis(_zAxis, ze);
  }
  translateOnAxis(ze, Gr) {
    return (
      _v1$4.copy(ze).applyQuaternion(this.quaternion),
      this.position.add(_v1$4.multiplyScalar(Gr)),
      this
    );
  }
  translateX(ze) {
    return this.translateOnAxis(_xAxis, ze);
  }
  translateY(ze) {
    return this.translateOnAxis(_yAxis, ze);
  }
  translateZ(ze) {
    return this.translateOnAxis(_zAxis, ze);
  }
  localToWorld(ze) {
    return this.updateWorldMatrix(!0, !1), ze.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(ze) {
    return (
      this.updateWorldMatrix(!0, !1),
      ze.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())
    );
  }
  lookAt(ze, Gr, Yr) {
    ze.isVector3 ? _target.copy(ze) : _target.set(ze, Gr, Yr);
    const Kr = this.parent;
    this.updateWorldMatrix(!0, !1),
      _position$3.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? _m1$1.lookAt(_position$3, _target, this.up)
        : _m1$1.lookAt(_target, _position$3, this.up),
      this.quaternion.setFromRotationMatrix(_m1$1),
      Kr &&
        (_m1$1.extractRotation(Kr.matrixWorld),
        _q1.setFromRotationMatrix(_m1$1),
        this.quaternion.premultiply(_q1.invert()));
  }
  add(ze) {
    if (arguments.length > 1) {
      for (let Gr = 0; Gr < arguments.length; Gr++) this.add(arguments[Gr]);
      return this;
    }
    return ze === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          ze
        ),
        this)
      : (ze && ze.isObject3D
          ? (ze.parent !== null && ze.parent.remove(ze),
            (ze.parent = this),
            this.children.push(ze),
            ze.dispatchEvent(_addedEvent))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              ze
            ),
        this);
  }
  remove(ze) {
    if (arguments.length > 1) {
      for (let Yr = 0; Yr < arguments.length; Yr++) this.remove(arguments[Yr]);
      return this;
    }
    const Gr = this.children.indexOf(ze);
    return (
      Gr !== -1 &&
        ((ze.parent = null),
        this.children.splice(Gr, 1),
        ze.dispatchEvent(_removedEvent)),
      this
    );
  }
  removeFromParent() {
    const ze = this.parent;
    return ze !== null && ze.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(ze) {
    return (
      this.updateWorldMatrix(!0, !1),
      _m1$1.copy(this.matrixWorld).invert(),
      ze.parent !== null &&
        (ze.parent.updateWorldMatrix(!0, !1),
        _m1$1.multiply(ze.parent.matrixWorld)),
      ze.applyMatrix4(_m1$1),
      this.add(ze),
      ze.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(ze) {
    return this.getObjectByProperty("id", ze);
  }
  getObjectByName(ze) {
    return this.getObjectByProperty("name", ze);
  }
  getObjectByProperty(ze, Gr) {
    if (this[ze] === Gr) return this;
    for (let Yr = 0, Kr = this.children.length; Yr < Kr; Yr++) {
      const Jr = this.children[Yr].getObjectByProperty(ze, Gr);
      if (Jr !== void 0) return Jr;
    }
  }
  getObjectsByProperty(ze, Gr) {
    let Yr = [];
    this[ze] === Gr && Yr.push(this);
    for (let Kr = 0, Zr = this.children.length; Kr < Zr; Kr++) {
      const Jr = this.children[Kr].getObjectsByProperty(ze, Gr);
      Jr.length > 0 && (Yr = Yr.concat(Jr));
    }
    return Yr;
  }
  getWorldPosition(ze) {
    return (
      this.updateWorldMatrix(!0, !1), ze.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(ze) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, ze, _scale$2),
      ze
    );
  }
  getWorldScale(ze) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, _quaternion$2, ze),
      ze
    );
  }
  getWorldDirection(ze) {
    this.updateWorldMatrix(!0, !1);
    const Gr = this.matrixWorld.elements;
    return ze.set(Gr[8], Gr[9], Gr[10]).normalize();
  }
  raycast() {}
  traverse(ze) {
    ze(this);
    const Gr = this.children;
    for (let Yr = 0, Kr = Gr.length; Yr < Kr; Yr++) Gr[Yr].traverse(ze);
  }
  traverseVisible(ze) {
    if (this.visible === !1) return;
    ze(this);
    const Gr = this.children;
    for (let Yr = 0, Kr = Gr.length; Yr < Kr; Yr++) Gr[Yr].traverseVisible(ze);
  }
  traverseAncestors(ze) {
    const Gr = this.parent;
    Gr !== null && (ze(Gr), Gr.traverseAncestors(ze));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(ze) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || ze) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (ze = !0));
    const Gr = this.children;
    for (let Yr = 0, Kr = Gr.length; Yr < Kr; Yr++) {
      const Zr = Gr[Yr];
      (Zr.matrixWorldAutoUpdate === !0 || ze === !0) &&
        Zr.updateMatrixWorld(ze);
    }
  }
  updateWorldMatrix(ze, Gr) {
    const Yr = this.parent;
    if (
      (ze === !0 &&
        Yr !== null &&
        Yr.matrixWorldAutoUpdate === !0 &&
        Yr.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      Gr === !0)
    ) {
      const Kr = this.children;
      for (let Zr = 0, Jr = Kr.length; Zr < Jr; Zr++) {
        const Qr = Kr[Zr];
        Qr.matrixWorldAutoUpdate === !0 && Qr.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(ze) {
    const Gr = ze === void 0 || typeof ze == "string",
      Yr = {};
    Gr &&
      ((ze = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (Yr.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const Kr = {};
    (Kr.uuid = this.uuid),
      (Kr.type = this.type),
      this.name !== "" && (Kr.name = this.name),
      this.castShadow === !0 && (Kr.castShadow = !0),
      this.receiveShadow === !0 && (Kr.receiveShadow = !0),
      this.visible === !1 && (Kr.visible = !1),
      this.frustumCulled === !1 && (Kr.frustumCulled = !1),
      this.renderOrder !== 0 && (Kr.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (Kr.userData = this.userData),
      (Kr.layers = this.layers.mask),
      (Kr.matrix = this.matrix.toArray()),
      (Kr.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (Kr.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((Kr.type = "InstancedMesh"),
        (Kr.count = this.count),
        (Kr.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (Kr.instanceColor = this.instanceColor.toJSON()));
    function Zr(Qr, ei) {
      return Qr[ei.uuid] === void 0 && (Qr[ei.uuid] = ei.toJSON(ze)), ei.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (Kr.background = this.background.toJSON())
          : this.background.isTexture &&
            (Kr.background = this.background.toJSON(ze).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (Kr.environment = this.environment.toJSON(ze).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      Kr.geometry = Zr(ze.geometries, this.geometry);
      const Qr = this.geometry.parameters;
      if (Qr !== void 0 && Qr.shapes !== void 0) {
        const ei = Qr.shapes;
        if (Array.isArray(ei))
          for (let ti = 0, ri = ei.length; ti < ri; ti++) {
            const ni = ei[ti];
            Zr(ze.shapes, ni);
          }
        else Zr(ze.shapes, ei);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((Kr.bindMode = this.bindMode),
        (Kr.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (Zr(ze.skeletons, this.skeleton),
          (Kr.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const Qr = [];
        for (let ei = 0, ti = this.material.length; ei < ti; ei++)
          Qr.push(Zr(ze.materials, this.material[ei]));
        Kr.material = Qr;
      } else Kr.material = Zr(ze.materials, this.material);
    if (this.children.length > 0) {
      Kr.children = [];
      for (let Qr = 0; Qr < this.children.length; Qr++)
        Kr.children.push(this.children[Qr].toJSON(ze).object);
    }
    if (this.animations.length > 0) {
      Kr.animations = [];
      for (let Qr = 0; Qr < this.animations.length; Qr++) {
        const ei = this.animations[Qr];
        Kr.animations.push(Zr(ze.animations, ei));
      }
    }
    if (Gr) {
      const Qr = Jr(ze.geometries),
        ei = Jr(ze.materials),
        ti = Jr(ze.textures),
        ri = Jr(ze.images),
        ni = Jr(ze.shapes),
        ii = Jr(ze.skeletons),
        si = Jr(ze.animations),
        li = Jr(ze.nodes);
      Qr.length > 0 && (Yr.geometries = Qr),
        ei.length > 0 && (Yr.materials = ei),
        ti.length > 0 && (Yr.textures = ti),
        ri.length > 0 && (Yr.images = ri),
        ni.length > 0 && (Yr.shapes = ni),
        ii.length > 0 && (Yr.skeletons = ii),
        si.length > 0 && (Yr.animations = si),
        li.length > 0 && (Yr.nodes = li);
    }
    return (Yr.object = Kr), Yr;
    function Jr(Qr) {
      const ei = [];
      for (const ti in Qr) {
        const ri = Qr[ti];
        delete ri.metadata, ei.push(ri);
      }
      return ei;
    }
  }
  clone(ze) {
    return new this.constructor().copy(this, ze);
  }
  copy(ze, Gr = !0) {
    if (
      ((this.name = ze.name),
      this.up.copy(ze.up),
      this.position.copy(ze.position),
      (this.rotation.order = ze.rotation.order),
      this.quaternion.copy(ze.quaternion),
      this.scale.copy(ze.scale),
      this.matrix.copy(ze.matrix),
      this.matrixWorld.copy(ze.matrixWorld),
      (this.matrixAutoUpdate = ze.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = ze.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = ze.matrixWorldAutoUpdate),
      (this.layers.mask = ze.layers.mask),
      (this.visible = ze.visible),
      (this.castShadow = ze.castShadow),
      (this.receiveShadow = ze.receiveShadow),
      (this.frustumCulled = ze.frustumCulled),
      (this.renderOrder = ze.renderOrder),
      (this.animations = ze.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(ze.userData))),
      Gr === !0)
    )
      for (let Yr = 0; Yr < ze.children.length; Yr++) {
        const Kr = ze.children[Yr];
        this.add(Kr.clone());
      }
    return this;
  }
}
Object3D.DEFAULT_UP = new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const _v0$1 = new Vector3(),
  _v1$3 = new Vector3(),
  _v2$2 = new Vector3(),
  _v3$1 = new Vector3(),
  _vab = new Vector3(),
  _vac = new Vector3(),
  _vbc = new Vector3(),
  _vap = new Vector3(),
  _vbp = new Vector3(),
  _vcp = new Vector3();
let warnedGetUV = !1;
class Triangle {
  constructor(ze = new Vector3(), Gr = new Vector3(), Yr = new Vector3()) {
    (this.a = ze), (this.b = Gr), (this.c = Yr);
  }
  static getNormal(ze, Gr, Yr, Kr) {
    Kr.subVectors(Yr, Gr), _v0$1.subVectors(ze, Gr), Kr.cross(_v0$1);
    const Zr = Kr.lengthSq();
    return Zr > 0 ? Kr.multiplyScalar(1 / Math.sqrt(Zr)) : Kr.set(0, 0, 0);
  }
  static getBarycoord(ze, Gr, Yr, Kr, Zr) {
    _v0$1.subVectors(Kr, Gr),
      _v1$3.subVectors(Yr, Gr),
      _v2$2.subVectors(ze, Gr);
    const Jr = _v0$1.dot(_v0$1),
      Qr = _v0$1.dot(_v1$3),
      ei = _v0$1.dot(_v2$2),
      ti = _v1$3.dot(_v1$3),
      ri = _v1$3.dot(_v2$2),
      ni = Jr * ti - Qr * Qr;
    if (ni === 0) return Zr.set(-2, -1, -1);
    const ii = 1 / ni,
      si = (ti * ei - Qr * ri) * ii,
      li = (Jr * ri - Qr * ei) * ii;
    return Zr.set(1 - si - li, li, si);
  }
  static containsPoint(ze, Gr, Yr, Kr) {
    return (
      this.getBarycoord(ze, Gr, Yr, Kr, _v3$1),
      _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1
    );
  }
  static getUV(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei) {
    return (
      warnedGetUV === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (warnedGetUV = !0)),
      this.getInterpolation(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei)
    );
  }
  static getInterpolation(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei) {
    return (
      this.getBarycoord(ze, Gr, Yr, Kr, _v3$1),
      ei.setScalar(0),
      ei.addScaledVector(Zr, _v3$1.x),
      ei.addScaledVector(Jr, _v3$1.y),
      ei.addScaledVector(Qr, _v3$1.z),
      ei
    );
  }
  static isFrontFacing(ze, Gr, Yr, Kr) {
    return (
      _v0$1.subVectors(Yr, Gr),
      _v1$3.subVectors(ze, Gr),
      _v0$1.cross(_v1$3).dot(Kr) < 0
    );
  }
  set(ze, Gr, Yr) {
    return this.a.copy(ze), this.b.copy(Gr), this.c.copy(Yr), this;
  }
  setFromPointsAndIndices(ze, Gr, Yr, Kr) {
    return this.a.copy(ze[Gr]), this.b.copy(ze[Yr]), this.c.copy(ze[Kr]), this;
  }
  setFromAttributeAndIndices(ze, Gr, Yr, Kr) {
    return (
      this.a.fromBufferAttribute(ze, Gr),
      this.b.fromBufferAttribute(ze, Yr),
      this.c.fromBufferAttribute(ze, Kr),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(ze) {
    return this.a.copy(ze.a), this.b.copy(ze.b), this.c.copy(ze.c), this;
  }
  getArea() {
    return (
      _v0$1.subVectors(this.c, this.b),
      _v1$3.subVectors(this.a, this.b),
      _v0$1.cross(_v1$3).length() * 0.5
    );
  }
  getMidpoint(ze) {
    return ze
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(ze) {
    return Triangle.getNormal(this.a, this.b, this.c, ze);
  }
  getPlane(ze) {
    return ze.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(ze, Gr) {
    return Triangle.getBarycoord(ze, this.a, this.b, this.c, Gr);
  }
  getUV(ze, Gr, Yr, Kr, Zr) {
    return (
      warnedGetUV === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (warnedGetUV = !0)),
      Triangle.getInterpolation(ze, this.a, this.b, this.c, Gr, Yr, Kr, Zr)
    );
  }
  getInterpolation(ze, Gr, Yr, Kr, Zr) {
    return Triangle.getInterpolation(
      ze,
      this.a,
      this.b,
      this.c,
      Gr,
      Yr,
      Kr,
      Zr
    );
  }
  containsPoint(ze) {
    return Triangle.containsPoint(ze, this.a, this.b, this.c);
  }
  isFrontFacing(ze) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, ze);
  }
  intersectsBox(ze) {
    return ze.intersectsTriangle(this);
  }
  closestPointToPoint(ze, Gr) {
    const Yr = this.a,
      Kr = this.b,
      Zr = this.c;
    let Jr, Qr;
    _vab.subVectors(Kr, Yr), _vac.subVectors(Zr, Yr), _vap.subVectors(ze, Yr);
    const ei = _vab.dot(_vap),
      ti = _vac.dot(_vap);
    if (ei <= 0 && ti <= 0) return Gr.copy(Yr);
    _vbp.subVectors(ze, Kr);
    const ri = _vab.dot(_vbp),
      ni = _vac.dot(_vbp);
    if (ri >= 0 && ni <= ri) return Gr.copy(Kr);
    const ii = ei * ni - ri * ti;
    if (ii <= 0 && ei >= 0 && ri <= 0)
      return (Jr = ei / (ei - ri)), Gr.copy(Yr).addScaledVector(_vab, Jr);
    _vcp.subVectors(ze, Zr);
    const si = _vab.dot(_vcp),
      li = _vac.dot(_vcp);
    if (li >= 0 && si <= li) return Gr.copy(Zr);
    const oi = si * ti - ei * li;
    if (oi <= 0 && ti >= 0 && li <= 0)
      return (Qr = ti / (ti - li)), Gr.copy(Yr).addScaledVector(_vac, Qr);
    const ui = ri * li - si * ni;
    if (ui <= 0 && ni - ri >= 0 && si - li >= 0)
      return (
        _vbc.subVectors(Zr, Kr),
        (Qr = (ni - ri) / (ni - ri + (si - li))),
        Gr.copy(Kr).addScaledVector(_vbc, Qr)
      );
    const ai = 1 / (ui + oi + ii);
    return (
      (Jr = oi * ai),
      (Qr = ii * ai),
      Gr.copy(Yr).addScaledVector(_vab, Jr).addScaledVector(_vac, Qr)
    );
  }
  equals(ze) {
    return ze.a.equals(this.a) && ze.b.equals(this.b) && ze.c.equals(this.c);
  }
}
const _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  _hslA = {
    h: 0,
    s: 0,
    l: 0,
  },
  _hslB = {
    h: 0,
    s: 0,
    l: 0,
  };
function hue2rgb(Wr, ze, Gr) {
  return (
    Gr < 0 && (Gr += 1),
    Gr > 1 && (Gr -= 1),
    Gr < 1 / 6
      ? Wr + (ze - Wr) * 6 * Gr
      : Gr < 1 / 2
      ? ze
      : Gr < 2 / 3
      ? Wr + (ze - Wr) * 6 * (2 / 3 - Gr)
      : Wr
  );
}
class Color {
  constructor(ze, Gr, Yr) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(ze, Gr, Yr)
    );
  }
  set(ze, Gr, Yr) {
    if (Gr === void 0 && Yr === void 0) {
      const Kr = ze;
      Kr && Kr.isColor
        ? this.copy(Kr)
        : typeof Kr == "number"
        ? this.setHex(Kr)
        : typeof Kr == "string" && this.setStyle(Kr);
    } else this.setRGB(ze, Gr, Yr);
    return this;
  }
  setScalar(ze) {
    return (this.r = ze), (this.g = ze), (this.b = ze), this;
  }
  setHex(ze, Gr = SRGBColorSpace) {
    return (
      (ze = Math.floor(ze)),
      (this.r = ((ze >> 16) & 255) / 255),
      (this.g = ((ze >> 8) & 255) / 255),
      (this.b = (ze & 255) / 255),
      ColorManagement.toWorkingColorSpace(this, Gr),
      this
    );
  }
  setRGB(ze, Gr, Yr, Kr = ColorManagement.workingColorSpace) {
    return (
      (this.r = ze),
      (this.g = Gr),
      (this.b = Yr),
      ColorManagement.toWorkingColorSpace(this, Kr),
      this
    );
  }
  setHSL(ze, Gr, Yr, Kr = ColorManagement.workingColorSpace) {
    if (
      ((ze = euclideanModulo(ze, 1)),
      (Gr = clamp(Gr, 0, 1)),
      (Yr = clamp(Yr, 0, 1)),
      Gr === 0)
    )
      this.r = this.g = this.b = Yr;
    else {
      const Zr = Yr <= 0.5 ? Yr * (1 + Gr) : Yr + Gr - Yr * Gr,
        Jr = 2 * Yr - Zr;
      (this.r = hue2rgb(Jr, Zr, ze + 1 / 3)),
        (this.g = hue2rgb(Jr, Zr, ze)),
        (this.b = hue2rgb(Jr, Zr, ze - 1 / 3));
    }
    return ColorManagement.toWorkingColorSpace(this, Kr), this;
  }
  setStyle(ze, Gr = SRGBColorSpace) {
    function Yr(Zr) {
      Zr !== void 0 &&
        parseFloat(Zr) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + ze + " will be ignored."
        );
    }
    let Kr;
    if ((Kr = /^(\w+)\(([^\)]*)\)/.exec(ze))) {
      let Zr;
      const Jr = Kr[1],
        Qr = Kr[2];
      switch (Jr) {
        case "rgb":
        case "rgba":
          if (
            (Zr =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                Qr
              ))
          )
            return (
              Yr(Zr[4]),
              this.setRGB(
                Math.min(255, parseInt(Zr[1], 10)) / 255,
                Math.min(255, parseInt(Zr[2], 10)) / 255,
                Math.min(255, parseInt(Zr[3], 10)) / 255,
                Gr
              )
            );
          if (
            (Zr =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                Qr
              ))
          )
            return (
              Yr(Zr[4]),
              this.setRGB(
                Math.min(100, parseInt(Zr[1], 10)) / 100,
                Math.min(100, parseInt(Zr[2], 10)) / 100,
                Math.min(100, parseInt(Zr[3], 10)) / 100,
                Gr
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (Zr =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                Qr
              ))
          )
            return (
              Yr(Zr[4]),
              this.setHSL(
                parseFloat(Zr[1]) / 360,
                parseFloat(Zr[2]) / 100,
                parseFloat(Zr[3]) / 100,
                Gr
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + ze);
      }
    } else if ((Kr = /^\#([A-Fa-f\d]+)$/.exec(ze))) {
      const Zr = Kr[1],
        Jr = Zr.length;
      if (Jr === 3)
        return this.setRGB(
          parseInt(Zr.charAt(0), 16) / 15,
          parseInt(Zr.charAt(1), 16) / 15,
          parseInt(Zr.charAt(2), 16) / 15,
          Gr
        );
      if (Jr === 6) return this.setHex(parseInt(Zr, 16), Gr);
      console.warn("THREE.Color: Invalid hex color " + ze);
    } else if (ze && ze.length > 0) return this.setColorName(ze, Gr);
    return this;
  }
  setColorName(ze, Gr = SRGBColorSpace) {
    const Yr = _colorKeywords[ze.toLowerCase()];
    return (
      Yr !== void 0
        ? this.setHex(Yr, Gr)
        : console.warn("THREE.Color: Unknown color " + ze),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(ze) {
    return (this.r = ze.r), (this.g = ze.g), (this.b = ze.b), this;
  }
  copySRGBToLinear(ze) {
    return (
      (this.r = SRGBToLinear(ze.r)),
      (this.g = SRGBToLinear(ze.g)),
      (this.b = SRGBToLinear(ze.b)),
      this
    );
  }
  copyLinearToSRGB(ze) {
    return (
      (this.r = LinearToSRGB(ze.r)),
      (this.g = LinearToSRGB(ze.g)),
      (this.b = LinearToSRGB(ze.b)),
      this
    );
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(ze = SRGBColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), ze),
      Math.round(clamp(_color.r * 255, 0, 255)) * 65536 +
        Math.round(clamp(_color.g * 255, 0, 255)) * 256 +
        Math.round(clamp(_color.b * 255, 0, 255))
    );
  }
  getHexString(ze = SRGBColorSpace) {
    return ("000000" + this.getHex(ze).toString(16)).slice(-6);
  }
  getHSL(ze, Gr = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), Gr);
    const Yr = _color.r,
      Kr = _color.g,
      Zr = _color.b,
      Jr = Math.max(Yr, Kr, Zr),
      Qr = Math.min(Yr, Kr, Zr);
    let ei, ti;
    const ri = (Qr + Jr) / 2;
    if (Qr === Jr) (ei = 0), (ti = 0);
    else {
      const ni = Jr - Qr;
      switch (((ti = ri <= 0.5 ? ni / (Jr + Qr) : ni / (2 - Jr - Qr)), Jr)) {
        case Yr:
          ei = (Kr - Zr) / ni + (Kr < Zr ? 6 : 0);
          break;
        case Kr:
          ei = (Zr - Yr) / ni + 2;
          break;
        case Zr:
          ei = (Yr - Kr) / ni + 4;
          break;
      }
      ei /= 6;
    }
    return (ze.h = ei), (ze.s = ti), (ze.l = ri), ze;
  }
  getRGB(ze, Gr = ColorManagement.workingColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), Gr),
      (ze.r = _color.r),
      (ze.g = _color.g),
      (ze.b = _color.b),
      ze
    );
  }
  getStyle(ze = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), ze);
    const Gr = _color.r,
      Yr = _color.g,
      Kr = _color.b;
    return ze !== SRGBColorSpace
      ? `color(${ze} ${Gr.toFixed(3)} ${Yr.toFixed(3)} ${Kr.toFixed(3)})`
      : `rgb(${Math.round(Gr * 255)},${Math.round(Yr * 255)},${Math.round(
          Kr * 255
        )})`;
  }
  offsetHSL(ze, Gr, Yr) {
    return (
      this.getHSL(_hslA), this.setHSL(_hslA.h + ze, _hslA.s + Gr, _hslA.l + Yr)
    );
  }
  add(ze) {
    return (this.r += ze.r), (this.g += ze.g), (this.b += ze.b), this;
  }
  addColors(ze, Gr) {
    return (
      (this.r = ze.r + Gr.r),
      (this.g = ze.g + Gr.g),
      (this.b = ze.b + Gr.b),
      this
    );
  }
  addScalar(ze) {
    return (this.r += ze), (this.g += ze), (this.b += ze), this;
  }
  sub(ze) {
    return (
      (this.r = Math.max(0, this.r - ze.r)),
      (this.g = Math.max(0, this.g - ze.g)),
      (this.b = Math.max(0, this.b - ze.b)),
      this
    );
  }
  multiply(ze) {
    return (this.r *= ze.r), (this.g *= ze.g), (this.b *= ze.b), this;
  }
  multiplyScalar(ze) {
    return (this.r *= ze), (this.g *= ze), (this.b *= ze), this;
  }
  lerp(ze, Gr) {
    return (
      (this.r += (ze.r - this.r) * Gr),
      (this.g += (ze.g - this.g) * Gr),
      (this.b += (ze.b - this.b) * Gr),
      this
    );
  }
  lerpColors(ze, Gr, Yr) {
    return (
      (this.r = ze.r + (Gr.r - ze.r) * Yr),
      (this.g = ze.g + (Gr.g - ze.g) * Yr),
      (this.b = ze.b + (Gr.b - ze.b) * Yr),
      this
    );
  }
  lerpHSL(ze, Gr) {
    this.getHSL(_hslA), ze.getHSL(_hslB);
    const Yr = lerp(_hslA.h, _hslB.h, Gr),
      Kr = lerp(_hslA.s, _hslB.s, Gr),
      Zr = lerp(_hslA.l, _hslB.l, Gr);
    return this.setHSL(Yr, Kr, Zr), this;
  }
  setFromVector3(ze) {
    return (this.r = ze.x), (this.g = ze.y), (this.b = ze.z), this;
  }
  applyMatrix3(ze) {
    const Gr = this.r,
      Yr = this.g,
      Kr = this.b,
      Zr = ze.elements;
    return (
      (this.r = Zr[0] * Gr + Zr[3] * Yr + Zr[6] * Kr),
      (this.g = Zr[1] * Gr + Zr[4] * Yr + Zr[7] * Kr),
      (this.b = Zr[2] * Gr + Zr[5] * Yr + Zr[8] * Kr),
      this
    );
  }
  equals(ze) {
    return ze.r === this.r && ze.g === this.g && ze.b === this.b;
  }
  fromArray(ze, Gr = 0) {
    return (
      (this.r = ze[Gr]), (this.g = ze[Gr + 1]), (this.b = ze[Gr + 2]), this
    );
  }
  toArray(ze = [], Gr = 0) {
    return (ze[Gr] = this.r), (ze[Gr + 1] = this.g), (ze[Gr + 2] = this.b), ze;
  }
  fromBufferAttribute(ze, Gr) {
    return (
      (this.r = ze.getX(Gr)),
      (this.g = ze.getY(Gr)),
      (this.b = ze.getZ(Gr)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const _color = new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", {
        value: _materialId++,
      }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = NormalBlending),
      (this.side = FrontSide),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = SrcAlphaFactor),
      (this.blendDst = OneMinusSrcAlphaFactor),
      (this.blendEquation = AddEquation),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Color(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = LessEqualDepth),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = AlwaysStencilFunc),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = KeepStencilOp),
      (this.stencilZFail = KeepStencilOp),
      (this.stencilZPass = KeepStencilOp),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(ze) {
    this._alphaTest > 0 != ze > 0 && this.version++, (this._alphaTest = ze);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(ze) {
    if (ze !== void 0)
      for (const Gr in ze) {
        const Yr = ze[Gr];
        if (Yr === void 0) {
          console.warn(
            `THREE.Material: parameter '${Gr}' has value of undefined.`
          );
          continue;
        }
        const Kr = this[Gr];
        if (Kr === void 0) {
          console.warn(
            `THREE.Material: '${Gr}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        Kr && Kr.isColor
          ? Kr.set(Yr)
          : Kr && Kr.isVector3 && Yr && Yr.isVector3
          ? Kr.copy(Yr)
          : (this[Gr] = Yr);
      }
  }
  toJSON(ze) {
    const Gr = ze === void 0 || typeof ze == "string";
    Gr &&
      (ze = {
        textures: {},
        images: {},
      });
    const Yr = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (Yr.uuid = this.uuid),
      (Yr.type = this.type),
      this.name !== "" && (Yr.name = this.name),
      this.color && this.color.isColor && (Yr.color = this.color.getHex()),
      this.roughness !== void 0 && (Yr.roughness = this.roughness),
      this.metalness !== void 0 && (Yr.metalness = this.metalness),
      this.sheen !== void 0 && (Yr.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (Yr.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (Yr.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (Yr.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (Yr.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (Yr.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (Yr.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (Yr.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (Yr.shininess = this.shininess),
      this.clearcoat !== void 0 && (Yr.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (Yr.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (Yr.clearcoatMap = this.clearcoatMap.toJSON(ze).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (Yr.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(ze).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((Yr.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(ze).uuid),
        (Yr.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (Yr.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (Yr.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (Yr.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (Yr.iridescenceMap = this.iridescenceMap.toJSON(ze).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (Yr.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(ze).uuid),
      this.anisotropy !== void 0 && (Yr.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (Yr.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (Yr.anisotropyMap = this.anisotropyMap.toJSON(ze).uuid),
      this.map && this.map.isTexture && (Yr.map = this.map.toJSON(ze).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (Yr.matcap = this.matcap.toJSON(ze).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (Yr.alphaMap = this.alphaMap.toJSON(ze).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((Yr.lightMap = this.lightMap.toJSON(ze).uuid),
        (Yr.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((Yr.aoMap = this.aoMap.toJSON(ze).uuid),
        (Yr.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((Yr.bumpMap = this.bumpMap.toJSON(ze).uuid),
        (Yr.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((Yr.normalMap = this.normalMap.toJSON(ze).uuid),
        (Yr.normalMapType = this.normalMapType),
        (Yr.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((Yr.displacementMap = this.displacementMap.toJSON(ze).uuid),
        (Yr.displacementScale = this.displacementScale),
        (Yr.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (Yr.roughnessMap = this.roughnessMap.toJSON(ze).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (Yr.metalnessMap = this.metalnessMap.toJSON(ze).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (Yr.emissiveMap = this.emissiveMap.toJSON(ze).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (Yr.specularMap = this.specularMap.toJSON(ze).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (Yr.specularIntensityMap = this.specularIntensityMap.toJSON(ze).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (Yr.specularColorMap = this.specularColorMap.toJSON(ze).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((Yr.envMap = this.envMap.toJSON(ze).uuid),
        this.combine !== void 0 && (Yr.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (Yr.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (Yr.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (Yr.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (Yr.gradientMap = this.gradientMap.toJSON(ze).uuid),
      this.transmission !== void 0 && (Yr.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (Yr.transmissionMap = this.transmissionMap.toJSON(ze).uuid),
      this.thickness !== void 0 && (Yr.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (Yr.thicknessMap = this.thicknessMap.toJSON(ze).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (Yr.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (Yr.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (Yr.size = this.size),
      this.shadowSide !== null && (Yr.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (Yr.sizeAttenuation = this.sizeAttenuation),
      this.blending !== NormalBlending && (Yr.blending = this.blending),
      this.side !== FrontSide && (Yr.side = this.side),
      this.vertexColors === !0 && (Yr.vertexColors = !0),
      this.opacity < 1 && (Yr.opacity = this.opacity),
      this.transparent === !0 && (Yr.transparent = !0),
      this.blendSrc !== SrcAlphaFactor && (Yr.blendSrc = this.blendSrc),
      this.blendDst !== OneMinusSrcAlphaFactor && (Yr.blendDst = this.blendDst),
      this.blendEquation !== AddEquation &&
        (Yr.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (Yr.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (Yr.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (Yr.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (Yr.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (Yr.blendAlpha = this.blendAlpha),
      this.depthFunc !== LessEqualDepth && (Yr.depthFunc = this.depthFunc),
      this.depthTest === !1 && (Yr.depthTest = this.depthTest),
      this.depthWrite === !1 && (Yr.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (Yr.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (Yr.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== AlwaysStencilFunc &&
        (Yr.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (Yr.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (Yr.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== KeepStencilOp && (Yr.stencilFail = this.stencilFail),
      this.stencilZFail !== KeepStencilOp &&
        (Yr.stencilZFail = this.stencilZFail),
      this.stencilZPass !== KeepStencilOp &&
        (Yr.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (Yr.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (Yr.rotation = this.rotation),
      this.polygonOffset === !0 && (Yr.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (Yr.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (Yr.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (Yr.linewidth = this.linewidth),
      this.dashSize !== void 0 && (Yr.dashSize = this.dashSize),
      this.gapSize !== void 0 && (Yr.gapSize = this.gapSize),
      this.scale !== void 0 && (Yr.scale = this.scale),
      this.dithering === !0 && (Yr.dithering = !0),
      this.alphaTest > 0 && (Yr.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (Yr.alphaHash = !0),
      this.alphaToCoverage === !0 && (Yr.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (Yr.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (Yr.forceSinglePass = !0),
      this.wireframe === !0 && (Yr.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (Yr.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (Yr.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (Yr.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (Yr.flatShading = !0),
      this.visible === !1 && (Yr.visible = !1),
      this.toneMapped === !1 && (Yr.toneMapped = !1),
      this.fog === !1 && (Yr.fog = !1),
      Object.keys(this.userData).length > 0 && (Yr.userData = this.userData);
    function Kr(Zr) {
      const Jr = [];
      for (const Qr in Zr) {
        const ei = Zr[Qr];
        delete ei.metadata, Jr.push(ei);
      }
      return Jr;
    }
    if (Gr) {
      const Zr = Kr(ze.textures),
        Jr = Kr(ze.images);
      Zr.length > 0 && (Yr.textures = Zr), Jr.length > 0 && (Yr.images = Jr);
    }
    return Yr;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(ze) {
    (this.name = ze.name),
      (this.blending = ze.blending),
      (this.side = ze.side),
      (this.vertexColors = ze.vertexColors),
      (this.opacity = ze.opacity),
      (this.transparent = ze.transparent),
      (this.blendSrc = ze.blendSrc),
      (this.blendDst = ze.blendDst),
      (this.blendEquation = ze.blendEquation),
      (this.blendSrcAlpha = ze.blendSrcAlpha),
      (this.blendDstAlpha = ze.blendDstAlpha),
      (this.blendEquationAlpha = ze.blendEquationAlpha),
      this.blendColor.copy(ze.blendColor),
      (this.blendAlpha = ze.blendAlpha),
      (this.depthFunc = ze.depthFunc),
      (this.depthTest = ze.depthTest),
      (this.depthWrite = ze.depthWrite),
      (this.stencilWriteMask = ze.stencilWriteMask),
      (this.stencilFunc = ze.stencilFunc),
      (this.stencilRef = ze.stencilRef),
      (this.stencilFuncMask = ze.stencilFuncMask),
      (this.stencilFail = ze.stencilFail),
      (this.stencilZFail = ze.stencilZFail),
      (this.stencilZPass = ze.stencilZPass),
      (this.stencilWrite = ze.stencilWrite);
    const Gr = ze.clippingPlanes;
    let Yr = null;
    if (Gr !== null) {
      const Kr = Gr.length;
      Yr = new Array(Kr);
      for (let Zr = 0; Zr !== Kr; ++Zr) Yr[Zr] = Gr[Zr].clone();
    }
    return (
      (this.clippingPlanes = Yr),
      (this.clipIntersection = ze.clipIntersection),
      (this.clipShadows = ze.clipShadows),
      (this.shadowSide = ze.shadowSide),
      (this.colorWrite = ze.colorWrite),
      (this.precision = ze.precision),
      (this.polygonOffset = ze.polygonOffset),
      (this.polygonOffsetFactor = ze.polygonOffsetFactor),
      (this.polygonOffsetUnits = ze.polygonOffsetUnits),
      (this.dithering = ze.dithering),
      (this.alphaTest = ze.alphaTest),
      (this.alphaHash = ze.alphaHash),
      (this.alphaToCoverage = ze.alphaToCoverage),
      (this.premultipliedAlpha = ze.premultipliedAlpha),
      (this.forceSinglePass = ze.forceSinglePass),
      (this.visible = ze.visible),
      (this.toneMapped = ze.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(ze.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
  set needsUpdate(ze) {
    ze === !0 && this.version++;
  }
}
class MeshBasicMaterial extends Material {
  constructor(ze) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(ze);
  }
  copy(ze) {
    return (
      super.copy(ze),
      this.color.copy(ze.color),
      (this.map = ze.map),
      (this.lightMap = ze.lightMap),
      (this.lightMapIntensity = ze.lightMapIntensity),
      (this.aoMap = ze.aoMap),
      (this.aoMapIntensity = ze.aoMapIntensity),
      (this.specularMap = ze.specularMap),
      (this.alphaMap = ze.alphaMap),
      (this.envMap = ze.envMap),
      (this.combine = ze.combine),
      (this.reflectivity = ze.reflectivity),
      (this.refractionRatio = ze.refractionRatio),
      (this.wireframe = ze.wireframe),
      (this.wireframeLinewidth = ze.wireframeLinewidth),
      (this.wireframeLinecap = ze.wireframeLinecap),
      (this.wireframeLinejoin = ze.wireframeLinejoin),
      (this.fog = ze.fog),
      this
    );
  }
}
const _vector$8 = new Vector3(),
  _vector2$1 = new Vector2();
class BufferAttribute {
  constructor(ze, Gr, Yr = !1) {
    if (Array.isArray(ze))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = ze),
      (this.itemSize = Gr),
      (this.count = ze !== void 0 ? ze.length / Gr : 0),
      (this.normalized = Yr),
      (this.usage = StaticDrawUsage),
      (this.updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.gpuType = FloatType),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(ze) {
    ze === !0 && this.version++;
  }
  setUsage(ze) {
    return (this.usage = ze), this;
  }
  copy(ze) {
    return (
      (this.name = ze.name),
      (this.array = new ze.array.constructor(ze.array)),
      (this.itemSize = ze.itemSize),
      (this.count = ze.count),
      (this.normalized = ze.normalized),
      (this.usage = ze.usage),
      (this.gpuType = ze.gpuType),
      this
    );
  }
  copyAt(ze, Gr, Yr) {
    (ze *= this.itemSize), (Yr *= Gr.itemSize);
    for (let Kr = 0, Zr = this.itemSize; Kr < Zr; Kr++)
      this.array[ze + Kr] = Gr.array[Yr + Kr];
    return this;
  }
  copyArray(ze) {
    return this.array.set(ze), this;
  }
  applyMatrix3(ze) {
    if (this.itemSize === 2)
      for (let Gr = 0, Yr = this.count; Gr < Yr; Gr++)
        _vector2$1.fromBufferAttribute(this, Gr),
          _vector2$1.applyMatrix3(ze),
          this.setXY(Gr, _vector2$1.x, _vector2$1.y);
    else if (this.itemSize === 3)
      for (let Gr = 0, Yr = this.count; Gr < Yr; Gr++)
        _vector$8.fromBufferAttribute(this, Gr),
          _vector$8.applyMatrix3(ze),
          this.setXYZ(Gr, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  applyMatrix4(ze) {
    for (let Gr = 0, Yr = this.count; Gr < Yr; Gr++)
      _vector$8.fromBufferAttribute(this, Gr),
        _vector$8.applyMatrix4(ze),
        this.setXYZ(Gr, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  applyNormalMatrix(ze) {
    for (let Gr = 0, Yr = this.count; Gr < Yr; Gr++)
      _vector$8.fromBufferAttribute(this, Gr),
        _vector$8.applyNormalMatrix(ze),
        this.setXYZ(Gr, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  transformDirection(ze) {
    for (let Gr = 0, Yr = this.count; Gr < Yr; Gr++)
      _vector$8.fromBufferAttribute(this, Gr),
        _vector$8.transformDirection(ze),
        this.setXYZ(Gr, _vector$8.x, _vector$8.y, _vector$8.z);
    return this;
  }
  set(ze, Gr = 0) {
    return this.array.set(ze, Gr), this;
  }
  getComponent(ze, Gr) {
    let Yr = this.array[ze * this.itemSize + Gr];
    return this.normalized && (Yr = denormalize(Yr, this.array)), Yr;
  }
  setComponent(ze, Gr, Yr) {
    return (
      this.normalized && (Yr = normalize(Yr, this.array)),
      (this.array[ze * this.itemSize + Gr] = Yr),
      this
    );
  }
  getX(ze) {
    let Gr = this.array[ze * this.itemSize];
    return this.normalized && (Gr = denormalize(Gr, this.array)), Gr;
  }
  setX(ze, Gr) {
    return (
      this.normalized && (Gr = normalize(Gr, this.array)),
      (this.array[ze * this.itemSize] = Gr),
      this
    );
  }
  getY(ze) {
    let Gr = this.array[ze * this.itemSize + 1];
    return this.normalized && (Gr = denormalize(Gr, this.array)), Gr;
  }
  setY(ze, Gr) {
    return (
      this.normalized && (Gr = normalize(Gr, this.array)),
      (this.array[ze * this.itemSize + 1] = Gr),
      this
    );
  }
  getZ(ze) {
    let Gr = this.array[ze * this.itemSize + 2];
    return this.normalized && (Gr = denormalize(Gr, this.array)), Gr;
  }
  setZ(ze, Gr) {
    return (
      this.normalized && (Gr = normalize(Gr, this.array)),
      (this.array[ze * this.itemSize + 2] = Gr),
      this
    );
  }
  getW(ze) {
    let Gr = this.array[ze * this.itemSize + 3];
    return this.normalized && (Gr = denormalize(Gr, this.array)), Gr;
  }
  setW(ze, Gr) {
    return (
      this.normalized && (Gr = normalize(Gr, this.array)),
      (this.array[ze * this.itemSize + 3] = Gr),
      this
    );
  }
  setXY(ze, Gr, Yr) {
    return (
      (ze *= this.itemSize),
      this.normalized &&
        ((Gr = normalize(Gr, this.array)), (Yr = normalize(Yr, this.array))),
      (this.array[ze + 0] = Gr),
      (this.array[ze + 1] = Yr),
      this
    );
  }
  setXYZ(ze, Gr, Yr, Kr) {
    return (
      (ze *= this.itemSize),
      this.normalized &&
        ((Gr = normalize(Gr, this.array)),
        (Yr = normalize(Yr, this.array)),
        (Kr = normalize(Kr, this.array))),
      (this.array[ze + 0] = Gr),
      (this.array[ze + 1] = Yr),
      (this.array[ze + 2] = Kr),
      this
    );
  }
  setXYZW(ze, Gr, Yr, Kr, Zr) {
    return (
      (ze *= this.itemSize),
      this.normalized &&
        ((Gr = normalize(Gr, this.array)),
        (Yr = normalize(Yr, this.array)),
        (Kr = normalize(Kr, this.array)),
        (Zr = normalize(Zr, this.array))),
      (this.array[ze + 0] = Gr),
      (this.array[ze + 1] = Yr),
      (this.array[ze + 2] = Kr),
      (this.array[ze + 3] = Zr),
      this
    );
  }
  onUpload(ze) {
    return (this.onUploadCallback = ze), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const ze = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (ze.name = this.name),
      this.usage !== StaticDrawUsage && (ze.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (ze.updateRange = this.updateRange),
      ze
    );
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(ze, Gr, Yr) {
    super(new Uint16Array(ze), Gr, Yr);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(ze, Gr, Yr) {
    super(new Uint32Array(ze), Gr, Yr);
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(ze, Gr, Yr) {
    super(new Float32Array(ze), Gr, Yr);
  }
}
let _id$2 = 0;
const _m1 = new Matrix4(),
  _obj = new Object3D(),
  _offset = new Vector3(),
  _box$1 = new Box3(),
  _boxMorphTargets = new Box3(),
  _vector$7 = new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", {
        value: _id$2++,
      }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = {
        start: 0,
        count: 1 / 0,
      }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(ze) {
    return (
      Array.isArray(ze)
        ? (this.index = new (
            arrayNeedsUint32(ze) ? Uint32BufferAttribute : Uint16BufferAttribute
          )(ze, 1))
        : (this.index = ze),
      this
    );
  }
  getAttribute(ze) {
    return this.attributes[ze];
  }
  setAttribute(ze, Gr) {
    return (this.attributes[ze] = Gr), this;
  }
  deleteAttribute(ze) {
    return delete this.attributes[ze], this;
  }
  hasAttribute(ze) {
    return this.attributes[ze] !== void 0;
  }
  addGroup(ze, Gr, Yr = 0) {
    this.groups.push({
      start: ze,
      count: Gr,
      materialIndex: Yr,
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(ze, Gr) {
    (this.drawRange.start = ze), (this.drawRange.count = Gr);
  }
  applyMatrix4(ze) {
    const Gr = this.attributes.position;
    Gr !== void 0 && (Gr.applyMatrix4(ze), (Gr.needsUpdate = !0));
    const Yr = this.attributes.normal;
    if (Yr !== void 0) {
      const Zr = new Matrix3().getNormalMatrix(ze);
      Yr.applyNormalMatrix(Zr), (Yr.needsUpdate = !0);
    }
    const Kr = this.attributes.tangent;
    return (
      Kr !== void 0 && (Kr.transformDirection(ze), (Kr.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(ze) {
    return _m1.makeRotationFromQuaternion(ze), this.applyMatrix4(_m1), this;
  }
  rotateX(ze) {
    return _m1.makeRotationX(ze), this.applyMatrix4(_m1), this;
  }
  rotateY(ze) {
    return _m1.makeRotationY(ze), this.applyMatrix4(_m1), this;
  }
  rotateZ(ze) {
    return _m1.makeRotationZ(ze), this.applyMatrix4(_m1), this;
  }
  translate(ze, Gr, Yr) {
    return _m1.makeTranslation(ze, Gr, Yr), this.applyMatrix4(_m1), this;
  }
  scale(ze, Gr, Yr) {
    return _m1.makeScale(ze, Gr, Yr), this.applyMatrix4(_m1), this;
  }
  lookAt(ze) {
    return (
      _obj.lookAt(ze), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(_offset).negate(),
      this.translate(_offset.x, _offset.y, _offset.z),
      this
    );
  }
  setFromPoints(ze) {
    const Gr = [];
    for (let Yr = 0, Kr = ze.length; Yr < Kr; Yr++) {
      const Zr = ze[Yr];
      Gr.push(Zr.x, Zr.y, Zr.z || 0);
    }
    return (
      this.setAttribute("position", new Float32BufferAttribute(Gr, 3)), this
    );
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const ze = this.attributes.position,
      Gr = this.morphAttributes.position;
    if (ze && ze.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new Vector3(-1 / 0, -1 / 0, -1 / 0),
          new Vector3(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (ze !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(ze), Gr))
        for (let Yr = 0, Kr = Gr.length; Yr < Kr; Yr++) {
          const Zr = Gr[Yr];
          _box$1.setFromBufferAttribute(Zr),
            this.morphTargetsRelative
              ? (_vector$7.addVectors(this.boundingBox.min, _box$1.min),
                this.boundingBox.expandByPoint(_vector$7),
                _vector$7.addVectors(this.boundingBox.max, _box$1.max),
                this.boundingBox.expandByPoint(_vector$7))
              : (this.boundingBox.expandByPoint(_box$1.min),
                this.boundingBox.expandByPoint(_box$1.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const ze = this.attributes.position,
      Gr = this.morphAttributes.position;
    if (ze && ze.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new Vector3(), 1 / 0);
      return;
    }
    if (ze) {
      const Yr = this.boundingSphere.center;
      if ((_box$1.setFromBufferAttribute(ze), Gr))
        for (let Zr = 0, Jr = Gr.length; Zr < Jr; Zr++) {
          const Qr = Gr[Zr];
          _boxMorphTargets.setFromBufferAttribute(Qr),
            this.morphTargetsRelative
              ? (_vector$7.addVectors(_box$1.min, _boxMorphTargets.min),
                _box$1.expandByPoint(_vector$7),
                _vector$7.addVectors(_box$1.max, _boxMorphTargets.max),
                _box$1.expandByPoint(_vector$7))
              : (_box$1.expandByPoint(_boxMorphTargets.min),
                _box$1.expandByPoint(_boxMorphTargets.max));
        }
      _box$1.getCenter(Yr);
      let Kr = 0;
      for (let Zr = 0, Jr = ze.count; Zr < Jr; Zr++)
        _vector$7.fromBufferAttribute(ze, Zr),
          (Kr = Math.max(Kr, Yr.distanceToSquared(_vector$7)));
      if (Gr)
        for (let Zr = 0, Jr = Gr.length; Zr < Jr; Zr++) {
          const Qr = Gr[Zr],
            ei = this.morphTargetsRelative;
          for (let ti = 0, ri = Qr.count; ti < ri; ti++)
            _vector$7.fromBufferAttribute(Qr, ti),
              ei &&
                (_offset.fromBufferAttribute(ze, ti), _vector$7.add(_offset)),
              (Kr = Math.max(Kr, Yr.distanceToSquared(_vector$7)));
        }
      (this.boundingSphere.radius = Math.sqrt(Kr)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const ze = this.index,
      Gr = this.attributes;
    if (
      ze === null ||
      Gr.position === void 0 ||
      Gr.normal === void 0 ||
      Gr.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const Yr = ze.array,
      Kr = Gr.position.array,
      Zr = Gr.normal.array,
      Jr = Gr.uv.array,
      Qr = Kr.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute(
        "tangent",
        new BufferAttribute(new Float32Array(4 * Qr), 4)
      );
    const ei = this.getAttribute("tangent").array,
      ti = [],
      ri = [];
    for (let Ei = 0; Ei < Qr; Ei++)
      (ti[Ei] = new Vector3()), (ri[Ei] = new Vector3());
    const ni = new Vector3(),
      ii = new Vector3(),
      si = new Vector3(),
      li = new Vector2(),
      oi = new Vector2(),
      ui = new Vector2(),
      ai = new Vector3(),
      hi = new Vector3();
    function ci(Ei, Pi, Ai) {
      ni.fromArray(Kr, Ei * 3),
        ii.fromArray(Kr, Pi * 3),
        si.fromArray(Kr, Ai * 3),
        li.fromArray(Jr, Ei * 2),
        oi.fromArray(Jr, Pi * 2),
        ui.fromArray(Jr, Ai * 2),
        ii.sub(ni),
        si.sub(ni),
        oi.sub(li),
        ui.sub(li);
      const Ri = 1 / (oi.x * ui.y - ui.x * oi.y);
      isFinite(Ri) &&
        (ai
          .copy(ii)
          .multiplyScalar(ui.y)
          .addScaledVector(si, -oi.y)
          .multiplyScalar(Ri),
        hi
          .copy(si)
          .multiplyScalar(oi.x)
          .addScaledVector(ii, -ui.x)
          .multiplyScalar(Ri),
        ti[Ei].add(ai),
        ti[Pi].add(ai),
        ti[Ai].add(ai),
        ri[Ei].add(hi),
        ri[Pi].add(hi),
        ri[Ai].add(hi));
    }
    let fi = this.groups;
    fi.length === 0 &&
      (fi = [
        {
          start: 0,
          count: Yr.length,
        },
      ]);
    for (let Ei = 0, Pi = fi.length; Ei < Pi; ++Ei) {
      const Ai = fi[Ei],
        Ri = Ai.start,
        wi = Ai.count;
      for (let Ci = Ri, bi = Ri + wi; Ci < bi; Ci += 3)
        ci(Yr[Ci + 0], Yr[Ci + 1], Yr[Ci + 2]);
    }
    const di = new Vector3(),
      pi = new Vector3(),
      mi = new Vector3(),
      Si = new Vector3();
    function yi(Ei) {
      mi.fromArray(Zr, Ei * 3), Si.copy(mi);
      const Pi = ti[Ei];
      di.copy(Pi),
        di.sub(mi.multiplyScalar(mi.dot(Pi))).normalize(),
        pi.crossVectors(Si, Pi);
      const Ri = pi.dot(ri[Ei]) < 0 ? -1 : 1;
      (ei[Ei * 4] = di.x),
        (ei[Ei * 4 + 1] = di.y),
        (ei[Ei * 4 + 2] = di.z),
        (ei[Ei * 4 + 3] = Ri);
    }
    for (let Ei = 0, Pi = fi.length; Ei < Pi; ++Ei) {
      const Ai = fi[Ei],
        Ri = Ai.start,
        wi = Ai.count;
      for (let Ci = Ri, bi = Ri + wi; Ci < bi; Ci += 3)
        yi(Yr[Ci + 0]), yi(Yr[Ci + 1]), yi(Yr[Ci + 2]);
    }
  }
  computeVertexNormals() {
    const ze = this.index,
      Gr = this.getAttribute("position");
    if (Gr !== void 0) {
      let Yr = this.getAttribute("normal");
      if (Yr === void 0)
        (Yr = new BufferAttribute(new Float32Array(Gr.count * 3), 3)),
          this.setAttribute("normal", Yr);
      else
        for (let ii = 0, si = Yr.count; ii < si; ii++) Yr.setXYZ(ii, 0, 0, 0);
      const Kr = new Vector3(),
        Zr = new Vector3(),
        Jr = new Vector3(),
        Qr = new Vector3(),
        ei = new Vector3(),
        ti = new Vector3(),
        ri = new Vector3(),
        ni = new Vector3();
      if (ze)
        for (let ii = 0, si = ze.count; ii < si; ii += 3) {
          const li = ze.getX(ii + 0),
            oi = ze.getX(ii + 1),
            ui = ze.getX(ii + 2);
          Kr.fromBufferAttribute(Gr, li),
            Zr.fromBufferAttribute(Gr, oi),
            Jr.fromBufferAttribute(Gr, ui),
            ri.subVectors(Jr, Zr),
            ni.subVectors(Kr, Zr),
            ri.cross(ni),
            Qr.fromBufferAttribute(Yr, li),
            ei.fromBufferAttribute(Yr, oi),
            ti.fromBufferAttribute(Yr, ui),
            Qr.add(ri),
            ei.add(ri),
            ti.add(ri),
            Yr.setXYZ(li, Qr.x, Qr.y, Qr.z),
            Yr.setXYZ(oi, ei.x, ei.y, ei.z),
            Yr.setXYZ(ui, ti.x, ti.y, ti.z);
        }
      else
        for (let ii = 0, si = Gr.count; ii < si; ii += 3)
          Kr.fromBufferAttribute(Gr, ii + 0),
            Zr.fromBufferAttribute(Gr, ii + 1),
            Jr.fromBufferAttribute(Gr, ii + 2),
            ri.subVectors(Jr, Zr),
            ni.subVectors(Kr, Zr),
            ri.cross(ni),
            Yr.setXYZ(ii + 0, ri.x, ri.y, ri.z),
            Yr.setXYZ(ii + 1, ri.x, ri.y, ri.z),
            Yr.setXYZ(ii + 2, ri.x, ri.y, ri.z);
      this.normalizeNormals(), (Yr.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const ze = this.attributes.normal;
    for (let Gr = 0, Yr = ze.count; Gr < Yr; Gr++)
      _vector$7.fromBufferAttribute(ze, Gr),
        _vector$7.normalize(),
        ze.setXYZ(Gr, _vector$7.x, _vector$7.y, _vector$7.z);
  }
  toNonIndexed() {
    function ze(Qr, ei) {
      const ti = Qr.array,
        ri = Qr.itemSize,
        ni = Qr.normalized,
        ii = new ti.constructor(ei.length * ri);
      let si = 0,
        li = 0;
      for (let oi = 0, ui = ei.length; oi < ui; oi++) {
        Qr.isInterleavedBufferAttribute
          ? (si = ei[oi] * Qr.data.stride + Qr.offset)
          : (si = ei[oi] * ri);
        for (let ai = 0; ai < ri; ai++) ii[li++] = ti[si++];
      }
      return new BufferAttribute(ii, ri, ni);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const Gr = new BufferGeometry(),
      Yr = this.index.array,
      Kr = this.attributes;
    for (const Qr in Kr) {
      const ei = Kr[Qr],
        ti = ze(ei, Yr);
      Gr.setAttribute(Qr, ti);
    }
    const Zr = this.morphAttributes;
    for (const Qr in Zr) {
      const ei = [],
        ti = Zr[Qr];
      for (let ri = 0, ni = ti.length; ri < ni; ri++) {
        const ii = ti[ri],
          si = ze(ii, Yr);
        ei.push(si);
      }
      Gr.morphAttributes[Qr] = ei;
    }
    Gr.morphTargetsRelative = this.morphTargetsRelative;
    const Jr = this.groups;
    for (let Qr = 0, ei = Jr.length; Qr < ei; Qr++) {
      const ti = Jr[Qr];
      Gr.addGroup(ti.start, ti.count, ti.materialIndex);
    }
    return Gr;
  }
  toJSON() {
    const ze = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((ze.uuid = this.uuid),
      (ze.type = this.type),
      this.name !== "" && (ze.name = this.name),
      Object.keys(this.userData).length > 0 && (ze.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const ei = this.parameters;
      for (const ti in ei) ei[ti] !== void 0 && (ze[ti] = ei[ti]);
      return ze;
    }
    ze.data = {
      attributes: {},
    };
    const Gr = this.index;
    Gr !== null &&
      (ze.data.index = {
        type: Gr.array.constructor.name,
        array: Array.prototype.slice.call(Gr.array),
      });
    const Yr = this.attributes;
    for (const ei in Yr) {
      const ti = Yr[ei];
      ze.data.attributes[ei] = ti.toJSON(ze.data);
    }
    const Kr = {};
    let Zr = !1;
    for (const ei in this.morphAttributes) {
      const ti = this.morphAttributes[ei],
        ri = [];
      for (let ni = 0, ii = ti.length; ni < ii; ni++) {
        const si = ti[ni];
        ri.push(si.toJSON(ze.data));
      }
      ri.length > 0 && ((Kr[ei] = ri), (Zr = !0));
    }
    Zr &&
      ((ze.data.morphAttributes = Kr),
      (ze.data.morphTargetsRelative = this.morphTargetsRelative));
    const Jr = this.groups;
    Jr.length > 0 && (ze.data.groups = JSON.parse(JSON.stringify(Jr)));
    const Qr = this.boundingSphere;
    return (
      Qr !== null &&
        (ze.data.boundingSphere = {
          center: Qr.center.toArray(),
          radius: Qr.radius,
        }),
      ze
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(ze) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const Gr = {};
    this.name = ze.name;
    const Yr = ze.index;
    Yr !== null && this.setIndex(Yr.clone(Gr));
    const Kr = ze.attributes;
    for (const ti in Kr) {
      const ri = Kr[ti];
      this.setAttribute(ti, ri.clone(Gr));
    }
    const Zr = ze.morphAttributes;
    for (const ti in Zr) {
      const ri = [],
        ni = Zr[ti];
      for (let ii = 0, si = ni.length; ii < si; ii++) ri.push(ni[ii].clone(Gr));
      this.morphAttributes[ti] = ri;
    }
    this.morphTargetsRelative = ze.morphTargetsRelative;
    const Jr = ze.groups;
    for (let ti = 0, ri = Jr.length; ti < ri; ti++) {
      const ni = Jr[ti];
      this.addGroup(ni.start, ni.count, ni.materialIndex);
    }
    const Qr = ze.boundingBox;
    Qr !== null && (this.boundingBox = Qr.clone());
    const ei = ze.boundingSphere;
    return (
      ei !== null && (this.boundingSphere = ei.clone()),
      (this.drawRange.start = ze.drawRange.start),
      (this.drawRange.count = ze.drawRange.count),
      (this.userData = ze.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
}
const _inverseMatrix$3 = new Matrix4(),
  _ray$3 = new Ray(),
  _sphere$5 = new Sphere(),
  _sphereHitAt = new Vector3(),
  _vA$1 = new Vector3(),
  _vB$1 = new Vector3(),
  _vC$1 = new Vector3(),
  _tempA = new Vector3(),
  _morphA = new Vector3(),
  _uvA$1 = new Vector2(),
  _uvB$1 = new Vector2(),
  _uvC$1 = new Vector2(),
  _normalA = new Vector3(),
  _normalB = new Vector3(),
  _normalC = new Vector3(),
  _intersectionPoint = new Vector3(),
  _intersectionPointWorld = new Vector3();
class Mesh extends Object3D {
  constructor(ze = new BufferGeometry(), Gr = new MeshBasicMaterial()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = ze),
      (this.material = Gr),
      this.updateMorphTargets();
  }
  copy(ze, Gr) {
    return (
      super.copy(ze, Gr),
      ze.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = ze.morphTargetInfluences.slice()),
      ze.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          ze.morphTargetDictionary
        )),
      (this.material = Array.isArray(ze.material)
        ? ze.material.slice()
        : ze.material),
      (this.geometry = ze.geometry),
      this
    );
  }
  updateMorphTargets() {
    const Gr = this.geometry.morphAttributes,
      Yr = Object.keys(Gr);
    if (Yr.length > 0) {
      const Kr = Gr[Yr[0]];
      if (Kr !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let Zr = 0, Jr = Kr.length; Zr < Jr; Zr++) {
          const Qr = Kr[Zr].name || String(Zr);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[Qr] = Zr);
        }
      }
    }
  }
  getVertexPosition(ze, Gr) {
    const Yr = this.geometry,
      Kr = Yr.attributes.position,
      Zr = Yr.morphAttributes.position,
      Jr = Yr.morphTargetsRelative;
    Gr.fromBufferAttribute(Kr, ze);
    const Qr = this.morphTargetInfluences;
    if (Zr && Qr) {
      _morphA.set(0, 0, 0);
      for (let ei = 0, ti = Zr.length; ei < ti; ei++) {
        const ri = Qr[ei],
          ni = Zr[ei];
        ri !== 0 &&
          (_tempA.fromBufferAttribute(ni, ze),
          Jr
            ? _morphA.addScaledVector(_tempA, ri)
            : _morphA.addScaledVector(_tempA.sub(Gr), ri));
      }
      Gr.add(_morphA);
    }
    return Gr;
  }
  raycast(ze, Gr) {
    const Yr = this.geometry,
      Kr = this.material,
      Zr = this.matrixWorld;
    Kr !== void 0 &&
      (Yr.boundingSphere === null && Yr.computeBoundingSphere(),
      _sphere$5.copy(Yr.boundingSphere),
      _sphere$5.applyMatrix4(Zr),
      _ray$3.copy(ze.ray).recast(ze.near),
      !(
        _sphere$5.containsPoint(_ray$3.origin) === !1 &&
        (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null ||
          _ray$3.origin.distanceToSquared(_sphereHitAt) >
            (ze.far - ze.near) ** 2)
      ) &&
        (_inverseMatrix$3.copy(Zr).invert(),
        _ray$3.copy(ze.ray).applyMatrix4(_inverseMatrix$3),
        !(
          Yr.boundingBox !== null && _ray$3.intersectsBox(Yr.boundingBox) === !1
        ) && this._computeIntersections(ze, Gr, _ray$3)));
  }
  _computeIntersections(ze, Gr, Yr) {
    let Kr;
    const Zr = this.geometry,
      Jr = this.material,
      Qr = Zr.index,
      ei = Zr.attributes.position,
      ti = Zr.attributes.uv,
      ri = Zr.attributes.uv1,
      ni = Zr.attributes.normal,
      ii = Zr.groups,
      si = Zr.drawRange;
    if (Qr !== null)
      if (Array.isArray(Jr))
        for (let li = 0, oi = ii.length; li < oi; li++) {
          const ui = ii[li],
            ai = Jr[ui.materialIndex],
            hi = Math.max(ui.start, si.start),
            ci = Math.min(
              Qr.count,
              Math.min(ui.start + ui.count, si.start + si.count)
            );
          for (let fi = hi, di = ci; fi < di; fi += 3) {
            const pi = Qr.getX(fi),
              mi = Qr.getX(fi + 1),
              Si = Qr.getX(fi + 2);
            (Kr = checkGeometryIntersection(
              this,
              ai,
              ze,
              Yr,
              ti,
              ri,
              ni,
              pi,
              mi,
              Si
            )),
              Kr &&
                ((Kr.faceIndex = Math.floor(fi / 3)),
                (Kr.face.materialIndex = ui.materialIndex),
                Gr.push(Kr));
          }
        }
      else {
        const li = Math.max(0, si.start),
          oi = Math.min(Qr.count, si.start + si.count);
        for (let ui = li, ai = oi; ui < ai; ui += 3) {
          const hi = Qr.getX(ui),
            ci = Qr.getX(ui + 1),
            fi = Qr.getX(ui + 2);
          (Kr = checkGeometryIntersection(
            this,
            Jr,
            ze,
            Yr,
            ti,
            ri,
            ni,
            hi,
            ci,
            fi
          )),
            Kr && ((Kr.faceIndex = Math.floor(ui / 3)), Gr.push(Kr));
        }
      }
    else if (ei !== void 0)
      if (Array.isArray(Jr))
        for (let li = 0, oi = ii.length; li < oi; li++) {
          const ui = ii[li],
            ai = Jr[ui.materialIndex],
            hi = Math.max(ui.start, si.start),
            ci = Math.min(
              ei.count,
              Math.min(ui.start + ui.count, si.start + si.count)
            );
          for (let fi = hi, di = ci; fi < di; fi += 3) {
            const pi = fi,
              mi = fi + 1,
              Si = fi + 2;
            (Kr = checkGeometryIntersection(
              this,
              ai,
              ze,
              Yr,
              ti,
              ri,
              ni,
              pi,
              mi,
              Si
            )),
              Kr &&
                ((Kr.faceIndex = Math.floor(fi / 3)),
                (Kr.face.materialIndex = ui.materialIndex),
                Gr.push(Kr));
          }
        }
      else {
        const li = Math.max(0, si.start),
          oi = Math.min(ei.count, si.start + si.count);
        for (let ui = li, ai = oi; ui < ai; ui += 3) {
          const hi = ui,
            ci = ui + 1,
            fi = ui + 2;
          (Kr = checkGeometryIntersection(
            this,
            Jr,
            ze,
            Yr,
            ti,
            ri,
            ni,
            hi,
            ci,
            fi
          )),
            Kr && ((Kr.faceIndex = Math.floor(ui / 3)), Gr.push(Kr));
        }
      }
  }
}
function checkIntersection(Wr, ze, Gr, Yr, Kr, Zr, Jr, Qr) {
  let ei;
  if (
    (ze.side === BackSide
      ? (ei = Yr.intersectTriangle(Jr, Zr, Kr, !0, Qr))
      : (ei = Yr.intersectTriangle(Kr, Zr, Jr, ze.side === FrontSide, Qr)),
    ei === null)
  )
    return null;
  _intersectionPointWorld.copy(Qr),
    _intersectionPointWorld.applyMatrix4(Wr.matrixWorld);
  const ti = Gr.ray.origin.distanceTo(_intersectionPointWorld);
  return ti < Gr.near || ti > Gr.far
    ? null
    : {
        distance: ti,
        point: _intersectionPointWorld.clone(),
        object: Wr,
      };
}
function checkGeometryIntersection(Wr, ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti) {
  Wr.getVertexPosition(Qr, _vA$1),
    Wr.getVertexPosition(ei, _vB$1),
    Wr.getVertexPosition(ti, _vC$1);
  const ri = checkIntersection(
    Wr,
    ze,
    Gr,
    Yr,
    _vA$1,
    _vB$1,
    _vC$1,
    _intersectionPoint
  );
  if (ri) {
    Kr &&
      (_uvA$1.fromBufferAttribute(Kr, Qr),
      _uvB$1.fromBufferAttribute(Kr, ei),
      _uvC$1.fromBufferAttribute(Kr, ti),
      (ri.uv = Triangle.getInterpolation(
        _intersectionPoint,
        _vA$1,
        _vB$1,
        _vC$1,
        _uvA$1,
        _uvB$1,
        _uvC$1,
        new Vector2()
      ))),
      Zr &&
        (_uvA$1.fromBufferAttribute(Zr, Qr),
        _uvB$1.fromBufferAttribute(Zr, ei),
        _uvC$1.fromBufferAttribute(Zr, ti),
        (ri.uv1 = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _uvA$1,
          _uvB$1,
          _uvC$1,
          new Vector2()
        )),
        (ri.uv2 = ri.uv1)),
      Jr &&
        (_normalA.fromBufferAttribute(Jr, Qr),
        _normalB.fromBufferAttribute(Jr, ei),
        _normalC.fromBufferAttribute(Jr, ti),
        (ri.normal = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _normalA,
          _normalB,
          _normalC,
          new Vector3()
        )),
        ri.normal.dot(Yr.direction) > 0 && ri.normal.multiplyScalar(-1));
    const ni = {
      a: Qr,
      b: ei,
      c: ti,
      normal: new Vector3(),
      materialIndex: 0,
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, ni.normal), (ri.face = ni);
  }
  return ri;
}
class BoxGeometry extends BufferGeometry {
  constructor(ze = 1, Gr = 1, Yr = 1, Kr = 1, Zr = 1, Jr = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: ze,
        height: Gr,
        depth: Yr,
        widthSegments: Kr,
        heightSegments: Zr,
        depthSegments: Jr,
      });
    const Qr = this;
    (Kr = Math.floor(Kr)), (Zr = Math.floor(Zr)), (Jr = Math.floor(Jr));
    const ei = [],
      ti = [],
      ri = [],
      ni = [];
    let ii = 0,
      si = 0;
    li("z", "y", "x", -1, -1, Yr, Gr, ze, Jr, Zr, 0),
      li("z", "y", "x", 1, -1, Yr, Gr, -ze, Jr, Zr, 1),
      li("x", "z", "y", 1, 1, ze, Yr, Gr, Kr, Jr, 2),
      li("x", "z", "y", 1, -1, ze, Yr, -Gr, Kr, Jr, 3),
      li("x", "y", "z", 1, -1, ze, Gr, Yr, Kr, Zr, 4),
      li("x", "y", "z", -1, -1, ze, Gr, -Yr, Kr, Zr, 5),
      this.setIndex(ei),
      this.setAttribute("position", new Float32BufferAttribute(ti, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ri, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ni, 2));
    function li(oi, ui, ai, hi, ci, fi, di, pi, mi, Si, yi) {
      const Ei = fi / mi,
        Pi = di / Si,
        Ai = fi / 2,
        Ri = di / 2,
        wi = pi / 2,
        Ci = mi + 1,
        bi = Si + 1;
      let Mi = 0,
        gi = 0;
      const xi = new Vector3();
      for (let Ti = 0; Ti < bi; Ti++) {
        const vi = Ti * Pi - Ri;
        for (let Ii = 0; Ii < Ci; Ii++) {
          const Oi = Ii * Ei - Ai;
          (xi[oi] = Oi * hi),
            (xi[ui] = vi * ci),
            (xi[ai] = wi),
            ti.push(xi.x, xi.y, xi.z),
            (xi[oi] = 0),
            (xi[ui] = 0),
            (xi[ai] = pi > 0 ? 1 : -1),
            ri.push(xi.x, xi.y, xi.z),
            ni.push(Ii / mi),
            ni.push(1 - Ti / Si),
            (Mi += 1);
        }
      }
      for (let Ti = 0; Ti < Si; Ti++)
        for (let vi = 0; vi < mi; vi++) {
          const Ii = ii + vi + Ci * Ti,
            Oi = ii + vi + Ci * (Ti + 1),
            ki = ii + (vi + 1) + Ci * (Ti + 1),
            Bi = ii + (vi + 1) + Ci * Ti;
          ei.push(Ii, Oi, Bi), ei.push(Oi, ki, Bi), (gi += 6);
        }
      Qr.addGroup(si, gi, yi), (si += gi), (ii += Mi);
    }
  }
  copy(ze) {
    return (
      super.copy(ze), (this.parameters = Object.assign({}, ze.parameters)), this
    );
  }
  static fromJSON(ze) {
    return new BoxGeometry(
      ze.width,
      ze.height,
      ze.depth,
      ze.widthSegments,
      ze.heightSegments,
      ze.depthSegments
    );
  }
}
function cloneUniforms(Wr) {
  const ze = {};
  for (const Gr in Wr) {
    ze[Gr] = {};
    for (const Yr in Wr[Gr]) {
      const Kr = Wr[Gr][Yr];
      Kr &&
      (Kr.isColor ||
        Kr.isMatrix3 ||
        Kr.isMatrix4 ||
        Kr.isVector2 ||
        Kr.isVector3 ||
        Kr.isVector4 ||
        Kr.isTexture ||
        Kr.isQuaternion)
        ? Kr.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (ze[Gr][Yr] = null))
          : (ze[Gr][Yr] = Kr.clone())
        : Array.isArray(Kr)
        ? (ze[Gr][Yr] = Kr.slice())
        : (ze[Gr][Yr] = Kr);
    }
  }
  return ze;
}
function mergeUniforms(Wr) {
  const ze = {};
  for (let Gr = 0; Gr < Wr.length; Gr++) {
    const Yr = cloneUniforms(Wr[Gr]);
    for (const Kr in Yr) ze[Kr] = Yr[Kr];
  }
  return ze;
}
function cloneUniformsGroups(Wr) {
  const ze = [];
  for (let Gr = 0; Gr < Wr.length; Gr++) ze.push(Wr[Gr].clone());
  return ze;
}
function getUnlitUniformColorSpace(Wr) {
  return Wr.getRenderTarget() === null
    ? Wr.outputColorSpace
    : ColorManagement.workingColorSpace;
}
const UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms,
};
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
  constructor(ze) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = default_vertex),
      (this.fragmentShader = default_fragment),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      ze !== void 0 && this.setValues(ze);
  }
  copy(ze) {
    return (
      super.copy(ze),
      (this.fragmentShader = ze.fragmentShader),
      (this.vertexShader = ze.vertexShader),
      (this.uniforms = cloneUniforms(ze.uniforms)),
      (this.uniformsGroups = cloneUniformsGroups(ze.uniformsGroups)),
      (this.defines = Object.assign({}, ze.defines)),
      (this.wireframe = ze.wireframe),
      (this.wireframeLinewidth = ze.wireframeLinewidth),
      (this.fog = ze.fog),
      (this.lights = ze.lights),
      (this.clipping = ze.clipping),
      (this.extensions = Object.assign({}, ze.extensions)),
      (this.glslVersion = ze.glslVersion),
      this
    );
  }
  toJSON(ze) {
    const Gr = super.toJSON(ze);
    (Gr.glslVersion = this.glslVersion), (Gr.uniforms = {});
    for (const Kr in this.uniforms) {
      const Jr = this.uniforms[Kr].value;
      Jr && Jr.isTexture
        ? (Gr.uniforms[Kr] = {
            type: "t",
            value: Jr.toJSON(ze).uuid,
          })
        : Jr && Jr.isColor
        ? (Gr.uniforms[Kr] = {
            type: "c",
            value: Jr.getHex(),
          })
        : Jr && Jr.isVector2
        ? (Gr.uniforms[Kr] = {
            type: "v2",
            value: Jr.toArray(),
          })
        : Jr && Jr.isVector3
        ? (Gr.uniforms[Kr] = {
            type: "v3",
            value: Jr.toArray(),
          })
        : Jr && Jr.isVector4
        ? (Gr.uniforms[Kr] = {
            type: "v4",
            value: Jr.toArray(),
          })
        : Jr && Jr.isMatrix3
        ? (Gr.uniforms[Kr] = {
            type: "m3",
            value: Jr.toArray(),
          })
        : Jr && Jr.isMatrix4
        ? (Gr.uniforms[Kr] = {
            type: "m4",
            value: Jr.toArray(),
          })
        : (Gr.uniforms[Kr] = {
            value: Jr,
          });
    }
    Object.keys(this.defines).length > 0 && (Gr.defines = this.defines),
      (Gr.vertexShader = this.vertexShader),
      (Gr.fragmentShader = this.fragmentShader),
      (Gr.lights = this.lights),
      (Gr.clipping = this.clipping);
    const Yr = {};
    for (const Kr in this.extensions)
      this.extensions[Kr] === !0 && (Yr[Kr] = !0);
    return Object.keys(Yr).length > 0 && (Gr.extensions = Yr), Gr;
  }
}
class Camera extends Object3D {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.projectionMatrixInverse = new Matrix4()),
      (this.coordinateSystem = WebGLCoordinateSystem);
  }
  copy(ze, Gr) {
    return (
      super.copy(ze, Gr),
      this.matrixWorldInverse.copy(ze.matrixWorldInverse),
      this.projectionMatrix.copy(ze.projectionMatrix),
      this.projectionMatrixInverse.copy(ze.projectionMatrixInverse),
      (this.coordinateSystem = ze.coordinateSystem),
      this
    );
  }
  getWorldDirection(ze) {
    return super.getWorldDirection(ze).negate();
  }
  updateMatrixWorld(ze) {
    super.updateMatrixWorld(ze),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(ze, Gr) {
    super.updateWorldMatrix(ze, Gr),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class PerspectiveCamera extends Camera {
  constructor(ze = 50, Gr = 1, Yr = 0.1, Kr = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = ze),
      (this.zoom = 1),
      (this.near = Yr),
      (this.far = Kr),
      (this.focus = 10),
      (this.aspect = Gr),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(ze, Gr) {
    return (
      super.copy(ze, Gr),
      (this.fov = ze.fov),
      (this.zoom = ze.zoom),
      (this.near = ze.near),
      (this.far = ze.far),
      (this.focus = ze.focus),
      (this.aspect = ze.aspect),
      (this.view = ze.view === null ? null : Object.assign({}, ze.view)),
      (this.filmGauge = ze.filmGauge),
      (this.filmOffset = ze.filmOffset),
      this
    );
  }
  setFocalLength(ze) {
    const Gr = (0.5 * this.getFilmHeight()) / ze;
    (this.fov = RAD2DEG * 2 * Math.atan(Gr)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const ze = Math.tan(DEG2RAD * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / ze;
  }
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(ze, Gr, Yr, Kr, Zr, Jr) {
    (this.aspect = ze / Gr),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = ze),
      (this.view.fullHeight = Gr),
      (this.view.offsetX = Yr),
      (this.view.offsetY = Kr),
      (this.view.width = Zr),
      (this.view.height = Jr),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const ze = this.near;
    let Gr = (ze * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom,
      Yr = 2 * Gr,
      Kr = this.aspect * Yr,
      Zr = -0.5 * Kr;
    const Jr = this.view;
    if (this.view !== null && this.view.enabled) {
      const ei = Jr.fullWidth,
        ti = Jr.fullHeight;
      (Zr += (Jr.offsetX * Kr) / ei),
        (Gr -= (Jr.offsetY * Yr) / ti),
        (Kr *= Jr.width / ei),
        (Yr *= Jr.height / ti);
    }
    const Qr = this.filmOffset;
    Qr !== 0 && (Zr += (ze * Qr) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        Zr,
        Zr + Kr,
        Gr,
        Gr - Yr,
        ze,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(ze) {
    const Gr = super.toJSON(ze);
    return (
      (Gr.object.fov = this.fov),
      (Gr.object.zoom = this.zoom),
      (Gr.object.near = this.near),
      (Gr.object.far = this.far),
      (Gr.object.focus = this.focus),
      (Gr.object.aspect = this.aspect),
      this.view !== null && (Gr.object.view = Object.assign({}, this.view)),
      (Gr.object.filmGauge = this.filmGauge),
      (Gr.object.filmOffset = this.filmOffset),
      Gr
    );
  }
}
const fov = -90,
  aspect = 1;
class CubeCamera extends Object3D {
  constructor(ze, Gr, Yr) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = Yr),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const Kr = new PerspectiveCamera(fov, aspect, ze, Gr);
    (Kr.layers = this.layers), this.add(Kr);
    const Zr = new PerspectiveCamera(fov, aspect, ze, Gr);
    (Zr.layers = this.layers), this.add(Zr);
    const Jr = new PerspectiveCamera(fov, aspect, ze, Gr);
    (Jr.layers = this.layers), this.add(Jr);
    const Qr = new PerspectiveCamera(fov, aspect, ze, Gr);
    (Qr.layers = this.layers), this.add(Qr);
    const ei = new PerspectiveCamera(fov, aspect, ze, Gr);
    (ei.layers = this.layers), this.add(ei);
    const ti = new PerspectiveCamera(fov, aspect, ze, Gr);
    (ti.layers = this.layers), this.add(ti);
  }
  updateCoordinateSystem() {
    const ze = this.coordinateSystem,
      Gr = this.children.concat(),
      [Yr, Kr, Zr, Jr, Qr, ei] = Gr;
    for (const ti of Gr) this.remove(ti);
    if (ze === WebGLCoordinateSystem)
      Yr.up.set(0, 1, 0),
        Yr.lookAt(1, 0, 0),
        Kr.up.set(0, 1, 0),
        Kr.lookAt(-1, 0, 0),
        Zr.up.set(0, 0, -1),
        Zr.lookAt(0, 1, 0),
        Jr.up.set(0, 0, 1),
        Jr.lookAt(0, -1, 0),
        Qr.up.set(0, 1, 0),
        Qr.lookAt(0, 0, 1),
        ei.up.set(0, 1, 0),
        ei.lookAt(0, 0, -1);
    else if (ze === WebGPUCoordinateSystem)
      Yr.up.set(0, -1, 0),
        Yr.lookAt(-1, 0, 0),
        Kr.up.set(0, -1, 0),
        Kr.lookAt(1, 0, 0),
        Zr.up.set(0, 0, 1),
        Zr.lookAt(0, 1, 0),
        Jr.up.set(0, 0, -1),
        Jr.lookAt(0, -1, 0),
        Qr.up.set(0, -1, 0),
        Qr.lookAt(0, 0, 1),
        ei.up.set(0, -1, 0),
        ei.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          ze
      );
    for (const ti of Gr) this.add(ti), ti.updateMatrixWorld();
  }
  update(ze, Gr) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: Yr, activeMipmapLevel: Kr } = this;
    this.coordinateSystem !== ze.coordinateSystem &&
      ((this.coordinateSystem = ze.coordinateSystem),
      this.updateCoordinateSystem());
    const [Zr, Jr, Qr, ei, ti, ri] = this.children,
      ni = ze.getRenderTarget(),
      ii = ze.getActiveCubeFace(),
      si = ze.getActiveMipmapLevel(),
      li = ze.xr.enabled;
    ze.xr.enabled = !1;
    const oi = Yr.texture.generateMipmaps;
    (Yr.texture.generateMipmaps = !1),
      ze.setRenderTarget(Yr, 0, Kr),
      ze.render(Gr, Zr),
      ze.setRenderTarget(Yr, 1, Kr),
      ze.render(Gr, Jr),
      ze.setRenderTarget(Yr, 2, Kr),
      ze.render(Gr, Qr),
      ze.setRenderTarget(Yr, 3, Kr),
      ze.render(Gr, ei),
      ze.setRenderTarget(Yr, 4, Kr),
      ze.render(Gr, ti),
      (Yr.texture.generateMipmaps = oi),
      ze.setRenderTarget(Yr, 5, Kr),
      ze.render(Gr, ri),
      ze.setRenderTarget(ni, ii, si),
      (ze.xr.enabled = li),
      (Yr.texture.needsPMREMUpdate = !0);
  }
}
class CubeTexture extends Texture {
  constructor(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti, ri) {
    (ze = ze !== void 0 ? ze : []),
      (Gr = Gr !== void 0 ? Gr : CubeReflectionMapping),
      super(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti, ri),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(ze) {
    this.image = ze;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(ze = 1, Gr = {}) {
    super(ze, ze, Gr), (this.isWebGLCubeRenderTarget = !0);
    const Yr = {
        width: ze,
        height: ze,
        depth: 1,
      },
      Kr = [Yr, Yr, Yr, Yr, Yr, Yr];
    Gr.encoding !== void 0 &&
      (warnOnce(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (Gr.colorSpace =
        Gr.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (this.texture = new CubeTexture(
        Kr,
        Gr.mapping,
        Gr.wrapS,
        Gr.wrapT,
        Gr.magFilter,
        Gr.minFilter,
        Gr.format,
        Gr.type,
        Gr.anisotropy,
        Gr.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        Gr.generateMipmaps !== void 0 ? Gr.generateMipmaps : !1),
      (this.texture.minFilter =
        Gr.minFilter !== void 0 ? Gr.minFilter : LinearFilter);
  }
  fromEquirectangularTexture(ze, Gr) {
    (this.texture.type = Gr.type),
      (this.texture.colorSpace = Gr.colorSpace),
      (this.texture.generateMipmaps = Gr.generateMipmaps),
      (this.texture.minFilter = Gr.minFilter),
      (this.texture.magFilter = Gr.magFilter);
    const Yr = {
        uniforms: {
          tEquirect: {
            value: null,
          },
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      Kr = new BoxGeometry(5, 5, 5),
      Zr = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(Yr.uniforms),
        vertexShader: Yr.vertexShader,
        fragmentShader: Yr.fragmentShader,
        side: BackSide,
        blending: NoBlending,
      });
    Zr.uniforms.tEquirect.value = Gr;
    const Jr = new Mesh(Kr, Zr),
      Qr = Gr.minFilter;
    return (
      Gr.minFilter === LinearMipmapLinearFilter &&
        (Gr.minFilter = LinearFilter),
      new CubeCamera(1, 10, this).update(ze, Jr),
      (Gr.minFilter = Qr),
      Jr.geometry.dispose(),
      Jr.material.dispose(),
      this
    );
  }
  clear(ze, Gr, Yr, Kr) {
    const Zr = ze.getRenderTarget();
    for (let Jr = 0; Jr < 6; Jr++)
      ze.setRenderTarget(this, Jr), ze.clear(Gr, Yr, Kr);
    ze.setRenderTarget(Zr);
  }
}
const _vector1 = new Vector3(),
  _vector2 = new Vector3(),
  _normalMatrix = new Matrix3();
class Plane {
  constructor(ze = new Vector3(1, 0, 0), Gr = 0) {
    (this.isPlane = !0), (this.normal = ze), (this.constant = Gr);
  }
  set(ze, Gr) {
    return this.normal.copy(ze), (this.constant = Gr), this;
  }
  setComponents(ze, Gr, Yr, Kr) {
    return this.normal.set(ze, Gr, Yr), (this.constant = Kr), this;
  }
  setFromNormalAndCoplanarPoint(ze, Gr) {
    return this.normal.copy(ze), (this.constant = -Gr.dot(this.normal)), this;
  }
  setFromCoplanarPoints(ze, Gr, Yr) {
    const Kr = _vector1
      .subVectors(Yr, Gr)
      .cross(_vector2.subVectors(ze, Gr))
      .normalize();
    return this.setFromNormalAndCoplanarPoint(Kr, ze), this;
  }
  copy(ze) {
    return this.normal.copy(ze.normal), (this.constant = ze.constant), this;
  }
  normalize() {
    const ze = 1 / this.normal.length();
    return this.normal.multiplyScalar(ze), (this.constant *= ze), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(ze) {
    return this.normal.dot(ze) + this.constant;
  }
  distanceToSphere(ze) {
    return this.distanceToPoint(ze.center) - ze.radius;
  }
  projectPoint(ze, Gr) {
    return Gr.copy(ze).addScaledVector(this.normal, -this.distanceToPoint(ze));
  }
  intersectLine(ze, Gr) {
    const Yr = ze.delta(_vector1),
      Kr = this.normal.dot(Yr);
    if (Kr === 0)
      return this.distanceToPoint(ze.start) === 0 ? Gr.copy(ze.start) : null;
    const Zr = -(ze.start.dot(this.normal) + this.constant) / Kr;
    return Zr < 0 || Zr > 1 ? null : Gr.copy(ze.start).addScaledVector(Yr, Zr);
  }
  intersectsLine(ze) {
    const Gr = this.distanceToPoint(ze.start),
      Yr = this.distanceToPoint(ze.end);
    return (Gr < 0 && Yr > 0) || (Yr < 0 && Gr > 0);
  }
  intersectsBox(ze) {
    return ze.intersectsPlane(this);
  }
  intersectsSphere(ze) {
    return ze.intersectsPlane(this);
  }
  coplanarPoint(ze) {
    return ze.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(ze, Gr) {
    const Yr = Gr || _normalMatrix.getNormalMatrix(ze),
      Kr = this.coplanarPoint(_vector1).applyMatrix4(ze),
      Zr = this.normal.applyMatrix3(Yr).normalize();
    return (this.constant = -Kr.dot(Zr)), this;
  }
  translate(ze) {
    return (this.constant -= ze.dot(this.normal)), this;
  }
  equals(ze) {
    return ze.normal.equals(this.normal) && ze.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$4 = new Sphere(),
  _vector$6 = new Vector3();
class Frustum {
  constructor(
    ze = new Plane(),
    Gr = new Plane(),
    Yr = new Plane(),
    Kr = new Plane(),
    Zr = new Plane(),
    Jr = new Plane()
  ) {
    this.planes = [ze, Gr, Yr, Kr, Zr, Jr];
  }
  set(ze, Gr, Yr, Kr, Zr, Jr) {
    const Qr = this.planes;
    return (
      Qr[0].copy(ze),
      Qr[1].copy(Gr),
      Qr[2].copy(Yr),
      Qr[3].copy(Kr),
      Qr[4].copy(Zr),
      Qr[5].copy(Jr),
      this
    );
  }
  copy(ze) {
    const Gr = this.planes;
    for (let Yr = 0; Yr < 6; Yr++) Gr[Yr].copy(ze.planes[Yr]);
    return this;
  }
  setFromProjectionMatrix(ze, Gr = WebGLCoordinateSystem) {
    const Yr = this.planes,
      Kr = ze.elements,
      Zr = Kr[0],
      Jr = Kr[1],
      Qr = Kr[2],
      ei = Kr[3],
      ti = Kr[4],
      ri = Kr[5],
      ni = Kr[6],
      ii = Kr[7],
      si = Kr[8],
      li = Kr[9],
      oi = Kr[10],
      ui = Kr[11],
      ai = Kr[12],
      hi = Kr[13],
      ci = Kr[14],
      fi = Kr[15];
    if (
      (Yr[0].setComponents(ei - Zr, ii - ti, ui - si, fi - ai).normalize(),
      Yr[1].setComponents(ei + Zr, ii + ti, ui + si, fi + ai).normalize(),
      Yr[2].setComponents(ei + Jr, ii + ri, ui + li, fi + hi).normalize(),
      Yr[3].setComponents(ei - Jr, ii - ri, ui - li, fi - hi).normalize(),
      Yr[4].setComponents(ei - Qr, ii - ni, ui - oi, fi - ci).normalize(),
      Gr === WebGLCoordinateSystem)
    )
      Yr[5].setComponents(ei + Qr, ii + ni, ui + oi, fi + ci).normalize();
    else if (Gr === WebGPUCoordinateSystem)
      Yr[5].setComponents(Qr, ni, oi, ci).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          Gr
      );
    return this;
  }
  intersectsObject(ze) {
    if (ze.boundingSphere !== void 0)
      ze.boundingSphere === null && ze.computeBoundingSphere(),
        _sphere$4.copy(ze.boundingSphere).applyMatrix4(ze.matrixWorld);
    else {
      const Gr = ze.geometry;
      Gr.boundingSphere === null && Gr.computeBoundingSphere(),
        _sphere$4.copy(Gr.boundingSphere).applyMatrix4(ze.matrixWorld);
    }
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSprite(ze) {
    return (
      _sphere$4.center.set(0, 0, 0),
      (_sphere$4.radius = 0.7071067811865476),
      _sphere$4.applyMatrix4(ze.matrixWorld),
      this.intersectsSphere(_sphere$4)
    );
  }
  intersectsSphere(ze) {
    const Gr = this.planes,
      Yr = ze.center,
      Kr = -ze.radius;
    for (let Zr = 0; Zr < 6; Zr++)
      if (Gr[Zr].distanceToPoint(Yr) < Kr) return !1;
    return !0;
  }
  intersectsBox(ze) {
    const Gr = this.planes;
    for (let Yr = 0; Yr < 6; Yr++) {
      const Kr = Gr[Yr];
      if (
        ((_vector$6.x = Kr.normal.x > 0 ? ze.max.x : ze.min.x),
        (_vector$6.y = Kr.normal.y > 0 ? ze.max.y : ze.min.y),
        (_vector$6.z = Kr.normal.z > 0 ? ze.max.z : ze.min.z),
        Kr.distanceToPoint(_vector$6) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(ze) {
    const Gr = this.planes;
    for (let Yr = 0; Yr < 6; Yr++)
      if (Gr[Yr].distanceToPoint(ze) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let Wr = null,
    ze = !1,
    Gr = null,
    Yr = null;
  function Kr(Zr, Jr) {
    Gr(Zr, Jr), (Yr = Wr.requestAnimationFrame(Kr));
  }
  return {
    start: function () {
      ze !== !0 &&
        Gr !== null &&
        ((Yr = Wr.requestAnimationFrame(Kr)), (ze = !0));
    },
    stop: function () {
      Wr.cancelAnimationFrame(Yr), (ze = !1);
    },
    setAnimationLoop: function (Zr) {
      Gr = Zr;
    },
    setContext: function (Zr) {
      Wr = Zr;
    },
  };
}
function WebGLAttributes(Wr, ze) {
  const Gr = ze.isWebGL2,
    Yr = new WeakMap();
  function Kr(ti, ri) {
    const ni = ti.array,
      ii = ti.usage,
      si = Wr.createBuffer();
    Wr.bindBuffer(ri, si), Wr.bufferData(ri, ni, ii), ti.onUploadCallback();
    let li;
    if (ni instanceof Float32Array) li = Wr.FLOAT;
    else if (ni instanceof Uint16Array)
      if (ti.isFloat16BufferAttribute)
        if (Gr) li = Wr.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else li = Wr.UNSIGNED_SHORT;
    else if (ni instanceof Int16Array) li = Wr.SHORT;
    else if (ni instanceof Uint32Array) li = Wr.UNSIGNED_INT;
    else if (ni instanceof Int32Array) li = Wr.INT;
    else if (ni instanceof Int8Array) li = Wr.BYTE;
    else if (ni instanceof Uint8Array) li = Wr.UNSIGNED_BYTE;
    else if (ni instanceof Uint8ClampedArray) li = Wr.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + ni
      );
    return {
      buffer: si,
      type: li,
      bytesPerElement: ni.BYTES_PER_ELEMENT,
      version: ti.version,
    };
  }
  function Zr(ti, ri, ni) {
    const ii = ri.array,
      si = ri.updateRange;
    Wr.bindBuffer(ni, ti),
      si.count === -1
        ? Wr.bufferSubData(ni, 0, ii)
        : (Gr
            ? Wr.bufferSubData(
                ni,
                si.offset * ii.BYTES_PER_ELEMENT,
                ii,
                si.offset,
                si.count
              )
            : Wr.bufferSubData(
                ni,
                si.offset * ii.BYTES_PER_ELEMENT,
                ii.subarray(si.offset, si.offset + si.count)
              ),
          (si.count = -1)),
      ri.onUploadCallback();
  }
  function Jr(ti) {
    return ti.isInterleavedBufferAttribute && (ti = ti.data), Yr.get(ti);
  }
  function Qr(ti) {
    ti.isInterleavedBufferAttribute && (ti = ti.data);
    const ri = Yr.get(ti);
    ri && (Wr.deleteBuffer(ri.buffer), Yr.delete(ti));
  }
  function ei(ti, ri) {
    if (ti.isGLBufferAttribute) {
      const ii = Yr.get(ti);
      (!ii || ii.version < ti.version) &&
        Yr.set(ti, {
          buffer: ti.buffer,
          type: ti.type,
          bytesPerElement: ti.elementSize,
          version: ti.version,
        });
      return;
    }
    ti.isInterleavedBufferAttribute && (ti = ti.data);
    const ni = Yr.get(ti);
    ni === void 0
      ? Yr.set(ti, Kr(ti, ri))
      : ni.version < ti.version &&
        (Zr(ni.buffer, ti, ri), (ni.version = ti.version));
  }
  return {
    get: Jr,
    remove: Qr,
    update: ei,
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(ze = 1, Gr = 1, Yr = 1, Kr = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: ze,
        height: Gr,
        widthSegments: Yr,
        heightSegments: Kr,
      });
    const Zr = ze / 2,
      Jr = Gr / 2,
      Qr = Math.floor(Yr),
      ei = Math.floor(Kr),
      ti = Qr + 1,
      ri = ei + 1,
      ni = ze / Qr,
      ii = Gr / ei,
      si = [],
      li = [],
      oi = [],
      ui = [];
    for (let ai = 0; ai < ri; ai++) {
      const hi = ai * ii - Jr;
      for (let ci = 0; ci < ti; ci++) {
        const fi = ci * ni - Zr;
        li.push(fi, -hi, 0),
          oi.push(0, 0, 1),
          ui.push(ci / Qr),
          ui.push(1 - ai / ei);
      }
    }
    for (let ai = 0; ai < ei; ai++)
      for (let hi = 0; hi < Qr; hi++) {
        const ci = hi + ti * ai,
          fi = hi + ti * (ai + 1),
          di = hi + 1 + ti * (ai + 1),
          pi = hi + 1 + ti * ai;
        si.push(ci, fi, pi), si.push(fi, di, pi);
      }
    this.setIndex(si),
      this.setAttribute("position", new Float32BufferAttribute(li, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(oi, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ui, 2));
  }
  copy(ze) {
    return (
      super.copy(ze), (this.parameters = Object.assign({}, ze.parameters)), this
    );
  }
  static fromJSON(ze) {
    return new PlaneGeometry(
      ze.width,
      ze.height,
      ze.widthSegments,
      ze.heightSegments
    );
  }
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  alphatest_fragment = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  colorspace_pars_fragment = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  morphcolor_vertex = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$e = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$a = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$2 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1,
  },
  UniformsLib = {
    common: {
      diffuse: {
        value: new Color(16777215),
      },
      opacity: {
        value: 1,
      },
      map: {
        value: null,
      },
      mapTransform: {
        value: new Matrix3(),
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new Matrix3(),
      },
      alphaTest: {
        value: 0,
      },
    },
    specularmap: {
      specularMap: {
        value: null,
      },
      specularMapTransform: {
        value: new Matrix3(),
      },
    },
    envmap: {
      envMap: {
        value: null,
      },
      flipEnvMap: {
        value: -1,
      },
      reflectivity: {
        value: 1,
      },
      ior: {
        value: 1.5,
      },
      refractionRatio: {
        value: 0.98,
      },
    },
    aomap: {
      aoMap: {
        value: null,
      },
      aoMapIntensity: {
        value: 1,
      },
      aoMapTransform: {
        value: new Matrix3(),
      },
    },
    lightmap: {
      lightMap: {
        value: null,
      },
      lightMapIntensity: {
        value: 1,
      },
      lightMapTransform: {
        value: new Matrix3(),
      },
    },
    bumpmap: {
      bumpMap: {
        value: null,
      },
      bumpMapTransform: {
        value: new Matrix3(),
      },
      bumpScale: {
        value: 1,
      },
    },
    normalmap: {
      normalMap: {
        value: null,
      },
      normalMapTransform: {
        value: new Matrix3(),
      },
      normalScale: {
        value: new Vector2(1, 1),
      },
    },
    displacementmap: {
      displacementMap: {
        value: null,
      },
      displacementMapTransform: {
        value: new Matrix3(),
      },
      displacementScale: {
        value: 1,
      },
      displacementBias: {
        value: 0,
      },
    },
    emissivemap: {
      emissiveMap: {
        value: null,
      },
      emissiveMapTransform: {
        value: new Matrix3(),
      },
    },
    metalnessmap: {
      metalnessMap: {
        value: null,
      },
      metalnessMapTransform: {
        value: new Matrix3(),
      },
    },
    roughnessmap: {
      roughnessMap: {
        value: null,
      },
      roughnessMapTransform: {
        value: new Matrix3(),
      },
    },
    gradientmap: {
      gradientMap: {
        value: null,
      },
    },
    fog: {
      fogDensity: {
        value: 25e-5,
      },
      fogNear: {
        value: 1,
      },
      fogFar: {
        value: 2e3,
      },
      fogColor: {
        value: new Color(16777215),
      },
    },
    lights: {
      ambientLightColor: {
        value: [],
      },
      lightProbe: {
        value: [],
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
        },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: {
        value: [],
      },
      directionalShadowMatrix: {
        value: [],
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: {
        value: [],
      },
      spotShadowMap: {
        value: [],
      },
      spotLightMatrix: {
        value: [],
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
        },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: {
        value: [],
      },
      pointShadowMatrix: {
        value: [],
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {},
        },
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {},
        },
      },
      ltc_1: {
        value: null,
      },
      ltc_2: {
        value: null,
      },
    },
    points: {
      diffuse: {
        value: new Color(16777215),
      },
      opacity: {
        value: 1,
      },
      size: {
        value: 1,
      },
      scale: {
        value: 1,
      },
      map: {
        value: null,
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new Matrix3(),
      },
      alphaTest: {
        value: 0,
      },
      uvTransform: {
        value: new Matrix3(),
      },
    },
    sprite: {
      diffuse: {
        value: new Color(16777215),
      },
      opacity: {
        value: 1,
      },
      center: {
        value: new Vector2(0.5, 0.5),
      },
      rotation: {
        value: 0,
      },
      map: {
        value: null,
      },
      mapTransform: {
        value: new Matrix3(),
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new Matrix3(),
      },
      alphaTest: {
        value: 0,
      },
    },
  },
  ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog,
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag,
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {
            value: new Color(0),
          },
        },
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag,
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {
            value: new Color(0),
          },
          specular: {
            value: new Color(1118481),
          },
          shininess: {
            value: 30,
          },
        },
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag,
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {
            value: new Color(0),
          },
          roughness: {
            value: 1,
          },
          metalness: {
            value: 0,
          },
          envMapIntensity: {
            value: 1,
          },
        },
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag,
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {
            value: new Color(0),
          },
        },
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag,
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: {
            value: null,
          },
        },
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag,
    },
    points: {
      uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag,
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: {
            value: 1,
          },
          dashSize: {
            value: 1,
          },
          totalSize: {
            value: 2,
          },
        },
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag,
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag,
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag,
    },
    sprite: {
      uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new Matrix3(),
        },
        t2D: {
          value: null,
        },
        backgroundIntensity: {
          value: 1,
        },
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null,
        },
        flipEnvMap: {
          value: -1,
        },
        backgroundBlurriness: {
          value: 0,
        },
        backgroundIntensity: {
          value: 1,
        },
      },
      vertexShader: ShaderChunk.backgroundCube_vert,
      fragmentShader: ShaderChunk.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: {
          value: null,
        },
        tFlip: {
          value: -1,
        },
        opacity: {
          value: 1,
        },
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag,
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null,
        },
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag,
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: {
            value: new Vector3(),
          },
          nearDistance: {
            value: 1,
          },
          farDistance: {
            value: 1e3,
          },
        },
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag,
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: {
            value: new Color(0),
          },
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag,
    },
  };
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: {
        value: 0,
      },
      clearcoatMap: {
        value: null,
      },
      clearcoatMapTransform: {
        value: new Matrix3(),
      },
      clearcoatNormalMap: {
        value: null,
      },
      clearcoatNormalMapTransform: {
        value: new Matrix3(),
      },
      clearcoatNormalScale: {
        value: new Vector2(1, 1),
      },
      clearcoatRoughness: {
        value: 0,
      },
      clearcoatRoughnessMap: {
        value: null,
      },
      clearcoatRoughnessMapTransform: {
        value: new Matrix3(),
      },
      iridescence: {
        value: 0,
      },
      iridescenceMap: {
        value: null,
      },
      iridescenceMapTransform: {
        value: new Matrix3(),
      },
      iridescenceIOR: {
        value: 1.3,
      },
      iridescenceThicknessMinimum: {
        value: 100,
      },
      iridescenceThicknessMaximum: {
        value: 400,
      },
      iridescenceThicknessMap: {
        value: null,
      },
      iridescenceThicknessMapTransform: {
        value: new Matrix3(),
      },
      sheen: {
        value: 0,
      },
      sheenColor: {
        value: new Color(0),
      },
      sheenColorMap: {
        value: null,
      },
      sheenColorMapTransform: {
        value: new Matrix3(),
      },
      sheenRoughness: {
        value: 1,
      },
      sheenRoughnessMap: {
        value: null,
      },
      sheenRoughnessMapTransform: {
        value: new Matrix3(),
      },
      transmission: {
        value: 0,
      },
      transmissionMap: {
        value: null,
      },
      transmissionMapTransform: {
        value: new Matrix3(),
      },
      transmissionSamplerSize: {
        value: new Vector2(),
      },
      transmissionSamplerMap: {
        value: null,
      },
      thickness: {
        value: 0,
      },
      thicknessMap: {
        value: null,
      },
      thicknessMapTransform: {
        value: new Matrix3(),
      },
      attenuationDistance: {
        value: 0,
      },
      attenuationColor: {
        value: new Color(0),
      },
      specularColor: {
        value: new Color(1, 1, 1),
      },
      specularColorMap: {
        value: null,
      },
      specularColorMapTransform: {
        value: new Matrix3(),
      },
      specularIntensity: {
        value: 1,
      },
      specularIntensityMap: {
        value: null,
      },
      specularIntensityMapTransform: {
        value: new Matrix3(),
      },
      anisotropyVector: {
        value: new Vector2(),
      },
      anisotropyMap: {
        value: null,
      },
      anisotropyMapTransform: {
        value: new Matrix3(),
      },
    },
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag,
};
const _rgb = {
  r: 0,
  b: 0,
  g: 0,
};
function WebGLBackground(Wr, ze, Gr, Yr, Kr, Zr, Jr) {
  const Qr = new Color(0);
  let ei = Zr === !0 ? 0 : 1,
    ti,
    ri,
    ni = null,
    ii = 0,
    si = null;
  function li(ui, ai) {
    let hi = !1,
      ci = ai.isScene === !0 ? ai.background : null;
    ci &&
      ci.isTexture &&
      (ci = (ai.backgroundBlurriness > 0 ? Gr : ze).get(ci)),
      ci === null ? oi(Qr, ei) : ci && ci.isColor && (oi(ci, 1), (hi = !0));
    const fi = Wr.xr.getEnvironmentBlendMode();
    fi === "additive"
      ? Yr.buffers.color.setClear(0, 0, 0, 1, Jr)
      : fi === "alpha-blend" && Yr.buffers.color.setClear(0, 0, 0, 0, Jr),
      (Wr.autoClear || hi) &&
        Wr.clear(Wr.autoClearColor, Wr.autoClearDepth, Wr.autoClearStencil),
      ci && (ci.isCubeTexture || ci.mapping === CubeUVReflectionMapping)
        ? (ri === void 0 &&
            ((ri = new Mesh(
              new BoxGeometry(1, 1, 1),
              new ShaderMaterial({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
                vertexShader: ShaderLib.backgroundCube.vertexShader,
                fragmentShader: ShaderLib.backgroundCube.fragmentShader,
                side: BackSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            ri.geometry.deleteAttribute("normal"),
            ri.geometry.deleteAttribute("uv"),
            (ri.onBeforeRender = function (di, pi, mi) {
              this.matrixWorld.copyPosition(mi.matrixWorld);
            }),
            Object.defineProperty(ri.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            Kr.update(ri)),
          (ri.material.uniforms.envMap.value = ci),
          (ri.material.uniforms.flipEnvMap.value =
            ci.isCubeTexture && ci.isRenderTargetTexture === !1 ? -1 : 1),
          (ri.material.uniforms.backgroundBlurriness.value =
            ai.backgroundBlurriness),
          (ri.material.uniforms.backgroundIntensity.value =
            ai.backgroundIntensity),
          (ri.material.toneMapped =
            ColorManagement.getTransfer(ci.colorSpace) !== SRGBTransfer),
          (ni !== ci || ii !== ci.version || si !== Wr.toneMapping) &&
            ((ri.material.needsUpdate = !0),
            (ni = ci),
            (ii = ci.version),
            (si = Wr.toneMapping)),
          ri.layers.enableAll(),
          ui.unshift(ri, ri.geometry, ri.material, 0, 0, null))
        : ci &&
          ci.isTexture &&
          (ti === void 0 &&
            ((ti = new Mesh(
              new PlaneGeometry(2, 2),
              new ShaderMaterial({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms(ShaderLib.background.uniforms),
                vertexShader: ShaderLib.background.vertexShader,
                fragmentShader: ShaderLib.background.fragmentShader,
                side: FrontSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            ti.geometry.deleteAttribute("normal"),
            Object.defineProperty(ti.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            Kr.update(ti)),
          (ti.material.uniforms.t2D.value = ci),
          (ti.material.uniforms.backgroundIntensity.value =
            ai.backgroundIntensity),
          (ti.material.toneMapped =
            ColorManagement.getTransfer(ci.colorSpace) !== SRGBTransfer),
          ci.matrixAutoUpdate === !0 && ci.updateMatrix(),
          ti.material.uniforms.uvTransform.value.copy(ci.matrix),
          (ni !== ci || ii !== ci.version || si !== Wr.toneMapping) &&
            ((ti.material.needsUpdate = !0),
            (ni = ci),
            (ii = ci.version),
            (si = Wr.toneMapping)),
          ti.layers.enableAll(),
          ui.unshift(ti, ti.geometry, ti.material, 0, 0, null));
  }
  function oi(ui, ai) {
    ui.getRGB(_rgb, getUnlitUniformColorSpace(Wr)),
      Yr.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, ai, Jr);
  }
  return {
    getClearColor: function () {
      return Qr;
    },
    setClearColor: function (ui, ai = 1) {
      Qr.set(ui), (ei = ai), oi(Qr, ei);
    },
    getClearAlpha: function () {
      return ei;
    },
    setClearAlpha: function (ui) {
      (ei = ui), oi(Qr, ei);
    },
    render: li,
  };
}
function WebGLBindingStates(Wr, ze, Gr, Yr) {
  const Kr = Wr.getParameter(Wr.MAX_VERTEX_ATTRIBS),
    Zr = Yr.isWebGL2 ? null : ze.get("OES_vertex_array_object"),
    Jr = Yr.isWebGL2 || Zr !== null,
    Qr = {},
    ei = ui(null);
  let ti = ei,
    ri = !1;
  function ni(wi, Ci, bi, Mi, gi) {
    let xi = !1;
    if (Jr) {
      const Ti = oi(Mi, bi, Ci);
      ti !== Ti && ((ti = Ti), si(ti.object)),
        (xi = ai(wi, Mi, bi, gi)),
        xi && hi(wi, Mi, bi, gi);
    } else {
      const Ti = Ci.wireframe === !0;
      (ti.geometry !== Mi.id || ti.program !== bi.id || ti.wireframe !== Ti) &&
        ((ti.geometry = Mi.id),
        (ti.program = bi.id),
        (ti.wireframe = Ti),
        (xi = !0));
    }
    gi !== null && Gr.update(gi, Wr.ELEMENT_ARRAY_BUFFER),
      (xi || ri) &&
        ((ri = !1),
        Si(wi, Ci, bi, Mi),
        gi !== null &&
          Wr.bindBuffer(Wr.ELEMENT_ARRAY_BUFFER, Gr.get(gi).buffer));
  }
  function ii() {
    return Yr.isWebGL2 ? Wr.createVertexArray() : Zr.createVertexArrayOES();
  }
  function si(wi) {
    return Yr.isWebGL2 ? Wr.bindVertexArray(wi) : Zr.bindVertexArrayOES(wi);
  }
  function li(wi) {
    return Yr.isWebGL2 ? Wr.deleteVertexArray(wi) : Zr.deleteVertexArrayOES(wi);
  }
  function oi(wi, Ci, bi) {
    const Mi = bi.wireframe === !0;
    let gi = Qr[wi.id];
    gi === void 0 && ((gi = {}), (Qr[wi.id] = gi));
    let xi = gi[Ci.id];
    xi === void 0 && ((xi = {}), (gi[Ci.id] = xi));
    let Ti = xi[Mi];
    return Ti === void 0 && ((Ti = ui(ii())), (xi[Mi] = Ti)), Ti;
  }
  function ui(wi) {
    const Ci = [],
      bi = [],
      Mi = [];
    for (let gi = 0; gi < Kr; gi++) (Ci[gi] = 0), (bi[gi] = 0), (Mi[gi] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Ci,
      enabledAttributes: bi,
      attributeDivisors: Mi,
      object: wi,
      attributes: {},
      index: null,
    };
  }
  function ai(wi, Ci, bi, Mi) {
    const gi = ti.attributes,
      xi = Ci.attributes;
    let Ti = 0;
    const vi = bi.getAttributes();
    for (const Ii in vi)
      if (vi[Ii].location >= 0) {
        const ki = gi[Ii];
        let Bi = xi[Ii];
        if (
          (Bi === void 0 &&
            (Ii === "instanceMatrix" &&
              wi.instanceMatrix &&
              (Bi = wi.instanceMatrix),
            Ii === "instanceColor" &&
              wi.instanceColor &&
              (Bi = wi.instanceColor)),
          ki === void 0 || ki.attribute !== Bi || (Bi && ki.data !== Bi.data))
        )
          return !0;
        Ti++;
      }
    return ti.attributesNum !== Ti || ti.index !== Mi;
  }
  function hi(wi, Ci, bi, Mi) {
    const gi = {},
      xi = Ci.attributes;
    let Ti = 0;
    const vi = bi.getAttributes();
    for (const Ii in vi)
      if (vi[Ii].location >= 0) {
        let ki = xi[Ii];
        ki === void 0 &&
          (Ii === "instanceMatrix" &&
            wi.instanceMatrix &&
            (ki = wi.instanceMatrix),
          Ii === "instanceColor" &&
            wi.instanceColor &&
            (ki = wi.instanceColor));
        const Bi = {};
        (Bi.attribute = ki),
          ki && ki.data && (Bi.data = ki.data),
          (gi[Ii] = Bi),
          Ti++;
      }
    (ti.attributes = gi), (ti.attributesNum = Ti), (ti.index = Mi);
  }
  function ci() {
    const wi = ti.newAttributes;
    for (let Ci = 0, bi = wi.length; Ci < bi; Ci++) wi[Ci] = 0;
  }
  function fi(wi) {
    di(wi, 0);
  }
  function di(wi, Ci) {
    const bi = ti.newAttributes,
      Mi = ti.enabledAttributes,
      gi = ti.attributeDivisors;
    (bi[wi] = 1),
      Mi[wi] === 0 && (Wr.enableVertexAttribArray(wi), (Mi[wi] = 1)),
      gi[wi] !== Ci &&
        ((Yr.isWebGL2 ? Wr : ze.get("ANGLE_instanced_arrays"))[
          Yr.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](wi, Ci),
        (gi[wi] = Ci));
  }
  function pi() {
    const wi = ti.newAttributes,
      Ci = ti.enabledAttributes;
    for (let bi = 0, Mi = Ci.length; bi < Mi; bi++)
      Ci[bi] !== wi[bi] && (Wr.disableVertexAttribArray(bi), (Ci[bi] = 0));
  }
  function mi(wi, Ci, bi, Mi, gi, xi, Ti) {
    Ti === !0
      ? Wr.vertexAttribIPointer(wi, Ci, bi, gi, xi)
      : Wr.vertexAttribPointer(wi, Ci, bi, Mi, gi, xi);
  }
  function Si(wi, Ci, bi, Mi) {
    if (
      Yr.isWebGL2 === !1 &&
      (wi.isInstancedMesh || Mi.isInstancedBufferGeometry) &&
      ze.get("ANGLE_instanced_arrays") === null
    )
      return;
    ci();
    const gi = Mi.attributes,
      xi = bi.getAttributes(),
      Ti = Ci.defaultAttributeValues;
    for (const vi in xi) {
      const Ii = xi[vi];
      if (Ii.location >= 0) {
        let Oi = gi[vi];
        if (
          (Oi === void 0 &&
            (vi === "instanceMatrix" &&
              wi.instanceMatrix &&
              (Oi = wi.instanceMatrix),
            vi === "instanceColor" &&
              wi.instanceColor &&
              (Oi = wi.instanceColor)),
          Oi !== void 0)
        ) {
          const ki = Oi.normalized,
            Bi = Oi.itemSize,
            Xi = Gr.get(Oi);
          if (Xi === void 0) continue;
          const an = Xi.buffer,
            Qi = Xi.type,
            ln = Xi.bytesPerElement,
            yn =
              Yr.isWebGL2 === !0 &&
              (Qi === Wr.INT ||
                Qi === Wr.UNSIGNED_INT ||
                Oi.gpuType === IntType);
          if (Oi.isInterleavedBufferAttribute) {
            const un = Oi.data,
              Vi = un.stride,
              rn = Oi.offset;
            if (un.isInstancedInterleavedBuffer) {
              for (let qi = 0; qi < Ii.locationSize; qi++)
                di(Ii.location + qi, un.meshPerAttribute);
              wi.isInstancedMesh !== !0 &&
                Mi._maxInstanceCount === void 0 &&
                (Mi._maxInstanceCount = un.meshPerAttribute * un.count);
            } else
              for (let qi = 0; qi < Ii.locationSize; qi++) fi(Ii.location + qi);
            Wr.bindBuffer(Wr.ARRAY_BUFFER, an);
            for (let qi = 0; qi < Ii.locationSize; qi++)
              mi(
                Ii.location + qi,
                Bi / Ii.locationSize,
                Qi,
                ki,
                Vi * ln,
                (rn + (Bi / Ii.locationSize) * qi) * ln,
                yn
              );
          } else {
            if (Oi.isInstancedBufferAttribute) {
              for (let un = 0; un < Ii.locationSize; un++)
                di(Ii.location + un, Oi.meshPerAttribute);
              wi.isInstancedMesh !== !0 &&
                Mi._maxInstanceCount === void 0 &&
                (Mi._maxInstanceCount = Oi.meshPerAttribute * Oi.count);
            } else
              for (let un = 0; un < Ii.locationSize; un++) fi(Ii.location + un);
            Wr.bindBuffer(Wr.ARRAY_BUFFER, an);
            for (let un = 0; un < Ii.locationSize; un++)
              mi(
                Ii.location + un,
                Bi / Ii.locationSize,
                Qi,
                ki,
                Bi * ln,
                (Bi / Ii.locationSize) * un * ln,
                yn
              );
          }
        } else if (Ti !== void 0) {
          const ki = Ti[vi];
          if (ki !== void 0)
            switch (ki.length) {
              case 2:
                Wr.vertexAttrib2fv(Ii.location, ki);
                break;
              case 3:
                Wr.vertexAttrib3fv(Ii.location, ki);
                break;
              case 4:
                Wr.vertexAttrib4fv(Ii.location, ki);
                break;
              default:
                Wr.vertexAttrib1fv(Ii.location, ki);
            }
        }
      }
    }
    pi();
  }
  function yi() {
    Ai();
    for (const wi in Qr) {
      const Ci = Qr[wi];
      for (const bi in Ci) {
        const Mi = Ci[bi];
        for (const gi in Mi) li(Mi[gi].object), delete Mi[gi];
        delete Ci[bi];
      }
      delete Qr[wi];
    }
  }
  function Ei(wi) {
    if (Qr[wi.id] === void 0) return;
    const Ci = Qr[wi.id];
    for (const bi in Ci) {
      const Mi = Ci[bi];
      for (const gi in Mi) li(Mi[gi].object), delete Mi[gi];
      delete Ci[bi];
    }
    delete Qr[wi.id];
  }
  function Pi(wi) {
    for (const Ci in Qr) {
      const bi = Qr[Ci];
      if (bi[wi.id] === void 0) continue;
      const Mi = bi[wi.id];
      for (const gi in Mi) li(Mi[gi].object), delete Mi[gi];
      delete bi[wi.id];
    }
  }
  function Ai() {
    Ri(), (ri = !0), ti !== ei && ((ti = ei), si(ti.object));
  }
  function Ri() {
    (ei.geometry = null), (ei.program = null), (ei.wireframe = !1);
  }
  return {
    setup: ni,
    reset: Ai,
    resetDefaultState: Ri,
    dispose: yi,
    releaseStatesOfGeometry: Ei,
    releaseStatesOfProgram: Pi,
    initAttributes: ci,
    enableAttribute: fi,
    disableUnusedAttributes: pi,
  };
}
function WebGLBufferRenderer(Wr, ze, Gr, Yr) {
  const Kr = Yr.isWebGL2;
  let Zr;
  function Jr(ti) {
    Zr = ti;
  }
  function Qr(ti, ri) {
    Wr.drawArrays(Zr, ti, ri), Gr.update(ri, Zr, 1);
  }
  function ei(ti, ri, ni) {
    if (ni === 0) return;
    let ii, si;
    if (Kr) (ii = Wr), (si = "drawArraysInstanced");
    else if (
      ((ii = ze.get("ANGLE_instanced_arrays")),
      (si = "drawArraysInstancedANGLE"),
      ii === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    ii[si](Zr, ti, ri, ni), Gr.update(ri, Zr, ni);
  }
  (this.setMode = Jr), (this.render = Qr), (this.renderInstances = ei);
}
function WebGLCapabilities(Wr, ze, Gr) {
  let Yr;
  function Kr() {
    if (Yr !== void 0) return Yr;
    if (ze.has("EXT_texture_filter_anisotropic") === !0) {
      const mi = ze.get("EXT_texture_filter_anisotropic");
      Yr = Wr.getParameter(mi.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else Yr = 0;
    return Yr;
  }
  function Zr(mi) {
    if (mi === "highp") {
      if (
        Wr.getShaderPrecisionFormat(Wr.VERTEX_SHADER, Wr.HIGH_FLOAT).precision >
          0 &&
        Wr.getShaderPrecisionFormat(Wr.FRAGMENT_SHADER, Wr.HIGH_FLOAT)
          .precision > 0
      )
        return "highp";
      mi = "mediump";
    }
    return mi === "mediump" &&
      Wr.getShaderPrecisionFormat(Wr.VERTEX_SHADER, Wr.MEDIUM_FLOAT).precision >
        0 &&
      Wr.getShaderPrecisionFormat(Wr.FRAGMENT_SHADER, Wr.MEDIUM_FLOAT)
        .precision > 0
      ? "mediump"
      : "lowp";
  }
  const Jr =
    typeof WebGL2RenderingContext < "u" &&
    Wr.constructor.name === "WebGL2RenderingContext";
  let Qr = Gr.precision !== void 0 ? Gr.precision : "highp";
  const ei = Zr(Qr);
  ei !== Qr &&
    (console.warn(
      "THREE.WebGLRenderer:",
      Qr,
      "not supported, using",
      ei,
      "instead."
    ),
    (Qr = ei));
  const ti = Jr || ze.has("WEBGL_draw_buffers"),
    ri = Gr.logarithmicDepthBuffer === !0,
    ni = Wr.getParameter(Wr.MAX_TEXTURE_IMAGE_UNITS),
    ii = Wr.getParameter(Wr.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    si = Wr.getParameter(Wr.MAX_TEXTURE_SIZE),
    li = Wr.getParameter(Wr.MAX_CUBE_MAP_TEXTURE_SIZE),
    oi = Wr.getParameter(Wr.MAX_VERTEX_ATTRIBS),
    ui = Wr.getParameter(Wr.MAX_VERTEX_UNIFORM_VECTORS),
    ai = Wr.getParameter(Wr.MAX_VARYING_VECTORS),
    hi = Wr.getParameter(Wr.MAX_FRAGMENT_UNIFORM_VECTORS),
    ci = ii > 0,
    fi = Jr || ze.has("OES_texture_float"),
    di = ci && fi,
    pi = Jr ? Wr.getParameter(Wr.MAX_SAMPLES) : 0;
  return {
    isWebGL2: Jr,
    drawBuffers: ti,
    getMaxAnisotropy: Kr,
    getMaxPrecision: Zr,
    precision: Qr,
    logarithmicDepthBuffer: ri,
    maxTextures: ni,
    maxVertexTextures: ii,
    maxTextureSize: si,
    maxCubemapSize: li,
    maxAttributes: oi,
    maxVertexUniforms: ui,
    maxVaryings: ai,
    maxFragmentUniforms: hi,
    vertexTextures: ci,
    floatFragmentTextures: fi,
    floatVertexTextures: di,
    maxSamples: pi,
  };
}
function WebGLClipping(Wr) {
  const ze = this;
  let Gr = null,
    Yr = 0,
    Kr = !1,
    Zr = !1;
  const Jr = new Plane(),
    Qr = new Matrix3(),
    ei = {
      value: null,
      needsUpdate: !1,
    };
  (this.uniform = ei),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (ni, ii) {
      const si = ni.length !== 0 || ii || Yr !== 0 || Kr;
      return (Kr = ii), (Yr = ni.length), si;
    }),
    (this.beginShadows = function () {
      (Zr = !0), ri(null);
    }),
    (this.endShadows = function () {
      Zr = !1;
    }),
    (this.setGlobalState = function (ni, ii) {
      Gr = ri(ni, ii, 0);
    }),
    (this.setState = function (ni, ii, si) {
      const li = ni.clippingPlanes,
        oi = ni.clipIntersection,
        ui = ni.clipShadows,
        ai = Wr.get(ni);
      if (!Kr || li === null || li.length === 0 || (Zr && !ui))
        Zr ? ri(null) : ti();
      else {
        const hi = Zr ? 0 : Yr,
          ci = hi * 4;
        let fi = ai.clippingState || null;
        (ei.value = fi), (fi = ri(li, ii, ci, si));
        for (let di = 0; di !== ci; ++di) fi[di] = Gr[di];
        (ai.clippingState = fi),
          (this.numIntersection = oi ? this.numPlanes : 0),
          (this.numPlanes += hi);
      }
    });
  function ti() {
    ei.value !== Gr && ((ei.value = Gr), (ei.needsUpdate = Yr > 0)),
      (ze.numPlanes = Yr),
      (ze.numIntersection = 0);
  }
  function ri(ni, ii, si, li) {
    const oi = ni !== null ? ni.length : 0;
    let ui = null;
    if (oi !== 0) {
      if (((ui = ei.value), li !== !0 || ui === null)) {
        const ai = si + oi * 4,
          hi = ii.matrixWorldInverse;
        Qr.getNormalMatrix(hi),
          (ui === null || ui.length < ai) && (ui = new Float32Array(ai));
        for (let ci = 0, fi = si; ci !== oi; ++ci, fi += 4)
          Jr.copy(ni[ci]).applyMatrix4(hi, Qr),
            Jr.normal.toArray(ui, fi),
            (ui[fi + 3] = Jr.constant);
      }
      (ei.value = ui), (ei.needsUpdate = !0);
    }
    return (ze.numPlanes = oi), (ze.numIntersection = 0), ui;
  }
}
function WebGLCubeMaps(Wr) {
  let ze = new WeakMap();
  function Gr(Jr, Qr) {
    return (
      Qr === EquirectangularReflectionMapping
        ? (Jr.mapping = CubeReflectionMapping)
        : Qr === EquirectangularRefractionMapping &&
          (Jr.mapping = CubeRefractionMapping),
      Jr
    );
  }
  function Yr(Jr) {
    if (Jr && Jr.isTexture && Jr.isRenderTargetTexture === !1) {
      const Qr = Jr.mapping;
      if (
        Qr === EquirectangularReflectionMapping ||
        Qr === EquirectangularRefractionMapping
      )
        if (ze.has(Jr)) {
          const ei = ze.get(Jr).texture;
          return Gr(ei, Jr.mapping);
        } else {
          const ei = Jr.image;
          if (ei && ei.height > 0) {
            const ti = new WebGLCubeRenderTarget(ei.height / 2);
            return (
              ti.fromEquirectangularTexture(Wr, Jr),
              ze.set(Jr, ti),
              Jr.addEventListener("dispose", Kr),
              Gr(ti.texture, Jr.mapping)
            );
          } else return null;
        }
    }
    return Jr;
  }
  function Kr(Jr) {
    const Qr = Jr.target;
    Qr.removeEventListener("dispose", Kr);
    const ei = ze.get(Qr);
    ei !== void 0 && (ze.delete(Qr), ei.dispose());
  }
  function Zr() {
    ze = new WeakMap();
  }
  return {
    get: Yr,
    dispose: Zr,
  };
}
class OrthographicCamera extends Camera {
  constructor(ze = -1, Gr = 1, Yr = 1, Kr = -1, Zr = 0.1, Jr = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = ze),
      (this.right = Gr),
      (this.top = Yr),
      (this.bottom = Kr),
      (this.near = Zr),
      (this.far = Jr),
      this.updateProjectionMatrix();
  }
  copy(ze, Gr) {
    return (
      super.copy(ze, Gr),
      (this.left = ze.left),
      (this.right = ze.right),
      (this.top = ze.top),
      (this.bottom = ze.bottom),
      (this.near = ze.near),
      (this.far = ze.far),
      (this.zoom = ze.zoom),
      (this.view = ze.view === null ? null : Object.assign({}, ze.view)),
      this
    );
  }
  setViewOffset(ze, Gr, Yr, Kr, Zr, Jr) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = ze),
      (this.view.fullHeight = Gr),
      (this.view.offsetX = Yr),
      (this.view.offsetY = Kr),
      (this.view.width = Zr),
      (this.view.height = Jr),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const ze = (this.right - this.left) / (2 * this.zoom),
      Gr = (this.top - this.bottom) / (2 * this.zoom),
      Yr = (this.right + this.left) / 2,
      Kr = (this.top + this.bottom) / 2;
    let Zr = Yr - ze,
      Jr = Yr + ze,
      Qr = Kr + Gr,
      ei = Kr - Gr;
    if (this.view !== null && this.view.enabled) {
      const ti = (this.right - this.left) / this.view.fullWidth / this.zoom,
        ri = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (Zr += ti * this.view.offsetX),
        (Jr = Zr + ti * this.view.width),
        (Qr -= ri * this.view.offsetY),
        (ei = Qr - ri * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      Zr,
      Jr,
      Qr,
      ei,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(ze) {
    const Gr = super.toJSON(ze);
    return (
      (Gr.object.zoom = this.zoom),
      (Gr.object.left = this.left),
      (Gr.object.right = this.right),
      (Gr.object.top = this.top),
      (Gr.object.bottom = this.bottom),
      (Gr.object.near = this.near),
      (Gr.object.far = this.far),
      this.view !== null && (Gr.object.view = Object.assign({}, this.view)),
      Gr
    );
  }
}
const LOD_MIN = 4,
  EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  MAX_SAMPLES = 20,
  _flatCamera = new OrthographicCamera(),
  _clearColor = new Color();
let _oldTarget = null,
  _oldActiveCubeFace = 0,
  _oldActiveMipmapLevel = 0;
const PHI = (1 + Math.sqrt(5)) / 2,
  INV_PHI = 1 / PHI,
  _axisDirections = [
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, -1),
    new Vector3(0, PHI, INV_PHI),
    new Vector3(0, PHI, -INV_PHI),
    new Vector3(INV_PHI, 0, PHI),
    new Vector3(-INV_PHI, 0, PHI),
    new Vector3(PHI, INV_PHI, 0),
    new Vector3(-PHI, INV_PHI, 0),
  ];
class PMREMGenerator {
  constructor(ze) {
    (this._renderer = ze),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(ze, Gr = 0, Yr = 0.1, Kr = 100) {
    (_oldTarget = this._renderer.getRenderTarget()),
      (_oldActiveCubeFace = this._renderer.getActiveCubeFace()),
      (_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel()),
      this._setSize(256);
    const Zr = this._allocateTargets();
    return (
      (Zr.depthBuffer = !0),
      this._sceneToCubeUV(ze, Yr, Kr, Zr),
      Gr > 0 && this._blur(Zr, 0, 0, Gr),
      this._applyPMREM(Zr),
      this._cleanup(Zr),
      Zr
    );
  }
  fromEquirectangular(ze, Gr = null) {
    return this._fromTexture(ze, Gr);
  }
  fromCubemap(ze, Gr = null) {
    return this._fromTexture(ze, Gr);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = _getCubemapMaterial()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = _getEquirectMaterial()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(ze) {
    (this._lodMax = Math.floor(Math.log2(ze))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let ze = 0; ze < this._lodPlanes.length; ze++)
      this._lodPlanes[ze].dispose();
  }
  _cleanup(ze) {
    this._renderer.setRenderTarget(
      _oldTarget,
      _oldActiveCubeFace,
      _oldActiveMipmapLevel
    ),
      (ze.scissorTest = !1),
      _setViewport(ze, 0, 0, ze.width, ze.height);
  }
  _fromTexture(ze, Gr) {
    ze.mapping === CubeReflectionMapping || ze.mapping === CubeRefractionMapping
      ? this._setSize(
          ze.image.length === 0
            ? 16
            : ze.image[0].width || ze.image[0].image.width
        )
      : this._setSize(ze.image.width / 4),
      (_oldTarget = this._renderer.getRenderTarget()),
      (_oldActiveCubeFace = this._renderer.getActiveCubeFace()),
      (_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel());
    const Yr = Gr || this._allocateTargets();
    return (
      this._textureToCubeUV(ze, Yr), this._applyPMREM(Yr), this._cleanup(Yr), Yr
    );
  }
  _allocateTargets() {
    const ze = 3 * Math.max(this._cubeSize, 112),
      Gr = 4 * this._cubeSize,
      Yr = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: !1,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        depthBuffer: !1,
      },
      Kr = _createRenderTarget(ze, Gr, Yr);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== ze ||
      this._pingPongRenderTarget.height !== Gr
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = _createRenderTarget(ze, Gr, Yr));
      const { _lodMax: Zr } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = _createPlanes(Zr)),
        (this._blurMaterial = _getBlurShader(Zr, ze, Gr));
    }
    return Kr;
  }
  _compileMaterial(ze) {
    const Gr = new Mesh(this._lodPlanes[0], ze);
    this._renderer.compile(Gr, _flatCamera);
  }
  _sceneToCubeUV(ze, Gr, Yr, Kr) {
    const Qr = new PerspectiveCamera(90, 1, Gr, Yr),
      ei = [1, -1, 1, 1, 1, 1],
      ti = [1, 1, 1, -1, -1, -1],
      ri = this._renderer,
      ni = ri.autoClear,
      ii = ri.toneMapping;
    ri.getClearColor(_clearColor),
      (ri.toneMapping = NoToneMapping),
      (ri.autoClear = !1);
    const si = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: !1,
        depthTest: !1,
      }),
      li = new Mesh(new BoxGeometry(), si);
    let oi = !1;
    const ui = ze.background;
    ui
      ? ui.isColor && (si.color.copy(ui), (ze.background = null), (oi = !0))
      : (si.color.copy(_clearColor), (oi = !0));
    for (let ai = 0; ai < 6; ai++) {
      const hi = ai % 3;
      hi === 0
        ? (Qr.up.set(0, ei[ai], 0), Qr.lookAt(ti[ai], 0, 0))
        : hi === 1
        ? (Qr.up.set(0, 0, ei[ai]), Qr.lookAt(0, ti[ai], 0))
        : (Qr.up.set(0, ei[ai], 0), Qr.lookAt(0, 0, ti[ai]));
      const ci = this._cubeSize;
      _setViewport(Kr, hi * ci, ai > 2 ? ci : 0, ci, ci),
        ri.setRenderTarget(Kr),
        oi && ri.render(li, Qr),
        ri.render(ze, Qr);
    }
    li.geometry.dispose(),
      li.material.dispose(),
      (ri.toneMapping = ii),
      (ri.autoClear = ni),
      (ze.background = ui);
  }
  _textureToCubeUV(ze, Gr) {
    const Yr = this._renderer,
      Kr =
        ze.mapping === CubeReflectionMapping ||
        ze.mapping === CubeRefractionMapping;
    Kr
      ? (this._cubemapMaterial === null &&
          (this._cubemapMaterial = _getCubemapMaterial()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          ze.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null &&
        (this._equirectMaterial = _getEquirectMaterial());
    const Zr = Kr ? this._cubemapMaterial : this._equirectMaterial,
      Jr = new Mesh(this._lodPlanes[0], Zr),
      Qr = Zr.uniforms;
    Qr.envMap.value = ze;
    const ei = this._cubeSize;
    _setViewport(Gr, 0, 0, 3 * ei, 2 * ei),
      Yr.setRenderTarget(Gr),
      Yr.render(Jr, _flatCamera);
  }
  _applyPMREM(ze) {
    const Gr = this._renderer,
      Yr = Gr.autoClear;
    Gr.autoClear = !1;
    for (let Kr = 1; Kr < this._lodPlanes.length; Kr++) {
      const Zr = Math.sqrt(
          this._sigmas[Kr] * this._sigmas[Kr] -
            this._sigmas[Kr - 1] * this._sigmas[Kr - 1]
        ),
        Jr = _axisDirections[(Kr - 1) % _axisDirections.length];
      this._blur(ze, Kr - 1, Kr, Zr, Jr);
    }
    Gr.autoClear = Yr;
  }
  _blur(ze, Gr, Yr, Kr, Zr) {
    const Jr = this._pingPongRenderTarget;
    this._halfBlur(ze, Jr, Gr, Yr, Kr, "latitudinal", Zr),
      this._halfBlur(Jr, ze, Yr, Yr, Kr, "longitudinal", Zr);
  }
  _halfBlur(ze, Gr, Yr, Kr, Zr, Jr, Qr) {
    const ei = this._renderer,
      ti = this._blurMaterial;
    Jr !== "latitudinal" &&
      Jr !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const ri = 3,
      ni = new Mesh(this._lodPlanes[Kr], ti),
      ii = ti.uniforms,
      si = this._sizeLods[Yr] - 1,
      li = isFinite(Zr)
        ? Math.PI / (2 * si)
        : (2 * Math.PI) / (2 * MAX_SAMPLES - 1),
      oi = Zr / li,
      ui = isFinite(Zr) ? 1 + Math.floor(ri * oi) : MAX_SAMPLES;
    ui > MAX_SAMPLES &&
      console.warn(
        `sigmaRadians, ${Zr}, is too large and will clip, as it requested ${ui} samples when the maximum is set to ${MAX_SAMPLES}`
      );
    const ai = [];
    let hi = 0;
    for (let mi = 0; mi < MAX_SAMPLES; ++mi) {
      const Si = mi / oi,
        yi = Math.exp((-Si * Si) / 2);
      ai.push(yi), mi === 0 ? (hi += yi) : mi < ui && (hi += 2 * yi);
    }
    for (let mi = 0; mi < ai.length; mi++) ai[mi] = ai[mi] / hi;
    (ii.envMap.value = ze.texture),
      (ii.samples.value = ui),
      (ii.weights.value = ai),
      (ii.latitudinal.value = Jr === "latitudinal"),
      Qr && (ii.poleAxis.value = Qr);
    const { _lodMax: ci } = this;
    (ii.dTheta.value = li), (ii.mipInt.value = ci - Yr);
    const fi = this._sizeLods[Kr],
      di = 3 * fi * (Kr > ci - LOD_MIN ? Kr - ci + LOD_MIN : 0),
      pi = 4 * (this._cubeSize - fi);
    _setViewport(Gr, di, pi, 3 * fi, 2 * fi),
      ei.setRenderTarget(Gr),
      ei.render(ni, _flatCamera);
  }
}
function _createPlanes(Wr) {
  const ze = [],
    Gr = [],
    Yr = [];
  let Kr = Wr;
  const Zr = Wr - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let Jr = 0; Jr < Zr; Jr++) {
    const Qr = Math.pow(2, Kr);
    Gr.push(Qr);
    let ei = 1 / Qr;
    Jr > Wr - LOD_MIN
      ? (ei = EXTRA_LOD_SIGMA[Jr - Wr + LOD_MIN - 1])
      : Jr === 0 && (ei = 0),
      Yr.push(ei);
    const ti = 1 / (Qr - 2),
      ri = -ti,
      ni = 1 + ti,
      ii = [ri, ri, ni, ri, ni, ni, ri, ri, ni, ni, ri, ni],
      si = 6,
      li = 6,
      oi = 3,
      ui = 2,
      ai = 1,
      hi = new Float32Array(oi * li * si),
      ci = new Float32Array(ui * li * si),
      fi = new Float32Array(ai * li * si);
    for (let pi = 0; pi < si; pi++) {
      const mi = ((pi % 3) * 2) / 3 - 1,
        Si = pi > 2 ? 0 : -1,
        yi = [
          mi,
          Si,
          0,
          mi + 2 / 3,
          Si,
          0,
          mi + 2 / 3,
          Si + 1,
          0,
          mi,
          Si,
          0,
          mi + 2 / 3,
          Si + 1,
          0,
          mi,
          Si + 1,
          0,
        ];
      hi.set(yi, oi * li * pi), ci.set(ii, ui * li * pi);
      const Ei = [pi, pi, pi, pi, pi, pi];
      fi.set(Ei, ai * li * pi);
    }
    const di = new BufferGeometry();
    di.setAttribute("position", new BufferAttribute(hi, oi)),
      di.setAttribute("uv", new BufferAttribute(ci, ui)),
      di.setAttribute("faceIndex", new BufferAttribute(fi, ai)),
      ze.push(di),
      Kr > LOD_MIN && Kr--;
  }
  return {
    lodPlanes: ze,
    sizeLods: Gr,
    sigmas: Yr,
  };
}
function _createRenderTarget(Wr, ze, Gr) {
  const Yr = new WebGLRenderTarget(Wr, ze, Gr);
  return (
    (Yr.texture.mapping = CubeUVReflectionMapping),
    (Yr.texture.name = "PMREM.cubeUv"),
    (Yr.scissorTest = !0),
    Yr
  );
}
function _setViewport(Wr, ze, Gr, Yr, Kr) {
  Wr.viewport.set(ze, Gr, Yr, Kr), Wr.scissor.set(ze, Gr, Yr, Kr);
}
function _getBlurShader(Wr, ze, Gr) {
  const Yr = new Float32Array(MAX_SAMPLES),
    Kr = new Vector3(0, 1, 0);
  return new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / ze,
      CUBEUV_TEXEL_HEIGHT: 1 / Gr,
      CUBEUV_MAX_MIP: `${Wr}.0`,
    },
    uniforms: {
      envMap: {
        value: null,
      },
      samples: {
        value: 1,
      },
      weights: {
        value: Yr,
      },
      latitudinal: {
        value: !1,
      },
      dTheta: {
        value: 0,
      },
      mipInt: {
        value: 0,
      },
      poleAxis: {
        value: Kr,
      },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {
        value: null,
      },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {
        value: null,
      },
      flipEnvMap: {
        value: -1,
      },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(Wr) {
  let ze = new WeakMap(),
    Gr = null;
  function Yr(Qr) {
    if (Qr && Qr.isTexture) {
      const ei = Qr.mapping,
        ti =
          ei === EquirectangularReflectionMapping ||
          ei === EquirectangularRefractionMapping,
        ri = ei === CubeReflectionMapping || ei === CubeRefractionMapping;
      if (ti || ri)
        if (Qr.isRenderTargetTexture && Qr.needsPMREMUpdate === !0) {
          Qr.needsPMREMUpdate = !1;
          let ni = ze.get(Qr);
          return (
            Gr === null && (Gr = new PMREMGenerator(Wr)),
            (ni = ti ? Gr.fromEquirectangular(Qr, ni) : Gr.fromCubemap(Qr, ni)),
            ze.set(Qr, ni),
            ni.texture
          );
        } else {
          if (ze.has(Qr)) return ze.get(Qr).texture;
          {
            const ni = Qr.image;
            if ((ti && ni && ni.height > 0) || (ri && ni && Kr(ni))) {
              Gr === null && (Gr = new PMREMGenerator(Wr));
              const ii = ti ? Gr.fromEquirectangular(Qr) : Gr.fromCubemap(Qr);
              return (
                ze.set(Qr, ii), Qr.addEventListener("dispose", Zr), ii.texture
              );
            } else return null;
          }
        }
    }
    return Qr;
  }
  function Kr(Qr) {
    let ei = 0;
    const ti = 6;
    for (let ri = 0; ri < ti; ri++) Qr[ri] !== void 0 && ei++;
    return ei === ti;
  }
  function Zr(Qr) {
    const ei = Qr.target;
    ei.removeEventListener("dispose", Zr);
    const ti = ze.get(ei);
    ti !== void 0 && (ze.delete(ei), ti.dispose());
  }
  function Jr() {
    (ze = new WeakMap()), Gr !== null && (Gr.dispose(), (Gr = null));
  }
  return {
    get: Yr,
    dispose: Jr,
  };
}
function WebGLExtensions(Wr) {
  const ze = {};
  function Gr(Yr) {
    if (ze[Yr] !== void 0) return ze[Yr];
    let Kr;
    switch (Yr) {
      case "WEBGL_depth_texture":
        Kr =
          Wr.getExtension("WEBGL_depth_texture") ||
          Wr.getExtension("MOZ_WEBGL_depth_texture") ||
          Wr.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        Kr =
          Wr.getExtension("EXT_texture_filter_anisotropic") ||
          Wr.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          Wr.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        Kr =
          Wr.getExtension("WEBGL_compressed_texture_s3tc") ||
          Wr.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          Wr.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        Kr =
          Wr.getExtension("WEBGL_compressed_texture_pvrtc") ||
          Wr.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        Kr = Wr.getExtension(Yr);
    }
    return (ze[Yr] = Kr), Kr;
  }
  return {
    has: function (Yr) {
      return Gr(Yr) !== null;
    },
    init: function (Yr) {
      Yr.isWebGL2
        ? Gr("EXT_color_buffer_float")
        : (Gr("WEBGL_depth_texture"),
          Gr("OES_texture_float"),
          Gr("OES_texture_half_float"),
          Gr("OES_texture_half_float_linear"),
          Gr("OES_standard_derivatives"),
          Gr("OES_element_index_uint"),
          Gr("OES_vertex_array_object"),
          Gr("ANGLE_instanced_arrays")),
        Gr("OES_texture_float_linear"),
        Gr("EXT_color_buffer_half_float"),
        Gr("WEBGL_multisampled_render_to_texture");
    },
    get: function (Yr) {
      const Kr = Gr(Yr);
      return (
        Kr === null &&
          console.warn(
            "THREE.WebGLRenderer: " + Yr + " extension not supported."
          ),
        Kr
      );
    },
  };
}
function WebGLGeometries(Wr, ze, Gr, Yr) {
  const Kr = {},
    Zr = new WeakMap();
  function Jr(ni) {
    const ii = ni.target;
    ii.index !== null && ze.remove(ii.index);
    for (const li in ii.attributes) ze.remove(ii.attributes[li]);
    for (const li in ii.morphAttributes) {
      const oi = ii.morphAttributes[li];
      for (let ui = 0, ai = oi.length; ui < ai; ui++) ze.remove(oi[ui]);
    }
    ii.removeEventListener("dispose", Jr), delete Kr[ii.id];
    const si = Zr.get(ii);
    si && (ze.remove(si), Zr.delete(ii)),
      Yr.releaseStatesOfGeometry(ii),
      ii.isInstancedBufferGeometry === !0 && delete ii._maxInstanceCount,
      Gr.memory.geometries--;
  }
  function Qr(ni, ii) {
    return (
      Kr[ii.id] === !0 ||
        (ii.addEventListener("dispose", Jr),
        (Kr[ii.id] = !0),
        Gr.memory.geometries++),
      ii
    );
  }
  function ei(ni) {
    const ii = ni.attributes;
    for (const li in ii) ze.update(ii[li], Wr.ARRAY_BUFFER);
    const si = ni.morphAttributes;
    for (const li in si) {
      const oi = si[li];
      for (let ui = 0, ai = oi.length; ui < ai; ui++)
        ze.update(oi[ui], Wr.ARRAY_BUFFER);
    }
  }
  function ti(ni) {
    const ii = [],
      si = ni.index,
      li = ni.attributes.position;
    let oi = 0;
    if (si !== null) {
      const hi = si.array;
      oi = si.version;
      for (let ci = 0, fi = hi.length; ci < fi; ci += 3) {
        const di = hi[ci + 0],
          pi = hi[ci + 1],
          mi = hi[ci + 2];
        ii.push(di, pi, pi, mi, mi, di);
      }
    } else if (li !== void 0) {
      const hi = li.array;
      oi = li.version;
      for (let ci = 0, fi = hi.length / 3 - 1; ci < fi; ci += 3) {
        const di = ci + 0,
          pi = ci + 1,
          mi = ci + 2;
        ii.push(di, pi, pi, mi, mi, di);
      }
    } else return;
    const ui = new (
      arrayNeedsUint32(ii) ? Uint32BufferAttribute : Uint16BufferAttribute
    )(ii, 1);
    ui.version = oi;
    const ai = Zr.get(ni);
    ai && ze.remove(ai), Zr.set(ni, ui);
  }
  function ri(ni) {
    const ii = Zr.get(ni);
    if (ii) {
      const si = ni.index;
      si !== null && ii.version < si.version && ti(ni);
    } else ti(ni);
    return Zr.get(ni);
  }
  return {
    get: Qr,
    update: ei,
    getWireframeAttribute: ri,
  };
}
function WebGLIndexedBufferRenderer(Wr, ze, Gr, Yr) {
  const Kr = Yr.isWebGL2;
  let Zr;
  function Jr(ii) {
    Zr = ii;
  }
  let Qr, ei;
  function ti(ii) {
    (Qr = ii.type), (ei = ii.bytesPerElement);
  }
  function ri(ii, si) {
    Wr.drawElements(Zr, si, Qr, ii * ei), Gr.update(si, Zr, 1);
  }
  function ni(ii, si, li) {
    if (li === 0) return;
    let oi, ui;
    if (Kr) (oi = Wr), (ui = "drawElementsInstanced");
    else if (
      ((oi = ze.get("ANGLE_instanced_arrays")),
      (ui = "drawElementsInstancedANGLE"),
      oi === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    oi[ui](Zr, si, Qr, ii * ei, li), Gr.update(si, Zr, li);
  }
  (this.setMode = Jr),
    (this.setIndex = ti),
    (this.render = ri),
    (this.renderInstances = ni);
}
function WebGLInfo(Wr) {
  const ze = {
      geometries: 0,
      textures: 0,
    },
    Gr = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
    };
  function Yr(Zr, Jr, Qr) {
    switch ((Gr.calls++, Jr)) {
      case Wr.TRIANGLES:
        Gr.triangles += Qr * (Zr / 3);
        break;
      case Wr.LINES:
        Gr.lines += Qr * (Zr / 2);
        break;
      case Wr.LINE_STRIP:
        Gr.lines += Qr * (Zr - 1);
        break;
      case Wr.LINE_LOOP:
        Gr.lines += Qr * Zr;
        break;
      case Wr.POINTS:
        Gr.points += Qr * Zr;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", Jr);
        break;
    }
  }
  function Kr() {
    (Gr.calls = 0), (Gr.triangles = 0), (Gr.points = 0), (Gr.lines = 0);
  }
  return {
    memory: ze,
    render: Gr,
    programs: null,
    autoReset: !0,
    reset: Kr,
    update: Yr,
  };
}
function numericalSort(Wr, ze) {
  return Wr[0] - ze[0];
}
function absNumericalSort(Wr, ze) {
  return Math.abs(ze[1]) - Math.abs(Wr[1]);
}
function WebGLMorphtargets(Wr, ze, Gr) {
  const Yr = {},
    Kr = new Float32Array(8),
    Zr = new WeakMap(),
    Jr = new Vector4(),
    Qr = [];
  for (let ti = 0; ti < 8; ti++) Qr[ti] = [ti, 0];
  function ei(ti, ri, ni) {
    const ii = ti.morphTargetInfluences;
    if (ze.isWebGL2 === !0) {
      const si =
          ri.morphAttributes.position ||
          ri.morphAttributes.normal ||
          ri.morphAttributes.color,
        li = si !== void 0 ? si.length : 0;
      let oi = Zr.get(ri);
      if (oi === void 0 || oi.count !== li) {
        let wi = function () {
          Ai.dispose(), Zr.delete(ri), ri.removeEventListener("dispose", wi);
        };
        oi !== void 0 && oi.texture.dispose();
        const hi = ri.morphAttributes.position !== void 0,
          ci = ri.morphAttributes.normal !== void 0,
          fi = ri.morphAttributes.color !== void 0,
          di = ri.morphAttributes.position || [],
          pi = ri.morphAttributes.normal || [],
          mi = ri.morphAttributes.color || [];
        let Si = 0;
        hi === !0 && (Si = 1), ci === !0 && (Si = 2), fi === !0 && (Si = 3);
        let yi = ri.attributes.position.count * Si,
          Ei = 1;
        yi > ze.maxTextureSize &&
          ((Ei = Math.ceil(yi / ze.maxTextureSize)), (yi = ze.maxTextureSize));
        const Pi = new Float32Array(yi * Ei * 4 * li),
          Ai = new DataArrayTexture(Pi, yi, Ei, li);
        (Ai.type = FloatType), (Ai.needsUpdate = !0);
        const Ri = Si * 4;
        for (let Ci = 0; Ci < li; Ci++) {
          const bi = di[Ci],
            Mi = pi[Ci],
            gi = mi[Ci],
            xi = yi * Ei * 4 * Ci;
          for (let Ti = 0; Ti < bi.count; Ti++) {
            const vi = Ti * Ri;
            hi === !0 &&
              (Jr.fromBufferAttribute(bi, Ti),
              (Pi[xi + vi + 0] = Jr.x),
              (Pi[xi + vi + 1] = Jr.y),
              (Pi[xi + vi + 2] = Jr.z),
              (Pi[xi + vi + 3] = 0)),
              ci === !0 &&
                (Jr.fromBufferAttribute(Mi, Ti),
                (Pi[xi + vi + 4] = Jr.x),
                (Pi[xi + vi + 5] = Jr.y),
                (Pi[xi + vi + 6] = Jr.z),
                (Pi[xi + vi + 7] = 0)),
              fi === !0 &&
                (Jr.fromBufferAttribute(gi, Ti),
                (Pi[xi + vi + 8] = Jr.x),
                (Pi[xi + vi + 9] = Jr.y),
                (Pi[xi + vi + 10] = Jr.z),
                (Pi[xi + vi + 11] = gi.itemSize === 4 ? Jr.w : 1));
          }
        }
        (oi = {
          count: li,
          texture: Ai,
          size: new Vector2(yi, Ei),
        }),
          Zr.set(ri, oi),
          ri.addEventListener("dispose", wi);
      }
      let ui = 0;
      for (let hi = 0; hi < ii.length; hi++) ui += ii[hi];
      const ai = ri.morphTargetsRelative ? 1 : 1 - ui;
      ni.getUniforms().setValue(Wr, "morphTargetBaseInfluence", ai),
        ni.getUniforms().setValue(Wr, "morphTargetInfluences", ii),
        ni.getUniforms().setValue(Wr, "morphTargetsTexture", oi.texture, Gr),
        ni.getUniforms().setValue(Wr, "morphTargetsTextureSize", oi.size);
    } else {
      const si = ii === void 0 ? 0 : ii.length;
      let li = Yr[ri.id];
      if (li === void 0 || li.length !== si) {
        li = [];
        for (let ci = 0; ci < si; ci++) li[ci] = [ci, 0];
        Yr[ri.id] = li;
      }
      for (let ci = 0; ci < si; ci++) {
        const fi = li[ci];
        (fi[0] = ci), (fi[1] = ii[ci]);
      }
      li.sort(absNumericalSort);
      for (let ci = 0; ci < 8; ci++)
        ci < si && li[ci][1]
          ? ((Qr[ci][0] = li[ci][0]), (Qr[ci][1] = li[ci][1]))
          : ((Qr[ci][0] = Number.MAX_SAFE_INTEGER), (Qr[ci][1] = 0));
      Qr.sort(numericalSort);
      const oi = ri.morphAttributes.position,
        ui = ri.morphAttributes.normal;
      let ai = 0;
      for (let ci = 0; ci < 8; ci++) {
        const fi = Qr[ci],
          di = fi[0],
          pi = fi[1];
        di !== Number.MAX_SAFE_INTEGER && pi
          ? (oi &&
              ri.getAttribute("morphTarget" + ci) !== oi[di] &&
              ri.setAttribute("morphTarget" + ci, oi[di]),
            ui &&
              ri.getAttribute("morphNormal" + ci) !== ui[di] &&
              ri.setAttribute("morphNormal" + ci, ui[di]),
            (Kr[ci] = pi),
            (ai += pi))
          : (oi &&
              ri.hasAttribute("morphTarget" + ci) === !0 &&
              ri.deleteAttribute("morphTarget" + ci),
            ui &&
              ri.hasAttribute("morphNormal" + ci) === !0 &&
              ri.deleteAttribute("morphNormal" + ci),
            (Kr[ci] = 0));
      }
      const hi = ri.morphTargetsRelative ? 1 : 1 - ai;
      ni.getUniforms().setValue(Wr, "morphTargetBaseInfluence", hi),
        ni.getUniforms().setValue(Wr, "morphTargetInfluences", Kr);
    }
  }
  return {
    update: ei,
  };
}
function WebGLObjects(Wr, ze, Gr, Yr) {
  let Kr = new WeakMap();
  function Zr(ei) {
    const ti = Yr.render.frame,
      ri = ei.geometry,
      ni = ze.get(ei, ri);
    if (
      (Kr.get(ni) !== ti && (ze.update(ni), Kr.set(ni, ti)),
      ei.isInstancedMesh &&
        (ei.hasEventListener("dispose", Qr) === !1 &&
          ei.addEventListener("dispose", Qr),
        Kr.get(ei) !== ti &&
          (Gr.update(ei.instanceMatrix, Wr.ARRAY_BUFFER),
          ei.instanceColor !== null &&
            Gr.update(ei.instanceColor, Wr.ARRAY_BUFFER),
          Kr.set(ei, ti))),
      ei.isSkinnedMesh)
    ) {
      const ii = ei.skeleton;
      Kr.get(ii) !== ti && (ii.update(), Kr.set(ii, ti));
    }
    return ni;
  }
  function Jr() {
    Kr = new WeakMap();
  }
  function Qr(ei) {
    const ti = ei.target;
    ti.removeEventListener("dispose", Qr),
      Gr.remove(ti.instanceMatrix),
      ti.instanceColor !== null && Gr.remove(ti.instanceColor);
  }
  return {
    update: Zr,
    dispose: Jr,
  };
}
const emptyTexture = new Texture(),
  emptyArrayTexture = new DataArrayTexture(),
  empty3dTexture = new Data3DTexture(),
  emptyCubeTexture = new CubeTexture(),
  arrayCacheF32 = [],
  arrayCacheI32 = [],
  mat4array = new Float32Array(16),
  mat3array = new Float32Array(9),
  mat2array = new Float32Array(4);
function flatten(Wr, ze, Gr) {
  const Yr = Wr[0];
  if (Yr <= 0 || Yr > 0) return Wr;
  const Kr = ze * Gr;
  let Zr = arrayCacheF32[Kr];
  if (
    (Zr === void 0 && ((Zr = new Float32Array(Kr)), (arrayCacheF32[Kr] = Zr)),
    ze !== 0)
  ) {
    Yr.toArray(Zr, 0);
    for (let Jr = 1, Qr = 0; Jr !== ze; ++Jr)
      (Qr += Gr), Wr[Jr].toArray(Zr, Qr);
  }
  return Zr;
}
function arraysEqual(Wr, ze) {
  if (Wr.length !== ze.length) return !1;
  for (let Gr = 0, Yr = Wr.length; Gr < Yr; Gr++)
    if (Wr[Gr] !== ze[Gr]) return !1;
  return !0;
}
function copyArray(Wr, ze) {
  for (let Gr = 0, Yr = ze.length; Gr < Yr; Gr++) Wr[Gr] = ze[Gr];
}
function allocTexUnits(Wr, ze) {
  let Gr = arrayCacheI32[ze];
  Gr === void 0 && ((Gr = new Int32Array(ze)), (arrayCacheI32[ze] = Gr));
  for (let Yr = 0; Yr !== ze; ++Yr) Gr[Yr] = Wr.allocateTextureUnit();
  return Gr;
}
function setValueV1f(Wr, ze) {
  const Gr = this.cache;
  Gr[0] !== ze && (Wr.uniform1f(this.addr, ze), (Gr[0] = ze));
}
function setValueV2f(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y) &&
      (Wr.uniform2f(this.addr, ze.x, ze.y), (Gr[0] = ze.x), (Gr[1] = ze.y));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform2fv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueV3f(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y || Gr[2] !== ze.z) &&
      (Wr.uniform3f(this.addr, ze.x, ze.y, ze.z),
      (Gr[0] = ze.x),
      (Gr[1] = ze.y),
      (Gr[2] = ze.z));
  else if (ze.r !== void 0)
    (Gr[0] !== ze.r || Gr[1] !== ze.g || Gr[2] !== ze.b) &&
      (Wr.uniform3f(this.addr, ze.r, ze.g, ze.b),
      (Gr[0] = ze.r),
      (Gr[1] = ze.g),
      (Gr[2] = ze.b));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform3fv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueV4f(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y || Gr[2] !== ze.z || Gr[3] !== ze.w) &&
      (Wr.uniform4f(this.addr, ze.x, ze.y, ze.z, ze.w),
      (Gr[0] = ze.x),
      (Gr[1] = ze.y),
      (Gr[2] = ze.z),
      (Gr[3] = ze.w));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform4fv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueM2(Wr, ze) {
  const Gr = this.cache,
    Yr = ze.elements;
  if (Yr === void 0) {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniformMatrix2fv(this.addr, !1, ze), copyArray(Gr, ze);
  } else {
    if (arraysEqual(Gr, Yr)) return;
    mat2array.set(Yr),
      Wr.uniformMatrix2fv(this.addr, !1, mat2array),
      copyArray(Gr, Yr);
  }
}
function setValueM3(Wr, ze) {
  const Gr = this.cache,
    Yr = ze.elements;
  if (Yr === void 0) {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniformMatrix3fv(this.addr, !1, ze), copyArray(Gr, ze);
  } else {
    if (arraysEqual(Gr, Yr)) return;
    mat3array.set(Yr),
      Wr.uniformMatrix3fv(this.addr, !1, mat3array),
      copyArray(Gr, Yr);
  }
}
function setValueM4(Wr, ze) {
  const Gr = this.cache,
    Yr = ze.elements;
  if (Yr === void 0) {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniformMatrix4fv(this.addr, !1, ze), copyArray(Gr, ze);
  } else {
    if (arraysEqual(Gr, Yr)) return;
    mat4array.set(Yr),
      Wr.uniformMatrix4fv(this.addr, !1, mat4array),
      copyArray(Gr, Yr);
  }
}
function setValueV1i(Wr, ze) {
  const Gr = this.cache;
  Gr[0] !== ze && (Wr.uniform1i(this.addr, ze), (Gr[0] = ze));
}
function setValueV2i(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y) &&
      (Wr.uniform2i(this.addr, ze.x, ze.y), (Gr[0] = ze.x), (Gr[1] = ze.y));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform2iv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueV3i(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y || Gr[2] !== ze.z) &&
      (Wr.uniform3i(this.addr, ze.x, ze.y, ze.z),
      (Gr[0] = ze.x),
      (Gr[1] = ze.y),
      (Gr[2] = ze.z));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform3iv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueV4i(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y || Gr[2] !== ze.z || Gr[3] !== ze.w) &&
      (Wr.uniform4i(this.addr, ze.x, ze.y, ze.z, ze.w),
      (Gr[0] = ze.x),
      (Gr[1] = ze.y),
      (Gr[2] = ze.z),
      (Gr[3] = ze.w));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform4iv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueV1ui(Wr, ze) {
  const Gr = this.cache;
  Gr[0] !== ze && (Wr.uniform1ui(this.addr, ze), (Gr[0] = ze));
}
function setValueV2ui(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y) &&
      (Wr.uniform2ui(this.addr, ze.x, ze.y), (Gr[0] = ze.x), (Gr[1] = ze.y));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform2uiv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueV3ui(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y || Gr[2] !== ze.z) &&
      (Wr.uniform3ui(this.addr, ze.x, ze.y, ze.z),
      (Gr[0] = ze.x),
      (Gr[1] = ze.y),
      (Gr[2] = ze.z));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform3uiv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueV4ui(Wr, ze) {
  const Gr = this.cache;
  if (ze.x !== void 0)
    (Gr[0] !== ze.x || Gr[1] !== ze.y || Gr[2] !== ze.z || Gr[3] !== ze.w) &&
      (Wr.uniform4ui(this.addr, ze.x, ze.y, ze.z, ze.w),
      (Gr[0] = ze.x),
      (Gr[1] = ze.y),
      (Gr[2] = ze.z),
      (Gr[3] = ze.w));
  else {
    if (arraysEqual(Gr, ze)) return;
    Wr.uniform4uiv(this.addr, ze), copyArray(Gr, ze);
  }
}
function setValueT1(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = Gr.allocateTextureUnit();
  Yr[0] !== Kr && (Wr.uniform1i(this.addr, Kr), (Yr[0] = Kr)),
    Gr.setTexture2D(ze || emptyTexture, Kr);
}
function setValueT3D1(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = Gr.allocateTextureUnit();
  Yr[0] !== Kr && (Wr.uniform1i(this.addr, Kr), (Yr[0] = Kr)),
    Gr.setTexture3D(ze || empty3dTexture, Kr);
}
function setValueT6(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = Gr.allocateTextureUnit();
  Yr[0] !== Kr && (Wr.uniform1i(this.addr, Kr), (Yr[0] = Kr)),
    Gr.setTextureCube(ze || emptyCubeTexture, Kr);
}
function setValueT2DArray1(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = Gr.allocateTextureUnit();
  Yr[0] !== Kr && (Wr.uniform1i(this.addr, Kr), (Yr[0] = Kr)),
    Gr.setTexture2DArray(ze || emptyArrayTexture, Kr);
}
function getSingularSetter(Wr) {
  switch (Wr) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(Wr, ze) {
  Wr.uniform1fv(this.addr, ze);
}
function setValueV2fArray(Wr, ze) {
  const Gr = flatten(ze, this.size, 2);
  Wr.uniform2fv(this.addr, Gr);
}
function setValueV3fArray(Wr, ze) {
  const Gr = flatten(ze, this.size, 3);
  Wr.uniform3fv(this.addr, Gr);
}
function setValueV4fArray(Wr, ze) {
  const Gr = flatten(ze, this.size, 4);
  Wr.uniform4fv(this.addr, Gr);
}
function setValueM2Array(Wr, ze) {
  const Gr = flatten(ze, this.size, 4);
  Wr.uniformMatrix2fv(this.addr, !1, Gr);
}
function setValueM3Array(Wr, ze) {
  const Gr = flatten(ze, this.size, 9);
  Wr.uniformMatrix3fv(this.addr, !1, Gr);
}
function setValueM4Array(Wr, ze) {
  const Gr = flatten(ze, this.size, 16);
  Wr.uniformMatrix4fv(this.addr, !1, Gr);
}
function setValueV1iArray(Wr, ze) {
  Wr.uniform1iv(this.addr, ze);
}
function setValueV2iArray(Wr, ze) {
  Wr.uniform2iv(this.addr, ze);
}
function setValueV3iArray(Wr, ze) {
  Wr.uniform3iv(this.addr, ze);
}
function setValueV4iArray(Wr, ze) {
  Wr.uniform4iv(this.addr, ze);
}
function setValueV1uiArray(Wr, ze) {
  Wr.uniform1uiv(this.addr, ze);
}
function setValueV2uiArray(Wr, ze) {
  Wr.uniform2uiv(this.addr, ze);
}
function setValueV3uiArray(Wr, ze) {
  Wr.uniform3uiv(this.addr, ze);
}
function setValueV4uiArray(Wr, ze) {
  Wr.uniform4uiv(this.addr, ze);
}
function setValueT1Array(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = ze.length,
    Zr = allocTexUnits(Gr, Kr);
  arraysEqual(Yr, Zr) || (Wr.uniform1iv(this.addr, Zr), copyArray(Yr, Zr));
  for (let Jr = 0; Jr !== Kr; ++Jr)
    Gr.setTexture2D(ze[Jr] || emptyTexture, Zr[Jr]);
}
function setValueT3DArray(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = ze.length,
    Zr = allocTexUnits(Gr, Kr);
  arraysEqual(Yr, Zr) || (Wr.uniform1iv(this.addr, Zr), copyArray(Yr, Zr));
  for (let Jr = 0; Jr !== Kr; ++Jr)
    Gr.setTexture3D(ze[Jr] || empty3dTexture, Zr[Jr]);
}
function setValueT6Array(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = ze.length,
    Zr = allocTexUnits(Gr, Kr);
  arraysEqual(Yr, Zr) || (Wr.uniform1iv(this.addr, Zr), copyArray(Yr, Zr));
  for (let Jr = 0; Jr !== Kr; ++Jr)
    Gr.setTextureCube(ze[Jr] || emptyCubeTexture, Zr[Jr]);
}
function setValueT2DArrayArray(Wr, ze, Gr) {
  const Yr = this.cache,
    Kr = ze.length,
    Zr = allocTexUnits(Gr, Kr);
  arraysEqual(Yr, Zr) || (Wr.uniform1iv(this.addr, Zr), copyArray(Yr, Zr));
  for (let Jr = 0; Jr !== Kr; ++Jr)
    Gr.setTexture2DArray(ze[Jr] || emptyArrayTexture, Zr[Jr]);
}
function getPureArraySetter(Wr) {
  switch (Wr) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(ze, Gr, Yr) {
    (this.id = ze),
      (this.addr = Yr),
      (this.cache = []),
      (this.setValue = getSingularSetter(Gr.type));
  }
}
class PureArrayUniform {
  constructor(ze, Gr, Yr) {
    (this.id = ze),
      (this.addr = Yr),
      (this.cache = []),
      (this.size = Gr.size),
      (this.setValue = getPureArraySetter(Gr.type));
  }
}
class StructuredUniform {
  constructor(ze) {
    (this.id = ze), (this.seq = []), (this.map = {});
  }
  setValue(ze, Gr, Yr) {
    const Kr = this.seq;
    for (let Zr = 0, Jr = Kr.length; Zr !== Jr; ++Zr) {
      const Qr = Kr[Zr];
      Qr.setValue(ze, Gr[Qr.id], Yr);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(Wr, ze) {
  Wr.seq.push(ze), (Wr.map[ze.id] = ze);
}
function parseUniform(Wr, ze, Gr) {
  const Yr = Wr.name,
    Kr = Yr.length;
  for (RePathPart.lastIndex = 0; ; ) {
    const Zr = RePathPart.exec(Yr),
      Jr = RePathPart.lastIndex;
    let Qr = Zr[1];
    const ei = Zr[2] === "]",
      ti = Zr[3];
    if ((ei && (Qr = Qr | 0), ti === void 0 || (ti === "[" && Jr + 2 === Kr))) {
      addUniform(
        Gr,
        ti === void 0
          ? new SingleUniform(Qr, Wr, ze)
          : new PureArrayUniform(Qr, Wr, ze)
      );
      break;
    } else {
      let ni = Gr.map[Qr];
      ni === void 0 && ((ni = new StructuredUniform(Qr)), addUniform(Gr, ni)),
        (Gr = ni);
    }
  }
}
class WebGLUniforms {
  constructor(ze, Gr) {
    (this.seq = []), (this.map = {});
    const Yr = ze.getProgramParameter(Gr, ze.ACTIVE_UNIFORMS);
    for (let Kr = 0; Kr < Yr; ++Kr) {
      const Zr = ze.getActiveUniform(Gr, Kr),
        Jr = ze.getUniformLocation(Gr, Zr.name);
      parseUniform(Zr, Jr, this);
    }
  }
  setValue(ze, Gr, Yr, Kr) {
    const Zr = this.map[Gr];
    Zr !== void 0 && Zr.setValue(ze, Yr, Kr);
  }
  setOptional(ze, Gr, Yr) {
    const Kr = Gr[Yr];
    Kr !== void 0 && this.setValue(ze, Yr, Kr);
  }
  static upload(ze, Gr, Yr, Kr) {
    for (let Zr = 0, Jr = Gr.length; Zr !== Jr; ++Zr) {
      const Qr = Gr[Zr],
        ei = Yr[Qr.id];
      ei.needsUpdate !== !1 && Qr.setValue(ze, ei.value, Kr);
    }
  }
  static seqWithValue(ze, Gr) {
    const Yr = [];
    for (let Kr = 0, Zr = ze.length; Kr !== Zr; ++Kr) {
      const Jr = ze[Kr];
      Jr.id in Gr && Yr.push(Jr);
    }
    return Yr;
  }
}
function WebGLShader(Wr, ze, Gr) {
  const Yr = Wr.createShader(ze);
  return Wr.shaderSource(Yr, Gr), Wr.compileShader(Yr), Yr;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(Wr, ze) {
  const Gr = Wr.split(`
`),
    Yr = [],
    Kr = Math.max(ze - 6, 0),
    Zr = Math.min(ze + 6, Gr.length);
  for (let Jr = Kr; Jr < Zr; Jr++) {
    const Qr = Jr + 1;
    Yr.push(`${Qr === ze ? ">" : " "} ${Qr}: ${Gr[Jr]}`);
  }
  return Yr.join(`
`);
}
function getEncodingComponents(Wr) {
  const ze = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
    Gr = ColorManagement.getPrimaries(Wr);
  let Yr;
  switch (
    (ze === Gr
      ? (Yr = "")
      : ze === P3Primaries && Gr === Rec709Primaries
      ? (Yr = "LinearDisplayP3ToLinearSRGB")
      : ze === Rec709Primaries &&
        Gr === P3Primaries &&
        (Yr = "LinearSRGBToLinearDisplayP3"),
    Wr)
  ) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [Yr, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [Yr, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", Wr),
        [Yr, "LinearTransferOETF"]
      );
  }
}
function getShaderErrors(Wr, ze, Gr) {
  const Yr = Wr.getShaderParameter(ze, Wr.COMPILE_STATUS),
    Kr = Wr.getShaderInfoLog(ze).trim();
  if (Yr && Kr === "") return "";
  const Zr = /ERROR: 0:(\d+)/.exec(Kr);
  if (Zr) {
    const Jr = parseInt(Zr[1]);
    return (
      Gr.toUpperCase() +
      `

` +
      Kr +
      `

` +
      handleSource(Wr.getShaderSource(ze), Jr)
    );
  } else return Kr;
}
function getTexelEncodingFunction(Wr, ze) {
  const Gr = getEncodingComponents(ze);
  return `vec4 ${Wr}( vec4 value ) { return ${Gr[0]}( ${Gr[1]}( value ) ); }`;
}
function getToneMappingFunction(Wr, ze) {
  let Gr;
  switch (ze) {
    case LinearToneMapping:
      Gr = "Linear";
      break;
    case ReinhardToneMapping:
      Gr = "Reinhard";
      break;
    case CineonToneMapping:
      Gr = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      Gr = "ACESFilmic";
      break;
    case CustomToneMapping:
      Gr = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", ze),
        (Gr = "Linear");
  }
  return (
    "vec3 " + Wr + "( vec3 color ) { return " + Gr + "ToneMapping( color ); }"
  );
}
function generateExtensions(Wr) {
  return [
    Wr.extensionDerivatives ||
    Wr.envMapCubeUVHeight ||
    Wr.bumpMap ||
    Wr.normalMapTangentSpace ||
    Wr.clearcoatNormalMap ||
    Wr.flatShading ||
    Wr.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (Wr.extensionFragDepth || Wr.logarithmicDepthBuffer) &&
    Wr.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    Wr.extensionDrawBuffers && Wr.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (Wr.extensionShaderTextureLOD || Wr.envMap || Wr.transmission) &&
    Wr.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(filterEmptyLine).join(`
`);
}
function generateDefines(Wr) {
  const ze = [];
  for (const Gr in Wr) {
    const Yr = Wr[Gr];
    Yr !== !1 && ze.push("#define " + Gr + " " + Yr);
  }
  return ze.join(`
`);
}
function fetchAttributeLocations(Wr, ze) {
  const Gr = {},
    Yr = Wr.getProgramParameter(ze, Wr.ACTIVE_ATTRIBUTES);
  for (let Kr = 0; Kr < Yr; Kr++) {
    const Zr = Wr.getActiveAttrib(ze, Kr),
      Jr = Zr.name;
    let Qr = 1;
    Zr.type === Wr.FLOAT_MAT2 && (Qr = 2),
      Zr.type === Wr.FLOAT_MAT3 && (Qr = 3),
      Zr.type === Wr.FLOAT_MAT4 && (Qr = 4),
      (Gr[Jr] = {
        type: Zr.type,
        location: Wr.getAttribLocation(ze, Jr),
        locationSize: Qr,
      });
  }
  return Gr;
}
function filterEmptyLine(Wr) {
  return Wr !== "";
}
function replaceLightNums(Wr, ze) {
  const Gr =
    ze.numSpotLightShadows +
    ze.numSpotLightMaps -
    ze.numSpotLightShadowsWithMaps;
  return Wr.replace(/NUM_DIR_LIGHTS/g, ze.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, ze.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, ze.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, Gr)
    .replace(/NUM_RECT_AREA_LIGHTS/g, ze.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, ze.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, ze.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, ze.numDirLightShadows)
    .replace(
      /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
      ze.numSpotLightShadowsWithMaps
    )
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, ze.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, ze.numPointLightShadows);
}
function replaceClippingPlaneNums(Wr, ze) {
  return Wr.replace(/NUM_CLIPPING_PLANES/g, ze.numClippingPlanes).replace(
    /UNION_CLIPPING_PLANES/g,
    ze.numClippingPlanes - ze.numClipIntersection
  );
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(Wr) {
  return Wr.replace(includePattern, includeReplacer);
}
const shaderChunkMap = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function includeReplacer(Wr, ze) {
  let Gr = ShaderChunk[ze];
  if (Gr === void 0) {
    const Yr = shaderChunkMap.get(ze);
    if (Yr !== void 0)
      (Gr = ShaderChunk[Yr]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          ze,
          Yr
        );
    else throw new Error("Can not resolve #include <" + ze + ">");
  }
  return resolveIncludes(Gr);
}
const unrollLoopPattern =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(Wr) {
  return Wr.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(Wr, ze, Gr, Yr) {
  let Kr = "";
  for (let Zr = parseInt(ze); Zr < parseInt(Gr); Zr++)
    Kr += Yr.replace(/\[\s*i\s*\]/g, "[ " + Zr + " ]").replace(
      /UNROLLED_LOOP_INDEX/g,
      Zr
    );
  return Kr;
}
function generatePrecision(Wr) {
  let ze =
    "precision " +
    Wr.precision +
    ` float;
precision ` +
    Wr.precision +
    " int;";
  return (
    Wr.precision === "highp"
      ? (ze += `
#define HIGH_PRECISION`)
      : Wr.precision === "mediump"
      ? (ze += `
#define MEDIUM_PRECISION`)
      : Wr.precision === "lowp" &&
        (ze += `
#define LOW_PRECISION`),
    ze
  );
}
function generateShadowMapTypeDefine(Wr) {
  let ze = "SHADOWMAP_TYPE_BASIC";
  return (
    Wr.shadowMapType === PCFShadowMap
      ? (ze = "SHADOWMAP_TYPE_PCF")
      : Wr.shadowMapType === PCFSoftShadowMap
      ? (ze = "SHADOWMAP_TYPE_PCF_SOFT")
      : Wr.shadowMapType === VSMShadowMap && (ze = "SHADOWMAP_TYPE_VSM"),
    ze
  );
}
function generateEnvMapTypeDefine(Wr) {
  let ze = "ENVMAP_TYPE_CUBE";
  if (Wr.envMap)
    switch (Wr.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        ze = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        ze = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return ze;
}
function generateEnvMapModeDefine(Wr) {
  let ze = "ENVMAP_MODE_REFLECTION";
  if (Wr.envMap)
    switch (Wr.envMapMode) {
      case CubeRefractionMapping:
        ze = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return ze;
}
function generateEnvMapBlendingDefine(Wr) {
  let ze = "ENVMAP_BLENDING_NONE";
  if (Wr.envMap)
    switch (Wr.combine) {
      case MultiplyOperation:
        ze = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        ze = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        ze = "ENVMAP_BLENDING_ADD";
        break;
    }
  return ze;
}
function generateCubeUVSize(Wr) {
  const ze = Wr.envMapCubeUVHeight;
  if (ze === null) return null;
  const Gr = Math.log2(ze) - 2,
    Yr = 1 / ze;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, Gr), 7 * 16)),
    texelHeight: Yr,
    maxMip: Gr,
  };
}
function WebGLProgram(Wr, ze, Gr, Yr) {
  const Kr = Wr.getContext(),
    Zr = Gr.defines;
  let Jr = Gr.vertexShader,
    Qr = Gr.fragmentShader;
  const ei = generateShadowMapTypeDefine(Gr),
    ti = generateEnvMapTypeDefine(Gr),
    ri = generateEnvMapModeDefine(Gr),
    ni = generateEnvMapBlendingDefine(Gr),
    ii = generateCubeUVSize(Gr),
    si = Gr.isWebGL2 ? "" : generateExtensions(Gr),
    li = generateDefines(Zr),
    oi = Kr.createProgram();
  let ui,
    ai,
    hi = Gr.glslVersion
      ? "#version " +
        Gr.glslVersion +
        `
`
      : "";
  Gr.isRawShaderMaterial
    ? ((ui = [
        "#define SHADER_TYPE " + Gr.shaderType,
        "#define SHADER_NAME " + Gr.shaderName,
        li,
      ].filter(filterEmptyLine).join(`
`)),
      ui.length > 0 &&
        (ui += `
`),
      (ai = [
        si,
        "#define SHADER_TYPE " + Gr.shaderType,
        "#define SHADER_NAME " + Gr.shaderName,
        li,
      ].filter(filterEmptyLine).join(`
`)),
      ai.length > 0 &&
        (ai += `
`))
    : ((ui = [
        generatePrecision(Gr),
        "#define SHADER_TYPE " + Gr.shaderType,
        "#define SHADER_NAME " + Gr.shaderName,
        li,
        Gr.instancing ? "#define USE_INSTANCING" : "",
        Gr.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        Gr.useFog && Gr.fog ? "#define USE_FOG" : "",
        Gr.useFog && Gr.fogExp2 ? "#define FOG_EXP2" : "",
        Gr.map ? "#define USE_MAP" : "",
        Gr.envMap ? "#define USE_ENVMAP" : "",
        Gr.envMap ? "#define " + ri : "",
        Gr.lightMap ? "#define USE_LIGHTMAP" : "",
        Gr.aoMap ? "#define USE_AOMAP" : "",
        Gr.bumpMap ? "#define USE_BUMPMAP" : "",
        Gr.normalMap ? "#define USE_NORMALMAP" : "",
        Gr.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        Gr.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        Gr.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        Gr.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        Gr.anisotropy ? "#define USE_ANISOTROPY" : "",
        Gr.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        Gr.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        Gr.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        Gr.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        Gr.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        Gr.iridescenceThicknessMap
          ? "#define USE_IRIDESCENCE_THICKNESSMAP"
          : "",
        Gr.specularMap ? "#define USE_SPECULARMAP" : "",
        Gr.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        Gr.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        Gr.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        Gr.metalnessMap ? "#define USE_METALNESSMAP" : "",
        Gr.alphaMap ? "#define USE_ALPHAMAP" : "",
        Gr.alphaHash ? "#define USE_ALPHAHASH" : "",
        Gr.transmission ? "#define USE_TRANSMISSION" : "",
        Gr.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        Gr.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        Gr.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        Gr.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        Gr.mapUv ? "#define MAP_UV " + Gr.mapUv : "",
        Gr.alphaMapUv ? "#define ALPHAMAP_UV " + Gr.alphaMapUv : "",
        Gr.lightMapUv ? "#define LIGHTMAP_UV " + Gr.lightMapUv : "",
        Gr.aoMapUv ? "#define AOMAP_UV " + Gr.aoMapUv : "",
        Gr.emissiveMapUv ? "#define EMISSIVEMAP_UV " + Gr.emissiveMapUv : "",
        Gr.bumpMapUv ? "#define BUMPMAP_UV " + Gr.bumpMapUv : "",
        Gr.normalMapUv ? "#define NORMALMAP_UV " + Gr.normalMapUv : "",
        Gr.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + Gr.displacementMapUv
          : "",
        Gr.metalnessMapUv ? "#define METALNESSMAP_UV " + Gr.metalnessMapUv : "",
        Gr.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + Gr.roughnessMapUv : "",
        Gr.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + Gr.anisotropyMapUv
          : "",
        Gr.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + Gr.clearcoatMapUv : "",
        Gr.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + Gr.clearcoatNormalMapUv
          : "",
        Gr.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + Gr.clearcoatRoughnessMapUv
          : "",
        Gr.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + Gr.iridescenceMapUv
          : "",
        Gr.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
            Gr.iridescenceThicknessMapUv
          : "",
        Gr.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + Gr.sheenColorMapUv
          : "",
        Gr.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + Gr.sheenRoughnessMapUv
          : "",
        Gr.specularMapUv ? "#define SPECULARMAP_UV " + Gr.specularMapUv : "",
        Gr.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + Gr.specularColorMapUv
          : "",
        Gr.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + Gr.specularIntensityMapUv
          : "",
        Gr.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + Gr.transmissionMapUv
          : "",
        Gr.thicknessMapUv ? "#define THICKNESSMAP_UV " + Gr.thicknessMapUv : "",
        Gr.vertexTangents && Gr.flatShading === !1 ? "#define USE_TANGENT" : "",
        Gr.vertexColors ? "#define USE_COLOR" : "",
        Gr.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        Gr.vertexUv1s ? "#define USE_UV1" : "",
        Gr.vertexUv2s ? "#define USE_UV2" : "",
        Gr.vertexUv3s ? "#define USE_UV3" : "",
        Gr.pointsUvs ? "#define USE_POINTS_UV" : "",
        Gr.flatShading ? "#define FLAT_SHADED" : "",
        Gr.skinning ? "#define USE_SKINNING" : "",
        Gr.morphTargets ? "#define USE_MORPHTARGETS" : "",
        Gr.morphNormals && Gr.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        Gr.morphColors && Gr.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        Gr.morphTargetsCount > 0 && Gr.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        Gr.morphTargetsCount > 0 && Gr.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + Gr.morphTextureStride
          : "",
        Gr.morphTargetsCount > 0 && Gr.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + Gr.morphTargetsCount
          : "",
        Gr.doubleSided ? "#define DOUBLE_SIDED" : "",
        Gr.flipSided ? "#define FLIP_SIDED" : "",
        Gr.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        Gr.shadowMapEnabled ? "#define " + ei : "",
        Gr.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        Gr.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        Gr.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        Gr.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        Gr.logarithmicDepthBuffer && Gr.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(filterEmptyLine).join(`
`)),
      (ai = [
        si,
        generatePrecision(Gr),
        "#define SHADER_TYPE " + Gr.shaderType,
        "#define SHADER_NAME " + Gr.shaderName,
        li,
        Gr.useFog && Gr.fog ? "#define USE_FOG" : "",
        Gr.useFog && Gr.fogExp2 ? "#define FOG_EXP2" : "",
        Gr.map ? "#define USE_MAP" : "",
        Gr.matcap ? "#define USE_MATCAP" : "",
        Gr.envMap ? "#define USE_ENVMAP" : "",
        Gr.envMap ? "#define " + ti : "",
        Gr.envMap ? "#define " + ri : "",
        Gr.envMap ? "#define " + ni : "",
        ii ? "#define CUBEUV_TEXEL_WIDTH " + ii.texelWidth : "",
        ii ? "#define CUBEUV_TEXEL_HEIGHT " + ii.texelHeight : "",
        ii ? "#define CUBEUV_MAX_MIP " + ii.maxMip + ".0" : "",
        Gr.lightMap ? "#define USE_LIGHTMAP" : "",
        Gr.aoMap ? "#define USE_AOMAP" : "",
        Gr.bumpMap ? "#define USE_BUMPMAP" : "",
        Gr.normalMap ? "#define USE_NORMALMAP" : "",
        Gr.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        Gr.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        Gr.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        Gr.anisotropy ? "#define USE_ANISOTROPY" : "",
        Gr.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        Gr.clearcoat ? "#define USE_CLEARCOAT" : "",
        Gr.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        Gr.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        Gr.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        Gr.iridescence ? "#define USE_IRIDESCENCE" : "",
        Gr.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        Gr.iridescenceThicknessMap
          ? "#define USE_IRIDESCENCE_THICKNESSMAP"
          : "",
        Gr.specularMap ? "#define USE_SPECULARMAP" : "",
        Gr.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        Gr.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        Gr.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        Gr.metalnessMap ? "#define USE_METALNESSMAP" : "",
        Gr.alphaMap ? "#define USE_ALPHAMAP" : "",
        Gr.alphaTest ? "#define USE_ALPHATEST" : "",
        Gr.alphaHash ? "#define USE_ALPHAHASH" : "",
        Gr.sheen ? "#define USE_SHEEN" : "",
        Gr.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        Gr.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        Gr.transmission ? "#define USE_TRANSMISSION" : "",
        Gr.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        Gr.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        Gr.vertexTangents && Gr.flatShading === !1 ? "#define USE_TANGENT" : "",
        Gr.vertexColors || Gr.instancingColor ? "#define USE_COLOR" : "",
        Gr.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        Gr.vertexUv1s ? "#define USE_UV1" : "",
        Gr.vertexUv2s ? "#define USE_UV2" : "",
        Gr.vertexUv3s ? "#define USE_UV3" : "",
        Gr.pointsUvs ? "#define USE_POINTS_UV" : "",
        Gr.gradientMap ? "#define USE_GRADIENTMAP" : "",
        Gr.flatShading ? "#define FLAT_SHADED" : "",
        Gr.doubleSided ? "#define DOUBLE_SIDED" : "",
        Gr.flipSided ? "#define FLIP_SIDED" : "",
        Gr.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        Gr.shadowMapEnabled ? "#define " + ei : "",
        Gr.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        Gr.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        Gr.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        Gr.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        Gr.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        Gr.logarithmicDepthBuffer && Gr.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        Gr.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        Gr.toneMapping !== NoToneMapping
          ? ShaderChunk.tonemapping_pars_fragment
          : "",
        Gr.toneMapping !== NoToneMapping
          ? getToneMappingFunction("toneMapping", Gr.toneMapping)
          : "",
        Gr.dithering ? "#define DITHERING" : "",
        Gr.opaque ? "#define OPAQUE" : "",
        ShaderChunk.colorspace_pars_fragment,
        getTexelEncodingFunction("linearToOutputTexel", Gr.outputColorSpace),
        Gr.useDepthPacking ? "#define DEPTH_PACKING " + Gr.depthPacking : "",
        `
`,
      ].filter(filterEmptyLine).join(`
`))),
    (Jr = resolveIncludes(Jr)),
    (Jr = replaceLightNums(Jr, Gr)),
    (Jr = replaceClippingPlaneNums(Jr, Gr)),
    (Qr = resolveIncludes(Qr)),
    (Qr = replaceLightNums(Qr, Gr)),
    (Qr = replaceClippingPlaneNums(Qr, Gr)),
    (Jr = unrollLoops(Jr)),
    (Qr = unrollLoops(Qr)),
    Gr.isWebGL2 &&
      Gr.isRawShaderMaterial !== !0 &&
      ((hi = `#version 300 es
`),
      (ui =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        ui),
      (ai =
        [
          "precision mediump sampler2DArray;",
          "#define varying in",
          Gr.glslVersion === GLSL3
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          Gr.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        ai));
  const ci = hi + ui + Jr,
    fi = hi + ai + Qr,
    di = WebGLShader(Kr, Kr.VERTEX_SHADER, ci),
    pi = WebGLShader(Kr, Kr.FRAGMENT_SHADER, fi);
  Kr.attachShader(oi, di),
    Kr.attachShader(oi, pi),
    Gr.index0AttributeName !== void 0
      ? Kr.bindAttribLocation(oi, 0, Gr.index0AttributeName)
      : Gr.morphTargets === !0 && Kr.bindAttribLocation(oi, 0, "position"),
    Kr.linkProgram(oi);
  function mi(Pi) {
    if (Wr.debug.checkShaderErrors) {
      const Ai = Kr.getProgramInfoLog(oi).trim(),
        Ri = Kr.getShaderInfoLog(di).trim(),
        wi = Kr.getShaderInfoLog(pi).trim();
      let Ci = !0,
        bi = !0;
      if (Kr.getProgramParameter(oi, Kr.LINK_STATUS) === !1)
        if (((Ci = !1), typeof Wr.debug.onShaderError == "function"))
          Wr.debug.onShaderError(Kr, oi, di, pi);
        else {
          const Mi = getShaderErrors(Kr, di, "vertex"),
            gi = getShaderErrors(Kr, pi, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              Kr.getError() +
              " - VALIDATE_STATUS " +
              Kr.getProgramParameter(oi, Kr.VALIDATE_STATUS) +
              `

Program Info Log: ` +
              Ai +
              `
` +
              Mi +
              `
` +
              gi
          );
        }
      else
        Ai !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", Ai)
          : (Ri === "" || wi === "") && (bi = !1);
      bi &&
        (Pi.diagnostics = {
          runnable: Ci,
          programLog: Ai,
          vertexShader: {
            log: Ri,
            prefix: ui,
          },
          fragmentShader: {
            log: wi,
            prefix: ai,
          },
        });
    }
    Kr.deleteShader(di),
      Kr.deleteShader(pi),
      (Si = new WebGLUniforms(Kr, oi)),
      (yi = fetchAttributeLocations(Kr, oi));
  }
  let Si;
  this.getUniforms = function () {
    return Si === void 0 && mi(this), Si;
  };
  let yi;
  this.getAttributes = function () {
    return yi === void 0 && mi(this), yi;
  };
  let Ei = Gr.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return (
        Ei === !1 && (Ei = Kr.getProgramParameter(oi, COMPLETION_STATUS_KHR)),
        Ei
      );
    }),
    (this.destroy = function () {
      Yr.releaseStatesOfProgram(this),
        Kr.deleteProgram(oi),
        (this.program = void 0);
    }),
    (this.type = Gr.shaderType),
    (this.name = Gr.shaderName),
    (this.id = programIdCount++),
    (this.cacheKey = ze),
    (this.usedTimes = 1),
    (this.program = oi),
    (this.vertexShader = di),
    (this.fragmentShader = pi),
    this
  );
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(ze) {
    const Gr = ze.vertexShader,
      Yr = ze.fragmentShader,
      Kr = this._getShaderStage(Gr),
      Zr = this._getShaderStage(Yr),
      Jr = this._getShaderCacheForMaterial(ze);
    return (
      Jr.has(Kr) === !1 && (Jr.add(Kr), Kr.usedTimes++),
      Jr.has(Zr) === !1 && (Jr.add(Zr), Zr.usedTimes++),
      this
    );
  }
  remove(ze) {
    const Gr = this.materialCache.get(ze);
    for (const Yr of Gr)
      Yr.usedTimes--, Yr.usedTimes === 0 && this.shaderCache.delete(Yr.code);
    return this.materialCache.delete(ze), this;
  }
  getVertexShaderID(ze) {
    return this._getShaderStage(ze.vertexShader).id;
  }
  getFragmentShaderID(ze) {
    return this._getShaderStage(ze.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(ze) {
    const Gr = this.materialCache;
    let Yr = Gr.get(ze);
    return Yr === void 0 && ((Yr = new Set()), Gr.set(ze, Yr)), Yr;
  }
  _getShaderStage(ze) {
    const Gr = this.shaderCache;
    let Yr = Gr.get(ze);
    return (
      Yr === void 0 && ((Yr = new WebGLShaderStage(ze)), Gr.set(ze, Yr)), Yr
    );
  }
}
class WebGLShaderStage {
  constructor(ze) {
    (this.id = _id$1++), (this.code = ze), (this.usedTimes = 0);
  }
}
function WebGLPrograms(Wr, ze, Gr, Yr, Kr, Zr, Jr) {
  const Qr = new Layers(),
    ei = new WebGLShaderCache(),
    ti = [],
    ri = Kr.isWebGL2,
    ni = Kr.logarithmicDepthBuffer,
    ii = Kr.vertexTextures;
  let si = Kr.precision;
  const li = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function oi(yi) {
    return yi === 0 ? "uv" : `uv${yi}`;
  }
  function ui(yi, Ei, Pi, Ai, Ri) {
    const wi = Ai.fog,
      Ci = Ri.geometry,
      bi = yi.isMeshStandardMaterial ? Ai.environment : null,
      Mi = (yi.isMeshStandardMaterial ? Gr : ze).get(yi.envMap || bi),
      gi =
        Mi && Mi.mapping === CubeUVReflectionMapping ? Mi.image.height : null,
      xi = li[yi.type];
    yi.precision !== null &&
      ((si = Kr.getMaxPrecision(yi.precision)),
      si !== yi.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          yi.precision,
          "not supported, using",
          si,
          "instead."
        ));
    const Ti =
        Ci.morphAttributes.position ||
        Ci.morphAttributes.normal ||
        Ci.morphAttributes.color,
      vi = Ti !== void 0 ? Ti.length : 0;
    let Ii = 0;
    Ci.morphAttributes.position !== void 0 && (Ii = 1),
      Ci.morphAttributes.normal !== void 0 && (Ii = 2),
      Ci.morphAttributes.color !== void 0 && (Ii = 3);
    let Oi, ki, Bi, Xi;
    if (xi) {
      const gn = ShaderLib[xi];
      (Oi = gn.vertexShader), (ki = gn.fragmentShader);
    } else
      (Oi = yi.vertexShader),
        (ki = yi.fragmentShader),
        ei.update(yi),
        (Bi = ei.getVertexShaderID(yi)),
        (Xi = ei.getFragmentShaderID(yi));
    const an = Wr.getRenderTarget(),
      Qi = Ri.isInstancedMesh === !0,
      ln = !!yi.map,
      yn = !!yi.matcap,
      un = !!Mi,
      Vi = !!yi.aoMap,
      rn = !!yi.lightMap,
      qi = !!yi.bumpMap,
      pn = !!yi.normalMap,
      vn = !!yi.displacementMap,
      zi = !!yi.emissiveMap,
      mn = !!yi.metalnessMap,
      Sn = !!yi.roughnessMap,
      Dn = yi.anisotropy > 0,
      Cn = yi.clearcoat > 0,
      $n = yi.iridescence > 0,
      Di = yi.sheen > 0,
      Li = yi.transmission > 0,
      Gi = Dn && !!yi.anisotropyMap,
      Yi = Cn && !!yi.clearcoatMap,
      Ki = Cn && !!yi.clearcoatNormalMap,
      Zi = Cn && !!yi.clearcoatRoughnessMap,
      _n = $n && !!yi.iridescenceMap,
      tn = $n && !!yi.iridescenceThicknessMap,
      fn = Di && !!yi.sheenColorMap,
      En = Di && !!yi.sheenRoughnessMap,
      Vn = !!yi.specularMap,
      nn = !!yi.specularColorMap,
      Hn = !!yi.specularIntensityMap,
      Ln = Li && !!yi.transmissionMap,
      An = Li && !!yi.thicknessMap,
      Mn = !!yi.gradientMap,
      Ji = !!yi.alphaMap,
      Bn = yi.alphaTest > 0,
      Ni = !!yi.alphaHash,
      cn = !!yi.extensions,
      en = !!Ci.attributes.uv1,
      ji = !!Ci.attributes.uv2,
      sn = !!Ci.attributes.uv3;
    let wn = NoToneMapping;
    return (
      yi.toneMapped &&
        (an === null || an.isXRRenderTarget === !0) &&
        (wn = Wr.toneMapping),
      {
        isWebGL2: ri,
        shaderID: xi,
        shaderType: yi.type,
        shaderName: yi.name,
        vertexShader: Oi,
        fragmentShader: ki,
        defines: yi.defines,
        customVertexShaderID: Bi,
        customFragmentShaderID: Xi,
        isRawShaderMaterial: yi.isRawShaderMaterial === !0,
        glslVersion: yi.glslVersion,
        precision: si,
        instancing: Qi,
        instancingColor: Qi && Ri.instanceColor !== null,
        supportsVertexTextures: ii,
        outputColorSpace:
          an === null
            ? Wr.outputColorSpace
            : an.isXRRenderTarget === !0
            ? an.texture.colorSpace
            : LinearSRGBColorSpace,
        map: ln,
        matcap: yn,
        envMap: un,
        envMapMode: un && Mi.mapping,
        envMapCubeUVHeight: gi,
        aoMap: Vi,
        lightMap: rn,
        bumpMap: qi,
        normalMap: pn,
        displacementMap: ii && vn,
        emissiveMap: zi,
        normalMapObjectSpace: pn && yi.normalMapType === ObjectSpaceNormalMap,
        normalMapTangentSpace: pn && yi.normalMapType === TangentSpaceNormalMap,
        metalnessMap: mn,
        roughnessMap: Sn,
        anisotropy: Dn,
        anisotropyMap: Gi,
        clearcoat: Cn,
        clearcoatMap: Yi,
        clearcoatNormalMap: Ki,
        clearcoatRoughnessMap: Zi,
        iridescence: $n,
        iridescenceMap: _n,
        iridescenceThicknessMap: tn,
        sheen: Di,
        sheenColorMap: fn,
        sheenRoughnessMap: En,
        specularMap: Vn,
        specularColorMap: nn,
        specularIntensityMap: Hn,
        transmission: Li,
        transmissionMap: Ln,
        thicknessMap: An,
        gradientMap: Mn,
        opaque: yi.transparent === !1 && yi.blending === NormalBlending,
        alphaMap: Ji,
        alphaTest: Bn,
        alphaHash: Ni,
        combine: yi.combine,
        mapUv: ln && oi(yi.map.channel),
        aoMapUv: Vi && oi(yi.aoMap.channel),
        lightMapUv: rn && oi(yi.lightMap.channel),
        bumpMapUv: qi && oi(yi.bumpMap.channel),
        normalMapUv: pn && oi(yi.normalMap.channel),
        displacementMapUv: vn && oi(yi.displacementMap.channel),
        emissiveMapUv: zi && oi(yi.emissiveMap.channel),
        metalnessMapUv: mn && oi(yi.metalnessMap.channel),
        roughnessMapUv: Sn && oi(yi.roughnessMap.channel),
        anisotropyMapUv: Gi && oi(yi.anisotropyMap.channel),
        clearcoatMapUv: Yi && oi(yi.clearcoatMap.channel),
        clearcoatNormalMapUv: Ki && oi(yi.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: Zi && oi(yi.clearcoatRoughnessMap.channel),
        iridescenceMapUv: _n && oi(yi.iridescenceMap.channel),
        iridescenceThicknessMapUv: tn && oi(yi.iridescenceThicknessMap.channel),
        sheenColorMapUv: fn && oi(yi.sheenColorMap.channel),
        sheenRoughnessMapUv: En && oi(yi.sheenRoughnessMap.channel),
        specularMapUv: Vn && oi(yi.specularMap.channel),
        specularColorMapUv: nn && oi(yi.specularColorMap.channel),
        specularIntensityMapUv: Hn && oi(yi.specularIntensityMap.channel),
        transmissionMapUv: Ln && oi(yi.transmissionMap.channel),
        thicknessMapUv: An && oi(yi.thicknessMap.channel),
        alphaMapUv: Ji && oi(yi.alphaMap.channel),
        vertexTangents: !!Ci.attributes.tangent && (pn || Dn),
        vertexColors: yi.vertexColors,
        vertexAlphas:
          yi.vertexColors === !0 &&
          !!Ci.attributes.color &&
          Ci.attributes.color.itemSize === 4,
        vertexUv1s: en,
        vertexUv2s: ji,
        vertexUv3s: sn,
        pointsUvs: Ri.isPoints === !0 && !!Ci.attributes.uv && (ln || Ji),
        fog: !!wi,
        useFog: yi.fog === !0,
        fogExp2: wi && wi.isFogExp2,
        flatShading: yi.flatShading === !0,
        sizeAttenuation: yi.sizeAttenuation === !0,
        logarithmicDepthBuffer: ni,
        skinning: Ri.isSkinnedMesh === !0,
        morphTargets: Ci.morphAttributes.position !== void 0,
        morphNormals: Ci.morphAttributes.normal !== void 0,
        morphColors: Ci.morphAttributes.color !== void 0,
        morphTargetsCount: vi,
        morphTextureStride: Ii,
        numDirLights: Ei.directional.length,
        numPointLights: Ei.point.length,
        numSpotLights: Ei.spot.length,
        numSpotLightMaps: Ei.spotLightMap.length,
        numRectAreaLights: Ei.rectArea.length,
        numHemiLights: Ei.hemi.length,
        numDirLightShadows: Ei.directionalShadowMap.length,
        numPointLightShadows: Ei.pointShadowMap.length,
        numSpotLightShadows: Ei.spotShadowMap.length,
        numSpotLightShadowsWithMaps: Ei.numSpotLightShadowsWithMaps,
        numLightProbes: Ei.numLightProbes,
        numClippingPlanes: Jr.numPlanes,
        numClipIntersection: Jr.numIntersection,
        dithering: yi.dithering,
        shadowMapEnabled: Wr.shadowMap.enabled && Pi.length > 0,
        shadowMapType: Wr.shadowMap.type,
        toneMapping: wn,
        useLegacyLights: Wr._useLegacyLights,
        decodeVideoTexture:
          ln &&
          yi.map.isVideoTexture === !0 &&
          ColorManagement.getTransfer(yi.map.colorSpace) === SRGBTransfer,
        premultipliedAlpha: yi.premultipliedAlpha,
        doubleSided: yi.side === DoubleSide,
        flipSided: yi.side === BackSide,
        useDepthPacking: yi.depthPacking >= 0,
        depthPacking: yi.depthPacking || 0,
        index0AttributeName: yi.index0AttributeName,
        extensionDerivatives: cn && yi.extensions.derivatives === !0,
        extensionFragDepth: cn && yi.extensions.fragDepth === !0,
        extensionDrawBuffers: cn && yi.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: cn && yi.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: ri || Yr.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: ri || Yr.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod:
          ri || Yr.has("EXT_shader_texture_lod"),
        rendererExtensionParallelShaderCompile: Yr.has(
          "KHR_parallel_shader_compile"
        ),
        customProgramCacheKey: yi.customProgramCacheKey(),
      }
    );
  }
  function ai(yi) {
    const Ei = [];
    if (
      (yi.shaderID
        ? Ei.push(yi.shaderID)
        : (Ei.push(yi.customVertexShaderID),
          Ei.push(yi.customFragmentShaderID)),
      yi.defines !== void 0)
    )
      for (const Pi in yi.defines) Ei.push(Pi), Ei.push(yi.defines[Pi]);
    return (
      yi.isRawShaderMaterial === !1 &&
        (hi(Ei, yi), ci(Ei, yi), Ei.push(Wr.outputColorSpace)),
      Ei.push(yi.customProgramCacheKey),
      Ei.join()
    );
  }
  function hi(yi, Ei) {
    yi.push(Ei.precision),
      yi.push(Ei.outputColorSpace),
      yi.push(Ei.envMapMode),
      yi.push(Ei.envMapCubeUVHeight),
      yi.push(Ei.mapUv),
      yi.push(Ei.alphaMapUv),
      yi.push(Ei.lightMapUv),
      yi.push(Ei.aoMapUv),
      yi.push(Ei.bumpMapUv),
      yi.push(Ei.normalMapUv),
      yi.push(Ei.displacementMapUv),
      yi.push(Ei.emissiveMapUv),
      yi.push(Ei.metalnessMapUv),
      yi.push(Ei.roughnessMapUv),
      yi.push(Ei.anisotropyMapUv),
      yi.push(Ei.clearcoatMapUv),
      yi.push(Ei.clearcoatNormalMapUv),
      yi.push(Ei.clearcoatRoughnessMapUv),
      yi.push(Ei.iridescenceMapUv),
      yi.push(Ei.iridescenceThicknessMapUv),
      yi.push(Ei.sheenColorMapUv),
      yi.push(Ei.sheenRoughnessMapUv),
      yi.push(Ei.specularMapUv),
      yi.push(Ei.specularColorMapUv),
      yi.push(Ei.specularIntensityMapUv),
      yi.push(Ei.transmissionMapUv),
      yi.push(Ei.thicknessMapUv),
      yi.push(Ei.combine),
      yi.push(Ei.fogExp2),
      yi.push(Ei.sizeAttenuation),
      yi.push(Ei.morphTargetsCount),
      yi.push(Ei.morphAttributeCount),
      yi.push(Ei.numDirLights),
      yi.push(Ei.numPointLights),
      yi.push(Ei.numSpotLights),
      yi.push(Ei.numSpotLightMaps),
      yi.push(Ei.numHemiLights),
      yi.push(Ei.numRectAreaLights),
      yi.push(Ei.numDirLightShadows),
      yi.push(Ei.numPointLightShadows),
      yi.push(Ei.numSpotLightShadows),
      yi.push(Ei.numSpotLightShadowsWithMaps),
      yi.push(Ei.numLightProbes),
      yi.push(Ei.shadowMapType),
      yi.push(Ei.toneMapping),
      yi.push(Ei.numClippingPlanes),
      yi.push(Ei.numClipIntersection),
      yi.push(Ei.depthPacking);
  }
  function ci(yi, Ei) {
    Qr.disableAll(),
      Ei.isWebGL2 && Qr.enable(0),
      Ei.supportsVertexTextures && Qr.enable(1),
      Ei.instancing && Qr.enable(2),
      Ei.instancingColor && Qr.enable(3),
      Ei.matcap && Qr.enable(4),
      Ei.envMap && Qr.enable(5),
      Ei.normalMapObjectSpace && Qr.enable(6),
      Ei.normalMapTangentSpace && Qr.enable(7),
      Ei.clearcoat && Qr.enable(8),
      Ei.iridescence && Qr.enable(9),
      Ei.alphaTest && Qr.enable(10),
      Ei.vertexColors && Qr.enable(11),
      Ei.vertexAlphas && Qr.enable(12),
      Ei.vertexUv1s && Qr.enable(13),
      Ei.vertexUv2s && Qr.enable(14),
      Ei.vertexUv3s && Qr.enable(15),
      Ei.vertexTangents && Qr.enable(16),
      Ei.anisotropy && Qr.enable(17),
      Ei.alphaHash && Qr.enable(18),
      yi.push(Qr.mask),
      Qr.disableAll(),
      Ei.fog && Qr.enable(0),
      Ei.useFog && Qr.enable(1),
      Ei.flatShading && Qr.enable(2),
      Ei.logarithmicDepthBuffer && Qr.enable(3),
      Ei.skinning && Qr.enable(4),
      Ei.morphTargets && Qr.enable(5),
      Ei.morphNormals && Qr.enable(6),
      Ei.morphColors && Qr.enable(7),
      Ei.premultipliedAlpha && Qr.enable(8),
      Ei.shadowMapEnabled && Qr.enable(9),
      Ei.useLegacyLights && Qr.enable(10),
      Ei.doubleSided && Qr.enable(11),
      Ei.flipSided && Qr.enable(12),
      Ei.useDepthPacking && Qr.enable(13),
      Ei.dithering && Qr.enable(14),
      Ei.transmission && Qr.enable(15),
      Ei.sheen && Qr.enable(16),
      Ei.opaque && Qr.enable(17),
      Ei.pointsUvs && Qr.enable(18),
      Ei.decodeVideoTexture && Qr.enable(19),
      yi.push(Qr.mask);
  }
  function fi(yi) {
    const Ei = li[yi.type];
    let Pi;
    if (Ei) {
      const Ai = ShaderLib[Ei];
      Pi = UniformsUtils.clone(Ai.uniforms);
    } else Pi = yi.uniforms;
    return Pi;
  }
  function di(yi, Ei) {
    let Pi;
    for (let Ai = 0, Ri = ti.length; Ai < Ri; Ai++) {
      const wi = ti[Ai];
      if (wi.cacheKey === Ei) {
        (Pi = wi), ++Pi.usedTimes;
        break;
      }
    }
    return (
      Pi === void 0 && ((Pi = new WebGLProgram(Wr, Ei, yi, Zr)), ti.push(Pi)),
      Pi
    );
  }
  function pi(yi) {
    if (--yi.usedTimes === 0) {
      const Ei = ti.indexOf(yi);
      (ti[Ei] = ti[ti.length - 1]), ti.pop(), yi.destroy();
    }
  }
  function mi(yi) {
    ei.remove(yi);
  }
  function Si() {
    ei.dispose();
  }
  return {
    getParameters: ui,
    getProgramCacheKey: ai,
    getUniforms: fi,
    acquireProgram: di,
    releaseProgram: pi,
    releaseShaderCache: mi,
    programs: ti,
    dispose: Si,
  };
}
function WebGLProperties() {
  let Wr = new WeakMap();
  function ze(Zr) {
    let Jr = Wr.get(Zr);
    return Jr === void 0 && ((Jr = {}), Wr.set(Zr, Jr)), Jr;
  }
  function Gr(Zr) {
    Wr.delete(Zr);
  }
  function Yr(Zr, Jr, Qr) {
    Wr.get(Zr)[Jr] = Qr;
  }
  function Kr() {
    Wr = new WeakMap();
  }
  return {
    get: ze,
    remove: Gr,
    update: Yr,
    dispose: Kr,
  };
}
function painterSortStable(Wr, ze) {
  return Wr.groupOrder !== ze.groupOrder
    ? Wr.groupOrder - ze.groupOrder
    : Wr.renderOrder !== ze.renderOrder
    ? Wr.renderOrder - ze.renderOrder
    : Wr.material.id !== ze.material.id
    ? Wr.material.id - ze.material.id
    : Wr.z !== ze.z
    ? Wr.z - ze.z
    : Wr.id - ze.id;
}
function reversePainterSortStable(Wr, ze) {
  return Wr.groupOrder !== ze.groupOrder
    ? Wr.groupOrder - ze.groupOrder
    : Wr.renderOrder !== ze.renderOrder
    ? Wr.renderOrder - ze.renderOrder
    : Wr.z !== ze.z
    ? ze.z - Wr.z
    : Wr.id - ze.id;
}
function WebGLRenderList() {
  const Wr = [];
  let ze = 0;
  const Gr = [],
    Yr = [],
    Kr = [];
  function Zr() {
    (ze = 0), (Gr.length = 0), (Yr.length = 0), (Kr.length = 0);
  }
  function Jr(ni, ii, si, li, oi, ui) {
    let ai = Wr[ze];
    return (
      ai === void 0
        ? ((ai = {
            id: ni.id,
            object: ni,
            geometry: ii,
            material: si,
            groupOrder: li,
            renderOrder: ni.renderOrder,
            z: oi,
            group: ui,
          }),
          (Wr[ze] = ai))
        : ((ai.id = ni.id),
          (ai.object = ni),
          (ai.geometry = ii),
          (ai.material = si),
          (ai.groupOrder = li),
          (ai.renderOrder = ni.renderOrder),
          (ai.z = oi),
          (ai.group = ui)),
      ze++,
      ai
    );
  }
  function Qr(ni, ii, si, li, oi, ui) {
    const ai = Jr(ni, ii, si, li, oi, ui);
    si.transmission > 0
      ? Yr.push(ai)
      : si.transparent === !0
      ? Kr.push(ai)
      : Gr.push(ai);
  }
  function ei(ni, ii, si, li, oi, ui) {
    const ai = Jr(ni, ii, si, li, oi, ui);
    si.transmission > 0
      ? Yr.unshift(ai)
      : si.transparent === !0
      ? Kr.unshift(ai)
      : Gr.unshift(ai);
  }
  function ti(ni, ii) {
    Gr.length > 1 && Gr.sort(ni || painterSortStable),
      Yr.length > 1 && Yr.sort(ii || reversePainterSortStable),
      Kr.length > 1 && Kr.sort(ii || reversePainterSortStable);
  }
  function ri() {
    for (let ni = ze, ii = Wr.length; ni < ii; ni++) {
      const si = Wr[ni];
      if (si.id === null) break;
      (si.id = null),
        (si.object = null),
        (si.geometry = null),
        (si.material = null),
        (si.group = null);
    }
  }
  return {
    opaque: Gr,
    transmissive: Yr,
    transparent: Kr,
    init: Zr,
    push: Qr,
    unshift: ei,
    finish: ri,
    sort: ti,
  };
}
function WebGLRenderLists() {
  let Wr = new WeakMap();
  function ze(Yr, Kr) {
    const Zr = Wr.get(Yr);
    let Jr;
    return (
      Zr === void 0
        ? ((Jr = new WebGLRenderList()), Wr.set(Yr, [Jr]))
        : Kr >= Zr.length
        ? ((Jr = new WebGLRenderList()), Zr.push(Jr))
        : (Jr = Zr[Kr]),
      Jr
    );
  }
  function Gr() {
    Wr = new WeakMap();
  }
  return {
    get: ze,
    dispose: Gr,
  };
}
function UniformsCache() {
  const Wr = {};
  return {
    get: function (ze) {
      if (Wr[ze.id] !== void 0) return Wr[ze.id];
      let Gr;
      switch (ze.type) {
        case "DirectionalLight":
          Gr = {
            direction: new Vector3(),
            color: new Color(),
          };
          break;
        case "SpotLight":
          Gr = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          Gr = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
          };
          break;
        case "HemisphereLight":
          Gr = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color(),
          };
          break;
        case "RectAreaLight":
          Gr = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3(),
          };
          break;
      }
      return (Wr[ze.id] = Gr), Gr;
    },
  };
}
function ShadowUniformsCache() {
  const Wr = {};
  return {
    get: function (ze) {
      if (Wr[ze.id] !== void 0) return Wr[ze.id];
      let Gr;
      switch (ze.type) {
        case "DirectionalLight":
          Gr = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "SpotLight":
          Gr = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "PointLight":
          Gr = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (Wr[ze.id] = Gr), Gr;
    },
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(Wr, ze) {
  return (
    (ze.castShadow ? 2 : 0) -
    (Wr.castShadow ? 2 : 0) +
    (ze.map ? 1 : 0) -
    (Wr.map ? 1 : 0)
  );
}
function WebGLLights(Wr, ze) {
  const Gr = new UniformsCache(),
    Yr = ShadowUniformsCache(),
    Kr = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let ri = 0; ri < 9; ri++) Kr.probe.push(new Vector3());
  const Zr = new Vector3(),
    Jr = new Matrix4(),
    Qr = new Matrix4();
  function ei(ri, ni) {
    let ii = 0,
      si = 0,
      li = 0;
    for (let Ai = 0; Ai < 9; Ai++) Kr.probe[Ai].set(0, 0, 0);
    let oi = 0,
      ui = 0,
      ai = 0,
      hi = 0,
      ci = 0,
      fi = 0,
      di = 0,
      pi = 0,
      mi = 0,
      Si = 0,
      yi = 0;
    ri.sort(shadowCastingAndTexturingLightsFirst);
    const Ei = ni === !0 ? Math.PI : 1;
    for (let Ai = 0, Ri = ri.length; Ai < Ri; Ai++) {
      const wi = ri[Ai],
        Ci = wi.color,
        bi = wi.intensity,
        Mi = wi.distance,
        gi = wi.shadow && wi.shadow.map ? wi.shadow.map.texture : null;
      if (wi.isAmbientLight)
        (ii += Ci.r * bi * Ei), (si += Ci.g * bi * Ei), (li += Ci.b * bi * Ei);
      else if (wi.isLightProbe) {
        for (let xi = 0; xi < 9; xi++)
          Kr.probe[xi].addScaledVector(wi.sh.coefficients[xi], bi);
        yi++;
      } else if (wi.isDirectionalLight) {
        const xi = Gr.get(wi);
        if (
          (xi.color.copy(wi.color).multiplyScalar(wi.intensity * Ei),
          wi.castShadow)
        ) {
          const Ti = wi.shadow,
            vi = Yr.get(wi);
          (vi.shadowBias = Ti.bias),
            (vi.shadowNormalBias = Ti.normalBias),
            (vi.shadowRadius = Ti.radius),
            (vi.shadowMapSize = Ti.mapSize),
            (Kr.directionalShadow[oi] = vi),
            (Kr.directionalShadowMap[oi] = gi),
            (Kr.directionalShadowMatrix[oi] = wi.shadow.matrix),
            fi++;
        }
        (Kr.directional[oi] = xi), oi++;
      } else if (wi.isSpotLight) {
        const xi = Gr.get(wi);
        xi.position.setFromMatrixPosition(wi.matrixWorld),
          xi.color.copy(Ci).multiplyScalar(bi * Ei),
          (xi.distance = Mi),
          (xi.coneCos = Math.cos(wi.angle)),
          (xi.penumbraCos = Math.cos(wi.angle * (1 - wi.penumbra))),
          (xi.decay = wi.decay),
          (Kr.spot[ai] = xi);
        const Ti = wi.shadow;
        if (
          (wi.map &&
            ((Kr.spotLightMap[mi] = wi.map),
            mi++,
            Ti.updateMatrices(wi),
            wi.castShadow && Si++),
          (Kr.spotLightMatrix[ai] = Ti.matrix),
          wi.castShadow)
        ) {
          const vi = Yr.get(wi);
          (vi.shadowBias = Ti.bias),
            (vi.shadowNormalBias = Ti.normalBias),
            (vi.shadowRadius = Ti.radius),
            (vi.shadowMapSize = Ti.mapSize),
            (Kr.spotShadow[ai] = vi),
            (Kr.spotShadowMap[ai] = gi),
            pi++;
        }
        ai++;
      } else if (wi.isRectAreaLight) {
        const xi = Gr.get(wi);
        xi.color.copy(Ci).multiplyScalar(bi),
          xi.halfWidth.set(wi.width * 0.5, 0, 0),
          xi.halfHeight.set(0, wi.height * 0.5, 0),
          (Kr.rectArea[hi] = xi),
          hi++;
      } else if (wi.isPointLight) {
        const xi = Gr.get(wi);
        if (
          (xi.color.copy(wi.color).multiplyScalar(wi.intensity * Ei),
          (xi.distance = wi.distance),
          (xi.decay = wi.decay),
          wi.castShadow)
        ) {
          const Ti = wi.shadow,
            vi = Yr.get(wi);
          (vi.shadowBias = Ti.bias),
            (vi.shadowNormalBias = Ti.normalBias),
            (vi.shadowRadius = Ti.radius),
            (vi.shadowMapSize = Ti.mapSize),
            (vi.shadowCameraNear = Ti.camera.near),
            (vi.shadowCameraFar = Ti.camera.far),
            (Kr.pointShadow[ui] = vi),
            (Kr.pointShadowMap[ui] = gi),
            (Kr.pointShadowMatrix[ui] = wi.shadow.matrix),
            di++;
        }
        (Kr.point[ui] = xi), ui++;
      } else if (wi.isHemisphereLight) {
        const xi = Gr.get(wi);
        xi.skyColor.copy(wi.color).multiplyScalar(bi * Ei),
          xi.groundColor.copy(wi.groundColor).multiplyScalar(bi * Ei),
          (Kr.hemi[ci] = xi),
          ci++;
      }
    }
    hi > 0 &&
      (ze.isWebGL2 || Wr.has("OES_texture_float_linear") === !0
        ? ((Kr.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1),
          (Kr.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2))
        : Wr.has("OES_texture_half_float_linear") === !0
        ? ((Kr.rectAreaLTC1 = UniformsLib.LTC_HALF_1),
          (Kr.rectAreaLTC2 = UniformsLib.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (Kr.ambient[0] = ii),
      (Kr.ambient[1] = si),
      (Kr.ambient[2] = li);
    const Pi = Kr.hash;
    (Pi.directionalLength !== oi ||
      Pi.pointLength !== ui ||
      Pi.spotLength !== ai ||
      Pi.rectAreaLength !== hi ||
      Pi.hemiLength !== ci ||
      Pi.numDirectionalShadows !== fi ||
      Pi.numPointShadows !== di ||
      Pi.numSpotShadows !== pi ||
      Pi.numSpotMaps !== mi ||
      Pi.numLightProbes !== yi) &&
      ((Kr.directional.length = oi),
      (Kr.spot.length = ai),
      (Kr.rectArea.length = hi),
      (Kr.point.length = ui),
      (Kr.hemi.length = ci),
      (Kr.directionalShadow.length = fi),
      (Kr.directionalShadowMap.length = fi),
      (Kr.pointShadow.length = di),
      (Kr.pointShadowMap.length = di),
      (Kr.spotShadow.length = pi),
      (Kr.spotShadowMap.length = pi),
      (Kr.directionalShadowMatrix.length = fi),
      (Kr.pointShadowMatrix.length = di),
      (Kr.spotLightMatrix.length = pi + mi - Si),
      (Kr.spotLightMap.length = mi),
      (Kr.numSpotLightShadowsWithMaps = Si),
      (Kr.numLightProbes = yi),
      (Pi.directionalLength = oi),
      (Pi.pointLength = ui),
      (Pi.spotLength = ai),
      (Pi.rectAreaLength = hi),
      (Pi.hemiLength = ci),
      (Pi.numDirectionalShadows = fi),
      (Pi.numPointShadows = di),
      (Pi.numSpotShadows = pi),
      (Pi.numSpotMaps = mi),
      (Pi.numLightProbes = yi),
      (Kr.version = nextVersion++));
  }
  function ti(ri, ni) {
    let ii = 0,
      si = 0,
      li = 0,
      oi = 0,
      ui = 0;
    const ai = ni.matrixWorldInverse;
    for (let hi = 0, ci = ri.length; hi < ci; hi++) {
      const fi = ri[hi];
      if (fi.isDirectionalLight) {
        const di = Kr.directional[ii];
        di.direction.setFromMatrixPosition(fi.matrixWorld),
          Zr.setFromMatrixPosition(fi.target.matrixWorld),
          di.direction.sub(Zr),
          di.direction.transformDirection(ai),
          ii++;
      } else if (fi.isSpotLight) {
        const di = Kr.spot[li];
        di.position.setFromMatrixPosition(fi.matrixWorld),
          di.position.applyMatrix4(ai),
          di.direction.setFromMatrixPosition(fi.matrixWorld),
          Zr.setFromMatrixPosition(fi.target.matrixWorld),
          di.direction.sub(Zr),
          di.direction.transformDirection(ai),
          li++;
      } else if (fi.isRectAreaLight) {
        const di = Kr.rectArea[oi];
        di.position.setFromMatrixPosition(fi.matrixWorld),
          di.position.applyMatrix4(ai),
          Qr.identity(),
          Jr.copy(fi.matrixWorld),
          Jr.premultiply(ai),
          Qr.extractRotation(Jr),
          di.halfWidth.set(fi.width * 0.5, 0, 0),
          di.halfHeight.set(0, fi.height * 0.5, 0),
          di.halfWidth.applyMatrix4(Qr),
          di.halfHeight.applyMatrix4(Qr),
          oi++;
      } else if (fi.isPointLight) {
        const di = Kr.point[si];
        di.position.setFromMatrixPosition(fi.matrixWorld),
          di.position.applyMatrix4(ai),
          si++;
      } else if (fi.isHemisphereLight) {
        const di = Kr.hemi[ui];
        di.direction.setFromMatrixPosition(fi.matrixWorld),
          di.direction.transformDirection(ai),
          ui++;
      }
    }
  }
  return {
    setup: ei,
    setupView: ti,
    state: Kr,
  };
}
function WebGLRenderState(Wr, ze) {
  const Gr = new WebGLLights(Wr, ze),
    Yr = [],
    Kr = [];
  function Zr() {
    (Yr.length = 0), (Kr.length = 0);
  }
  function Jr(ni) {
    Yr.push(ni);
  }
  function Qr(ni) {
    Kr.push(ni);
  }
  function ei(ni) {
    Gr.setup(Yr, ni);
  }
  function ti(ni) {
    Gr.setupView(Yr, ni);
  }
  return {
    init: Zr,
    state: {
      lightsArray: Yr,
      shadowsArray: Kr,
      lights: Gr,
    },
    setupLights: ei,
    setupLightsView: ti,
    pushLight: Jr,
    pushShadow: Qr,
  };
}
function WebGLRenderStates(Wr, ze) {
  let Gr = new WeakMap();
  function Yr(Zr, Jr = 0) {
    const Qr = Gr.get(Zr);
    let ei;
    return (
      Qr === void 0
        ? ((ei = new WebGLRenderState(Wr, ze)), Gr.set(Zr, [ei]))
        : Jr >= Qr.length
        ? ((ei = new WebGLRenderState(Wr, ze)), Qr.push(ei))
        : (ei = Qr[Jr]),
      ei
    );
  }
  function Kr() {
    Gr = new WeakMap();
  }
  return {
    get: Yr,
    dispose: Kr,
  };
}
class MeshDepthMaterial extends Material {
  constructor(ze) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = BasicDepthPacking),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(ze);
  }
  copy(ze) {
    return (
      super.copy(ze),
      (this.depthPacking = ze.depthPacking),
      (this.map = ze.map),
      (this.alphaMap = ze.alphaMap),
      (this.displacementMap = ze.displacementMap),
      (this.displacementScale = ze.displacementScale),
      (this.displacementBias = ze.displacementBias),
      (this.wireframe = ze.wireframe),
      (this.wireframeLinewidth = ze.wireframeLinewidth),
      this
    );
  }
}
class MeshDistanceMaterial extends Material {
  constructor(ze) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(ze);
  }
  copy(ze) {
    return (
      super.copy(ze),
      (this.map = ze.map),
      (this.alphaMap = ze.alphaMap),
      (this.displacementMap = ze.displacementMap),
      (this.displacementScale = ze.displacementScale),
      (this.displacementBias = ze.displacementBias),
      this
    );
  }
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function WebGLShadowMap(Wr, ze, Gr) {
  let Yr = new Frustum();
  const Kr = new Vector2(),
    Zr = new Vector2(),
    Jr = new Vector4(),
    Qr = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
    }),
    ei = new MeshDistanceMaterial(),
    ti = {},
    ri = Gr.maxTextureSize,
    ni = {
      [FrontSide]: BackSide,
      [BackSide]: FrontSide,
      [DoubleSide]: DoubleSide,
    },
    ii = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8,
      },
      uniforms: {
        shadow_pass: {
          value: null,
        },
        resolution: {
          value: new Vector2(),
        },
        radius: {
          value: 4,
        },
      },
      vertexShader: vertex,
      fragmentShader: fragment,
    }),
    si = ii.clone();
  si.defines.HORIZONTAL_PASS = 1;
  const li = new BufferGeometry();
  li.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const oi = new Mesh(li, ii),
    ui = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = PCFShadowMap);
  let ai = this.type;
  this.render = function (di, pi, mi) {
    if (
      ui.enabled === !1 ||
      (ui.autoUpdate === !1 && ui.needsUpdate === !1) ||
      di.length === 0
    )
      return;
    const Si = Wr.getRenderTarget(),
      yi = Wr.getActiveCubeFace(),
      Ei = Wr.getActiveMipmapLevel(),
      Pi = Wr.state;
    Pi.setBlending(NoBlending),
      Pi.buffers.color.setClear(1, 1, 1, 1),
      Pi.buffers.depth.setTest(!0),
      Pi.setScissorTest(!1);
    const Ai = ai !== VSMShadowMap && this.type === VSMShadowMap,
      Ri = ai === VSMShadowMap && this.type !== VSMShadowMap;
    for (let wi = 0, Ci = di.length; wi < Ci; wi++) {
      const bi = di[wi],
        Mi = bi.shadow;
      if (Mi === void 0) {
        console.warn("THREE.WebGLShadowMap:", bi, "has no shadow.");
        continue;
      }
      if (Mi.autoUpdate === !1 && Mi.needsUpdate === !1) continue;
      Kr.copy(Mi.mapSize);
      const gi = Mi.getFrameExtents();
      if (
        (Kr.multiply(gi),
        Zr.copy(Mi.mapSize),
        (Kr.x > ri || Kr.y > ri) &&
          (Kr.x > ri &&
            ((Zr.x = Math.floor(ri / gi.x)),
            (Kr.x = Zr.x * gi.x),
            (Mi.mapSize.x = Zr.x)),
          Kr.y > ri &&
            ((Zr.y = Math.floor(ri / gi.y)),
            (Kr.y = Zr.y * gi.y),
            (Mi.mapSize.y = Zr.y))),
        Mi.map === null || Ai === !0 || Ri === !0)
      ) {
        const Ti =
          this.type !== VSMShadowMap
            ? {
                minFilter: NearestFilter,
                magFilter: NearestFilter,
              }
            : {};
        Mi.map !== null && Mi.map.dispose(),
          (Mi.map = new WebGLRenderTarget(Kr.x, Kr.y, Ti)),
          (Mi.map.texture.name = bi.name + ".shadowMap"),
          Mi.camera.updateProjectionMatrix();
      }
      Wr.setRenderTarget(Mi.map), Wr.clear();
      const xi = Mi.getViewportCount();
      for (let Ti = 0; Ti < xi; Ti++) {
        const vi = Mi.getViewport(Ti);
        Jr.set(Zr.x * vi.x, Zr.y * vi.y, Zr.x * vi.z, Zr.y * vi.w),
          Pi.viewport(Jr),
          Mi.updateMatrices(bi, Ti),
          (Yr = Mi.getFrustum()),
          fi(pi, mi, Mi.camera, bi, this.type);
      }
      Mi.isPointLightShadow !== !0 && this.type === VSMShadowMap && hi(Mi, mi),
        (Mi.needsUpdate = !1);
    }
    (ai = this.type), (ui.needsUpdate = !1), Wr.setRenderTarget(Si, yi, Ei);
  };
  function hi(di, pi) {
    const mi = ze.update(oi);
    ii.defines.VSM_SAMPLES !== di.blurSamples &&
      ((ii.defines.VSM_SAMPLES = di.blurSamples),
      (si.defines.VSM_SAMPLES = di.blurSamples),
      (ii.needsUpdate = !0),
      (si.needsUpdate = !0)),
      di.mapPass === null && (di.mapPass = new WebGLRenderTarget(Kr.x, Kr.y)),
      (ii.uniforms.shadow_pass.value = di.map.texture),
      (ii.uniforms.resolution.value = di.mapSize),
      (ii.uniforms.radius.value = di.radius),
      Wr.setRenderTarget(di.mapPass),
      Wr.clear(),
      Wr.renderBufferDirect(pi, null, mi, ii, oi, null),
      (si.uniforms.shadow_pass.value = di.mapPass.texture),
      (si.uniforms.resolution.value = di.mapSize),
      (si.uniforms.radius.value = di.radius),
      Wr.setRenderTarget(di.map),
      Wr.clear(),
      Wr.renderBufferDirect(pi, null, mi, si, oi, null);
  }
  function ci(di, pi, mi, Si) {
    let yi = null;
    const Ei =
      mi.isPointLight === !0
        ? di.customDistanceMaterial
        : di.customDepthMaterial;
    if (Ei !== void 0) yi = Ei;
    else if (
      ((yi = mi.isPointLight === !0 ? ei : Qr),
      (Wr.localClippingEnabled &&
        pi.clipShadows === !0 &&
        Array.isArray(pi.clippingPlanes) &&
        pi.clippingPlanes.length !== 0) ||
        (pi.displacementMap && pi.displacementScale !== 0) ||
        (pi.alphaMap && pi.alphaTest > 0) ||
        (pi.map && pi.alphaTest > 0))
    ) {
      const Pi = yi.uuid,
        Ai = pi.uuid;
      let Ri = ti[Pi];
      Ri === void 0 && ((Ri = {}), (ti[Pi] = Ri));
      let wi = Ri[Ai];
      wi === void 0 && ((wi = yi.clone()), (Ri[Ai] = wi)), (yi = wi);
    }
    if (
      ((yi.visible = pi.visible),
      (yi.wireframe = pi.wireframe),
      Si === VSMShadowMap
        ? (yi.side = pi.shadowSide !== null ? pi.shadowSide : pi.side)
        : (yi.side = pi.shadowSide !== null ? pi.shadowSide : ni[pi.side]),
      (yi.alphaMap = pi.alphaMap),
      (yi.alphaTest = pi.alphaTest),
      (yi.map = pi.map),
      (yi.clipShadows = pi.clipShadows),
      (yi.clippingPlanes = pi.clippingPlanes),
      (yi.clipIntersection = pi.clipIntersection),
      (yi.displacementMap = pi.displacementMap),
      (yi.displacementScale = pi.displacementScale),
      (yi.displacementBias = pi.displacementBias),
      (yi.wireframeLinewidth = pi.wireframeLinewidth),
      (yi.linewidth = pi.linewidth),
      mi.isPointLight === !0 && yi.isMeshDistanceMaterial === !0)
    ) {
      const Pi = Wr.properties.get(yi);
      Pi.light = mi;
    }
    return yi;
  }
  function fi(di, pi, mi, Si, yi) {
    if (di.visible === !1) return;
    if (
      di.layers.test(pi.layers) &&
      (di.isMesh || di.isLine || di.isPoints) &&
      (di.castShadow || (di.receiveShadow && yi === VSMShadowMap)) &&
      (!di.frustumCulled || Yr.intersectsObject(di))
    ) {
      di.modelViewMatrix.multiplyMatrices(
        mi.matrixWorldInverse,
        di.matrixWorld
      );
      const Ai = ze.update(di),
        Ri = di.material;
      if (Array.isArray(Ri)) {
        const wi = Ai.groups;
        for (let Ci = 0, bi = wi.length; Ci < bi; Ci++) {
          const Mi = wi[Ci],
            gi = Ri[Mi.materialIndex];
          if (gi && gi.visible) {
            const xi = ci(di, gi, Si, yi);
            Wr.renderBufferDirect(mi, null, Ai, xi, di, Mi);
          }
        }
      } else if (Ri.visible) {
        const wi = ci(di, Ri, Si, yi);
        Wr.renderBufferDirect(mi, null, Ai, wi, di, null);
      }
    }
    const Pi = di.children;
    for (let Ai = 0, Ri = Pi.length; Ai < Ri; Ai++) fi(Pi[Ai], pi, mi, Si, yi);
  }
}
function WebGLState(Wr, ze, Gr) {
  const Yr = Gr.isWebGL2;
  function Kr() {
    let Ni = !1;
    const cn = new Vector4();
    let en = null;
    const ji = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (sn) {
        en !== sn && !Ni && (Wr.colorMask(sn, sn, sn, sn), (en = sn));
      },
      setLocked: function (sn) {
        Ni = sn;
      },
      setClear: function (sn, wn, dn, gn, Nn) {
        Nn === !0 && ((sn *= gn), (wn *= gn), (dn *= gn)),
          cn.set(sn, wn, dn, gn),
          ji.equals(cn) === !1 && (Wr.clearColor(sn, wn, dn, gn), ji.copy(cn));
      },
      reset: function () {
        (Ni = !1), (en = null), ji.set(-1, 0, 0, 0);
      },
    };
  }
  function Zr() {
    let Ni = !1,
      cn = null,
      en = null,
      ji = null;
    return {
      setTest: function (sn) {
        sn ? ln(Wr.DEPTH_TEST) : yn(Wr.DEPTH_TEST);
      },
      setMask: function (sn) {
        cn !== sn && !Ni && (Wr.depthMask(sn), (cn = sn));
      },
      setFunc: function (sn) {
        if (en !== sn) {
          switch (sn) {
            case NeverDepth:
              Wr.depthFunc(Wr.NEVER);
              break;
            case AlwaysDepth:
              Wr.depthFunc(Wr.ALWAYS);
              break;
            case LessDepth:
              Wr.depthFunc(Wr.LESS);
              break;
            case LessEqualDepth:
              Wr.depthFunc(Wr.LEQUAL);
              break;
            case EqualDepth:
              Wr.depthFunc(Wr.EQUAL);
              break;
            case GreaterEqualDepth:
              Wr.depthFunc(Wr.GEQUAL);
              break;
            case GreaterDepth:
              Wr.depthFunc(Wr.GREATER);
              break;
            case NotEqualDepth:
              Wr.depthFunc(Wr.NOTEQUAL);
              break;
            default:
              Wr.depthFunc(Wr.LEQUAL);
          }
          en = sn;
        }
      },
      setLocked: function (sn) {
        Ni = sn;
      },
      setClear: function (sn) {
        ji !== sn && (Wr.clearDepth(sn), (ji = sn));
      },
      reset: function () {
        (Ni = !1), (cn = null), (en = null), (ji = null);
      },
    };
  }
  function Jr() {
    let Ni = !1,
      cn = null,
      en = null,
      ji = null,
      sn = null,
      wn = null,
      dn = null,
      gn = null,
      Nn = null;
    return {
      setTest: function (Fn) {
        Ni || (Fn ? ln(Wr.STENCIL_TEST) : yn(Wr.STENCIL_TEST));
      },
      setMask: function (Fn) {
        cn !== Fn && !Ni && (Wr.stencilMask(Fn), (cn = Fn));
      },
      setFunc: function (Fn, hn, On) {
        (en !== Fn || ji !== hn || sn !== On) &&
          (Wr.stencilFunc(Fn, hn, On), (en = Fn), (ji = hn), (sn = On));
      },
      setOp: function (Fn, hn, On) {
        (wn !== Fn || dn !== hn || gn !== On) &&
          (Wr.stencilOp(Fn, hn, On), (wn = Fn), (dn = hn), (gn = On));
      },
      setLocked: function (Fn) {
        Ni = Fn;
      },
      setClear: function (Fn) {
        Nn !== Fn && (Wr.clearStencil(Fn), (Nn = Fn));
      },
      reset: function () {
        (Ni = !1),
          (cn = null),
          (en = null),
          (ji = null),
          (sn = null),
          (wn = null),
          (dn = null),
          (gn = null),
          (Nn = null);
      },
    };
  }
  const Qr = new Kr(),
    ei = new Zr(),
    ti = new Jr(),
    ri = new WeakMap(),
    ni = new WeakMap();
  let ii = {},
    si = {},
    li = new WeakMap(),
    oi = [],
    ui = null,
    ai = !1,
    hi = null,
    ci = null,
    fi = null,
    di = null,
    pi = null,
    mi = null,
    Si = null,
    yi = new Color(0, 0, 0),
    Ei = 0,
    Pi = !1,
    Ai = null,
    Ri = null,
    wi = null,
    Ci = null,
    bi = null;
  const Mi = Wr.getParameter(Wr.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let gi = !1,
    xi = 0;
  const Ti = Wr.getParameter(Wr.VERSION);
  Ti.indexOf("WebGL") !== -1
    ? ((xi = parseFloat(/^WebGL (\d)/.exec(Ti)[1])), (gi = xi >= 1))
    : Ti.indexOf("OpenGL ES") !== -1 &&
      ((xi = parseFloat(/^OpenGL ES (\d)/.exec(Ti)[1])), (gi = xi >= 2));
  let vi = null,
    Ii = {};
  const Oi = Wr.getParameter(Wr.SCISSOR_BOX),
    ki = Wr.getParameter(Wr.VIEWPORT),
    Bi = new Vector4().fromArray(Oi),
    Xi = new Vector4().fromArray(ki);
  function an(Ni, cn, en, ji) {
    const sn = new Uint8Array(4),
      wn = Wr.createTexture();
    Wr.bindTexture(Ni, wn),
      Wr.texParameteri(Ni, Wr.TEXTURE_MIN_FILTER, Wr.NEAREST),
      Wr.texParameteri(Ni, Wr.TEXTURE_MAG_FILTER, Wr.NEAREST);
    for (let dn = 0; dn < en; dn++)
      Yr && (Ni === Wr.TEXTURE_3D || Ni === Wr.TEXTURE_2D_ARRAY)
        ? Wr.texImage3D(
            cn,
            0,
            Wr.RGBA,
            1,
            1,
            ji,
            0,
            Wr.RGBA,
            Wr.UNSIGNED_BYTE,
            sn
          )
        : Wr.texImage2D(
            cn + dn,
            0,
            Wr.RGBA,
            1,
            1,
            0,
            Wr.RGBA,
            Wr.UNSIGNED_BYTE,
            sn
          );
    return wn;
  }
  const Qi = {};
  (Qi[Wr.TEXTURE_2D] = an(Wr.TEXTURE_2D, Wr.TEXTURE_2D, 1)),
    (Qi[Wr.TEXTURE_CUBE_MAP] = an(
      Wr.TEXTURE_CUBE_MAP,
      Wr.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    Yr &&
      ((Qi[Wr.TEXTURE_2D_ARRAY] = an(
        Wr.TEXTURE_2D_ARRAY,
        Wr.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Qi[Wr.TEXTURE_3D] = an(Wr.TEXTURE_3D, Wr.TEXTURE_3D, 1, 1))),
    Qr.setClear(0, 0, 0, 1),
    ei.setClear(1),
    ti.setClear(0),
    ln(Wr.DEPTH_TEST),
    ei.setFunc(LessEqualDepth),
    mn(!1),
    Sn(CullFaceBack),
    ln(Wr.CULL_FACE),
    vn(NoBlending);
  function ln(Ni) {
    ii[Ni] !== !0 && (Wr.enable(Ni), (ii[Ni] = !0));
  }
  function yn(Ni) {
    ii[Ni] !== !1 && (Wr.disable(Ni), (ii[Ni] = !1));
  }
  function un(Ni, cn) {
    return si[Ni] !== cn
      ? (Wr.bindFramebuffer(Ni, cn),
        (si[Ni] = cn),
        Yr &&
          (Ni === Wr.DRAW_FRAMEBUFFER && (si[Wr.FRAMEBUFFER] = cn),
          Ni === Wr.FRAMEBUFFER && (si[Wr.DRAW_FRAMEBUFFER] = cn)),
        !0)
      : !1;
  }
  function Vi(Ni, cn) {
    let en = oi,
      ji = !1;
    if (Ni)
      if (
        ((en = li.get(cn)),
        en === void 0 && ((en = []), li.set(cn, en)),
        Ni.isWebGLMultipleRenderTargets)
      ) {
        const sn = Ni.texture;
        if (en.length !== sn.length || en[0] !== Wr.COLOR_ATTACHMENT0) {
          for (let wn = 0, dn = sn.length; wn < dn; wn++)
            en[wn] = Wr.COLOR_ATTACHMENT0 + wn;
          (en.length = sn.length), (ji = !0);
        }
      } else
        en[0] !== Wr.COLOR_ATTACHMENT0 &&
          ((en[0] = Wr.COLOR_ATTACHMENT0), (ji = !0));
    else en[0] !== Wr.BACK && ((en[0] = Wr.BACK), (ji = !0));
    ji &&
      (Gr.isWebGL2
        ? Wr.drawBuffers(en)
        : ze.get("WEBGL_draw_buffers").drawBuffersWEBGL(en));
  }
  function rn(Ni) {
    return ui !== Ni ? (Wr.useProgram(Ni), (ui = Ni), !0) : !1;
  }
  const qi = {
    [AddEquation]: Wr.FUNC_ADD,
    [SubtractEquation]: Wr.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: Wr.FUNC_REVERSE_SUBTRACT,
  };
  if (Yr) (qi[MinEquation] = Wr.MIN), (qi[MaxEquation] = Wr.MAX);
  else {
    const Ni = ze.get("EXT_blend_minmax");
    Ni !== null &&
      ((qi[MinEquation] = Ni.MIN_EXT), (qi[MaxEquation] = Ni.MAX_EXT));
  }
  const pn = {
    [ZeroFactor]: Wr.ZERO,
    [OneFactor]: Wr.ONE,
    [SrcColorFactor]: Wr.SRC_COLOR,
    [SrcAlphaFactor]: Wr.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: Wr.SRC_ALPHA_SATURATE,
    [DstColorFactor]: Wr.DST_COLOR,
    [DstAlphaFactor]: Wr.DST_ALPHA,
    [OneMinusSrcColorFactor]: Wr.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: Wr.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: Wr.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: Wr.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: Wr.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: Wr.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: Wr.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: Wr.ONE_MINUS_CONSTANT_ALPHA,
  };
  function vn(Ni, cn, en, ji, sn, wn, dn, gn, Nn, Fn) {
    if (Ni === NoBlending) {
      ai === !0 && (yn(Wr.BLEND), (ai = !1));
      return;
    }
    if ((ai === !1 && (ln(Wr.BLEND), (ai = !0)), Ni !== CustomBlending)) {
      if (Ni !== hi || Fn !== Pi) {
        if (
          ((ci !== AddEquation || pi !== AddEquation) &&
            (Wr.blendEquation(Wr.FUNC_ADD),
            (ci = AddEquation),
            (pi = AddEquation)),
          Fn)
        )
          switch (Ni) {
            case NormalBlending:
              Wr.blendFuncSeparate(
                Wr.ONE,
                Wr.ONE_MINUS_SRC_ALPHA,
                Wr.ONE,
                Wr.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              Wr.blendFunc(Wr.ONE, Wr.ONE);
              break;
            case SubtractiveBlending:
              Wr.blendFuncSeparate(
                Wr.ZERO,
                Wr.ONE_MINUS_SRC_COLOR,
                Wr.ZERO,
                Wr.ONE
              );
              break;
            case MultiplyBlending:
              Wr.blendFuncSeparate(
                Wr.ZERO,
                Wr.SRC_COLOR,
                Wr.ZERO,
                Wr.SRC_ALPHA
              );
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Ni);
              break;
          }
        else
          switch (Ni) {
            case NormalBlending:
              Wr.blendFuncSeparate(
                Wr.SRC_ALPHA,
                Wr.ONE_MINUS_SRC_ALPHA,
                Wr.ONE,
                Wr.ONE_MINUS_SRC_ALPHA
              );
              break;
            case AdditiveBlending:
              Wr.blendFunc(Wr.SRC_ALPHA, Wr.ONE);
              break;
            case SubtractiveBlending:
              Wr.blendFuncSeparate(
                Wr.ZERO,
                Wr.ONE_MINUS_SRC_COLOR,
                Wr.ZERO,
                Wr.ONE
              );
              break;
            case MultiplyBlending:
              Wr.blendFunc(Wr.ZERO, Wr.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Ni);
              break;
          }
        (fi = null),
          (di = null),
          (mi = null),
          (Si = null),
          yi.set(0, 0, 0),
          (Ei = 0),
          (hi = Ni),
          (Pi = Fn);
      }
      return;
    }
    (sn = sn || cn),
      (wn = wn || en),
      (dn = dn || ji),
      (cn !== ci || sn !== pi) &&
        (Wr.blendEquationSeparate(qi[cn], qi[sn]), (ci = cn), (pi = sn)),
      (en !== fi || ji !== di || wn !== mi || dn !== Si) &&
        (Wr.blendFuncSeparate(pn[en], pn[ji], pn[wn], pn[dn]),
        (fi = en),
        (di = ji),
        (mi = wn),
        (Si = dn)),
      (gn.equals(yi) === !1 || Nn !== Ei) &&
        (Wr.blendColor(gn.r, gn.g, gn.b, Nn), yi.copy(gn), (Ei = Nn)),
      (hi = Ni),
      (Pi = !1);
  }
  function zi(Ni, cn) {
    Ni.side === DoubleSide ? yn(Wr.CULL_FACE) : ln(Wr.CULL_FACE);
    let en = Ni.side === BackSide;
    cn && (en = !en),
      mn(en),
      Ni.blending === NormalBlending && Ni.transparent === !1
        ? vn(NoBlending)
        : vn(
            Ni.blending,
            Ni.blendEquation,
            Ni.blendSrc,
            Ni.blendDst,
            Ni.blendEquationAlpha,
            Ni.blendSrcAlpha,
            Ni.blendDstAlpha,
            Ni.blendColor,
            Ni.blendAlpha,
            Ni.premultipliedAlpha
          ),
      ei.setFunc(Ni.depthFunc),
      ei.setTest(Ni.depthTest),
      ei.setMask(Ni.depthWrite),
      Qr.setMask(Ni.colorWrite);
    const ji = Ni.stencilWrite;
    ti.setTest(ji),
      ji &&
        (ti.setMask(Ni.stencilWriteMask),
        ti.setFunc(Ni.stencilFunc, Ni.stencilRef, Ni.stencilFuncMask),
        ti.setOp(Ni.stencilFail, Ni.stencilZFail, Ni.stencilZPass)),
      Cn(Ni.polygonOffset, Ni.polygonOffsetFactor, Ni.polygonOffsetUnits),
      Ni.alphaToCoverage === !0
        ? ln(Wr.SAMPLE_ALPHA_TO_COVERAGE)
        : yn(Wr.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function mn(Ni) {
    Ai !== Ni && (Ni ? Wr.frontFace(Wr.CW) : Wr.frontFace(Wr.CCW), (Ai = Ni));
  }
  function Sn(Ni) {
    Ni !== CullFaceNone
      ? (ln(Wr.CULL_FACE),
        Ni !== Ri &&
          (Ni === CullFaceBack
            ? Wr.cullFace(Wr.BACK)
            : Ni === CullFaceFront
            ? Wr.cullFace(Wr.FRONT)
            : Wr.cullFace(Wr.FRONT_AND_BACK)))
      : yn(Wr.CULL_FACE),
      (Ri = Ni);
  }
  function Dn(Ni) {
    Ni !== wi && (gi && Wr.lineWidth(Ni), (wi = Ni));
  }
  function Cn(Ni, cn, en) {
    Ni
      ? (ln(Wr.POLYGON_OFFSET_FILL),
        (Ci !== cn || bi !== en) &&
          (Wr.polygonOffset(cn, en), (Ci = cn), (bi = en)))
      : yn(Wr.POLYGON_OFFSET_FILL);
  }
  function $n(Ni) {
    Ni ? ln(Wr.SCISSOR_TEST) : yn(Wr.SCISSOR_TEST);
  }
  function Di(Ni) {
    Ni === void 0 && (Ni = Wr.TEXTURE0 + Mi - 1),
      vi !== Ni && (Wr.activeTexture(Ni), (vi = Ni));
  }
  function Li(Ni, cn, en) {
    en === void 0 && (vi === null ? (en = Wr.TEXTURE0 + Mi - 1) : (en = vi));
    let ji = Ii[en];
    ji === void 0 &&
      ((ji = {
        type: void 0,
        texture: void 0,
      }),
      (Ii[en] = ji)),
      (ji.type !== Ni || ji.texture !== cn) &&
        (vi !== en && (Wr.activeTexture(en), (vi = en)),
        Wr.bindTexture(Ni, cn || Qi[Ni]),
        (ji.type = Ni),
        (ji.texture = cn));
  }
  function Gi() {
    const Ni = Ii[vi];
    Ni !== void 0 &&
      Ni.type !== void 0 &&
      (Wr.bindTexture(Ni.type, null),
      (Ni.type = void 0),
      (Ni.texture = void 0));
  }
  function Yi() {
    try {
      Wr.compressedTexImage2D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function Ki() {
    try {
      Wr.compressedTexImage3D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function Zi() {
    try {
      Wr.texSubImage2D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function _n() {
    try {
      Wr.texSubImage3D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function tn() {
    try {
      Wr.compressedTexSubImage2D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function fn() {
    try {
      Wr.compressedTexSubImage3D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function En() {
    try {
      Wr.texStorage2D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function Vn() {
    try {
      Wr.texStorage3D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function nn() {
    try {
      Wr.texImage2D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function Hn() {
    try {
      Wr.texImage3D.apply(Wr, arguments);
    } catch (Ni) {
      console.error("THREE.WebGLState:", Ni);
    }
  }
  function Ln(Ni) {
    Bi.equals(Ni) === !1 && (Wr.scissor(Ni.x, Ni.y, Ni.z, Ni.w), Bi.copy(Ni));
  }
  function An(Ni) {
    Xi.equals(Ni) === !1 && (Wr.viewport(Ni.x, Ni.y, Ni.z, Ni.w), Xi.copy(Ni));
  }
  function Mn(Ni, cn) {
    let en = ni.get(cn);
    en === void 0 && ((en = new WeakMap()), ni.set(cn, en));
    let ji = en.get(Ni);
    ji === void 0 &&
      ((ji = Wr.getUniformBlockIndex(cn, Ni.name)), en.set(Ni, ji));
  }
  function Ji(Ni, cn) {
    const ji = ni.get(cn).get(Ni);
    ri.get(cn) !== ji &&
      (Wr.uniformBlockBinding(cn, ji, Ni.__bindingPointIndex), ri.set(cn, ji));
  }
  function Bn() {
    Wr.disable(Wr.BLEND),
      Wr.disable(Wr.CULL_FACE),
      Wr.disable(Wr.DEPTH_TEST),
      Wr.disable(Wr.POLYGON_OFFSET_FILL),
      Wr.disable(Wr.SCISSOR_TEST),
      Wr.disable(Wr.STENCIL_TEST),
      Wr.disable(Wr.SAMPLE_ALPHA_TO_COVERAGE),
      Wr.blendEquation(Wr.FUNC_ADD),
      Wr.blendFunc(Wr.ONE, Wr.ZERO),
      Wr.blendFuncSeparate(Wr.ONE, Wr.ZERO, Wr.ONE, Wr.ZERO),
      Wr.blendColor(0, 0, 0, 0),
      Wr.colorMask(!0, !0, !0, !0),
      Wr.clearColor(0, 0, 0, 0),
      Wr.depthMask(!0),
      Wr.depthFunc(Wr.LESS),
      Wr.clearDepth(1),
      Wr.stencilMask(4294967295),
      Wr.stencilFunc(Wr.ALWAYS, 0, 4294967295),
      Wr.stencilOp(Wr.KEEP, Wr.KEEP, Wr.KEEP),
      Wr.clearStencil(0),
      Wr.cullFace(Wr.BACK),
      Wr.frontFace(Wr.CCW),
      Wr.polygonOffset(0, 0),
      Wr.activeTexture(Wr.TEXTURE0),
      Wr.bindFramebuffer(Wr.FRAMEBUFFER, null),
      Yr === !0 &&
        (Wr.bindFramebuffer(Wr.DRAW_FRAMEBUFFER, null),
        Wr.bindFramebuffer(Wr.READ_FRAMEBUFFER, null)),
      Wr.useProgram(null),
      Wr.lineWidth(1),
      Wr.scissor(0, 0, Wr.canvas.width, Wr.canvas.height),
      Wr.viewport(0, 0, Wr.canvas.width, Wr.canvas.height),
      (ii = {}),
      (vi = null),
      (Ii = {}),
      (si = {}),
      (li = new WeakMap()),
      (oi = []),
      (ui = null),
      (ai = !1),
      (hi = null),
      (ci = null),
      (fi = null),
      (di = null),
      (pi = null),
      (mi = null),
      (Si = null),
      (yi = new Color(0, 0, 0)),
      (Ei = 0),
      (Pi = !1),
      (Ai = null),
      (Ri = null),
      (wi = null),
      (Ci = null),
      (bi = null),
      Bi.set(0, 0, Wr.canvas.width, Wr.canvas.height),
      Xi.set(0, 0, Wr.canvas.width, Wr.canvas.height),
      Qr.reset(),
      ei.reset(),
      ti.reset();
  }
  return {
    buffers: {
      color: Qr,
      depth: ei,
      stencil: ti,
    },
    enable: ln,
    disable: yn,
    bindFramebuffer: un,
    drawBuffers: Vi,
    useProgram: rn,
    setBlending: vn,
    setMaterial: zi,
    setFlipSided: mn,
    setCullFace: Sn,
    setLineWidth: Dn,
    setPolygonOffset: Cn,
    setScissorTest: $n,
    activeTexture: Di,
    bindTexture: Li,
    unbindTexture: Gi,
    compressedTexImage2D: Yi,
    compressedTexImage3D: Ki,
    texImage2D: nn,
    texImage3D: Hn,
    updateUBOMapping: Mn,
    uniformBlockBinding: Ji,
    texStorage2D: En,
    texStorage3D: Vn,
    texSubImage2D: Zi,
    texSubImage3D: _n,
    compressedTexSubImage2D: tn,
    compressedTexSubImage3D: fn,
    scissor: Ln,
    viewport: An,
    reset: Bn,
  };
}
function WebGLTextures(Wr, ze, Gr, Yr, Kr, Zr, Jr) {
  const Qr = Kr.isWebGL2,
    ei = Kr.maxTextures,
    ti = Kr.maxCubemapSize,
    ri = Kr.maxTextureSize,
    ni = Kr.maxSamples,
    ii = ze.has("WEBGL_multisampled_render_to_texture")
      ? ze.get("WEBGL_multisampled_render_to_texture")
      : null,
    si =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    li = new WeakMap();
  let oi;
  const ui = new WeakMap();
  let ai = !1;
  try {
    ai =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (Di) {}
  function hi(Di, Li) {
    return ai ? new OffscreenCanvas(Di, Li) : createElementNS("canvas");
  }
  function ci(Di, Li, Gi, Yi) {
    let Ki = 1;
    if (
      ((Di.width > Yi || Di.height > Yi) &&
        (Ki = Yi / Math.max(Di.width, Di.height)),
      Ki < 1 || Li === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && Di instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && Di instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && Di instanceof ImageBitmap)
      ) {
        const Zi = Li ? floorPowerOfTwo : Math.floor,
          _n = Zi(Ki * Di.width),
          tn = Zi(Ki * Di.height);
        oi === void 0 && (oi = hi(_n, tn));
        const fn = Gi ? hi(_n, tn) : oi;
        return (
          (fn.width = _n),
          (fn.height = tn),
          fn.getContext("2d").drawImage(Di, 0, 0, _n, tn),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              Di.width +
              "x" +
              Di.height +
              ") to (" +
              _n +
              "x" +
              tn +
              ")."
          ),
          fn
        );
      } else
        return (
          "data" in Di &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                Di.width +
                "x" +
                Di.height +
                ")."
            ),
          Di
        );
    return Di;
  }
  function fi(Di) {
    return isPowerOfTwo(Di.width) && isPowerOfTwo(Di.height);
  }
  function di(Di) {
    return Qr
      ? !1
      : Di.wrapS !== ClampToEdgeWrapping ||
          Di.wrapT !== ClampToEdgeWrapping ||
          (Di.minFilter !== NearestFilter && Di.minFilter !== LinearFilter);
  }
  function pi(Di, Li) {
    return (
      Di.generateMipmaps &&
      Li &&
      Di.minFilter !== NearestFilter &&
      Di.minFilter !== LinearFilter
    );
  }
  function mi(Di) {
    Wr.generateMipmap(Di);
  }
  function Si(Di, Li, Gi, Yi, Ki = !1) {
    if (Qr === !1) return Li;
    if (Di !== null) {
      if (Wr[Di] !== void 0) return Wr[Di];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          Di +
          "'"
      );
    }
    let Zi = Li;
    if (
      (Li === Wr.RED &&
        (Gi === Wr.FLOAT && (Zi = Wr.R32F),
        Gi === Wr.HALF_FLOAT && (Zi = Wr.R16F),
        Gi === Wr.UNSIGNED_BYTE && (Zi = Wr.R8)),
      Li === Wr.RED_INTEGER &&
        (Gi === Wr.UNSIGNED_BYTE && (Zi = Wr.R8UI),
        Gi === Wr.UNSIGNED_SHORT && (Zi = Wr.R16UI),
        Gi === Wr.UNSIGNED_INT && (Zi = Wr.R32UI),
        Gi === Wr.BYTE && (Zi = Wr.R8I),
        Gi === Wr.SHORT && (Zi = Wr.R16I),
        Gi === Wr.INT && (Zi = Wr.R32I)),
      Li === Wr.RG &&
        (Gi === Wr.FLOAT && (Zi = Wr.RG32F),
        Gi === Wr.HALF_FLOAT && (Zi = Wr.RG16F),
        Gi === Wr.UNSIGNED_BYTE && (Zi = Wr.RG8)),
      Li === Wr.RGBA)
    ) {
      const _n = Ki ? LinearTransfer : ColorManagement.getTransfer(Yi);
      Gi === Wr.FLOAT && (Zi = Wr.RGBA32F),
        Gi === Wr.HALF_FLOAT && (Zi = Wr.RGBA16F),
        Gi === Wr.UNSIGNED_BYTE &&
          (Zi = _n === SRGBTransfer ? Wr.SRGB8_ALPHA8 : Wr.RGBA8),
        Gi === Wr.UNSIGNED_SHORT_4_4_4_4 && (Zi = Wr.RGBA4),
        Gi === Wr.UNSIGNED_SHORT_5_5_5_1 && (Zi = Wr.RGB5_A1);
    }
    return (
      (Zi === Wr.R16F ||
        Zi === Wr.R32F ||
        Zi === Wr.RG16F ||
        Zi === Wr.RG32F ||
        Zi === Wr.RGBA16F ||
        Zi === Wr.RGBA32F) &&
        ze.get("EXT_color_buffer_float"),
      Zi
    );
  }
  function yi(Di, Li, Gi) {
    return pi(Di, Gi) === !0 ||
      (Di.isFramebufferTexture &&
        Di.minFilter !== NearestFilter &&
        Di.minFilter !== LinearFilter)
      ? Math.log2(Math.max(Li.width, Li.height)) + 1
      : Di.mipmaps !== void 0 && Di.mipmaps.length > 0
      ? Di.mipmaps.length
      : Di.isCompressedTexture && Array.isArray(Di.image)
      ? Li.mipmaps.length
      : 1;
  }
  function Ei(Di) {
    return Di === NearestFilter ||
      Di === NearestMipmapNearestFilter ||
      Di === NearestMipmapLinearFilter
      ? Wr.NEAREST
      : Wr.LINEAR;
  }
  function Pi(Di) {
    const Li = Di.target;
    Li.removeEventListener("dispose", Pi),
      Ri(Li),
      Li.isVideoTexture && li.delete(Li);
  }
  function Ai(Di) {
    const Li = Di.target;
    Li.removeEventListener("dispose", Ai), Ci(Li);
  }
  function Ri(Di) {
    const Li = Yr.get(Di);
    if (Li.__webglInit === void 0) return;
    const Gi = Di.source,
      Yi = ui.get(Gi);
    if (Yi) {
      const Ki = Yi[Li.__cacheKey];
      Ki.usedTimes--,
        Ki.usedTimes === 0 && wi(Di),
        Object.keys(Yi).length === 0 && ui.delete(Gi);
    }
    Yr.remove(Di);
  }
  function wi(Di) {
    const Li = Yr.get(Di);
    Wr.deleteTexture(Li.__webglTexture);
    const Gi = Di.source,
      Yi = ui.get(Gi);
    delete Yi[Li.__cacheKey], Jr.memory.textures--;
  }
  function Ci(Di) {
    const Li = Di.texture,
      Gi = Yr.get(Di),
      Yi = Yr.get(Li);
    if (
      (Yi.__webglTexture !== void 0 &&
        (Wr.deleteTexture(Yi.__webglTexture), Jr.memory.textures--),
      Di.depthTexture && Di.depthTexture.dispose(),
      Di.isWebGLCubeRenderTarget)
    )
      for (let Ki = 0; Ki < 6; Ki++) {
        if (Array.isArray(Gi.__webglFramebuffer[Ki]))
          for (let Zi = 0; Zi < Gi.__webglFramebuffer[Ki].length; Zi++)
            Wr.deleteFramebuffer(Gi.__webglFramebuffer[Ki][Zi]);
        else Wr.deleteFramebuffer(Gi.__webglFramebuffer[Ki]);
        Gi.__webglDepthbuffer &&
          Wr.deleteRenderbuffer(Gi.__webglDepthbuffer[Ki]);
      }
    else {
      if (Array.isArray(Gi.__webglFramebuffer))
        for (let Ki = 0; Ki < Gi.__webglFramebuffer.length; Ki++)
          Wr.deleteFramebuffer(Gi.__webglFramebuffer[Ki]);
      else Wr.deleteFramebuffer(Gi.__webglFramebuffer);
      if (
        (Gi.__webglDepthbuffer && Wr.deleteRenderbuffer(Gi.__webglDepthbuffer),
        Gi.__webglMultisampledFramebuffer &&
          Wr.deleteFramebuffer(Gi.__webglMultisampledFramebuffer),
        Gi.__webglColorRenderbuffer)
      )
        for (let Ki = 0; Ki < Gi.__webglColorRenderbuffer.length; Ki++)
          Gi.__webglColorRenderbuffer[Ki] &&
            Wr.deleteRenderbuffer(Gi.__webglColorRenderbuffer[Ki]);
      Gi.__webglDepthRenderbuffer &&
        Wr.deleteRenderbuffer(Gi.__webglDepthRenderbuffer);
    }
    if (Di.isWebGLMultipleRenderTargets)
      for (let Ki = 0, Zi = Li.length; Ki < Zi; Ki++) {
        const _n = Yr.get(Li[Ki]);
        _n.__webglTexture &&
          (Wr.deleteTexture(_n.__webglTexture), Jr.memory.textures--),
          Yr.remove(Li[Ki]);
      }
    Yr.remove(Li), Yr.remove(Di);
  }
  let bi = 0;
  function Mi() {
    bi = 0;
  }
  function gi() {
    const Di = bi;
    return (
      Di >= ei &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            Di +
            " texture units while this GPU supports only " +
            ei
        ),
      (bi += 1),
      Di
    );
  }
  function xi(Di) {
    const Li = [];
    return (
      Li.push(Di.wrapS),
      Li.push(Di.wrapT),
      Li.push(Di.wrapR || 0),
      Li.push(Di.magFilter),
      Li.push(Di.minFilter),
      Li.push(Di.anisotropy),
      Li.push(Di.internalFormat),
      Li.push(Di.format),
      Li.push(Di.type),
      Li.push(Di.generateMipmaps),
      Li.push(Di.premultiplyAlpha),
      Li.push(Di.flipY),
      Li.push(Di.unpackAlignment),
      Li.push(Di.colorSpace),
      Li.join()
    );
  }
  function Ti(Di, Li) {
    const Gi = Yr.get(Di);
    if (
      (Di.isVideoTexture && Cn(Di),
      Di.isRenderTargetTexture === !1 &&
        Di.version > 0 &&
        Gi.__version !== Di.version)
    ) {
      const Yi = Di.image;
      if (Yi === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Yi.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        ln(Gi, Di, Li);
        return;
      }
    }
    Gr.bindTexture(Wr.TEXTURE_2D, Gi.__webglTexture, Wr.TEXTURE0 + Li);
  }
  function vi(Di, Li) {
    const Gi = Yr.get(Di);
    if (Di.version > 0 && Gi.__version !== Di.version) {
      ln(Gi, Di, Li);
      return;
    }
    Gr.bindTexture(Wr.TEXTURE_2D_ARRAY, Gi.__webglTexture, Wr.TEXTURE0 + Li);
  }
  function Ii(Di, Li) {
    const Gi = Yr.get(Di);
    if (Di.version > 0 && Gi.__version !== Di.version) {
      ln(Gi, Di, Li);
      return;
    }
    Gr.bindTexture(Wr.TEXTURE_3D, Gi.__webglTexture, Wr.TEXTURE0 + Li);
  }
  function Oi(Di, Li) {
    const Gi = Yr.get(Di);
    if (Di.version > 0 && Gi.__version !== Di.version) {
      yn(Gi, Di, Li);
      return;
    }
    Gr.bindTexture(Wr.TEXTURE_CUBE_MAP, Gi.__webglTexture, Wr.TEXTURE0 + Li);
  }
  const ki = {
      [RepeatWrapping]: Wr.REPEAT,
      [ClampToEdgeWrapping]: Wr.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: Wr.MIRRORED_REPEAT,
    },
    Bi = {
      [NearestFilter]: Wr.NEAREST,
      [NearestMipmapNearestFilter]: Wr.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: Wr.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: Wr.LINEAR,
      [LinearMipmapNearestFilter]: Wr.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: Wr.LINEAR_MIPMAP_LINEAR,
    },
    Xi = {
      [NeverCompare]: Wr.NEVER,
      [AlwaysCompare]: Wr.ALWAYS,
      [LessCompare]: Wr.LESS,
      [LessEqualCompare]: Wr.LEQUAL,
      [EqualCompare]: Wr.EQUAL,
      [GreaterEqualCompare]: Wr.GEQUAL,
      [GreaterCompare]: Wr.GREATER,
      [NotEqualCompare]: Wr.NOTEQUAL,
    };
  function an(Di, Li, Gi) {
    if (
      (Gi
        ? (Wr.texParameteri(Di, Wr.TEXTURE_WRAP_S, ki[Li.wrapS]),
          Wr.texParameteri(Di, Wr.TEXTURE_WRAP_T, ki[Li.wrapT]),
          (Di === Wr.TEXTURE_3D || Di === Wr.TEXTURE_2D_ARRAY) &&
            Wr.texParameteri(Di, Wr.TEXTURE_WRAP_R, ki[Li.wrapR]),
          Wr.texParameteri(Di, Wr.TEXTURE_MAG_FILTER, Bi[Li.magFilter]),
          Wr.texParameteri(Di, Wr.TEXTURE_MIN_FILTER, Bi[Li.minFilter]))
        : (Wr.texParameteri(Di, Wr.TEXTURE_WRAP_S, Wr.CLAMP_TO_EDGE),
          Wr.texParameteri(Di, Wr.TEXTURE_WRAP_T, Wr.CLAMP_TO_EDGE),
          (Di === Wr.TEXTURE_3D || Di === Wr.TEXTURE_2D_ARRAY) &&
            Wr.texParameteri(Di, Wr.TEXTURE_WRAP_R, Wr.CLAMP_TO_EDGE),
          (Li.wrapS !== ClampToEdgeWrapping ||
            Li.wrapT !== ClampToEdgeWrapping) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          Wr.texParameteri(Di, Wr.TEXTURE_MAG_FILTER, Ei(Li.magFilter)),
          Wr.texParameteri(Di, Wr.TEXTURE_MIN_FILTER, Ei(Li.minFilter)),
          Li.minFilter !== NearestFilter &&
            Li.minFilter !== LinearFilter &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      Li.compareFunction &&
        (Wr.texParameteri(
          Di,
          Wr.TEXTURE_COMPARE_MODE,
          Wr.COMPARE_REF_TO_TEXTURE
        ),
        Wr.texParameteri(Di, Wr.TEXTURE_COMPARE_FUNC, Xi[Li.compareFunction])),
      ze.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Yi = ze.get("EXT_texture_filter_anisotropic");
      if (
        Li.magFilter === NearestFilter ||
        (Li.minFilter !== NearestMipmapLinearFilter &&
          Li.minFilter !== LinearMipmapLinearFilter) ||
        (Li.type === FloatType && ze.has("OES_texture_float_linear") === !1) ||
        (Qr === !1 &&
          Li.type === HalfFloatType &&
          ze.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (Li.anisotropy > 1 || Yr.get(Li).__currentAnisotropy) &&
        (Wr.texParameterf(
          Di,
          Yi.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(Li.anisotropy, Kr.getMaxAnisotropy())
        ),
        (Yr.get(Li).__currentAnisotropy = Li.anisotropy));
    }
  }
  function Qi(Di, Li) {
    let Gi = !1;
    Di.__webglInit === void 0 &&
      ((Di.__webglInit = !0), Li.addEventListener("dispose", Pi));
    const Yi = Li.source;
    let Ki = ui.get(Yi);
    Ki === void 0 && ((Ki = {}), ui.set(Yi, Ki));
    const Zi = xi(Li);
    if (Zi !== Di.__cacheKey) {
      Ki[Zi] === void 0 &&
        ((Ki[Zi] = {
          texture: Wr.createTexture(),
          usedTimes: 0,
        }),
        Jr.memory.textures++,
        (Gi = !0)),
        Ki[Zi].usedTimes++;
      const _n = Ki[Di.__cacheKey];
      _n !== void 0 &&
        (Ki[Di.__cacheKey].usedTimes--, _n.usedTimes === 0 && wi(Li)),
        (Di.__cacheKey = Zi),
        (Di.__webglTexture = Ki[Zi].texture);
    }
    return Gi;
  }
  function ln(Di, Li, Gi) {
    let Yi = Wr.TEXTURE_2D;
    (Li.isDataArrayTexture || Li.isCompressedArrayTexture) &&
      (Yi = Wr.TEXTURE_2D_ARRAY),
      Li.isData3DTexture && (Yi = Wr.TEXTURE_3D);
    const Ki = Qi(Di, Li),
      Zi = Li.source;
    Gr.bindTexture(Yi, Di.__webglTexture, Wr.TEXTURE0 + Gi);
    const _n = Yr.get(Zi);
    if (Zi.version !== _n.__version || Ki === !0) {
      Gr.activeTexture(Wr.TEXTURE0 + Gi);
      const tn = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        fn =
          Li.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(Li.colorSpace),
        En =
          Li.colorSpace === NoColorSpace || tn === fn
            ? Wr.NONE
            : Wr.BROWSER_DEFAULT_WEBGL;
      Wr.pixelStorei(Wr.UNPACK_FLIP_Y_WEBGL, Li.flipY),
        Wr.pixelStorei(Wr.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Li.premultiplyAlpha),
        Wr.pixelStorei(Wr.UNPACK_ALIGNMENT, Li.unpackAlignment),
        Wr.pixelStorei(Wr.UNPACK_COLORSPACE_CONVERSION_WEBGL, En);
      const Vn = di(Li) && fi(Li.image) === !1;
      let nn = ci(Li.image, Vn, !1, ri);
      nn = $n(Li, nn);
      const Hn = fi(nn) || Qr,
        Ln = Zr.convert(Li.format, Li.colorSpace);
      let An = Zr.convert(Li.type),
        Mn = Si(Li.internalFormat, Ln, An, Li.colorSpace, Li.isVideoTexture);
      an(Yi, Li, Hn);
      let Ji;
      const Bn = Li.mipmaps,
        Ni = Qr && Li.isVideoTexture !== !0,
        cn = _n.__version === void 0 || Ki === !0,
        en = yi(Li, nn, Hn);
      if (Li.isDepthTexture)
        (Mn = Wr.DEPTH_COMPONENT),
          Qr
            ? Li.type === FloatType
              ? (Mn = Wr.DEPTH_COMPONENT32F)
              : Li.type === UnsignedIntType
              ? (Mn = Wr.DEPTH_COMPONENT24)
              : Li.type === UnsignedInt248Type
              ? (Mn = Wr.DEPTH24_STENCIL8)
              : (Mn = Wr.DEPTH_COMPONENT16)
            : Li.type === FloatType &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          Li.format === DepthFormat &&
            Mn === Wr.DEPTH_COMPONENT &&
            Li.type !== UnsignedShortType &&
            Li.type !== UnsignedIntType &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (Li.type = UnsignedIntType),
            (An = Zr.convert(Li.type))),
          Li.format === DepthStencilFormat &&
            Mn === Wr.DEPTH_COMPONENT &&
            ((Mn = Wr.DEPTH_STENCIL),
            Li.type !== UnsignedInt248Type &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (Li.type = UnsignedInt248Type),
              (An = Zr.convert(Li.type)))),
          cn &&
            (Ni
              ? Gr.texStorage2D(Wr.TEXTURE_2D, 1, Mn, nn.width, nn.height)
              : Gr.texImage2D(
                  Wr.TEXTURE_2D,
                  0,
                  Mn,
                  nn.width,
                  nn.height,
                  0,
                  Ln,
                  An,
                  null
                ));
      else if (Li.isDataTexture)
        if (Bn.length > 0 && Hn) {
          Ni &&
            cn &&
            Gr.texStorage2D(Wr.TEXTURE_2D, en, Mn, Bn[0].width, Bn[0].height);
          for (let ji = 0, sn = Bn.length; ji < sn; ji++)
            (Ji = Bn[ji]),
              Ni
                ? Gr.texSubImage2D(
                    Wr.TEXTURE_2D,
                    ji,
                    0,
                    0,
                    Ji.width,
                    Ji.height,
                    Ln,
                    An,
                    Ji.data
                  )
                : Gr.texImage2D(
                    Wr.TEXTURE_2D,
                    ji,
                    Mn,
                    Ji.width,
                    Ji.height,
                    0,
                    Ln,
                    An,
                    Ji.data
                  );
          Li.generateMipmaps = !1;
        } else
          Ni
            ? (cn &&
                Gr.texStorage2D(Wr.TEXTURE_2D, en, Mn, nn.width, nn.height),
              Gr.texSubImage2D(
                Wr.TEXTURE_2D,
                0,
                0,
                0,
                nn.width,
                nn.height,
                Ln,
                An,
                nn.data
              ))
            : Gr.texImage2D(
                Wr.TEXTURE_2D,
                0,
                Mn,
                nn.width,
                nn.height,
                0,
                Ln,
                An,
                nn.data
              );
      else if (Li.isCompressedTexture)
        if (Li.isCompressedArrayTexture) {
          Ni &&
            cn &&
            Gr.texStorage3D(
              Wr.TEXTURE_2D_ARRAY,
              en,
              Mn,
              Bn[0].width,
              Bn[0].height,
              nn.depth
            );
          for (let ji = 0, sn = Bn.length; ji < sn; ji++)
            (Ji = Bn[ji]),
              Li.format !== RGBAFormat
                ? Ln !== null
                  ? Ni
                    ? Gr.compressedTexSubImage3D(
                        Wr.TEXTURE_2D_ARRAY,
                        ji,
                        0,
                        0,
                        0,
                        Ji.width,
                        Ji.height,
                        nn.depth,
                        Ln,
                        Ji.data,
                        0,
                        0
                      )
                    : Gr.compressedTexImage3D(
                        Wr.TEXTURE_2D_ARRAY,
                        ji,
                        Mn,
                        Ji.width,
                        Ji.height,
                        nn.depth,
                        0,
                        Ji.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ni
                ? Gr.texSubImage3D(
                    Wr.TEXTURE_2D_ARRAY,
                    ji,
                    0,
                    0,
                    0,
                    Ji.width,
                    Ji.height,
                    nn.depth,
                    Ln,
                    An,
                    Ji.data
                  )
                : Gr.texImage3D(
                    Wr.TEXTURE_2D_ARRAY,
                    ji,
                    Mn,
                    Ji.width,
                    Ji.height,
                    nn.depth,
                    0,
                    Ln,
                    An,
                    Ji.data
                  );
        } else {
          Ni &&
            cn &&
            Gr.texStorage2D(Wr.TEXTURE_2D, en, Mn, Bn[0].width, Bn[0].height);
          for (let ji = 0, sn = Bn.length; ji < sn; ji++)
            (Ji = Bn[ji]),
              Li.format !== RGBAFormat
                ? Ln !== null
                  ? Ni
                    ? Gr.compressedTexSubImage2D(
                        Wr.TEXTURE_2D,
                        ji,
                        0,
                        0,
                        Ji.width,
                        Ji.height,
                        Ln,
                        Ji.data
                      )
                    : Gr.compressedTexImage2D(
                        Wr.TEXTURE_2D,
                        ji,
                        Mn,
                        Ji.width,
                        Ji.height,
                        0,
                        Ji.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ni
                ? Gr.texSubImage2D(
                    Wr.TEXTURE_2D,
                    ji,
                    0,
                    0,
                    Ji.width,
                    Ji.height,
                    Ln,
                    An,
                    Ji.data
                  )
                : Gr.texImage2D(
                    Wr.TEXTURE_2D,
                    ji,
                    Mn,
                    Ji.width,
                    Ji.height,
                    0,
                    Ln,
                    An,
                    Ji.data
                  );
        }
      else if (Li.isDataArrayTexture)
        Ni
          ? (cn &&
              Gr.texStorage3D(
                Wr.TEXTURE_2D_ARRAY,
                en,
                Mn,
                nn.width,
                nn.height,
                nn.depth
              ),
            Gr.texSubImage3D(
              Wr.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              nn.width,
              nn.height,
              nn.depth,
              Ln,
              An,
              nn.data
            ))
          : Gr.texImage3D(
              Wr.TEXTURE_2D_ARRAY,
              0,
              Mn,
              nn.width,
              nn.height,
              nn.depth,
              0,
              Ln,
              An,
              nn.data
            );
      else if (Li.isData3DTexture)
        Ni
          ? (cn &&
              Gr.texStorage3D(
                Wr.TEXTURE_3D,
                en,
                Mn,
                nn.width,
                nn.height,
                nn.depth
              ),
            Gr.texSubImage3D(
              Wr.TEXTURE_3D,
              0,
              0,
              0,
              0,
              nn.width,
              nn.height,
              nn.depth,
              Ln,
              An,
              nn.data
            ))
          : Gr.texImage3D(
              Wr.TEXTURE_3D,
              0,
              Mn,
              nn.width,
              nn.height,
              nn.depth,
              0,
              Ln,
              An,
              nn.data
            );
      else if (Li.isFramebufferTexture) {
        if (cn)
          if (Ni) Gr.texStorage2D(Wr.TEXTURE_2D, en, Mn, nn.width, nn.height);
          else {
            let ji = nn.width,
              sn = nn.height;
            for (let wn = 0; wn < en; wn++)
              Gr.texImage2D(Wr.TEXTURE_2D, wn, Mn, ji, sn, 0, Ln, An, null),
                (ji >>= 1),
                (sn >>= 1);
          }
      } else if (Bn.length > 0 && Hn) {
        Ni &&
          cn &&
          Gr.texStorage2D(Wr.TEXTURE_2D, en, Mn, Bn[0].width, Bn[0].height);
        for (let ji = 0, sn = Bn.length; ji < sn; ji++)
          (Ji = Bn[ji]),
            Ni
              ? Gr.texSubImage2D(Wr.TEXTURE_2D, ji, 0, 0, Ln, An, Ji)
              : Gr.texImage2D(Wr.TEXTURE_2D, ji, Mn, Ln, An, Ji);
        Li.generateMipmaps = !1;
      } else
        Ni
          ? (cn && Gr.texStorage2D(Wr.TEXTURE_2D, en, Mn, nn.width, nn.height),
            Gr.texSubImage2D(Wr.TEXTURE_2D, 0, 0, 0, Ln, An, nn))
          : Gr.texImage2D(Wr.TEXTURE_2D, 0, Mn, Ln, An, nn);
      pi(Li, Hn) && mi(Yi),
        (_n.__version = Zi.version),
        Li.onUpdate && Li.onUpdate(Li);
    }
    Di.__version = Li.version;
  }
  function yn(Di, Li, Gi) {
    if (Li.image.length !== 6) return;
    const Yi = Qi(Di, Li),
      Ki = Li.source;
    Gr.bindTexture(Wr.TEXTURE_CUBE_MAP, Di.__webglTexture, Wr.TEXTURE0 + Gi);
    const Zi = Yr.get(Ki);
    if (Ki.version !== Zi.__version || Yi === !0) {
      Gr.activeTexture(Wr.TEXTURE0 + Gi);
      const _n = ColorManagement.getPrimaries(
          ColorManagement.workingColorSpace
        ),
        tn =
          Li.colorSpace === NoColorSpace
            ? null
            : ColorManagement.getPrimaries(Li.colorSpace),
        fn =
          Li.colorSpace === NoColorSpace || _n === tn
            ? Wr.NONE
            : Wr.BROWSER_DEFAULT_WEBGL;
      Wr.pixelStorei(Wr.UNPACK_FLIP_Y_WEBGL, Li.flipY),
        Wr.pixelStorei(Wr.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Li.premultiplyAlpha),
        Wr.pixelStorei(Wr.UNPACK_ALIGNMENT, Li.unpackAlignment),
        Wr.pixelStorei(Wr.UNPACK_COLORSPACE_CONVERSION_WEBGL, fn);
      const En = Li.isCompressedTexture || Li.image[0].isCompressedTexture,
        Vn = Li.image[0] && Li.image[0].isDataTexture,
        nn = [];
      for (let ji = 0; ji < 6; ji++)
        !En && !Vn
          ? (nn[ji] = ci(Li.image[ji], !1, !0, ti))
          : (nn[ji] = Vn ? Li.image[ji].image : Li.image[ji]),
          (nn[ji] = $n(Li, nn[ji]));
      const Hn = nn[0],
        Ln = fi(Hn) || Qr,
        An = Zr.convert(Li.format, Li.colorSpace),
        Mn = Zr.convert(Li.type),
        Ji = Si(Li.internalFormat, An, Mn, Li.colorSpace),
        Bn = Qr && Li.isVideoTexture !== !0,
        Ni = Zi.__version === void 0 || Yi === !0;
      let cn = yi(Li, Hn, Ln);
      an(Wr.TEXTURE_CUBE_MAP, Li, Ln);
      let en;
      if (En) {
        Bn &&
          Ni &&
          Gr.texStorage2D(Wr.TEXTURE_CUBE_MAP, cn, Ji, Hn.width, Hn.height);
        for (let ji = 0; ji < 6; ji++) {
          en = nn[ji].mipmaps;
          for (let sn = 0; sn < en.length; sn++) {
            const wn = en[sn];
            Li.format !== RGBAFormat
              ? An !== null
                ? Bn
                  ? Gr.compressedTexSubImage2D(
                      Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                      sn,
                      0,
                      0,
                      wn.width,
                      wn.height,
                      An,
                      wn.data
                    )
                  : Gr.compressedTexImage2D(
                      Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                      sn,
                      Ji,
                      wn.width,
                      wn.height,
                      0,
                      wn.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Bn
              ? Gr.texSubImage2D(
                  Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                  sn,
                  0,
                  0,
                  wn.width,
                  wn.height,
                  An,
                  Mn,
                  wn.data
                )
              : Gr.texImage2D(
                  Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                  sn,
                  Ji,
                  wn.width,
                  wn.height,
                  0,
                  An,
                  Mn,
                  wn.data
                );
          }
        }
      } else {
        (en = Li.mipmaps),
          Bn &&
            Ni &&
            (en.length > 0 && cn++,
            Gr.texStorage2D(
              Wr.TEXTURE_CUBE_MAP,
              cn,
              Ji,
              nn[0].width,
              nn[0].height
            ));
        for (let ji = 0; ji < 6; ji++)
          if (Vn) {
            Bn
              ? Gr.texSubImage2D(
                  Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                  0,
                  0,
                  0,
                  nn[ji].width,
                  nn[ji].height,
                  An,
                  Mn,
                  nn[ji].data
                )
              : Gr.texImage2D(
                  Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                  0,
                  Ji,
                  nn[ji].width,
                  nn[ji].height,
                  0,
                  An,
                  Mn,
                  nn[ji].data
                );
            for (let sn = 0; sn < en.length; sn++) {
              const dn = en[sn].image[ji].image;
              Bn
                ? Gr.texSubImage2D(
                    Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                    sn + 1,
                    0,
                    0,
                    dn.width,
                    dn.height,
                    An,
                    Mn,
                    dn.data
                  )
                : Gr.texImage2D(
                    Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                    sn + 1,
                    Ji,
                    dn.width,
                    dn.height,
                    0,
                    An,
                    Mn,
                    dn.data
                  );
            }
          } else {
            Bn
              ? Gr.texSubImage2D(
                  Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                  0,
                  0,
                  0,
                  An,
                  Mn,
                  nn[ji]
                )
              : Gr.texImage2D(
                  Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                  0,
                  Ji,
                  An,
                  Mn,
                  nn[ji]
                );
            for (let sn = 0; sn < en.length; sn++) {
              const wn = en[sn];
              Bn
                ? Gr.texSubImage2D(
                    Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                    sn + 1,
                    0,
                    0,
                    An,
                    Mn,
                    wn.image[ji]
                  )
                : Gr.texImage2D(
                    Wr.TEXTURE_CUBE_MAP_POSITIVE_X + ji,
                    sn + 1,
                    Ji,
                    An,
                    Mn,
                    wn.image[ji]
                  );
            }
          }
      }
      pi(Li, Ln) && mi(Wr.TEXTURE_CUBE_MAP),
        (Zi.__version = Ki.version),
        Li.onUpdate && Li.onUpdate(Li);
    }
    Di.__version = Li.version;
  }
  function un(Di, Li, Gi, Yi, Ki, Zi) {
    const _n = Zr.convert(Gi.format, Gi.colorSpace),
      tn = Zr.convert(Gi.type),
      fn = Si(Gi.internalFormat, _n, tn, Gi.colorSpace);
    if (!Yr.get(Li).__hasExternalTextures) {
      const Vn = Math.max(1, Li.width >> Zi),
        nn = Math.max(1, Li.height >> Zi);
      Ki === Wr.TEXTURE_3D || Ki === Wr.TEXTURE_2D_ARRAY
        ? Gr.texImage3D(Ki, Zi, fn, Vn, nn, Li.depth, 0, _n, tn, null)
        : Gr.texImage2D(Ki, Zi, fn, Vn, nn, 0, _n, tn, null);
    }
    Gr.bindFramebuffer(Wr.FRAMEBUFFER, Di),
      Dn(Li)
        ? ii.framebufferTexture2DMultisampleEXT(
            Wr.FRAMEBUFFER,
            Yi,
            Ki,
            Yr.get(Gi).__webglTexture,
            0,
            Sn(Li)
          )
        : (Ki === Wr.TEXTURE_2D ||
            (Ki >= Wr.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Ki <= Wr.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          Wr.framebufferTexture2D(
            Wr.FRAMEBUFFER,
            Yi,
            Ki,
            Yr.get(Gi).__webglTexture,
            Zi
          ),
      Gr.bindFramebuffer(Wr.FRAMEBUFFER, null);
  }
  function Vi(Di, Li, Gi) {
    if (
      (Wr.bindRenderbuffer(Wr.RENDERBUFFER, Di),
      Li.depthBuffer && !Li.stencilBuffer)
    ) {
      let Yi = Qr === !0 ? Wr.DEPTH_COMPONENT24 : Wr.DEPTH_COMPONENT16;
      if (Gi || Dn(Li)) {
        const Ki = Li.depthTexture;
        Ki &&
          Ki.isDepthTexture &&
          (Ki.type === FloatType
            ? (Yi = Wr.DEPTH_COMPONENT32F)
            : Ki.type === UnsignedIntType && (Yi = Wr.DEPTH_COMPONENT24));
        const Zi = Sn(Li);
        Dn(Li)
          ? ii.renderbufferStorageMultisampleEXT(
              Wr.RENDERBUFFER,
              Zi,
              Yi,
              Li.width,
              Li.height
            )
          : Wr.renderbufferStorageMultisample(
              Wr.RENDERBUFFER,
              Zi,
              Yi,
              Li.width,
              Li.height
            );
      } else Wr.renderbufferStorage(Wr.RENDERBUFFER, Yi, Li.width, Li.height);
      Wr.framebufferRenderbuffer(
        Wr.FRAMEBUFFER,
        Wr.DEPTH_ATTACHMENT,
        Wr.RENDERBUFFER,
        Di
      );
    } else if (Li.depthBuffer && Li.stencilBuffer) {
      const Yi = Sn(Li);
      Gi && Dn(Li) === !1
        ? Wr.renderbufferStorageMultisample(
            Wr.RENDERBUFFER,
            Yi,
            Wr.DEPTH24_STENCIL8,
            Li.width,
            Li.height
          )
        : Dn(Li)
        ? ii.renderbufferStorageMultisampleEXT(
            Wr.RENDERBUFFER,
            Yi,
            Wr.DEPTH24_STENCIL8,
            Li.width,
            Li.height
          )
        : Wr.renderbufferStorage(
            Wr.RENDERBUFFER,
            Wr.DEPTH_STENCIL,
            Li.width,
            Li.height
          ),
        Wr.framebufferRenderbuffer(
          Wr.FRAMEBUFFER,
          Wr.DEPTH_STENCIL_ATTACHMENT,
          Wr.RENDERBUFFER,
          Di
        );
    } else {
      const Yi =
        Li.isWebGLMultipleRenderTargets === !0 ? Li.texture : [Li.texture];
      for (let Ki = 0; Ki < Yi.length; Ki++) {
        const Zi = Yi[Ki],
          _n = Zr.convert(Zi.format, Zi.colorSpace),
          tn = Zr.convert(Zi.type),
          fn = Si(Zi.internalFormat, _n, tn, Zi.colorSpace),
          En = Sn(Li);
        Gi && Dn(Li) === !1
          ? Wr.renderbufferStorageMultisample(
              Wr.RENDERBUFFER,
              En,
              fn,
              Li.width,
              Li.height
            )
          : Dn(Li)
          ? ii.renderbufferStorageMultisampleEXT(
              Wr.RENDERBUFFER,
              En,
              fn,
              Li.width,
              Li.height
            )
          : Wr.renderbufferStorage(Wr.RENDERBUFFER, fn, Li.width, Li.height);
      }
    }
    Wr.bindRenderbuffer(Wr.RENDERBUFFER, null);
  }
  function rn(Di, Li) {
    if (Li && Li.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (Gr.bindFramebuffer(Wr.FRAMEBUFFER, Di),
      !(Li.depthTexture && Li.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!Yr.get(Li.depthTexture).__webglTexture ||
      Li.depthTexture.image.width !== Li.width ||
      Li.depthTexture.image.height !== Li.height) &&
      ((Li.depthTexture.image.width = Li.width),
      (Li.depthTexture.image.height = Li.height),
      (Li.depthTexture.needsUpdate = !0)),
      Ti(Li.depthTexture, 0);
    const Yi = Yr.get(Li.depthTexture).__webglTexture,
      Ki = Sn(Li);
    if (Li.depthTexture.format === DepthFormat)
      Dn(Li)
        ? ii.framebufferTexture2DMultisampleEXT(
            Wr.FRAMEBUFFER,
            Wr.DEPTH_ATTACHMENT,
            Wr.TEXTURE_2D,
            Yi,
            0,
            Ki
          )
        : Wr.framebufferTexture2D(
            Wr.FRAMEBUFFER,
            Wr.DEPTH_ATTACHMENT,
            Wr.TEXTURE_2D,
            Yi,
            0
          );
    else if (Li.depthTexture.format === DepthStencilFormat)
      Dn(Li)
        ? ii.framebufferTexture2DMultisampleEXT(
            Wr.FRAMEBUFFER,
            Wr.DEPTH_STENCIL_ATTACHMENT,
            Wr.TEXTURE_2D,
            Yi,
            0,
            Ki
          )
        : Wr.framebufferTexture2D(
            Wr.FRAMEBUFFER,
            Wr.DEPTH_STENCIL_ATTACHMENT,
            Wr.TEXTURE_2D,
            Yi,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function qi(Di) {
    const Li = Yr.get(Di),
      Gi = Di.isWebGLCubeRenderTarget === !0;
    if (Di.depthTexture && !Li.__autoAllocateDepthBuffer) {
      if (Gi)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      rn(Li.__webglFramebuffer, Di);
    } else if (Gi) {
      Li.__webglDepthbuffer = [];
      for (let Yi = 0; Yi < 6; Yi++)
        Gr.bindFramebuffer(Wr.FRAMEBUFFER, Li.__webglFramebuffer[Yi]),
          (Li.__webglDepthbuffer[Yi] = Wr.createRenderbuffer()),
          Vi(Li.__webglDepthbuffer[Yi], Di, !1);
    } else
      Gr.bindFramebuffer(Wr.FRAMEBUFFER, Li.__webglFramebuffer),
        (Li.__webglDepthbuffer = Wr.createRenderbuffer()),
        Vi(Li.__webglDepthbuffer, Di, !1);
    Gr.bindFramebuffer(Wr.FRAMEBUFFER, null);
  }
  function pn(Di, Li, Gi) {
    const Yi = Yr.get(Di);
    Li !== void 0 &&
      un(
        Yi.__webglFramebuffer,
        Di,
        Di.texture,
        Wr.COLOR_ATTACHMENT0,
        Wr.TEXTURE_2D,
        0
      ),
      Gi !== void 0 && qi(Di);
  }
  function vn(Di) {
    const Li = Di.texture,
      Gi = Yr.get(Di),
      Yi = Yr.get(Li);
    Di.addEventListener("dispose", Ai),
      Di.isWebGLMultipleRenderTargets !== !0 &&
        (Yi.__webglTexture === void 0 &&
          (Yi.__webglTexture = Wr.createTexture()),
        (Yi.__version = Li.version),
        Jr.memory.textures++);
    const Ki = Di.isWebGLCubeRenderTarget === !0,
      Zi = Di.isWebGLMultipleRenderTargets === !0,
      _n = fi(Di) || Qr;
    if (Ki) {
      Gi.__webglFramebuffer = [];
      for (let tn = 0; tn < 6; tn++)
        if (Qr && Li.mipmaps && Li.mipmaps.length > 0) {
          Gi.__webglFramebuffer[tn] = [];
          for (let fn = 0; fn < Li.mipmaps.length; fn++)
            Gi.__webglFramebuffer[tn][fn] = Wr.createFramebuffer();
        } else Gi.__webglFramebuffer[tn] = Wr.createFramebuffer();
    } else {
      if (Qr && Li.mipmaps && Li.mipmaps.length > 0) {
        Gi.__webglFramebuffer = [];
        for (let tn = 0; tn < Li.mipmaps.length; tn++)
          Gi.__webglFramebuffer[tn] = Wr.createFramebuffer();
      } else Gi.__webglFramebuffer = Wr.createFramebuffer();
      if (Zi)
        if (Kr.drawBuffers) {
          const tn = Di.texture;
          for (let fn = 0, En = tn.length; fn < En; fn++) {
            const Vn = Yr.get(tn[fn]);
            Vn.__webglTexture === void 0 &&
              ((Vn.__webglTexture = Wr.createTexture()), Jr.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (Qr && Di.samples > 0 && Dn(Di) === !1) {
        const tn = Zi ? Li : [Li];
        (Gi.__webglMultisampledFramebuffer = Wr.createFramebuffer()),
          (Gi.__webglColorRenderbuffer = []),
          Gr.bindFramebuffer(Wr.FRAMEBUFFER, Gi.__webglMultisampledFramebuffer);
        for (let fn = 0; fn < tn.length; fn++) {
          const En = tn[fn];
          (Gi.__webglColorRenderbuffer[fn] = Wr.createRenderbuffer()),
            Wr.bindRenderbuffer(
              Wr.RENDERBUFFER,
              Gi.__webglColorRenderbuffer[fn]
            );
          const Vn = Zr.convert(En.format, En.colorSpace),
            nn = Zr.convert(En.type),
            Hn = Si(
              En.internalFormat,
              Vn,
              nn,
              En.colorSpace,
              Di.isXRRenderTarget === !0
            ),
            Ln = Sn(Di);
          Wr.renderbufferStorageMultisample(
            Wr.RENDERBUFFER,
            Ln,
            Hn,
            Di.width,
            Di.height
          ),
            Wr.framebufferRenderbuffer(
              Wr.FRAMEBUFFER,
              Wr.COLOR_ATTACHMENT0 + fn,
              Wr.RENDERBUFFER,
              Gi.__webglColorRenderbuffer[fn]
            );
        }
        Wr.bindRenderbuffer(Wr.RENDERBUFFER, null),
          Di.depthBuffer &&
            ((Gi.__webglDepthRenderbuffer = Wr.createRenderbuffer()),
            Vi(Gi.__webglDepthRenderbuffer, Di, !0)),
          Gr.bindFramebuffer(Wr.FRAMEBUFFER, null);
      }
    }
    if (Ki) {
      Gr.bindTexture(Wr.TEXTURE_CUBE_MAP, Yi.__webglTexture),
        an(Wr.TEXTURE_CUBE_MAP, Li, _n);
      for (let tn = 0; tn < 6; tn++)
        if (Qr && Li.mipmaps && Li.mipmaps.length > 0)
          for (let fn = 0; fn < Li.mipmaps.length; fn++)
            un(
              Gi.__webglFramebuffer[tn][fn],
              Di,
              Li,
              Wr.COLOR_ATTACHMENT0,
              Wr.TEXTURE_CUBE_MAP_POSITIVE_X + tn,
              fn
            );
        else
          un(
            Gi.__webglFramebuffer[tn],
            Di,
            Li,
            Wr.COLOR_ATTACHMENT0,
            Wr.TEXTURE_CUBE_MAP_POSITIVE_X + tn,
            0
          );
      pi(Li, _n) && mi(Wr.TEXTURE_CUBE_MAP), Gr.unbindTexture();
    } else if (Zi) {
      const tn = Di.texture;
      for (let fn = 0, En = tn.length; fn < En; fn++) {
        const Vn = tn[fn],
          nn = Yr.get(Vn);
        Gr.bindTexture(Wr.TEXTURE_2D, nn.__webglTexture),
          an(Wr.TEXTURE_2D, Vn, _n),
          un(
            Gi.__webglFramebuffer,
            Di,
            Vn,
            Wr.COLOR_ATTACHMENT0 + fn,
            Wr.TEXTURE_2D,
            0
          ),
          pi(Vn, _n) && mi(Wr.TEXTURE_2D);
      }
      Gr.unbindTexture();
    } else {
      let tn = Wr.TEXTURE_2D;
      if (
        ((Di.isWebGL3DRenderTarget || Di.isWebGLArrayRenderTarget) &&
          (Qr
            ? (tn = Di.isWebGL3DRenderTarget
                ? Wr.TEXTURE_3D
                : Wr.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        Gr.bindTexture(tn, Yi.__webglTexture),
        an(tn, Li, _n),
        Qr && Li.mipmaps && Li.mipmaps.length > 0)
      )
        for (let fn = 0; fn < Li.mipmaps.length; fn++)
          un(Gi.__webglFramebuffer[fn], Di, Li, Wr.COLOR_ATTACHMENT0, tn, fn);
      else un(Gi.__webglFramebuffer, Di, Li, Wr.COLOR_ATTACHMENT0, tn, 0);
      pi(Li, _n) && mi(tn), Gr.unbindTexture();
    }
    Di.depthBuffer && qi(Di);
  }
  function zi(Di) {
    const Li = fi(Di) || Qr,
      Gi = Di.isWebGLMultipleRenderTargets === !0 ? Di.texture : [Di.texture];
    for (let Yi = 0, Ki = Gi.length; Yi < Ki; Yi++) {
      const Zi = Gi[Yi];
      if (pi(Zi, Li)) {
        const _n = Di.isWebGLCubeRenderTarget
            ? Wr.TEXTURE_CUBE_MAP
            : Wr.TEXTURE_2D,
          tn = Yr.get(Zi).__webglTexture;
        Gr.bindTexture(_n, tn), mi(_n), Gr.unbindTexture();
      }
    }
  }
  function mn(Di) {
    if (Qr && Di.samples > 0 && Dn(Di) === !1) {
      const Li = Di.isWebGLMultipleRenderTargets ? Di.texture : [Di.texture],
        Gi = Di.width,
        Yi = Di.height;
      let Ki = Wr.COLOR_BUFFER_BIT;
      const Zi = [],
        _n = Di.stencilBuffer
          ? Wr.DEPTH_STENCIL_ATTACHMENT
          : Wr.DEPTH_ATTACHMENT,
        tn = Yr.get(Di),
        fn = Di.isWebGLMultipleRenderTargets === !0;
      if (fn)
        for (let En = 0; En < Li.length; En++)
          Gr.bindFramebuffer(Wr.FRAMEBUFFER, tn.__webglMultisampledFramebuffer),
            Wr.framebufferRenderbuffer(
              Wr.FRAMEBUFFER,
              Wr.COLOR_ATTACHMENT0 + En,
              Wr.RENDERBUFFER,
              null
            ),
            Gr.bindFramebuffer(Wr.FRAMEBUFFER, tn.__webglFramebuffer),
            Wr.framebufferTexture2D(
              Wr.DRAW_FRAMEBUFFER,
              Wr.COLOR_ATTACHMENT0 + En,
              Wr.TEXTURE_2D,
              null,
              0
            );
      Gr.bindFramebuffer(
        Wr.READ_FRAMEBUFFER,
        tn.__webglMultisampledFramebuffer
      ),
        Gr.bindFramebuffer(Wr.DRAW_FRAMEBUFFER, tn.__webglFramebuffer);
      for (let En = 0; En < Li.length; En++) {
        Zi.push(Wr.COLOR_ATTACHMENT0 + En), Di.depthBuffer && Zi.push(_n);
        const Vn =
          tn.__ignoreDepthValues !== void 0 ? tn.__ignoreDepthValues : !1;
        if (
          (Vn === !1 &&
            (Di.depthBuffer && (Ki |= Wr.DEPTH_BUFFER_BIT),
            Di.stencilBuffer && (Ki |= Wr.STENCIL_BUFFER_BIT)),
          fn &&
            Wr.framebufferRenderbuffer(
              Wr.READ_FRAMEBUFFER,
              Wr.COLOR_ATTACHMENT0,
              Wr.RENDERBUFFER,
              tn.__webglColorRenderbuffer[En]
            ),
          Vn === !0 &&
            (Wr.invalidateFramebuffer(Wr.READ_FRAMEBUFFER, [_n]),
            Wr.invalidateFramebuffer(Wr.DRAW_FRAMEBUFFER, [_n])),
          fn)
        ) {
          const nn = Yr.get(Li[En]).__webglTexture;
          Wr.framebufferTexture2D(
            Wr.DRAW_FRAMEBUFFER,
            Wr.COLOR_ATTACHMENT0,
            Wr.TEXTURE_2D,
            nn,
            0
          );
        }
        Wr.blitFramebuffer(0, 0, Gi, Yi, 0, 0, Gi, Yi, Ki, Wr.NEAREST),
          si && Wr.invalidateFramebuffer(Wr.READ_FRAMEBUFFER, Zi);
      }
      if (
        (Gr.bindFramebuffer(Wr.READ_FRAMEBUFFER, null),
        Gr.bindFramebuffer(Wr.DRAW_FRAMEBUFFER, null),
        fn)
      )
        for (let En = 0; En < Li.length; En++) {
          Gr.bindFramebuffer(Wr.FRAMEBUFFER, tn.__webglMultisampledFramebuffer),
            Wr.framebufferRenderbuffer(
              Wr.FRAMEBUFFER,
              Wr.COLOR_ATTACHMENT0 + En,
              Wr.RENDERBUFFER,
              tn.__webglColorRenderbuffer[En]
            );
          const Vn = Yr.get(Li[En]).__webglTexture;
          Gr.bindFramebuffer(Wr.FRAMEBUFFER, tn.__webglFramebuffer),
            Wr.framebufferTexture2D(
              Wr.DRAW_FRAMEBUFFER,
              Wr.COLOR_ATTACHMENT0 + En,
              Wr.TEXTURE_2D,
              Vn,
              0
            );
        }
      Gr.bindFramebuffer(
        Wr.DRAW_FRAMEBUFFER,
        tn.__webglMultisampledFramebuffer
      );
    }
  }
  function Sn(Di) {
    return Math.min(ni, Di.samples);
  }
  function Dn(Di) {
    const Li = Yr.get(Di);
    return (
      Qr &&
      Di.samples > 0 &&
      ze.has("WEBGL_multisampled_render_to_texture") === !0 &&
      Li.__useRenderToTexture !== !1
    );
  }
  function Cn(Di) {
    const Li = Jr.render.frame;
    li.get(Di) !== Li && (li.set(Di, Li), Di.update());
  }
  function $n(Di, Li) {
    const Gi = Di.colorSpace,
      Yi = Di.format,
      Ki = Di.type;
    return (
      Di.isCompressedTexture === !0 ||
        Di.isVideoTexture === !0 ||
        Di.format === _SRGBAFormat ||
        (Gi !== LinearSRGBColorSpace &&
          Gi !== NoColorSpace &&
          (ColorManagement.getTransfer(Gi) === SRGBTransfer
            ? Qr === !1
              ? ze.has("EXT_sRGB") === !0 && Yi === RGBAFormat
                ? ((Di.format = _SRGBAFormat),
                  (Di.minFilter = LinearFilter),
                  (Di.generateMipmaps = !1))
                : (Li = ImageUtils.sRGBToLinear(Li))
              : (Yi !== RGBAFormat || Ki !== UnsignedByteType) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                Gi
              ))),
      Li
    );
  }
  (this.allocateTextureUnit = gi),
    (this.resetTextureUnits = Mi),
    (this.setTexture2D = Ti),
    (this.setTexture2DArray = vi),
    (this.setTexture3D = Ii),
    (this.setTextureCube = Oi),
    (this.rebindTextures = pn),
    (this.setupRenderTarget = vn),
    (this.updateRenderTargetMipmap = zi),
    (this.updateMultisampleRenderTarget = mn),
    (this.setupDepthRenderbuffer = qi),
    (this.setupFrameBufferTexture = un),
    (this.useMultisampledRTT = Dn);
}
function WebGLUtils(Wr, ze, Gr) {
  const Yr = Gr.isWebGL2;
  function Kr(Zr, Jr = NoColorSpace) {
    let Qr;
    const ei = ColorManagement.getTransfer(Jr);
    if (Zr === UnsignedByteType) return Wr.UNSIGNED_BYTE;
    if (Zr === UnsignedShort4444Type) return Wr.UNSIGNED_SHORT_4_4_4_4;
    if (Zr === UnsignedShort5551Type) return Wr.UNSIGNED_SHORT_5_5_5_1;
    if (Zr === ByteType) return Wr.BYTE;
    if (Zr === ShortType) return Wr.SHORT;
    if (Zr === UnsignedShortType) return Wr.UNSIGNED_SHORT;
    if (Zr === IntType) return Wr.INT;
    if (Zr === UnsignedIntType) return Wr.UNSIGNED_INT;
    if (Zr === FloatType) return Wr.FLOAT;
    if (Zr === HalfFloatType)
      return Yr
        ? Wr.HALF_FLOAT
        : ((Qr = ze.get("OES_texture_half_float")),
          Qr !== null ? Qr.HALF_FLOAT_OES : null);
    if (Zr === AlphaFormat) return Wr.ALPHA;
    if (Zr === RGBAFormat) return Wr.RGBA;
    if (Zr === LuminanceFormat) return Wr.LUMINANCE;
    if (Zr === LuminanceAlphaFormat) return Wr.LUMINANCE_ALPHA;
    if (Zr === DepthFormat) return Wr.DEPTH_COMPONENT;
    if (Zr === DepthStencilFormat) return Wr.DEPTH_STENCIL;
    if (Zr === _SRGBAFormat)
      return (Qr = ze.get("EXT_sRGB")), Qr !== null ? Qr.SRGB_ALPHA_EXT : null;
    if (Zr === RedFormat) return Wr.RED;
    if (Zr === RedIntegerFormat) return Wr.RED_INTEGER;
    if (Zr === RGFormat) return Wr.RG;
    if (Zr === RGIntegerFormat) return Wr.RG_INTEGER;
    if (Zr === RGBAIntegerFormat) return Wr.RGBA_INTEGER;
    if (
      Zr === RGB_S3TC_DXT1_Format ||
      Zr === RGBA_S3TC_DXT1_Format ||
      Zr === RGBA_S3TC_DXT3_Format ||
      Zr === RGBA_S3TC_DXT5_Format
    )
      if (ei === SRGBTransfer)
        if (
          ((Qr = ze.get("WEBGL_compressed_texture_s3tc_srgb")), Qr !== null)
        ) {
          if (Zr === RGB_S3TC_DXT1_Format)
            return Qr.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (Zr === RGBA_S3TC_DXT1_Format)
            return Qr.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (Zr === RGBA_S3TC_DXT3_Format)
            return Qr.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (Zr === RGBA_S3TC_DXT5_Format)
            return Qr.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((Qr = ze.get("WEBGL_compressed_texture_s3tc")), Qr !== null)) {
        if (Zr === RGB_S3TC_DXT1_Format) return Qr.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (Zr === RGBA_S3TC_DXT1_Format)
          return Qr.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (Zr === RGBA_S3TC_DXT3_Format)
          return Qr.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (Zr === RGBA_S3TC_DXT5_Format)
          return Qr.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (
      Zr === RGB_PVRTC_4BPPV1_Format ||
      Zr === RGB_PVRTC_2BPPV1_Format ||
      Zr === RGBA_PVRTC_4BPPV1_Format ||
      Zr === RGBA_PVRTC_2BPPV1_Format
    )
      if (((Qr = ze.get("WEBGL_compressed_texture_pvrtc")), Qr !== null)) {
        if (Zr === RGB_PVRTC_4BPPV1_Format)
          return Qr.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (Zr === RGB_PVRTC_2BPPV1_Format)
          return Qr.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (Zr === RGBA_PVRTC_4BPPV1_Format)
          return Qr.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (Zr === RGBA_PVRTC_2BPPV1_Format)
          return Qr.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (Zr === RGB_ETC1_Format)
      return (
        (Qr = ze.get("WEBGL_compressed_texture_etc1")),
        Qr !== null ? Qr.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (Zr === RGB_ETC2_Format || Zr === RGBA_ETC2_EAC_Format)
      if (((Qr = ze.get("WEBGL_compressed_texture_etc")), Qr !== null)) {
        if (Zr === RGB_ETC2_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ETC2
            : Qr.COMPRESSED_RGB8_ETC2;
        if (Zr === RGBA_ETC2_EAC_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : Qr.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      Zr === RGBA_ASTC_4x4_Format ||
      Zr === RGBA_ASTC_5x4_Format ||
      Zr === RGBA_ASTC_5x5_Format ||
      Zr === RGBA_ASTC_6x5_Format ||
      Zr === RGBA_ASTC_6x6_Format ||
      Zr === RGBA_ASTC_8x5_Format ||
      Zr === RGBA_ASTC_8x6_Format ||
      Zr === RGBA_ASTC_8x8_Format ||
      Zr === RGBA_ASTC_10x5_Format ||
      Zr === RGBA_ASTC_10x6_Format ||
      Zr === RGBA_ASTC_10x8_Format ||
      Zr === RGBA_ASTC_10x10_Format ||
      Zr === RGBA_ASTC_12x10_Format ||
      Zr === RGBA_ASTC_12x12_Format
    )
      if (((Qr = ze.get("WEBGL_compressed_texture_astc")), Qr !== null)) {
        if (Zr === RGBA_ASTC_4x4_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : Qr.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (Zr === RGBA_ASTC_5x4_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : Qr.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (Zr === RGBA_ASTC_5x5_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : Qr.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (Zr === RGBA_ASTC_6x5_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : Qr.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (Zr === RGBA_ASTC_6x6_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : Qr.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (Zr === RGBA_ASTC_8x5_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : Qr.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (Zr === RGBA_ASTC_8x6_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : Qr.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (Zr === RGBA_ASTC_8x8_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : Qr.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (Zr === RGBA_ASTC_10x5_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : Qr.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (Zr === RGBA_ASTC_10x6_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : Qr.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (Zr === RGBA_ASTC_10x8_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : Qr.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (Zr === RGBA_ASTC_10x10_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : Qr.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (Zr === RGBA_ASTC_12x10_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : Qr.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (Zr === RGBA_ASTC_12x12_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : Qr.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (
      Zr === RGBA_BPTC_Format ||
      Zr === RGB_BPTC_SIGNED_Format ||
      Zr === RGB_BPTC_UNSIGNED_Format
    )
      if (((Qr = ze.get("EXT_texture_compression_bptc")), Qr !== null)) {
        if (Zr === RGBA_BPTC_Format)
          return ei === SRGBTransfer
            ? Qr.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : Qr.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (Zr === RGB_BPTC_SIGNED_Format)
          return Qr.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (Zr === RGB_BPTC_UNSIGNED_Format)
          return Qr.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (
      Zr === RED_RGTC1_Format ||
      Zr === SIGNED_RED_RGTC1_Format ||
      Zr === RED_GREEN_RGTC2_Format ||
      Zr === SIGNED_RED_GREEN_RGTC2_Format
    )
      if (((Qr = ze.get("EXT_texture_compression_rgtc")), Qr !== null)) {
        if (Zr === RGBA_BPTC_Format) return Qr.COMPRESSED_RED_RGTC1_EXT;
        if (Zr === SIGNED_RED_RGTC1_Format)
          return Qr.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (Zr === RED_GREEN_RGTC2_Format)
          return Qr.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (Zr === SIGNED_RED_GREEN_RGTC2_Format)
          return Qr.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return Zr === UnsignedInt248Type
      ? Yr
        ? Wr.UNSIGNED_INT_24_8
        : ((Qr = ze.get("WEBGL_depth_texture")),
          Qr !== null ? Qr.UNSIGNED_INT_24_8_WEBGL : null)
      : Wr[Zr] !== void 0
      ? Wr[Zr]
      : null;
  }
  return {
    convert: Kr,
  };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(ze = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = ze);
  }
}
class Group extends Object3D {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const _moveEvent = {
  type: "move",
};
class WebXRController {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Group()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = {
          pinching: !1,
        })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Group()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Vector3()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Vector3())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Group()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Vector3()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Vector3())),
      this._grip
    );
  }
  dispatchEvent(ze) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(ze),
      this._grip !== null && this._grip.dispatchEvent(ze),
      this._hand !== null && this._hand.dispatchEvent(ze),
      this
    );
  }
  connect(ze) {
    if (ze && ze.hand) {
      const Gr = this._hand;
      if (Gr) for (const Yr of ze.hand.values()) this._getHandJoint(Gr, Yr);
    }
    return (
      this.dispatchEvent({
        type: "connected",
        data: ze,
      }),
      this
    );
  }
  disconnect(ze) {
    return (
      this.dispatchEvent({
        type: "disconnected",
        data: ze,
      }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(ze, Gr, Yr) {
    let Kr = null,
      Zr = null,
      Jr = null;
    const Qr = this._targetRay,
      ei = this._grip,
      ti = this._hand;
    if (ze && Gr.session.visibilityState !== "visible-blurred") {
      if (ti && ze.hand) {
        Jr = !0;
        for (const oi of ze.hand.values()) {
          const ui = Gr.getJointPose(oi, Yr),
            ai = this._getHandJoint(ti, oi);
          ui !== null &&
            (ai.matrix.fromArray(ui.transform.matrix),
            ai.matrix.decompose(ai.position, ai.rotation, ai.scale),
            (ai.matrixWorldNeedsUpdate = !0),
            (ai.jointRadius = ui.radius)),
            (ai.visible = ui !== null);
        }
        const ri = ti.joints["index-finger-tip"],
          ni = ti.joints["thumb-tip"],
          ii = ri.position.distanceTo(ni.position),
          si = 0.02,
          li = 0.005;
        ti.inputState.pinching && ii > si + li
          ? ((ti.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: ze.handedness,
              target: this,
            }))
          : !ti.inputState.pinching &&
            ii <= si - li &&
            ((ti.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: ze.handedness,
              target: this,
            }));
      } else
        ei !== null &&
          ze.gripSpace &&
          ((Zr = Gr.getPose(ze.gripSpace, Yr)),
          Zr !== null &&
            (ei.matrix.fromArray(Zr.transform.matrix),
            ei.matrix.decompose(ei.position, ei.rotation, ei.scale),
            (ei.matrixWorldNeedsUpdate = !0),
            Zr.linearVelocity
              ? ((ei.hasLinearVelocity = !0),
                ei.linearVelocity.copy(Zr.linearVelocity))
              : (ei.hasLinearVelocity = !1),
            Zr.angularVelocity
              ? ((ei.hasAngularVelocity = !0),
                ei.angularVelocity.copy(Zr.angularVelocity))
              : (ei.hasAngularVelocity = !1)));
      Qr !== null &&
        ((Kr = Gr.getPose(ze.targetRaySpace, Yr)),
        Kr === null && Zr !== null && (Kr = Zr),
        Kr !== null &&
          (Qr.matrix.fromArray(Kr.transform.matrix),
          Qr.matrix.decompose(Qr.position, Qr.rotation, Qr.scale),
          (Qr.matrixWorldNeedsUpdate = !0),
          Kr.linearVelocity
            ? ((Qr.hasLinearVelocity = !0),
              Qr.linearVelocity.copy(Kr.linearVelocity))
            : (Qr.hasLinearVelocity = !1),
          Kr.angularVelocity
            ? ((Qr.hasAngularVelocity = !0),
              Qr.angularVelocity.copy(Kr.angularVelocity))
            : (Qr.hasAngularVelocity = !1),
          this.dispatchEvent(_moveEvent)));
    }
    return (
      Qr !== null && (Qr.visible = Kr !== null),
      ei !== null && (ei.visible = Zr !== null),
      ti !== null && (ti.visible = Jr !== null),
      this
    );
  }
  _getHandJoint(ze, Gr) {
    if (ze.joints[Gr.jointName] === void 0) {
      const Yr = new Group();
      (Yr.matrixAutoUpdate = !1),
        (Yr.visible = !1),
        (ze.joints[Gr.jointName] = Yr),
        ze.add(Yr);
    }
    return ze.joints[Gr.jointName];
  }
}
class DepthTexture extends Texture {
  constructor(ze, Gr, Yr, Kr, Zr, Jr, Qr, ei, ti, ri) {
    if (
      ((ri = ri !== void 0 ? ri : DepthFormat),
      ri !== DepthFormat && ri !== DepthStencilFormat)
    )
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    Yr === void 0 && ri === DepthFormat && (Yr = UnsignedIntType),
      Yr === void 0 && ri === DepthStencilFormat && (Yr = UnsignedInt248Type),
      super(null, Kr, Zr, Jr, Qr, ei, ri, Yr, ti),
      (this.isDepthTexture = !0),
      (this.image = {
        width: ze,
        height: Gr,
      }),
      (this.magFilter = Qr !== void 0 ? Qr : NearestFilter),
      (this.minFilter = ei !== void 0 ? ei : NearestFilter),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(ze) {
    return super.copy(ze), (this.compareFunction = ze.compareFunction), this;
  }
  toJSON(ze) {
    const Gr = super.toJSON(ze);
    return (
      this.compareFunction !== null &&
        (Gr.compareFunction = this.compareFunction),
      Gr
    );
  }
}
class WebXRManager extends EventDispatcher {
  constructor(ze, Gr) {
    super();
    const Yr = this;
    let Kr = null,
      Zr = 1,
      Jr = null,
      Qr = "local-floor",
      ei = 1,
      ti = null,
      ri = null,
      ni = null,
      ii = null,
      si = null,
      li = null;
    const oi = Gr.getContextAttributes();
    let ui = null,
      ai = null;
    const hi = [],
      ci = [],
      fi = new PerspectiveCamera();
    fi.layers.enable(1), (fi.viewport = new Vector4());
    const di = new PerspectiveCamera();
    di.layers.enable(2), (di.viewport = new Vector4());
    const pi = [fi, di],
      mi = new ArrayCamera();
    mi.layers.enable(1), mi.layers.enable(2);
    let Si = null,
      yi = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (vi) {
        let Ii = hi[vi];
        return (
          Ii === void 0 && ((Ii = new WebXRController()), (hi[vi] = Ii)),
          Ii.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (vi) {
        let Ii = hi[vi];
        return (
          Ii === void 0 && ((Ii = new WebXRController()), (hi[vi] = Ii)),
          Ii.getGripSpace()
        );
      }),
      (this.getHand = function (vi) {
        let Ii = hi[vi];
        return (
          Ii === void 0 && ((Ii = new WebXRController()), (hi[vi] = Ii)),
          Ii.getHandSpace()
        );
      });
    function Ei(vi) {
      const Ii = ci.indexOf(vi.inputSource);
      if (Ii === -1) return;
      const Oi = hi[Ii];
      Oi !== void 0 &&
        (Oi.update(vi.inputSource, vi.frame, ti || Jr),
        Oi.dispatchEvent({
          type: vi.type,
          data: vi.inputSource,
        }));
    }
    function Pi() {
      Kr.removeEventListener("select", Ei),
        Kr.removeEventListener("selectstart", Ei),
        Kr.removeEventListener("selectend", Ei),
        Kr.removeEventListener("squeeze", Ei),
        Kr.removeEventListener("squeezestart", Ei),
        Kr.removeEventListener("squeezeend", Ei),
        Kr.removeEventListener("end", Pi),
        Kr.removeEventListener("inputsourceschange", Ai);
      for (let vi = 0; vi < hi.length; vi++) {
        const Ii = ci[vi];
        Ii !== null && ((ci[vi] = null), hi[vi].disconnect(Ii));
      }
      (Si = null),
        (yi = null),
        ze.setRenderTarget(ui),
        (si = null),
        (ii = null),
        (ni = null),
        (Kr = null),
        (ai = null),
        Ti.stop(),
        (Yr.isPresenting = !1),
        Yr.dispatchEvent({
          type: "sessionend",
        });
    }
    (this.setFramebufferScaleFactor = function (vi) {
      (Zr = vi),
        Yr.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (vi) {
        (Qr = vi),
          Yr.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return ti || Jr;
      }),
      (this.setReferenceSpace = function (vi) {
        ti = vi;
      }),
      (this.getBaseLayer = function () {
        return ii !== null ? ii : si;
      }),
      (this.getBinding = function () {
        return ni;
      }),
      (this.getFrame = function () {
        return li;
      }),
      (this.getSession = function () {
        return Kr;
      }),
      (this.setSession = async function (vi) {
        if (((Kr = vi), Kr !== null)) {
          if (
            ((ui = ze.getRenderTarget()),
            Kr.addEventListener("select", Ei),
            Kr.addEventListener("selectstart", Ei),
            Kr.addEventListener("selectend", Ei),
            Kr.addEventListener("squeeze", Ei),
            Kr.addEventListener("squeezestart", Ei),
            Kr.addEventListener("squeezeend", Ei),
            Kr.addEventListener("end", Pi),
            Kr.addEventListener("inputsourceschange", Ai),
            oi.xrCompatible !== !0 && (await Gr.makeXRCompatible()),
            Kr.renderState.layers === void 0 || ze.capabilities.isWebGL2 === !1)
          ) {
            const Ii = {
              antialias: Kr.renderState.layers === void 0 ? oi.antialias : !0,
              alpha: !0,
              depth: oi.depth,
              stencil: oi.stencil,
              framebufferScaleFactor: Zr,
            };
            (si = new XRWebGLLayer(Kr, Gr, Ii)),
              Kr.updateRenderState({
                baseLayer: si,
              }),
              (ai = new WebGLRenderTarget(
                si.framebufferWidth,
                si.framebufferHeight,
                {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  colorSpace: ze.outputColorSpace,
                  stencilBuffer: oi.stencil,
                }
              ));
          } else {
            let Ii = null,
              Oi = null,
              ki = null;
            oi.depth &&
              ((ki = oi.stencil ? Gr.DEPTH24_STENCIL8 : Gr.DEPTH_COMPONENT24),
              (Ii = oi.stencil ? DepthStencilFormat : DepthFormat),
              (Oi = oi.stencil ? UnsignedInt248Type : UnsignedIntType));
            const Bi = {
              colorFormat: Gr.RGBA8,
              depthFormat: ki,
              scaleFactor: Zr,
            };
            (ni = new XRWebGLBinding(Kr, Gr)),
              (ii = ni.createProjectionLayer(Bi)),
              Kr.updateRenderState({
                layers: [ii],
              }),
              (ai = new WebGLRenderTarget(ii.textureWidth, ii.textureHeight, {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(
                  ii.textureWidth,
                  ii.textureHeight,
                  Oi,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Ii
                ),
                stencilBuffer: oi.stencil,
                colorSpace: ze.outputColorSpace,
                samples: oi.antialias ? 4 : 0,
              }));
            const Xi = ze.properties.get(ai);
            Xi.__ignoreDepthValues = ii.ignoreDepthValues;
          }
          (ai.isXRRenderTarget = !0),
            this.setFoveation(ei),
            (ti = null),
            (Jr = await Kr.requestReferenceSpace(Qr)),
            Ti.setContext(Kr),
            Ti.start(),
            (Yr.isPresenting = !0),
            Yr.dispatchEvent({
              type: "sessionstart",
            });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (Kr !== null) return Kr.environmentBlendMode;
      });
    function Ai(vi) {
      for (let Ii = 0; Ii < vi.removed.length; Ii++) {
        const Oi = vi.removed[Ii],
          ki = ci.indexOf(Oi);
        ki >= 0 && ((ci[ki] = null), hi[ki].disconnect(Oi));
      }
      for (let Ii = 0; Ii < vi.added.length; Ii++) {
        const Oi = vi.added[Ii];
        let ki = ci.indexOf(Oi);
        if (ki === -1) {
          for (let Xi = 0; Xi < hi.length; Xi++)
            if (Xi >= ci.length) {
              ci.push(Oi), (ki = Xi);
              break;
            } else if (ci[Xi] === null) {
              (ci[Xi] = Oi), (ki = Xi);
              break;
            }
          if (ki === -1) break;
        }
        const Bi = hi[ki];
        Bi && Bi.connect(Oi);
      }
    }
    const Ri = new Vector3(),
      wi = new Vector3();
    function Ci(vi, Ii, Oi) {
      Ri.setFromMatrixPosition(Ii.matrixWorld),
        wi.setFromMatrixPosition(Oi.matrixWorld);
      const ki = Ri.distanceTo(wi),
        Bi = Ii.projectionMatrix.elements,
        Xi = Oi.projectionMatrix.elements,
        an = Bi[14] / (Bi[10] - 1),
        Qi = Bi[14] / (Bi[10] + 1),
        ln = (Bi[9] + 1) / Bi[5],
        yn = (Bi[9] - 1) / Bi[5],
        un = (Bi[8] - 1) / Bi[0],
        Vi = (Xi[8] + 1) / Xi[0],
        rn = an * un,
        qi = an * Vi,
        pn = ki / (-un + Vi),
        vn = pn * -un;
      Ii.matrixWorld.decompose(vi.position, vi.quaternion, vi.scale),
        vi.translateX(vn),
        vi.translateZ(pn),
        vi.matrixWorld.compose(vi.position, vi.quaternion, vi.scale),
        vi.matrixWorldInverse.copy(vi.matrixWorld).invert();
      const zi = an + pn,
        mn = Qi + pn,
        Sn = rn - vn,
        Dn = qi + (ki - vn),
        Cn = ((ln * Qi) / mn) * zi,
        $n = ((yn * Qi) / mn) * zi;
      vi.projectionMatrix.makePerspective(Sn, Dn, Cn, $n, zi, mn),
        vi.projectionMatrixInverse.copy(vi.projectionMatrix).invert();
    }
    function bi(vi, Ii) {
      Ii === null
        ? vi.matrixWorld.copy(vi.matrix)
        : vi.matrixWorld.multiplyMatrices(Ii.matrixWorld, vi.matrix),
        vi.matrixWorldInverse.copy(vi.matrixWorld).invert();
    }
    this.updateCamera = function (vi) {
      if (Kr === null) return;
      (mi.near = di.near = fi.near = vi.near),
        (mi.far = di.far = fi.far = vi.far),
        (Si !== mi.near || yi !== mi.far) &&
          (Kr.updateRenderState({
            depthNear: mi.near,
            depthFar: mi.far,
          }),
          (Si = mi.near),
          (yi = mi.far));
      const Ii = vi.parent,
        Oi = mi.cameras;
      bi(mi, Ii);
      for (let ki = 0; ki < Oi.length; ki++) bi(Oi[ki], Ii);
      Oi.length === 2
        ? Ci(mi, fi, di)
        : mi.projectionMatrix.copy(fi.projectionMatrix),
        Mi(vi, mi, Ii);
    };
    function Mi(vi, Ii, Oi) {
      Oi === null
        ? vi.matrix.copy(Ii.matrixWorld)
        : (vi.matrix.copy(Oi.matrixWorld),
          vi.matrix.invert(),
          vi.matrix.multiply(Ii.matrixWorld)),
        vi.matrix.decompose(vi.position, vi.quaternion, vi.scale),
        vi.updateMatrixWorld(!0),
        vi.projectionMatrix.copy(Ii.projectionMatrix),
        vi.projectionMatrixInverse.copy(Ii.projectionMatrixInverse),
        vi.isPerspectiveCamera &&
          ((vi.fov =
            RAD2DEG * 2 * Math.atan(1 / vi.projectionMatrix.elements[5])),
          (vi.zoom = 1));
    }
    (this.getCamera = function () {
      return mi;
    }),
      (this.getFoveation = function () {
        if (!(ii === null && si === null)) return ei;
      }),
      (this.setFoveation = function (vi) {
        (ei = vi),
          ii !== null && (ii.fixedFoveation = vi),
          si !== null &&
            si.fixedFoveation !== void 0 &&
            (si.fixedFoveation = vi);
      });
    let gi = null;
    function xi(vi, Ii) {
      if (((ri = Ii.getViewerPose(ti || Jr)), (li = Ii), ri !== null)) {
        const Oi = ri.views;
        si !== null &&
          (ze.setRenderTargetFramebuffer(ai, si.framebuffer),
          ze.setRenderTarget(ai));
        let ki = !1;
        Oi.length !== mi.cameras.length && ((mi.cameras.length = 0), (ki = !0));
        for (let Bi = 0; Bi < Oi.length; Bi++) {
          const Xi = Oi[Bi];
          let an = null;
          if (si !== null) an = si.getViewport(Xi);
          else {
            const ln = ni.getViewSubImage(ii, Xi);
            (an = ln.viewport),
              Bi === 0 &&
                (ze.setRenderTargetTextures(
                  ai,
                  ln.colorTexture,
                  ii.ignoreDepthValues ? void 0 : ln.depthStencilTexture
                ),
                ze.setRenderTarget(ai));
          }
          let Qi = pi[Bi];
          Qi === void 0 &&
            ((Qi = new PerspectiveCamera()),
            Qi.layers.enable(Bi),
            (Qi.viewport = new Vector4()),
            (pi[Bi] = Qi)),
            Qi.matrix.fromArray(Xi.transform.matrix),
            Qi.matrix.decompose(Qi.position, Qi.quaternion, Qi.scale),
            Qi.projectionMatrix.fromArray(Xi.projectionMatrix),
            Qi.projectionMatrixInverse.copy(Qi.projectionMatrix).invert(),
            Qi.viewport.set(an.x, an.y, an.width, an.height),
            Bi === 0 &&
              (mi.matrix.copy(Qi.matrix),
              mi.matrix.decompose(mi.position, mi.quaternion, mi.scale)),
            ki === !0 && mi.cameras.push(Qi);
        }
      }
      for (let Oi = 0; Oi < hi.length; Oi++) {
        const ki = ci[Oi],
          Bi = hi[Oi];
        ki !== null && Bi !== void 0 && Bi.update(ki, Ii, ti || Jr);
      }
      gi && gi(vi, Ii),
        Ii.detectedPlanes &&
          Yr.dispatchEvent({
            type: "planesdetected",
            data: Ii,
          }),
        (li = null);
    }
    const Ti = new WebGLAnimation();
    Ti.setAnimationLoop(xi),
      (this.setAnimationLoop = function (vi) {
        gi = vi;
      }),
      (this.dispose = function () {});
  }
}
function WebGLMaterials(Wr, ze) {
  function Gr(ui, ai) {
    ui.matrixAutoUpdate === !0 && ui.updateMatrix(), ai.value.copy(ui.matrix);
  }
  function Yr(ui, ai) {
    ai.color.getRGB(ui.fogColor.value, getUnlitUniformColorSpace(Wr)),
      ai.isFog
        ? ((ui.fogNear.value = ai.near), (ui.fogFar.value = ai.far))
        : ai.isFogExp2 && (ui.fogDensity.value = ai.density);
  }
  function Kr(ui, ai, hi, ci, fi) {
    ai.isMeshBasicMaterial || ai.isMeshLambertMaterial
      ? Zr(ui, ai)
      : ai.isMeshToonMaterial
      ? (Zr(ui, ai), ni(ui, ai))
      : ai.isMeshPhongMaterial
      ? (Zr(ui, ai), ri(ui, ai))
      : ai.isMeshStandardMaterial
      ? (Zr(ui, ai), ii(ui, ai), ai.isMeshPhysicalMaterial && si(ui, ai, fi))
      : ai.isMeshMatcapMaterial
      ? (Zr(ui, ai), li(ui, ai))
      : ai.isMeshDepthMaterial
      ? Zr(ui, ai)
      : ai.isMeshDistanceMaterial
      ? (Zr(ui, ai), oi(ui, ai))
      : ai.isMeshNormalMaterial
      ? Zr(ui, ai)
      : ai.isLineBasicMaterial
      ? (Jr(ui, ai), ai.isLineDashedMaterial && Qr(ui, ai))
      : ai.isPointsMaterial
      ? ei(ui, ai, hi, ci)
      : ai.isSpriteMaterial
      ? ti(ui, ai)
      : ai.isShadowMaterial
      ? (ui.color.value.copy(ai.color), (ui.opacity.value = ai.opacity))
      : ai.isShaderMaterial && (ai.uniformsNeedUpdate = !1);
  }
  function Zr(ui, ai) {
    (ui.opacity.value = ai.opacity),
      ai.color && ui.diffuse.value.copy(ai.color),
      ai.emissive &&
        ui.emissive.value
          .copy(ai.emissive)
          .multiplyScalar(ai.emissiveIntensity),
      ai.map && ((ui.map.value = ai.map), Gr(ai.map, ui.mapTransform)),
      ai.alphaMap &&
        ((ui.alphaMap.value = ai.alphaMap),
        Gr(ai.alphaMap, ui.alphaMapTransform)),
      ai.bumpMap &&
        ((ui.bumpMap.value = ai.bumpMap),
        Gr(ai.bumpMap, ui.bumpMapTransform),
        (ui.bumpScale.value = ai.bumpScale),
        ai.side === BackSide && (ui.bumpScale.value *= -1)),
      ai.normalMap &&
        ((ui.normalMap.value = ai.normalMap),
        Gr(ai.normalMap, ui.normalMapTransform),
        ui.normalScale.value.copy(ai.normalScale),
        ai.side === BackSide && ui.normalScale.value.negate()),
      ai.displacementMap &&
        ((ui.displacementMap.value = ai.displacementMap),
        Gr(ai.displacementMap, ui.displacementMapTransform),
        (ui.displacementScale.value = ai.displacementScale),
        (ui.displacementBias.value = ai.displacementBias)),
      ai.emissiveMap &&
        ((ui.emissiveMap.value = ai.emissiveMap),
        Gr(ai.emissiveMap, ui.emissiveMapTransform)),
      ai.specularMap &&
        ((ui.specularMap.value = ai.specularMap),
        Gr(ai.specularMap, ui.specularMapTransform)),
      ai.alphaTest > 0 && (ui.alphaTest.value = ai.alphaTest);
    const hi = ze.get(ai).envMap;
    if (
      (hi &&
        ((ui.envMap.value = hi),
        (ui.flipEnvMap.value =
          hi.isCubeTexture && hi.isRenderTargetTexture === !1 ? -1 : 1),
        (ui.reflectivity.value = ai.reflectivity),
        (ui.ior.value = ai.ior),
        (ui.refractionRatio.value = ai.refractionRatio)),
      ai.lightMap)
    ) {
      ui.lightMap.value = ai.lightMap;
      const ci = Wr._useLegacyLights === !0 ? Math.PI : 1;
      (ui.lightMapIntensity.value = ai.lightMapIntensity * ci),
        Gr(ai.lightMap, ui.lightMapTransform);
    }
    ai.aoMap &&
      ((ui.aoMap.value = ai.aoMap),
      (ui.aoMapIntensity.value = ai.aoMapIntensity),
      Gr(ai.aoMap, ui.aoMapTransform));
  }
  function Jr(ui, ai) {
    ui.diffuse.value.copy(ai.color),
      (ui.opacity.value = ai.opacity),
      ai.map && ((ui.map.value = ai.map), Gr(ai.map, ui.mapTransform));
  }
  function Qr(ui, ai) {
    (ui.dashSize.value = ai.dashSize),
      (ui.totalSize.value = ai.dashSize + ai.gapSize),
      (ui.scale.value = ai.scale);
  }
  function ei(ui, ai, hi, ci) {
    ui.diffuse.value.copy(ai.color),
      (ui.opacity.value = ai.opacity),
      (ui.size.value = ai.size * hi),
      (ui.scale.value = ci * 0.5),
      ai.map && ((ui.map.value = ai.map), Gr(ai.map, ui.uvTransform)),
      ai.alphaMap &&
        ((ui.alphaMap.value = ai.alphaMap),
        Gr(ai.alphaMap, ui.alphaMapTransform)),
      ai.alphaTest > 0 && (ui.alphaTest.value = ai.alphaTest);
  }
  function ti(ui, ai) {
    ui.diffuse.value.copy(ai.color),
      (ui.opacity.value = ai.opacity),
      (ui.rotation.value = ai.rotation),
      ai.map && ((ui.map.value = ai.map), Gr(ai.map, ui.mapTransform)),
      ai.alphaMap &&
        ((ui.alphaMap.value = ai.alphaMap),
        Gr(ai.alphaMap, ui.alphaMapTransform)),
      ai.alphaTest > 0 && (ui.alphaTest.value = ai.alphaTest);
  }
  function ri(ui, ai) {
    ui.specular.value.copy(ai.specular),
      (ui.shininess.value = Math.max(ai.shininess, 1e-4));
  }
  function ni(ui, ai) {
    ai.gradientMap && (ui.gradientMap.value = ai.gradientMap);
  }
  function ii(ui, ai) {
    (ui.metalness.value = ai.metalness),
      ai.metalnessMap &&
        ((ui.metalnessMap.value = ai.metalnessMap),
        Gr(ai.metalnessMap, ui.metalnessMapTransform)),
      (ui.roughness.value = ai.roughness),
      ai.roughnessMap &&
        ((ui.roughnessMap.value = ai.roughnessMap),
        Gr(ai.roughnessMap, ui.roughnessMapTransform)),
      ze.get(ai).envMap && (ui.envMapIntensity.value = ai.envMapIntensity);
  }
  function si(ui, ai, hi) {
    (ui.ior.value = ai.ior),
      ai.sheen > 0 &&
        (ui.sheenColor.value.copy(ai.sheenColor).multiplyScalar(ai.sheen),
        (ui.sheenRoughness.value = ai.sheenRoughness),
        ai.sheenColorMap &&
          ((ui.sheenColorMap.value = ai.sheenColorMap),
          Gr(ai.sheenColorMap, ui.sheenColorMapTransform)),
        ai.sheenRoughnessMap &&
          ((ui.sheenRoughnessMap.value = ai.sheenRoughnessMap),
          Gr(ai.sheenRoughnessMap, ui.sheenRoughnessMapTransform))),
      ai.clearcoat > 0 &&
        ((ui.clearcoat.value = ai.clearcoat),
        (ui.clearcoatRoughness.value = ai.clearcoatRoughness),
        ai.clearcoatMap &&
          ((ui.clearcoatMap.value = ai.clearcoatMap),
          Gr(ai.clearcoatMap, ui.clearcoatMapTransform)),
        ai.clearcoatRoughnessMap &&
          ((ui.clearcoatRoughnessMap.value = ai.clearcoatRoughnessMap),
          Gr(ai.clearcoatRoughnessMap, ui.clearcoatRoughnessMapTransform)),
        ai.clearcoatNormalMap &&
          ((ui.clearcoatNormalMap.value = ai.clearcoatNormalMap),
          Gr(ai.clearcoatNormalMap, ui.clearcoatNormalMapTransform),
          ui.clearcoatNormalScale.value.copy(ai.clearcoatNormalScale),
          ai.side === BackSide && ui.clearcoatNormalScale.value.negate())),
      ai.iridescence > 0 &&
        ((ui.iridescence.value = ai.iridescence),
        (ui.iridescenceIOR.value = ai.iridescenceIOR),
        (ui.iridescenceThicknessMinimum.value =
          ai.iridescenceThicknessRange[0]),
        (ui.iridescenceThicknessMaximum.value =
          ai.iridescenceThicknessRange[1]),
        ai.iridescenceMap &&
          ((ui.iridescenceMap.value = ai.iridescenceMap),
          Gr(ai.iridescenceMap, ui.iridescenceMapTransform)),
        ai.iridescenceThicknessMap &&
          ((ui.iridescenceThicknessMap.value = ai.iridescenceThicknessMap),
          Gr(ai.iridescenceThicknessMap, ui.iridescenceThicknessMapTransform))),
      ai.transmission > 0 &&
        ((ui.transmission.value = ai.transmission),
        (ui.transmissionSamplerMap.value = hi.texture),
        ui.transmissionSamplerSize.value.set(hi.width, hi.height),
        ai.transmissionMap &&
          ((ui.transmissionMap.value = ai.transmissionMap),
          Gr(ai.transmissionMap, ui.transmissionMapTransform)),
        (ui.thickness.value = ai.thickness),
        ai.thicknessMap &&
          ((ui.thicknessMap.value = ai.thicknessMap),
          Gr(ai.thicknessMap, ui.thicknessMapTransform)),
        (ui.attenuationDistance.value = ai.attenuationDistance),
        ui.attenuationColor.value.copy(ai.attenuationColor)),
      ai.anisotropy > 0 &&
        (ui.anisotropyVector.value.set(
          ai.anisotropy * Math.cos(ai.anisotropyRotation),
          ai.anisotropy * Math.sin(ai.anisotropyRotation)
        ),
        ai.anisotropyMap &&
          ((ui.anisotropyMap.value = ai.anisotropyMap),
          Gr(ai.anisotropyMap, ui.anisotropyMapTransform))),
      (ui.specularIntensity.value = ai.specularIntensity),
      ui.specularColor.value.copy(ai.specularColor),
      ai.specularColorMap &&
        ((ui.specularColorMap.value = ai.specularColorMap),
        Gr(ai.specularColorMap, ui.specularColorMapTransform)),
      ai.specularIntensityMap &&
        ((ui.specularIntensityMap.value = ai.specularIntensityMap),
        Gr(ai.specularIntensityMap, ui.specularIntensityMapTransform));
  }
  function li(ui, ai) {
    ai.matcap && (ui.matcap.value = ai.matcap);
  }
  function oi(ui, ai) {
    const hi = ze.get(ai).light;
    ui.referencePosition.value.setFromMatrixPosition(hi.matrixWorld),
      (ui.nearDistance.value = hi.shadow.camera.near),
      (ui.farDistance.value = hi.shadow.camera.far);
  }
  return {
    refreshFogUniforms: Yr,
    refreshMaterialUniforms: Kr,
  };
}
function WebGLUniformsGroups(Wr, ze, Gr, Yr) {
  let Kr = {},
    Zr = {},
    Jr = [];
  const Qr = Gr.isWebGL2 ? Wr.getParameter(Wr.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function ei(hi, ci) {
    const fi = ci.program;
    Yr.uniformBlockBinding(hi, fi);
  }
  function ti(hi, ci) {
    let fi = Kr[hi.id];
    fi === void 0 &&
      (li(hi),
      (fi = ri(hi)),
      (Kr[hi.id] = fi),
      hi.addEventListener("dispose", ui));
    const di = ci.program;
    Yr.updateUBOMapping(hi, di);
    const pi = ze.render.frame;
    Zr[hi.id] !== pi && (ii(hi), (Zr[hi.id] = pi));
  }
  function ri(hi) {
    const ci = ni();
    hi.__bindingPointIndex = ci;
    const fi = Wr.createBuffer(),
      di = hi.__size,
      pi = hi.usage;
    return (
      Wr.bindBuffer(Wr.UNIFORM_BUFFER, fi),
      Wr.bufferData(Wr.UNIFORM_BUFFER, di, pi),
      Wr.bindBuffer(Wr.UNIFORM_BUFFER, null),
      Wr.bindBufferBase(Wr.UNIFORM_BUFFER, ci, fi),
      fi
    );
  }
  function ni() {
    for (let hi = 0; hi < Qr; hi++)
      if (Jr.indexOf(hi) === -1) return Jr.push(hi), hi;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function ii(hi) {
    const ci = Kr[hi.id],
      fi = hi.uniforms,
      di = hi.__cache;
    Wr.bindBuffer(Wr.UNIFORM_BUFFER, ci);
    for (let pi = 0, mi = fi.length; pi < mi; pi++) {
      const Si = fi[pi];
      if (si(Si, pi, di) === !0) {
        const yi = Si.__offset,
          Ei = Array.isArray(Si.value) ? Si.value : [Si.value];
        let Pi = 0;
        for (let Ai = 0; Ai < Ei.length; Ai++) {
          const Ri = Ei[Ai],
            wi = oi(Ri);
          typeof Ri == "number"
            ? ((Si.__data[0] = Ri),
              Wr.bufferSubData(Wr.UNIFORM_BUFFER, yi + Pi, Si.__data))
            : Ri.isMatrix3
            ? ((Si.__data[0] = Ri.elements[0]),
              (Si.__data[1] = Ri.elements[1]),
              (Si.__data[2] = Ri.elements[2]),
              (Si.__data[3] = Ri.elements[0]),
              (Si.__data[4] = Ri.elements[3]),
              (Si.__data[5] = Ri.elements[4]),
              (Si.__data[6] = Ri.elements[5]),
              (Si.__data[7] = Ri.elements[0]),
              (Si.__data[8] = Ri.elements[6]),
              (Si.__data[9] = Ri.elements[7]),
              (Si.__data[10] = Ri.elements[8]),
              (Si.__data[11] = Ri.elements[0]))
            : (Ri.toArray(Si.__data, Pi),
              (Pi += wi.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        Wr.bufferSubData(Wr.UNIFORM_BUFFER, yi, Si.__data);
      }
    }
    Wr.bindBuffer(Wr.UNIFORM_BUFFER, null);
  }
  function si(hi, ci, fi) {
    const di = hi.value;
    if (fi[ci] === void 0) {
      if (typeof di == "number") fi[ci] = di;
      else {
        const pi = Array.isArray(di) ? di : [di],
          mi = [];
        for (let Si = 0; Si < pi.length; Si++) mi.push(pi[Si].clone());
        fi[ci] = mi;
      }
      return !0;
    } else if (typeof di == "number") {
      if (fi[ci] !== di) return (fi[ci] = di), !0;
    } else {
      const pi = Array.isArray(fi[ci]) ? fi[ci] : [fi[ci]],
        mi = Array.isArray(di) ? di : [di];
      for (let Si = 0; Si < pi.length; Si++) {
        const yi = pi[Si];
        if (yi.equals(mi[Si]) === !1) return yi.copy(mi[Si]), !0;
      }
    }
    return !1;
  }
  function li(hi) {
    const ci = hi.uniforms;
    let fi = 0;
    const di = 16;
    let pi = 0;
    for (let mi = 0, Si = ci.length; mi < Si; mi++) {
      const yi = ci[mi],
        Ei = {
          boundary: 0,
          storage: 0,
        },
        Pi = Array.isArray(yi.value) ? yi.value : [yi.value];
      for (let Ai = 0, Ri = Pi.length; Ai < Ri; Ai++) {
        const wi = Pi[Ai],
          Ci = oi(wi);
        (Ei.boundary += Ci.boundary), (Ei.storage += Ci.storage);
      }
      if (
        ((yi.__data = new Float32Array(
          Ei.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (yi.__offset = fi),
        mi > 0)
      ) {
        pi = fi % di;
        const Ai = di - pi;
        pi !== 0 &&
          Ai - Ei.boundary < 0 &&
          ((fi += di - pi), (yi.__offset = fi));
      }
      fi += Ei.storage;
    }
    return (
      (pi = fi % di),
      pi > 0 && (fi += di - pi),
      (hi.__size = fi),
      (hi.__cache = {}),
      this
    );
  }
  function oi(hi) {
    const ci = {
      boundary: 0,
      storage: 0,
    };
    return (
      typeof hi == "number"
        ? ((ci.boundary = 4), (ci.storage = 4))
        : hi.isVector2
        ? ((ci.boundary = 8), (ci.storage = 8))
        : hi.isVector3 || hi.isColor
        ? ((ci.boundary = 16), (ci.storage = 12))
        : hi.isVector4
        ? ((ci.boundary = 16), (ci.storage = 16))
        : hi.isMatrix3
        ? ((ci.boundary = 48), (ci.storage = 48))
        : hi.isMatrix4
        ? ((ci.boundary = 64), (ci.storage = 64))
        : hi.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            hi
          ),
      ci
    );
  }
  function ui(hi) {
    const ci = hi.target;
    ci.removeEventListener("dispose", ui);
    const fi = Jr.indexOf(ci.__bindingPointIndex);
    Jr.splice(fi, 1),
      Wr.deleteBuffer(Kr[ci.id]),
      delete Kr[ci.id],
      delete Zr[ci.id];
  }
  function ai() {
    for (const hi in Kr) Wr.deleteBuffer(Kr[hi]);
    (Jr = []), (Kr = {}), (Zr = {});
  }
  return {
    bind: ei,
    update: ti,
    dispose: ai,
  };
}
class WebGLRenderer {
  constructor(ze = {}) {
    const {
      canvas: Gr = createCanvasElement(),
      context: Yr = null,
      depth: Kr = !0,
      stencil: Zr = !0,
      alpha: Jr = !1,
      antialias: Qr = !1,
      premultipliedAlpha: ei = !0,
      preserveDrawingBuffer: ti = !1,
      powerPreference: ri = "default",
      failIfMajorPerformanceCaveat: ni = !1,
    } = ze;
    this.isWebGLRenderer = !0;
    let ii;
    Yr !== null ? (ii = Yr.getContextAttributes().alpha) : (ii = Jr);
    const si = new Uint32Array(4),
      li = new Int32Array(4);
    let oi = null,
      ui = null;
    const ai = [],
      hi = [];
    (this.domElement = Gr),
      (this.debug = {
        checkShaderErrors: !0,
        onShaderError: null,
      }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = SRGBColorSpace),
      (this._useLegacyLights = !1),
      (this.toneMapping = NoToneMapping),
      (this.toneMappingExposure = 1);
    const ci = this;
    let fi = !1,
      di = 0,
      pi = 0,
      mi = null,
      Si = -1,
      yi = null;
    const Ei = new Vector4(),
      Pi = new Vector4();
    let Ai = null;
    const Ri = new Color(0);
    let wi = 0,
      Ci = Gr.width,
      bi = Gr.height,
      Mi = 1,
      gi = null,
      xi = null;
    const Ti = new Vector4(0, 0, Ci, bi),
      vi = new Vector4(0, 0, Ci, bi);
    let Ii = !1;
    const Oi = new Frustum();
    let ki = !1,
      Bi = !1,
      Xi = null;
    const an = new Matrix4(),
      Qi = new Vector2(),
      ln = new Vector3(),
      yn = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function un() {
      return mi === null ? Mi : 1;
    }
    let Vi = Yr;
    function rn(Fi, Ui) {
      for (let Hi = 0; Hi < Fi.length; Hi++) {
        const Wi = Fi[Hi],
          $i = Gr.getContext(Wi, Ui);
        if ($i !== null) return $i;
      }
      return null;
    }
    try {
      const Fi = {
        alpha: !0,
        depth: Kr,
        stencil: Zr,
        antialias: Qr,
        premultipliedAlpha: ei,
        preserveDrawingBuffer: ti,
        powerPreference: ri,
        failIfMajorPerformanceCaveat: ni,
      };
      if (
        ("setAttribute" in Gr &&
          Gr.setAttribute("data-engine", `three.js r${REVISION}`),
        Gr.addEventListener("webglcontextlost", Bn, !1),
        Gr.addEventListener("webglcontextrestored", Ni, !1),
        Gr.addEventListener("webglcontextcreationerror", cn, !1),
        Vi === null)
      ) {
        const Ui = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (ci.isWebGL1Renderer === !0 && Ui.shift(),
          (Vi = rn(Ui, Fi)),
          Vi === null)
        )
          throw rn(Ui)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        Vi instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        Vi.getShaderPrecisionFormat === void 0 &&
          (Vi.getShaderPrecisionFormat = function () {
            return {
              rangeMin: 1,
              rangeMax: 1,
              precision: 1,
            };
          });
    } catch (Fi) {
      throw (console.error("THREE.WebGLRenderer: " + Fi.message), Fi);
    }
    let qi,
      pn,
      vn,
      zi,
      mn,
      Sn,
      Dn,
      Cn,
      $n,
      Di,
      Li,
      Gi,
      Yi,
      Ki,
      Zi,
      _n,
      tn,
      fn,
      En,
      Vn,
      nn,
      Hn,
      Ln,
      An;
    function Mn() {
      (qi = new WebGLExtensions(Vi)),
        (pn = new WebGLCapabilities(Vi, qi, ze)),
        qi.init(pn),
        (Hn = new WebGLUtils(Vi, qi, pn)),
        (vn = new WebGLState(Vi, qi, pn)),
        (zi = new WebGLInfo(Vi)),
        (mn = new WebGLProperties()),
        (Sn = new WebGLTextures(Vi, qi, vn, mn, pn, Hn, zi)),
        (Dn = new WebGLCubeMaps(ci)),
        (Cn = new WebGLCubeUVMaps(ci)),
        ($n = new WebGLAttributes(Vi, pn)),
        (Ln = new WebGLBindingStates(Vi, qi, $n, pn)),
        (Di = new WebGLGeometries(Vi, $n, zi, Ln)),
        (Li = new WebGLObjects(Vi, Di, $n, zi)),
        (En = new WebGLMorphtargets(Vi, pn, Sn)),
        (_n = new WebGLClipping(mn)),
        (Gi = new WebGLPrograms(ci, Dn, Cn, qi, pn, Ln, _n)),
        (Yi = new WebGLMaterials(ci, mn)),
        (Ki = new WebGLRenderLists()),
        (Zi = new WebGLRenderStates(qi, pn)),
        (fn = new WebGLBackground(ci, Dn, Cn, vn, Li, ii, ei)),
        (tn = new WebGLShadowMap(ci, Li, pn)),
        (An = new WebGLUniformsGroups(Vi, zi, pn, vn)),
        (Vn = new WebGLBufferRenderer(Vi, qi, zi, pn)),
        (nn = new WebGLIndexedBufferRenderer(Vi, qi, zi, pn)),
        (zi.programs = Gi.programs),
        (ci.capabilities = pn),
        (ci.extensions = qi),
        (ci.properties = mn),
        (ci.renderLists = Ki),
        (ci.shadowMap = tn),
        (ci.state = vn),
        (ci.info = zi);
    }
    Mn();
    const Ji = new WebXRManager(ci, Vi);
    (this.xr = Ji),
      (this.getContext = function () {
        return Vi;
      }),
      (this.getContextAttributes = function () {
        return Vi.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const Fi = qi.get("WEBGL_lose_context");
        Fi && Fi.loseContext();
      }),
      (this.forceContextRestore = function () {
        const Fi = qi.get("WEBGL_lose_context");
        Fi && Fi.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Mi;
      }),
      (this.setPixelRatio = function (Fi) {
        Fi !== void 0 && ((Mi = Fi), this.setSize(Ci, bi, !1));
      }),
      (this.getSize = function (Fi) {
        return Fi.set(Ci, bi);
      }),
      (this.setSize = function (Fi, Ui, Hi = !0) {
        if (Ji.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Ci = Fi),
          (bi = Ui),
          (Gr.width = Math.floor(Fi * Mi)),
          (Gr.height = Math.floor(Ui * Mi)),
          Hi === !0 &&
            ((Gr.style.width = Fi + "px"), (Gr.style.height = Ui + "px")),
          this.setViewport(0, 0, Fi, Ui);
      }),
      (this.getDrawingBufferSize = function (Fi) {
        return Fi.set(Ci * Mi, bi * Mi).floor();
      }),
      (this.setDrawingBufferSize = function (Fi, Ui, Hi) {
        (Ci = Fi),
          (bi = Ui),
          (Mi = Hi),
          (Gr.width = Math.floor(Fi * Hi)),
          (Gr.height = Math.floor(Ui * Hi)),
          this.setViewport(0, 0, Fi, Ui);
      }),
      (this.getCurrentViewport = function (Fi) {
        return Fi.copy(Ei);
      }),
      (this.getViewport = function (Fi) {
        return Fi.copy(Ti);
      }),
      (this.setViewport = function (Fi, Ui, Hi, Wi) {
        Fi.isVector4 ? Ti.set(Fi.x, Fi.y, Fi.z, Fi.w) : Ti.set(Fi, Ui, Hi, Wi),
          vn.viewport(Ei.copy(Ti).multiplyScalar(Mi).floor());
      }),
      (this.getScissor = function (Fi) {
        return Fi.copy(vi);
      }),
      (this.setScissor = function (Fi, Ui, Hi, Wi) {
        Fi.isVector4 ? vi.set(Fi.x, Fi.y, Fi.z, Fi.w) : vi.set(Fi, Ui, Hi, Wi),
          vn.scissor(Pi.copy(vi).multiplyScalar(Mi).floor());
      }),
      (this.getScissorTest = function () {
        return Ii;
      }),
      (this.setScissorTest = function (Fi) {
        vn.setScissorTest((Ii = Fi));
      }),
      (this.setOpaqueSort = function (Fi) {
        gi = Fi;
      }),
      (this.setTransparentSort = function (Fi) {
        xi = Fi;
      }),
      (this.getClearColor = function (Fi) {
        return Fi.copy(fn.getClearColor());
      }),
      (this.setClearColor = function () {
        fn.setClearColor.apply(fn, arguments);
      }),
      (this.getClearAlpha = function () {
        return fn.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        fn.setClearAlpha.apply(fn, arguments);
      }),
      (this.clear = function (Fi = !0, Ui = !0, Hi = !0) {
        let Wi = 0;
        if (Fi) {
          let $i = !1;
          if (mi !== null) {
            const on = mi.texture.format;
            $i =
              on === RGBAIntegerFormat ||
              on === RGIntegerFormat ||
              on === RedIntegerFormat;
          }
          if ($i) {
            const on = mi.texture.type,
              xn =
                on === UnsignedByteType ||
                on === UnsignedIntType ||
                on === UnsignedShortType ||
                on === UnsignedInt248Type ||
                on === UnsignedShort4444Type ||
                on === UnsignedShort5551Type,
              Pn = fn.getClearColor(),
              bn = fn.getClearAlpha(),
              Tn = Pn.r,
              Rn = Pn.g,
              kn = Pn.b;
            xn
              ? ((si[0] = Tn),
                (si[1] = Rn),
                (si[2] = kn),
                (si[3] = bn),
                Vi.clearBufferuiv(Vi.COLOR, 0, si))
              : ((li[0] = Tn),
                (li[1] = Rn),
                (li[2] = kn),
                (li[3] = bn),
                Vi.clearBufferiv(Vi.COLOR, 0, li));
          } else Wi |= Vi.COLOR_BUFFER_BIT;
        }
        Ui && (Wi |= Vi.DEPTH_BUFFER_BIT),
          Hi &&
            ((Wi |= Vi.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          Vi.clear(Wi);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        Gr.removeEventListener("webglcontextlost", Bn, !1),
          Gr.removeEventListener("webglcontextrestored", Ni, !1),
          Gr.removeEventListener("webglcontextcreationerror", cn, !1),
          Ki.dispose(),
          Zi.dispose(),
          mn.dispose(),
          Dn.dispose(),
          Cn.dispose(),
          Li.dispose(),
          Ln.dispose(),
          An.dispose(),
          Gi.dispose(),
          Ji.dispose(),
          Ji.removeEventListener("sessionstart", Nn),
          Ji.removeEventListener("sessionend", Fn),
          Xi && (Xi.dispose(), (Xi = null)),
          hn.stop();
      });
    function Bn(Fi) {
      Fi.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (fi = !0);
    }
    function Ni() {
      console.log("THREE.WebGLRenderer: Context Restored."), (fi = !1);
      const Fi = zi.autoReset,
        Ui = tn.enabled,
        Hi = tn.autoUpdate,
        Wi = tn.needsUpdate,
        $i = tn.type;
      Mn(),
        (zi.autoReset = Fi),
        (tn.enabled = Ui),
        (tn.autoUpdate = Hi),
        (tn.needsUpdate = Wi),
        (tn.type = $i);
    }
    function cn(Fi) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        Fi.statusMessage
      );
    }
    function en(Fi) {
      const Ui = Fi.target;
      Ui.removeEventListener("dispose", en), ji(Ui);
    }
    function ji(Fi) {
      sn(Fi), mn.remove(Fi);
    }
    function sn(Fi) {
      const Ui = mn.get(Fi).programs;
      Ui !== void 0 &&
        (Ui.forEach(function (Hi) {
          Gi.releaseProgram(Hi);
        }),
        Fi.isShaderMaterial && Gi.releaseShaderCache(Fi));
    }
    this.renderBufferDirect = function (Fi, Ui, Hi, Wi, $i, on) {
      Ui === null && (Ui = yn);
      const xn = $i.isMesh && $i.matrixWorld.determinant() < 0,
        Pn = Yn(Fi, Ui, Hi, Wi, $i);
      vn.setMaterial(Wi, xn);
      let bn = Hi.index,
        Tn = 1;
      if (Wi.wireframe === !0) {
        if (((bn = Di.getWireframeAttribute(Hi)), bn === void 0)) return;
        Tn = 2;
      }
      const Rn = Hi.drawRange,
        kn = Hi.attributes.position;
      let Kn = Rn.start * Tn,
        es = (Rn.start + Rn.count) * Tn;
      on !== null &&
        ((Kn = Math.max(Kn, on.start * Tn)),
        (es = Math.min(es, (on.start + on.count) * Tn))),
        bn !== null
          ? ((Kn = Math.max(Kn, 0)), (es = Math.min(es, bn.count)))
          : kn != null &&
            ((Kn = Math.max(Kn, 0)), (es = Math.min(es, kn.count)));
      const qn = es - Kn;
      if (qn < 0 || qn === 1 / 0) return;
      Ln.setup($i, Wi, Pn, Hi, bn);
      let rs,
        jn = Vn;
      if (
        (bn !== null && ((rs = $n.get(bn)), (jn = nn), jn.setIndex(rs)),
        $i.isMesh)
      )
        Wi.wireframe === !0
          ? (vn.setLineWidth(Wi.wireframeLinewidth * un()),
            jn.setMode(Vi.LINES))
          : jn.setMode(Vi.TRIANGLES);
      else if ($i.isLine) {
        let Un = Wi.linewidth;
        Un === void 0 && (Un = 1),
          vn.setLineWidth(Un * un()),
          $i.isLineSegments
            ? jn.setMode(Vi.LINES)
            : $i.isLineLoop
            ? jn.setMode(Vi.LINE_LOOP)
            : jn.setMode(Vi.LINE_STRIP);
      } else
        $i.isPoints
          ? jn.setMode(Vi.POINTS)
          : $i.isSprite && jn.setMode(Vi.TRIANGLES);
      if ($i.isInstancedMesh) jn.renderInstances(Kn, qn, $i.count);
      else if (Hi.isInstancedBufferGeometry) {
        const Un =
            Hi._maxInstanceCount !== void 0 ? Hi._maxInstanceCount : 1 / 0,
          cs = Math.min(Hi.instanceCount, Un);
        jn.renderInstances(Kn, qn, cs);
      } else jn.render(Kn, qn);
    };
    function wn(Fi, Ui, Hi) {
      Fi.transparent === !0 &&
      Fi.side === DoubleSide &&
      Fi.forceSinglePass === !1
        ? ((Fi.side = BackSide),
          (Fi.needsUpdate = !0),
          Xn(Fi, Ui, Hi),
          (Fi.side = FrontSide),
          (Fi.needsUpdate = !0),
          Xn(Fi, Ui, Hi),
          (Fi.side = DoubleSide))
        : Xn(Fi, Ui, Hi);
    }
    (this.compile = function (Fi, Ui, Hi = null) {
      Hi === null && (Hi = Fi),
        (ui = Zi.get(Hi)),
        ui.init(),
        hi.push(ui),
        Hi.traverseVisible(function ($i) {
          $i.isLight &&
            $i.layers.test(Ui.layers) &&
            (ui.pushLight($i), $i.castShadow && ui.pushShadow($i));
        }),
        Fi !== Hi &&
          Fi.traverseVisible(function ($i) {
            $i.isLight &&
              $i.layers.test(Ui.layers) &&
              (ui.pushLight($i), $i.castShadow && ui.pushShadow($i));
          }),
        ui.setupLights(ci._useLegacyLights);
      const Wi = new Set();
      return (
        Fi.traverse(function ($i) {
          const on = $i.material;
          if (on)
            if (Array.isArray(on))
              for (let xn = 0; xn < on.length; xn++) {
                const Pn = on[xn];
                wn(Pn, Hi, $i), Wi.add(Pn);
              }
            else wn(on, Hi, $i), Wi.add(on);
        }),
        hi.pop(),
        (ui = null),
        Wi
      );
    }),
      (this.compileAsync = function (Fi, Ui, Hi = null) {
        const Wi = this.compile(Fi, Ui, Hi);
        return new Promise(($i) => {
          function on() {
            if (
              (Wi.forEach(function (xn) {
                mn.get(xn).currentProgram.isReady() && Wi.delete(xn);
              }),
              Wi.size === 0)
            ) {
              $i(Fi);
              return;
            }
            setTimeout(on, 10);
          }
          qi.get("KHR_parallel_shader_compile") !== null
            ? on()
            : setTimeout(on, 10);
        });
      });
    let dn = null;
    function gn(Fi) {
      dn && dn(Fi);
    }
    function Nn() {
      hn.stop();
    }
    function Fn() {
      hn.start();
    }
    const hn = new WebGLAnimation();
    hn.setAnimationLoop(gn),
      typeof self < "u" && hn.setContext(self),
      (this.setAnimationLoop = function (Fi) {
        (dn = Fi),
          Ji.setAnimationLoop(Fi),
          Fi === null ? hn.stop() : hn.start();
      }),
      Ji.addEventListener("sessionstart", Nn),
      Ji.addEventListener("sessionend", Fn),
      (this.render = function (Fi, Ui) {
        if (Ui !== void 0 && Ui.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (fi === !0) return;
        Fi.matrixWorldAutoUpdate === !0 && Fi.updateMatrixWorld(),
          Ui.parent === null &&
            Ui.matrixWorldAutoUpdate === !0 &&
            Ui.updateMatrixWorld(),
          Ji.enabled === !0 &&
            Ji.isPresenting === !0 &&
            (Ji.cameraAutoUpdate === !0 && Ji.updateCamera(Ui),
            (Ui = Ji.getCamera())),
          Fi.isScene === !0 && Fi.onBeforeRender(ci, Fi, Ui, mi),
          (ui = Zi.get(Fi, hi.length)),
          ui.init(),
          hi.push(ui),
          an.multiplyMatrices(Ui.projectionMatrix, Ui.matrixWorldInverse),
          Oi.setFromProjectionMatrix(an),
          (Bi = this.localClippingEnabled),
          (ki = _n.init(this.clippingPlanes, Bi)),
          (oi = Ki.get(Fi, ai.length)),
          oi.init(),
          ai.push(oi),
          On(Fi, Ui, 0, ci.sortObjects),
          oi.finish(),
          ci.sortObjects === !0 && oi.sort(gi, xi),
          this.info.render.frame++,
          ki === !0 && _n.beginShadows();
        const Hi = ui.state.shadowsArray;
        if (
          (tn.render(Hi, Fi, Ui),
          ki === !0 && _n.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          fn.render(oi, Fi),
          ui.setupLights(ci._useLegacyLights),
          Ui.isArrayCamera)
        ) {
          const Wi = Ui.cameras;
          for (let $i = 0, on = Wi.length; $i < on; $i++) {
            const xn = Wi[$i];
            In(oi, Fi, xn, xn.viewport);
          }
        } else In(oi, Fi, Ui);
        mi !== null &&
          (Sn.updateMultisampleRenderTarget(mi),
          Sn.updateRenderTargetMipmap(mi)),
          Fi.isScene === !0 && Fi.onAfterRender(ci, Fi, Ui),
          Ln.resetDefaultState(),
          (Si = -1),
          (yi = null),
          hi.pop(),
          hi.length > 0 ? (ui = hi[hi.length - 1]) : (ui = null),
          ai.pop(),
          ai.length > 0 ? (oi = ai[ai.length - 1]) : (oi = null);
      });
    function On(Fi, Ui, Hi, Wi) {
      if (Fi.visible === !1) return;
      if (Fi.layers.test(Ui.layers)) {
        if (Fi.isGroup) Hi = Fi.renderOrder;
        else if (Fi.isLOD) Fi.autoUpdate === !0 && Fi.update(Ui);
        else if (Fi.isLight)
          ui.pushLight(Fi), Fi.castShadow && ui.pushShadow(Fi);
        else if (Fi.isSprite) {
          if (!Fi.frustumCulled || Oi.intersectsSprite(Fi)) {
            Wi && ln.setFromMatrixPosition(Fi.matrixWorld).applyMatrix4(an);
            const xn = Li.update(Fi),
              Pn = Fi.material;
            Pn.visible && oi.push(Fi, xn, Pn, Hi, ln.z, null);
          }
        } else if (
          (Fi.isMesh || Fi.isLine || Fi.isPoints) &&
          (!Fi.frustumCulled || Oi.intersectsObject(Fi))
        ) {
          const xn = Li.update(Fi),
            Pn = Fi.material;
          if (
            (Wi &&
              (Fi.boundingSphere !== void 0
                ? (Fi.boundingSphere === null && Fi.computeBoundingSphere(),
                  ln.copy(Fi.boundingSphere.center))
                : (xn.boundingSphere === null && xn.computeBoundingSphere(),
                  ln.copy(xn.boundingSphere.center)),
              ln.applyMatrix4(Fi.matrixWorld).applyMatrix4(an)),
            Array.isArray(Pn))
          ) {
            const bn = xn.groups;
            for (let Tn = 0, Rn = bn.length; Tn < Rn; Tn++) {
              const kn = bn[Tn],
                Kn = Pn[kn.materialIndex];
              Kn && Kn.visible && oi.push(Fi, xn, Kn, Hi, ln.z, kn);
            }
          } else Pn.visible && oi.push(Fi, xn, Pn, Hi, ln.z, null);
        }
      }
      const on = Fi.children;
      for (let xn = 0, Pn = on.length; xn < Pn; xn++) On(on[xn], Ui, Hi, Wi);
    }
    function In(Fi, Ui, Hi, Wi) {
      const $i = Fi.opaque,
        on = Fi.transmissive,
        xn = Fi.transparent;
      ui.setupLightsView(Hi),
        ki === !0 && _n.setGlobalState(ci.clippingPlanes, Hi),
        on.length > 0 && zn($i, on, Ui, Hi),
        Wi && vn.viewport(Ei.copy(Wi)),
        $i.length > 0 && Zn($i, Ui, Hi),
        on.length > 0 && Zn(on, Ui, Hi),
        xn.length > 0 && Zn(xn, Ui, Hi),
        vn.buffers.depth.setTest(!0),
        vn.buffers.depth.setMask(!0),
        vn.buffers.color.setMask(!0),
        vn.setPolygonOffset(!1);
    }
    function zn(Fi, Ui, Hi, Wi) {
      if ((Hi.isScene === !0 ? Hi.overrideMaterial : null) !== null) return;
      const on = pn.isWebGL2;
      Xi === null &&
        (Xi = new WebGLRenderTarget(1, 1, {
          generateMipmaps: !0,
          type: qi.has("EXT_color_buffer_half_float")
            ? HalfFloatType
            : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: on ? 4 : 0,
        })),
        ci.getDrawingBufferSize(Qi),
        on
          ? Xi.setSize(Qi.x, Qi.y)
          : Xi.setSize(floorPowerOfTwo(Qi.x), floorPowerOfTwo(Qi.y));
      const xn = ci.getRenderTarget();
      ci.setRenderTarget(Xi),
        ci.getClearColor(Ri),
        (wi = ci.getClearAlpha()),
        wi < 1 && ci.setClearColor(16777215, 0.5),
        ci.clear();
      const Pn = ci.toneMapping;
      (ci.toneMapping = NoToneMapping),
        Zn(Fi, Hi, Wi),
        Sn.updateMultisampleRenderTarget(Xi),
        Sn.updateRenderTargetMipmap(Xi);
      let bn = !1;
      for (let Tn = 0, Rn = Ui.length; Tn < Rn; Tn++) {
        const kn = Ui[Tn],
          Kn = kn.object,
          es = kn.geometry,
          qn = kn.material,
          rs = kn.group;
        if (qn.side === DoubleSide && Kn.layers.test(Wi.layers)) {
          const jn = qn.side;
          (qn.side = BackSide),
            (qn.needsUpdate = !0),
            Gn(Kn, Hi, Wi, es, qn, rs),
            (qn.side = jn),
            (qn.needsUpdate = !0),
            (bn = !0);
        }
      }
      bn === !0 &&
        (Sn.updateMultisampleRenderTarget(Xi), Sn.updateRenderTargetMipmap(Xi)),
        ci.setRenderTarget(xn),
        ci.setClearColor(Ri, wi),
        (ci.toneMapping = Pn);
    }
    function Zn(Fi, Ui, Hi) {
      const Wi = Ui.isScene === !0 ? Ui.overrideMaterial : null;
      for (let $i = 0, on = Fi.length; $i < on; $i++) {
        const xn = Fi[$i],
          Pn = xn.object,
          bn = xn.geometry,
          Tn = Wi === null ? xn.material : Wi,
          Rn = xn.group;
        Pn.layers.test(Hi.layers) && Gn(Pn, Ui, Hi, bn, Tn, Rn);
      }
    }
    function Gn(Fi, Ui, Hi, Wi, $i, on) {
      Fi.onBeforeRender(ci, Ui, Hi, Wi, $i, on),
        Fi.modelViewMatrix.multiplyMatrices(
          Hi.matrixWorldInverse,
          Fi.matrixWorld
        ),
        Fi.normalMatrix.getNormalMatrix(Fi.modelViewMatrix),
        $i.onBeforeRender(ci, Ui, Hi, Wi, Fi, on),
        $i.transparent === !0 &&
        $i.side === DoubleSide &&
        $i.forceSinglePass === !1
          ? (($i.side = BackSide),
            ($i.needsUpdate = !0),
            ci.renderBufferDirect(Hi, Ui, Wi, $i, Fi, on),
            ($i.side = FrontSide),
            ($i.needsUpdate = !0),
            ci.renderBufferDirect(Hi, Ui, Wi, $i, Fi, on),
            ($i.side = DoubleSide))
          : ci.renderBufferDirect(Hi, Ui, Wi, $i, Fi, on),
        Fi.onAfterRender(ci, Ui, Hi, Wi, $i, on);
    }
    function Xn(Fi, Ui, Hi) {
      Ui.isScene !== !0 && (Ui = yn);
      const Wi = mn.get(Fi),
        $i = ui.state.lights,
        on = ui.state.shadowsArray,
        xn = $i.state.version,
        Pn = Gi.getParameters(Fi, $i.state, on, Ui, Hi),
        bn = Gi.getProgramCacheKey(Pn);
      let Tn = Wi.programs;
      (Wi.environment = Fi.isMeshStandardMaterial ? Ui.environment : null),
        (Wi.fog = Ui.fog),
        (Wi.envMap = (Fi.isMeshStandardMaterial ? Cn : Dn).get(
          Fi.envMap || Wi.environment
        )),
        Tn === void 0 &&
          (Fi.addEventListener("dispose", en),
          (Tn = new Map()),
          (Wi.programs = Tn));
      let Rn = Tn.get(bn);
      if (Rn !== void 0) {
        if (Wi.currentProgram === Rn && Wi.lightsStateVersion === xn)
          return Jn(Fi, Pn), Rn;
      } else
        (Pn.uniforms = Gi.getUniforms(Fi)),
          Fi.onBuild(Hi, Pn, ci),
          Fi.onBeforeCompile(Pn, ci),
          (Rn = Gi.acquireProgram(Pn, bn)),
          Tn.set(bn, Rn),
          (Wi.uniforms = Pn.uniforms);
      const kn = Wi.uniforms;
      return (
        ((!Fi.isShaderMaterial && !Fi.isRawShaderMaterial) ||
          Fi.clipping === !0) &&
          (kn.clippingPlanes = _n.uniform),
        Jn(Fi, Pn),
        (Wi.needsLights = ns(Fi)),
        (Wi.lightsStateVersion = xn),
        Wi.needsLights &&
          ((kn.ambientLightColor.value = $i.state.ambient),
          (kn.lightProbe.value = $i.state.probe),
          (kn.directionalLights.value = $i.state.directional),
          (kn.directionalLightShadows.value = $i.state.directionalShadow),
          (kn.spotLights.value = $i.state.spot),
          (kn.spotLightShadows.value = $i.state.spotShadow),
          (kn.rectAreaLights.value = $i.state.rectArea),
          (kn.ltc_1.value = $i.state.rectAreaLTC1),
          (kn.ltc_2.value = $i.state.rectAreaLTC2),
          (kn.pointLights.value = $i.state.point),
          (kn.pointLightShadows.value = $i.state.pointShadow),
          (kn.hemisphereLights.value = $i.state.hemi),
          (kn.directionalShadowMap.value = $i.state.directionalShadowMap),
          (kn.directionalShadowMatrix.value = $i.state.directionalShadowMatrix),
          (kn.spotShadowMap.value = $i.state.spotShadowMap),
          (kn.spotLightMatrix.value = $i.state.spotLightMatrix),
          (kn.spotLightMap.value = $i.state.spotLightMap),
          (kn.pointShadowMap.value = $i.state.pointShadowMap),
          (kn.pointShadowMatrix.value = $i.state.pointShadowMatrix)),
        (Wi.currentProgram = Rn),
        (Wi.uniformsList = null),
        Rn
      );
    }
    function ts(Fi) {
      if (Fi.uniformsList === null) {
        const Ui = Fi.currentProgram.getUniforms();
        Fi.uniformsList = WebGLUniforms.seqWithValue(Ui.seq, Fi.uniforms);
      }
      return Fi.uniformsList;
    }
    function Jn(Fi, Ui) {
      const Hi = mn.get(Fi);
      (Hi.outputColorSpace = Ui.outputColorSpace),
        (Hi.instancing = Ui.instancing),
        (Hi.instancingColor = Ui.instancingColor),
        (Hi.skinning = Ui.skinning),
        (Hi.morphTargets = Ui.morphTargets),
        (Hi.morphNormals = Ui.morphNormals),
        (Hi.morphColors = Ui.morphColors),
        (Hi.morphTargetsCount = Ui.morphTargetsCount),
        (Hi.numClippingPlanes = Ui.numClippingPlanes),
        (Hi.numIntersection = Ui.numClipIntersection),
        (Hi.vertexAlphas = Ui.vertexAlphas),
        (Hi.vertexTangents = Ui.vertexTangents),
        (Hi.toneMapping = Ui.toneMapping);
    }
    function Yn(Fi, Ui, Hi, Wi, $i) {
      Ui.isScene !== !0 && (Ui = yn), Sn.resetTextureUnits();
      const on = Ui.fog,
        xn = Wi.isMeshStandardMaterial ? Ui.environment : null,
        Pn =
          mi === null
            ? ci.outputColorSpace
            : mi.isXRRenderTarget === !0
            ? mi.texture.colorSpace
            : LinearSRGBColorSpace,
        bn = (Wi.isMeshStandardMaterial ? Cn : Dn).get(Wi.envMap || xn),
        Tn =
          Wi.vertexColors === !0 &&
          !!Hi.attributes.color &&
          Hi.attributes.color.itemSize === 4,
        Rn = !!Hi.attributes.tangent && (!!Wi.normalMap || Wi.anisotropy > 0),
        kn = !!Hi.morphAttributes.position,
        Kn = !!Hi.morphAttributes.normal,
        es = !!Hi.morphAttributes.color;
      let qn = NoToneMapping;
      Wi.toneMapped &&
        (mi === null || mi.isXRRenderTarget === !0) &&
        (qn = ci.toneMapping);
      const rs =
          Hi.morphAttributes.position ||
          Hi.morphAttributes.normal ||
          Hi.morphAttributes.color,
        jn = rs !== void 0 ? rs.length : 0,
        Un = mn.get(Wi),
        cs = ui.state.lights;
      if (ki === !0 && (Bi === !0 || Fi !== yi)) {
        const ss = Fi === yi && Wi.id === Si;
        _n.setState(Wi, Fi, ss);
      }
      let Qn = !1;
      Wi.version === Un.__version
        ? ((Un.needsLights && Un.lightsStateVersion !== cs.state.version) ||
            Un.outputColorSpace !== Pn ||
            ($i.isInstancedMesh && Un.instancing === !1) ||
            (!$i.isInstancedMesh && Un.instancing === !0) ||
            ($i.isSkinnedMesh && Un.skinning === !1) ||
            (!$i.isSkinnedMesh && Un.skinning === !0) ||
            ($i.isInstancedMesh &&
              Un.instancingColor === !0 &&
              $i.instanceColor === null) ||
            ($i.isInstancedMesh &&
              Un.instancingColor === !1 &&
              $i.instanceColor !== null) ||
            Un.envMap !== bn ||
            (Wi.fog === !0 && Un.fog !== on) ||
            (Un.numClippingPlanes !== void 0 &&
              (Un.numClippingPlanes !== _n.numPlanes ||
                Un.numIntersection !== _n.numIntersection)) ||
            Un.vertexAlphas !== Tn ||
            Un.vertexTangents !== Rn ||
            Un.morphTargets !== kn ||
            Un.morphNormals !== Kn ||
            Un.morphColors !== es ||
            Un.toneMapping !== qn ||
            (pn.isWebGL2 === !0 && Un.morphTargetsCount !== jn)) &&
          (Qn = !0)
        : ((Qn = !0), (Un.__version = Wi.version));
      let as = Un.currentProgram;
      Qn === !0 && (as = Xn(Wi, Ui, $i));
      let ps = !1,
        ls = !1,
        us = !1;
      const is = as.getUniforms(),
        os = Un.uniforms;
      if (
        (vn.useProgram(as.program) && ((ps = !0), (ls = !0), (us = !0)),
        Wi.id !== Si && ((Si = Wi.id), (ls = !0)),
        ps || yi !== Fi)
      ) {
        is.setValue(Vi, "projectionMatrix", Fi.projectionMatrix),
          is.setValue(Vi, "viewMatrix", Fi.matrixWorldInverse);
        const ss = is.map.cameraPosition;
        ss !== void 0 &&
          ss.setValue(Vi, ln.setFromMatrixPosition(Fi.matrixWorld)),
          pn.logarithmicDepthBuffer &&
            is.setValue(
              Vi,
              "logDepthBufFC",
              2 / (Math.log(Fi.far + 1) / Math.LN2)
            ),
          (Wi.isMeshPhongMaterial ||
            Wi.isMeshToonMaterial ||
            Wi.isMeshLambertMaterial ||
            Wi.isMeshBasicMaterial ||
            Wi.isMeshStandardMaterial ||
            Wi.isShaderMaterial) &&
            is.setValue(Vi, "isOrthographic", Fi.isOrthographicCamera === !0),
          yi !== Fi && ((yi = Fi), (ls = !0), (us = !0));
      }
      if ($i.isSkinnedMesh) {
        is.setOptional(Vi, $i, "bindMatrix"),
          is.setOptional(Vi, $i, "bindMatrixInverse");
        const ss = $i.skeleton;
        ss &&
          (pn.floatVertexTextures
            ? (ss.boneTexture === null && ss.computeBoneTexture(),
              is.setValue(Vi, "boneTexture", ss.boneTexture, Sn),
              is.setValue(Vi, "boneTextureSize", ss.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const hs = Hi.morphAttributes;
      if (
        ((hs.position !== void 0 ||
          hs.normal !== void 0 ||
          (hs.color !== void 0 && pn.isWebGL2 === !0)) &&
          En.update($i, Hi, as),
        (ls || Un.receiveShadow !== $i.receiveShadow) &&
          ((Un.receiveShadow = $i.receiveShadow),
          is.setValue(Vi, "receiveShadow", $i.receiveShadow)),
        Wi.isMeshGouraudMaterial &&
          Wi.envMap !== null &&
          ((os.envMap.value = bn),
          (os.flipEnvMap.value =
            bn.isCubeTexture && bn.isRenderTargetTexture === !1 ? -1 : 1)),
        ls &&
          (is.setValue(Vi, "toneMappingExposure", ci.toneMappingExposure),
          Un.needsLights && Wn(os, us),
          on && Wi.fog === !0 && Yi.refreshFogUniforms(os, on),
          Yi.refreshMaterialUniforms(os, Wi, Mi, bi, Xi),
          WebGLUniforms.upload(Vi, ts(Un), os, Sn)),
        Wi.isShaderMaterial &&
          Wi.uniformsNeedUpdate === !0 &&
          (WebGLUniforms.upload(Vi, ts(Un), os, Sn),
          (Wi.uniformsNeedUpdate = !1)),
        Wi.isSpriteMaterial && is.setValue(Vi, "center", $i.center),
        is.setValue(Vi, "modelViewMatrix", $i.modelViewMatrix),
        is.setValue(Vi, "normalMatrix", $i.normalMatrix),
        is.setValue(Vi, "modelMatrix", $i.matrixWorld),
        Wi.isShaderMaterial || Wi.isRawShaderMaterial)
      ) {
        const ss = Wi.uniformsGroups;
        for (let fs = 0, vs = ss.length; fs < vs; fs++)
          if (pn.isWebGL2) {
            const ms = ss[fs];
            An.update(ms, as), An.bind(ms, as);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return as;
    }
    function Wn(Fi, Ui) {
      (Fi.ambientLightColor.needsUpdate = Ui),
        (Fi.lightProbe.needsUpdate = Ui),
        (Fi.directionalLights.needsUpdate = Ui),
        (Fi.directionalLightShadows.needsUpdate = Ui),
        (Fi.pointLights.needsUpdate = Ui),
        (Fi.pointLightShadows.needsUpdate = Ui),
        (Fi.spotLights.needsUpdate = Ui),
        (Fi.spotLightShadows.needsUpdate = Ui),
        (Fi.rectAreaLights.needsUpdate = Ui),
        (Fi.hemisphereLights.needsUpdate = Ui);
    }
    function ns(Fi) {
      return (
        Fi.isMeshLambertMaterial ||
        Fi.isMeshToonMaterial ||
        Fi.isMeshPhongMaterial ||
        Fi.isMeshStandardMaterial ||
        Fi.isShadowMaterial ||
        (Fi.isShaderMaterial && Fi.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return di;
    }),
      (this.getActiveMipmapLevel = function () {
        return pi;
      }),
      (this.getRenderTarget = function () {
        return mi;
      }),
      (this.setRenderTargetTextures = function (Fi, Ui, Hi) {
        (mn.get(Fi.texture).__webglTexture = Ui),
          (mn.get(Fi.depthTexture).__webglTexture = Hi);
        const Wi = mn.get(Fi);
        (Wi.__hasExternalTextures = !0),
          Wi.__hasExternalTextures &&
            ((Wi.__autoAllocateDepthBuffer = Hi === void 0),
            Wi.__autoAllocateDepthBuffer ||
              (qi.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (Wi.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (Fi, Ui) {
        const Hi = mn.get(Fi);
        (Hi.__webglFramebuffer = Ui),
          (Hi.__useDefaultFramebuffer = Ui === void 0);
      }),
      (this.setRenderTarget = function (Fi, Ui = 0, Hi = 0) {
        (mi = Fi), (di = Ui), (pi = Hi);
        let Wi = !0,
          $i = null,
          on = !1,
          xn = !1;
        if (Fi) {
          const bn = mn.get(Fi);
          bn.__useDefaultFramebuffer !== void 0
            ? (vn.bindFramebuffer(Vi.FRAMEBUFFER, null), (Wi = !1))
            : bn.__webglFramebuffer === void 0
            ? Sn.setupRenderTarget(Fi)
            : bn.__hasExternalTextures &&
              Sn.rebindTextures(
                Fi,
                mn.get(Fi.texture).__webglTexture,
                mn.get(Fi.depthTexture).__webglTexture
              );
          const Tn = Fi.texture;
          (Tn.isData3DTexture ||
            Tn.isDataArrayTexture ||
            Tn.isCompressedArrayTexture) &&
            (xn = !0);
          const Rn = mn.get(Fi).__webglFramebuffer;
          Fi.isWebGLCubeRenderTarget
            ? (Array.isArray(Rn[Ui]) ? ($i = Rn[Ui][Hi]) : ($i = Rn[Ui]),
              (on = !0))
            : pn.isWebGL2 && Fi.samples > 0 && Sn.useMultisampledRTT(Fi) === !1
            ? ($i = mn.get(Fi).__webglMultisampledFramebuffer)
            : Array.isArray(Rn)
            ? ($i = Rn[Hi])
            : ($i = Rn),
            Ei.copy(Fi.viewport),
            Pi.copy(Fi.scissor),
            (Ai = Fi.scissorTest);
        } else
          Ei.copy(Ti).multiplyScalar(Mi).floor(),
            Pi.copy(vi).multiplyScalar(Mi).floor(),
            (Ai = Ii);
        if (
          (vn.bindFramebuffer(Vi.FRAMEBUFFER, $i) &&
            pn.drawBuffers &&
            Wi &&
            vn.drawBuffers(Fi, $i),
          vn.viewport(Ei),
          vn.scissor(Pi),
          vn.setScissorTest(Ai),
          on)
        ) {
          const bn = mn.get(Fi.texture);
          Vi.framebufferTexture2D(
            Vi.FRAMEBUFFER,
            Vi.COLOR_ATTACHMENT0,
            Vi.TEXTURE_CUBE_MAP_POSITIVE_X + Ui,
            bn.__webglTexture,
            Hi
          );
        } else if (xn) {
          const bn = mn.get(Fi.texture),
            Tn = Ui || 0;
          Vi.framebufferTextureLayer(
            Vi.FRAMEBUFFER,
            Vi.COLOR_ATTACHMENT0,
            bn.__webglTexture,
            Hi || 0,
            Tn
          );
        }
        Si = -1;
      }),
      (this.readRenderTargetPixels = function (Fi, Ui, Hi, Wi, $i, on, xn) {
        if (!(Fi && Fi.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Pn = mn.get(Fi).__webglFramebuffer;
        if (
          (Fi.isWebGLCubeRenderTarget && xn !== void 0 && (Pn = Pn[xn]), Pn)
        ) {
          vn.bindFramebuffer(Vi.FRAMEBUFFER, Pn);
          try {
            const bn = Fi.texture,
              Tn = bn.format,
              Rn = bn.type;
            if (
              Tn !== RGBAFormat &&
              Hn.convert(Tn) !==
                Vi.getParameter(Vi.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const kn =
              Rn === HalfFloatType &&
              (qi.has("EXT_color_buffer_half_float") ||
                (pn.isWebGL2 && qi.has("EXT_color_buffer_float")));
            if (
              Rn !== UnsignedByteType &&
              Hn.convert(Rn) !==
                Vi.getParameter(Vi.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                Rn === FloatType &&
                (pn.isWebGL2 ||
                  qi.has("OES_texture_float") ||
                  qi.has("WEBGL_color_buffer_float"))
              ) &&
              !kn
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            Ui >= 0 &&
              Ui <= Fi.width - Wi &&
              Hi >= 0 &&
              Hi <= Fi.height - $i &&
              Vi.readPixels(Ui, Hi, Wi, $i, Hn.convert(Tn), Hn.convert(Rn), on);
          } finally {
            const bn = mi !== null ? mn.get(mi).__webglFramebuffer : null;
            vn.bindFramebuffer(Vi.FRAMEBUFFER, bn);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (Fi, Ui, Hi = 0) {
        const Wi = Math.pow(2, -Hi),
          $i = Math.floor(Ui.image.width * Wi),
          on = Math.floor(Ui.image.height * Wi);
        Sn.setTexture2D(Ui, 0),
          Vi.copyTexSubImage2D(Vi.TEXTURE_2D, Hi, 0, 0, Fi.x, Fi.y, $i, on),
          vn.unbindTexture();
      }),
      (this.copyTextureToTexture = function (Fi, Ui, Hi, Wi = 0) {
        const $i = Ui.image.width,
          on = Ui.image.height,
          xn = Hn.convert(Hi.format),
          Pn = Hn.convert(Hi.type);
        Sn.setTexture2D(Hi, 0),
          Vi.pixelStorei(Vi.UNPACK_FLIP_Y_WEBGL, Hi.flipY),
          Vi.pixelStorei(
            Vi.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Hi.premultiplyAlpha
          ),
          Vi.pixelStorei(Vi.UNPACK_ALIGNMENT, Hi.unpackAlignment),
          Ui.isDataTexture
            ? Vi.texSubImage2D(
                Vi.TEXTURE_2D,
                Wi,
                Fi.x,
                Fi.y,
                $i,
                on,
                xn,
                Pn,
                Ui.image.data
              )
            : Ui.isCompressedTexture
            ? Vi.compressedTexSubImage2D(
                Vi.TEXTURE_2D,
                Wi,
                Fi.x,
                Fi.y,
                Ui.mipmaps[0].width,
                Ui.mipmaps[0].height,
                xn,
                Ui.mipmaps[0].data
              )
            : Vi.texSubImage2D(Vi.TEXTURE_2D, Wi, Fi.x, Fi.y, xn, Pn, Ui.image),
          Wi === 0 && Hi.generateMipmaps && Vi.generateMipmap(Vi.TEXTURE_2D),
          vn.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (Fi, Ui, Hi, Wi, $i = 0) {
        if (ci.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const on = Fi.max.x - Fi.min.x + 1,
          xn = Fi.max.y - Fi.min.y + 1,
          Pn = Fi.max.z - Fi.min.z + 1,
          bn = Hn.convert(Wi.format),
          Tn = Hn.convert(Wi.type);
        let Rn;
        if (Wi.isData3DTexture) Sn.setTexture3D(Wi, 0), (Rn = Vi.TEXTURE_3D);
        else if (Wi.isDataArrayTexture)
          Sn.setTexture2DArray(Wi, 0), (Rn = Vi.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        Vi.pixelStorei(Vi.UNPACK_FLIP_Y_WEBGL, Wi.flipY),
          Vi.pixelStorei(
            Vi.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Wi.premultiplyAlpha
          ),
          Vi.pixelStorei(Vi.UNPACK_ALIGNMENT, Wi.unpackAlignment);
        const kn = Vi.getParameter(Vi.UNPACK_ROW_LENGTH),
          Kn = Vi.getParameter(Vi.UNPACK_IMAGE_HEIGHT),
          es = Vi.getParameter(Vi.UNPACK_SKIP_PIXELS),
          qn = Vi.getParameter(Vi.UNPACK_SKIP_ROWS),
          rs = Vi.getParameter(Vi.UNPACK_SKIP_IMAGES),
          jn = Hi.isCompressedTexture ? Hi.mipmaps[0] : Hi.image;
        Vi.pixelStorei(Vi.UNPACK_ROW_LENGTH, jn.width),
          Vi.pixelStorei(Vi.UNPACK_IMAGE_HEIGHT, jn.height),
          Vi.pixelStorei(Vi.UNPACK_SKIP_PIXELS, Fi.min.x),
          Vi.pixelStorei(Vi.UNPACK_SKIP_ROWS, Fi.min.y),
          Vi.pixelStorei(Vi.UNPACK_SKIP_IMAGES, Fi.min.z),
          Hi.isDataTexture || Hi.isData3DTexture
            ? Vi.texSubImage3D(
                Rn,
                $i,
                Ui.x,
                Ui.y,
                Ui.z,
                on,
                xn,
                Pn,
                bn,
                Tn,
                jn.data
              )
            : Hi.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              Vi.compressedTexSubImage3D(
                Rn,
                $i,
                Ui.x,
                Ui.y,
                Ui.z,
                on,
                xn,
                Pn,
                bn,
                jn.data
              ))
            : Vi.texSubImage3D(
                Rn,
                $i,
                Ui.x,
                Ui.y,
                Ui.z,
                on,
                xn,
                Pn,
                bn,
                Tn,
                jn
              ),
          Vi.pixelStorei(Vi.UNPACK_ROW_LENGTH, kn),
          Vi.pixelStorei(Vi.UNPACK_IMAGE_HEIGHT, Kn),
          Vi.pixelStorei(Vi.UNPACK_SKIP_PIXELS, es),
          Vi.pixelStorei(Vi.UNPACK_SKIP_ROWS, qn),
          Vi.pixelStorei(Vi.UNPACK_SKIP_IMAGES, rs),
          $i === 0 && Wi.generateMipmaps && Vi.generateMipmap(Rn),
          vn.unbindTexture();
      }),
      (this.initTexture = function (Fi) {
        Fi.isCubeTexture
          ? Sn.setTextureCube(Fi, 0)
          : Fi.isData3DTexture
          ? Sn.setTexture3D(Fi, 0)
          : Fi.isDataArrayTexture || Fi.isCompressedArrayTexture
          ? Sn.setTexture2DArray(Fi, 0)
          : Sn.setTexture2D(Fi, 0),
          vn.unbindTexture();
      }),
      (this.resetState = function () {
        (di = 0), (pi = 0), (mi = null), vn.reset(), Ln.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", {
            detail: this,
          })
        );
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(ze) {
    this._outputColorSpace = ze;
    const Gr = this.getContext();
    (Gr.drawingBufferColorSpace =
      ze === DisplayP3ColorSpace ? "display-p3" : "srgb"),
      (Gr.unpackColorSpace =
        ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace
          ? "display-p3"
          : "srgb");
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(ze) {
    console.warn(
      "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !ze);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding
    );
  }
  set outputEncoding(ze) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace =
        ze === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(ze) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = ze);
  }
}
class WebGL1Renderer extends WebGLRenderer {}
WebGL1Renderer.prototype.isWebGL1Renderer = !0;
class Scene extends Object3D {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", {
            detail: this,
          })
        );
  }
  copy(ze, Gr) {
    return (
      super.copy(ze, Gr),
      ze.background !== null && (this.background = ze.background.clone()),
      ze.environment !== null && (this.environment = ze.environment.clone()),
      ze.fog !== null && (this.fog = ze.fog.clone()),
      (this.backgroundBlurriness = ze.backgroundBlurriness),
      (this.backgroundIntensity = ze.backgroundIntensity),
      ze.overrideMaterial !== null &&
        (this.overrideMaterial = ze.overrideMaterial.clone()),
      (this.matrixAutoUpdate = ze.matrixAutoUpdate),
      this
    );
  }
  toJSON(ze) {
    const Gr = super.toJSON(ze);
    return (
      this.fog !== null && (Gr.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (Gr.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (Gr.object.backgroundIntensity = this.backgroundIntensity),
      Gr
    );
  }
}
class DataTexture extends Texture {
  constructor(
    ze = null,
    Gr = 1,
    Yr = 1,
    Kr,
    Zr,
    Jr,
    Qr,
    ei,
    ti = NearestFilter,
    ri = NearestFilter,
    ni,
    ii
  ) {
    super(null, Jr, Qr, ei, ti, ri, Kr, Zr, ni, ii),
      (this.isDataTexture = !0),
      (this.image = {
        data: ze,
        width: Gr,
        height: Yr,
      }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const Cache = {
  enabled: !1,
  files: {},
  add: function (Wr, ze) {
    this.enabled !== !1 && (this.files[Wr] = ze);
  },
  get: function (Wr) {
    if (this.enabled !== !1) return this.files[Wr];
  },
  remove: function (Wr) {
    delete this.files[Wr];
  },
  clear: function () {
    this.files = {};
  },
};
class LoadingManager {
  constructor(ze, Gr, Yr) {
    const Kr = this;
    let Zr = !1,
      Jr = 0,
      Qr = 0,
      ei;
    const ti = [];
    (this.onStart = void 0),
      (this.onLoad = ze),
      (this.onProgress = Gr),
      (this.onError = Yr),
      (this.itemStart = function (ri) {
        Qr++,
          Zr === !1 && Kr.onStart !== void 0 && Kr.onStart(ri, Jr, Qr),
          (Zr = !0);
      }),
      (this.itemEnd = function (ri) {
        Jr++,
          Kr.onProgress !== void 0 && Kr.onProgress(ri, Jr, Qr),
          Jr === Qr && ((Zr = !1), Kr.onLoad !== void 0 && Kr.onLoad());
      }),
      (this.itemError = function (ri) {
        Kr.onError !== void 0 && Kr.onError(ri);
      }),
      (this.resolveURL = function (ri) {
        return ei ? ei(ri) : ri;
      }),
      (this.setURLModifier = function (ri) {
        return (ei = ri), this;
      }),
      (this.addHandler = function (ri, ni) {
        return ti.push(ri, ni), this;
      }),
      (this.removeHandler = function (ri) {
        const ni = ti.indexOf(ri);
        return ni !== -1 && ti.splice(ni, 2), this;
      }),
      (this.getHandler = function (ri) {
        for (let ni = 0, ii = ti.length; ni < ii; ni += 2) {
          const si = ti[ni],
            li = ti[ni + 1];
          if ((si.global && (si.lastIndex = 0), si.test(ri))) return li;
        }
        return null;
      });
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(ze) {
    (this.manager = ze !== void 0 ? ze : DefaultLoadingManager),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(ze, Gr) {
    const Yr = this;
    return new Promise(function (Kr, Zr) {
      Yr.load(ze, Kr, Gr, Zr);
    });
  }
  parse() {}
  setCrossOrigin(ze) {
    return (this.crossOrigin = ze), this;
  }
  setWithCredentials(ze) {
    return (this.withCredentials = ze), this;
  }
  setPath(ze) {
    return (this.path = ze), this;
  }
  setResourcePath(ze) {
    return (this.resourcePath = ze), this;
  }
  setRequestHeader(ze) {
    return (this.requestHeader = ze), this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class ImageLoader extends Loader {
  constructor(ze) {
    super(ze);
  }
  load(ze, Gr, Yr, Kr) {
    this.path !== void 0 && (ze = this.path + ze),
      (ze = this.manager.resolveURL(ze));
    const Zr = this,
      Jr = Cache.get(ze);
    if (Jr !== void 0)
      return (
        Zr.manager.itemStart(ze),
        setTimeout(function () {
          Gr && Gr(Jr), Zr.manager.itemEnd(ze);
        }, 0),
        Jr
      );
    const Qr = createElementNS("img");
    function ei() {
      ri(), Cache.add(ze, this), Gr && Gr(this), Zr.manager.itemEnd(ze);
    }
    function ti(ni) {
      ri(), Kr && Kr(ni), Zr.manager.itemError(ze), Zr.manager.itemEnd(ze);
    }
    function ri() {
      Qr.removeEventListener("load", ei, !1),
        Qr.removeEventListener("error", ti, !1);
    }
    return (
      Qr.addEventListener("load", ei, !1),
      Qr.addEventListener("error", ti, !1),
      ze.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (Qr.crossOrigin = this.crossOrigin),
      Zr.manager.itemStart(ze),
      (Qr.src = ze),
      Qr
    );
  }
}
class TextureLoader extends Loader {
  constructor(ze) {
    super(ze);
  }
  load(ze, Gr, Yr, Kr) {
    const Zr = new Texture(),
      Jr = new ImageLoader(this.manager);
    return (
      Jr.setCrossOrigin(this.crossOrigin),
      Jr.setPath(this.path),
      Jr.load(
        ze,
        function (Qr) {
          (Zr.image = Qr), (Zr.needsUpdate = !0), Gr !== void 0 && Gr(Zr);
        },
        Yr,
        Kr
      ),
      Zr
    );
  }
}
class Uniform {
  constructor(ze) {
    this.value = ze;
  }
  clone() {
    return new Uniform(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", {
      detail: {
        revision: REVISION,
      },
    })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = REVISION));
ColorManagement.enabled = !0;
const renderer = new WebGLRenderer({
  antialias: !1,
  alpha: !0,
  depth: !1,
  stencil: !0,
  powerPreference: "high-performance",
});
renderer.setPixelRatio(config.webgl.pixelRatio);
const resize$2 = () => {
  const Wr = window.innerWidth,
    ze = window.innerHeight;
  renderer.setSize(Wr, ze);
};
window.addEventListener("resize", resize$2);
resize$2();
const container = document.querySelector(".webgl"),
  canvas$1 = renderer.domElement;
container.appendChild(canvas$1);
const scene = new Scene();
scene.background = new Color(16777215);
const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
camera.position.z = 1;
class GPUComputationRenderer {
  constructor(ze, Gr, Yr) {
    (this.variables = []), (this.currentTextureIndex = 0);
    let Kr = FloatType;
    const Zr = new Scene(),
      Jr = new Camera();
    Jr.position.z = 1;
    const Qr = {
        passThruTexture: {
          value: null,
        },
      },
      ei = ni(si(), Qr),
      ti = new Mesh(new PlaneGeometry(2, 2), ei);
    Zr.add(ti),
      (this.setDataType = function (li) {
        return (Kr = li), this;
      }),
      (this.addVariable = function (li, oi, ui) {
        const ai = this.createShaderMaterial(oi),
          hi = {
            name: li,
            initialValueTexture: ui,
            material: ai,
            dependencies: null,
            renderTargets: [],
            wrapS: null,
            wrapT: null,
            minFilter: NearestFilter,
            magFilter: NearestFilter,
          };
        return this.variables.push(hi), hi;
      }),
      (this.setVariableDependencies = function (li, oi) {
        li.dependencies = oi;
      }),
      (this.init = function () {
        if (
          Yr.capabilities.isWebGL2 === !1 &&
          Yr.extensions.has("OES_texture_float") === !1
        )
          return "No OES_texture_float support for float textures.";
        if (Yr.capabilities.maxVertexTextures === 0)
          return "No support for vertex shader textures.";
        for (let li = 0; li < this.variables.length; li++) {
          const oi = this.variables[li];
          (oi.renderTargets[0] = this.createRenderTarget(
            ze,
            Gr,
            oi.wrapS,
            oi.wrapT,
            oi.minFilter,
            oi.magFilter
          )),
            (oi.renderTargets[1] = this.createRenderTarget(
              ze,
              Gr,
              oi.wrapS,
              oi.wrapT,
              oi.minFilter,
              oi.magFilter
            )),
            this.renderTexture(oi.initialValueTexture, oi.renderTargets[0]),
            this.renderTexture(oi.initialValueTexture, oi.renderTargets[1]);
          const ui = oi.material,
            ai = ui.uniforms;
          if (oi.dependencies !== null)
            for (let hi = 0; hi < oi.dependencies.length; hi++) {
              const ci = oi.dependencies[hi];
              if (ci.name !== oi.name) {
                let fi = !1;
                for (let di = 0; di < this.variables.length; di++)
                  if (ci.name === this.variables[di].name) {
                    fi = !0;
                    break;
                  }
                if (!fi)
                  return (
                    "Variable dependency not found. Variable=" +
                    oi.name +
                    ", dependency=" +
                    ci.name
                  );
              }
              (ai[ci.name] = {
                value: null,
              }),
                (ui.fragmentShader =
                  `
uniform sampler2D ` +
                  ci.name +
                  `;
` +
                  ui.fragmentShader);
            }
        }
        return (this.currentTextureIndex = 0), null;
      }),
      (this.compute = function () {
        const li = this.currentTextureIndex,
          oi = this.currentTextureIndex === 0 ? 1 : 0;
        for (let ui = 0, ai = this.variables.length; ui < ai; ui++) {
          const hi = this.variables[ui];
          if (hi.dependencies !== null) {
            const ci = hi.material.uniforms;
            for (let fi = 0, di = hi.dependencies.length; fi < di; fi++) {
              const pi = hi.dependencies[fi];
              ci[pi.name].value = pi.renderTargets[li].texture;
            }
          }
          this.doRenderTarget(hi.material, hi.renderTargets[oi]);
        }
        this.currentTextureIndex = oi;
      }),
      (this.getCurrentRenderTarget = function (li) {
        return li.renderTargets[this.currentTextureIndex];
      }),
      (this.getAlternateRenderTarget = function (li) {
        return li.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
      }),
      (this.dispose = function () {
        ti.geometry.dispose(), ti.material.dispose();
        const li = this.variables;
        for (let oi = 0; oi < li.length; oi++) {
          const ui = li[oi];
          ui.initialValueTexture && ui.initialValueTexture.dispose();
          const ai = ui.renderTargets;
          for (let hi = 0; hi < ai.length; hi++) ai[hi].dispose();
        }
      });
    function ri(li) {
      li.defines.resolution =
        "vec2( " + ze.toFixed(1) + ", " + Gr.toFixed(1) + " )";
    }
    this.addResolutionDefine = ri;
    function ni(li, oi) {
      oi = oi || {};
      const ui = new ShaderMaterial({
        name: "GPUComputationShader",
        uniforms: oi,
        vertexShader: ii(),
        fragmentShader: li,
      });
      return ri(ui), ui;
    }
    (this.createShaderMaterial = ni),
      (this.createRenderTarget = function (li, oi, ui, ai, hi, ci) {
        return (
          (li = li || ze),
          (oi = oi || Gr),
          (ui = ui || ClampToEdgeWrapping),
          (ai = ai || ClampToEdgeWrapping),
          (hi = hi || NearestFilter),
          (ci = ci || NearestFilter),
          new WebGLRenderTarget(li, oi, {
            wrapS: ui,
            wrapT: ai,
            minFilter: hi,
            magFilter: ci,
            format: RGBAFormat,
            type: Kr,
            depthBuffer: !1,
          })
        );
      }),
      (this.createTexture = function () {
        const li = new Float32Array(ze * Gr * 4),
          oi = new DataTexture(li, ze, Gr, RGBAFormat, FloatType);
        return (oi.needsUpdate = !0), oi;
      }),
      (this.renderTexture = function (li, oi) {
        (Qr.passThruTexture.value = li),
          this.doRenderTarget(ei, oi),
          (Qr.passThruTexture.value = null);
      }),
      (this.doRenderTarget = function (li, oi) {
        const ui = Yr.getRenderTarget(),
          ai = Yr.xr.enabled,
          hi = Yr.shadowMap.autoUpdate;
        (Yr.xr.enabled = !1),
          (Yr.shadowMap.autoUpdate = !1),
          (ti.material = li),
          Yr.setRenderTarget(oi),
          Yr.render(Zr, Jr),
          (ti.material = ei),
          (Yr.xr.enabled = ai),
          (Yr.shadowMap.autoUpdate = hi),
          Yr.setRenderTarget(ui);
      });
    function ii() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function si() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
class GPGPU {
  constructor(ze, Gr, Yr = ze) {
    (this.textures = {}),
      (this.variables = []),
      (this.gpuComputer = new GPUComputationRenderer(ze, Yr, Gr));
  }
  createTexture(ze, Gr = 8) {
    return (
      (this.textures[ze] = this.gpuComputer.createTexture()),
      this._createIndexes(Gr, this.textures[ze]),
      this.textures[ze]
    );
  }
  _createIndexes(ze, Gr) {
    const Yr = ze * ze;
    Gr.indexes = new Float32Array(Yr * 2);
    for (let Kr = 0; Kr < Yr; Kr++)
      (Gr.indexes[Kr * 2 + 0] = (Kr % ze) / ze),
        (Gr.indexes[Kr * 2 + 1] = ~~(Kr / ze) / ze);
  }
  addVariable(ze, Gr, Yr, Kr) {
    const Zr = this.gpuComputer.addVariable(ze, Yr, Gr);
    if ((this.gpuComputer.setVariableDependencies(Zr, [Zr]), Kr))
      for (const Qr in Kr)
        Zr.material.uniforms[Qr] = {
          value: Kr[Qr],
        };
    const Jr = this.gpuComputer.init();
    Jr !== null && console.error(Jr), (this.variables[ze] = Zr);
  }
  addDebugPlane(ze, Gr) {
    let Yr = new Mesh(
      new PlaneGeometry(1, 1),
      new MeshBasicMaterial({
        map: this.gpuComputer.getCurrentRenderTarget(this.variables[Gr])
          .texture,
      })
    );
    ze.add(Yr),
      gsapWithCSS.ticker.add(() => {
        (Yr.material.map = this.gpuComputer.getCurrentRenderTarget(
          this.variables[Gr]
        ).texture),
          (Yr.material.needsUpdate = !0);
      });
  }
}
const simulationFragShader = `
// The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader.
// For example:
// #DEFINE resolution vec2( 1024.0, 1024.0 )

uniform vec2 uMouse;
uniform vec2 uPrevMouse;
uniform float uTime;
uniform float uDelta;
uniform float uMouseFactor;

// Function to calculate the minimum distance from a point to a line segment
float distanceToSegment(vec2 point, vec2 start, vec2 end) {
    vec2 lineVec = end - start;
    vec2 pointVec = point - start;
    float lineLen = length(lineVec);
    vec2 lineUnitVec = lineVec / lineLen;
    float projLength = dot(pointVec, lineUnitVec);
    projLength = clamp(projLength, 0.0, lineLen);
    vec2 projPoint = start + lineUnitVec * projLength;
    return length(point - projPoint);
}

void main()
{
    vec2 uv = gl_FragCoord.xy / resolution.xy;

    vec4 data = texture2D(tPosition, uv);

    // blacken over time
    data.r = mix(data.r, .5, uDelta * .002);
    data.g = mix(data.g, .5, uDelta * .002);
    data.b = mix(data.b, 0., uDelta * .001);

    float dist = distance(uMouse, uPrevMouse);
    dist *= 1. - step(.2, dist); // avoid big straight lines when entering the canvas

    //float aspect = min(resolution.x, resolution.y) / max(resolution.x, resolution.y);
    //float mixer = smoothstep(.65, .85, aspect);
    //float aspectCorrection = mix(1., 1., mixer);
    vec2 direction = normalize(uMouse - uPrevMouse);// * aspectCorrection;

    //direction = vec2(10., 10.);
    //float angle = atan(direction.y, direction.x);
    //float hue = degrees(angle);

    // Normalize hue from -180 to 180 to 0 to 1
    //hue = mod((hue / 360.0) + 1.0, 1.0);

    // Calculate the distance to the line segment from last mouse position to current
    float distanceToLine = distanceToSegment(uv, uPrevMouse, uMouse);

    float lineInfluence = 1. - smoothstep(0., .2, distanceToLine);
    lineInfluence = clamp(lineInfluence, 0., 1.);
    lineInfluence = pow(lineInfluence, .5);

    float velocityFactor = dist * 1.;
    float influence = lineInfluence * velocityFactor * uMouseFactor;
    data.r += direction.x * 2. * influence;
    data.g += direction.y * 2. * influence;
    data.b += influence;

    data.r = clamp(data.r, 0., 1.);
    data.g = clamp(data.g, 0., 1.);
    data.b = clamp(data.b, 0., 1.);

    gl_FragColor = data;
}
`,
  mouse = new Vector2(),
  mouseUv = new Vector2(),
  prevMouseUv = new Vector2();
window.addEventListener("pointermove", (Wr) => {
  (mouse.x = Wr.clientX),
    (mouse.y = Wr.clientY),
    prevMouseUv.copy(mouseUv),
    (mouseUv.x = mouse.x / (canvas$1.width / config.webgl.pixelRatio)),
    (mouseUv.y = 1 - mouse.y / (canvas$1.height / config.webgl.pixelRatio));
});
const uLerpedMouseUv = new Uniform(new Vector2());
gsapWithCSS.ticker.add((Wr, ze) => {
  uLerpedMouseUv.value.lerp(mouseUv, ze / 150);
});
let mouseFactorTimeout;
const uMouseFactor = new Uniform(0),
  listenMouseMove = (Wr) => {
    Wr.target.getAttribute("no-webgl-hover") === null &&
      ((uMouseFactor.value = 1),
      mouseFactorTimeout && clearTimeout(mouseFactorTimeout),
      (mouseFactorTimeout = setTimeout(() => {
        gsapWithCSS.to(uMouseFactor, {
          value: 0,
          duration: 0.1,
          ease: "none",
        });
      }, 50)));
  };
window.addEventListener("mousemove", listenMouseMove);
const uResolution = new Uniform(
    new Vector2(canvas$1.offsetWidth, canvas$1.offsetHeight)
  ),
  resize$1 = () =>
    uResolution.value.set(canvas$1.offsetWidth, canvas$1.offsetHeight);
window.addEventListener("resize", resize$1);
const uScrollOffset = new Uniform(0);
lenis$1.on("scroll", (Wr) => {
  uScrollOffset.value += Wr.velocity * 3e-4;
});
let ww = document.documentElement.clientWidth,
  wh = window.innerHeight,
  w = Math.floor(ww / 40),
  h$1 = Math.floor(wh / 40),
  gpgpu;
const uSimulationTexture = new Uniform();
createGPGPU(w, h$1);
gsapWithCSS.ticker.add((Wr, ze) => {
  gpgpu &&
    ((gpgpu.variables.tPosition.material.uniforms.uTime.value = Wr),
    (gpgpu.variables.tPosition.material.uniforms.uDelta.value = ze),
    (gpgpu.variables.tPosition.material.uniforms.uMouseFactor.value =
      uMouseFactor.value),
    gpgpu.gpuComputer.compute());
});
window.addEventListener("resize", () => {
  gpgpu &&
    (gpgpu.gpuComputer.dispose(), (gpgpu.gpuComputer = null), (gpgpu = null)),
    (ww = document.documentElement.clientWidth),
    (wh = window.innerHeight),
    (w = Math.floor(ww / 40)),
    (h$1 = Math.floor(wh / 40)),
    createGPGPU(w, h$1);
});
function createGPGPU(Wr, ze) {
  (gpgpu = new GPGPU(Wr, renderer, ze)),
    gpgpu.addVariable("tPosition", null, simulationFragShader, {
      uMouse: mouseUv,
      uPrevMouse: prevMouseUv,
      uTime: 0,
      uDelta: 0,
      uMouseFactor,
    }),
    (uSimulationTexture.value = gpgpu.gpuComputer.getCurrentRenderTarget(
      gpgpu.variables.tPosition
    ).texture);
}
function styles(Wr) {
  return `
    .p-gui {
        --main-border-radius: 5px;
        --color-bg: #121212;
        --color-border: #484848;
        --color-border-2: rgba(255,255,255,.1);
        --color-accent: #1681ca;
        --color-accent-hover: #218fda;
    
        position: ${Wr};
        top: 0;
        left: 0;
        transform: translate3d(0,0,0);
        padding-top: 21px;
        background: var(--color-bg);
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        font-family: Verdana, Arial, sans-serif;
        width: 290px;
        overflow: auto;
        box-shadow: 0 0 2px black;
        box-sizing: border-box;
        z-index: 99999;
        user-select: none;
        border-bottom-right-radius: 3px;
        border-bottom-left-radius: 3px;
        cursor: auto;
        border-radius: var(--main-border-radius);
        border: 1px solid var(--color-border);
        line-height: normal;
    }
    
    .p-gui * {
        font-size: 11px;
    }
    
    .p-gui::-webkit-scrollbar,
    .p-gui *::-webkit-scrollbar {
        width: 10px;
    }
    
    .p-gui::-webkit-scrollbar-track,
    .p-gui *::-webkit-scrollbar-track {
        background: #2f2f2f; 
        border-radius: 3px;
    }
    
    .p-gui::-webkit-scrollbar-thumb,
    .p-gui *::-webkit-scrollbar-thumb {
        background: #757576; 
        border-radius: 10px;
        box-sizing: border-box;
        border: 1px solid #2f2f2f;
    }
    
    .p-gui--collapsed {
        height: 0;
        padding: 21px 10px 0 10px;
        overflow: hidden;
    }
    
    .p-gui__header {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 20px;
        background-color: rgba(0, 0, 0, .8);
        cursor: grab;
        color: grey;
        font-size: 10px;
        line-height: 20px;
        padding-left: 12px;
        box-sizing: border-box;
        touch-action: none;
    }
    
    .p-gui__header-close {
        width: 20px;
        height: 20px;
        position: absolute;
        top: 0;
        right: 5px;
        cursor: pointer;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUAQMAAAC3R49OAAAABlBMVEUAAAD///+l2Z/dAAAAAXRSTlMAQObYZgAAABFJREFUCNdjIAb8//8BjIkAAOrOBd3TR0jRAAAAAElFTkSuQmCC);
        background-size: 50% 50%;
        background-position: center;
        background-repeat: no-repeat; 
    }
    
    .p-gui--collapsed .p-gui__header-close {
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUAQMAAAC3R49OAAAABlBMVEUAAAD///+l2Z/dAAAAAXRSTlMAQObYZgAAABVJREFUCNdjYEhgIIj///8AwsSoBQD43QydY5mb0QAAAABJRU5ErkJggg==);
    }
    
    .p-gui__image-container {
        width: 100%;
        padding: 3px;
        display: flex;
        justify-content: flex-start;
        flex-wrap: wrap;
    }
    
    .p-gui__image {
        background-size: cover;
        cursor: pointer;
        position: relative;
        margin: 1px 2.5px 19px 2.5px;
        border-radius: var(--main-border-radius);
        flex: 0 0 calc(33.333% - 5px);
        height: 90px;
        background-position: center;
    }

    .p-gui__image--selected::after {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        content: '';
        border: 1px solid #06FF89;
        box-sizing: border-box;
        border-radius: var(--main-border-radius);
    }
    
    .p-gui__image-text {
        position: absolute;
        bottom: -15px;
        color: #eee;
        text-shadow: 0 -1px 0 #111;
        white-space: nowrap;
        width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .p-gui__button, 
    .p-gui__switch,
    .p-gui__list,
    .p-gui__vector2,
    .p-gui__color {
        width: 100%;
        padding: 7px 13px;
        color: white;
        cursor: pointer;
        position: relative;
        box-sizing: border-box;
        margin-bottom: 3px;
        margin: 3px;
        
        border: 1px solid var(--color-border-2);
        border-radius: var(--main-border-radius);
    }

    .p-gui__vector2 {
        padding: 7px;
    }
    
    .p-gui__button,
    .p-gui__switch {
        margin-right: 4px;
        margin-left: 4px;
    }
    
    .p-gui__button {
        background: var(--color-accent);
        text-align: center;
        color: white;
        border: none;
    }
    
    .p-gui__button:hover {
        background: var(--color-accent-hover);
    }
    
    .p-gui__switch {
        background: rgba(255, 255, 255, .05);
    }

    .p-gui__switch:hover {
        background: rgba(255, 255, 255, .1);
    }
    
    .p-gui__folder .p-gui__button,
    .p-gui__folder .p-gui__switch {
        margin-right: 0;
        margin-left: 0;
    }
    
    .p-gui__vector2 {
        background: transparent;
        aspect-ratio: 1;
        padding-bottom: 0;
    }
    
    .p-gui__vector2-area {
        position: relative;
        background: rgba(0, 0, 0, .3);
        margin-top: 8px;
        width: 100%;
        height: calc(100% - 28px);
        touch-action: none;
    }
    
    .p-gui__vector2-line {
        position: absolute;
        background: white;
        opacity: .3;
        pointer-events: none;
    }
    
    .p-gui__vector2-line-x {
        width: 100%;
        height: 1px;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
    }
    
    .p-gui__vector2-line-y {
        width: 1px;
        height: 100%;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
    }
    
    .p-gui__vector2-dot {
        position: absolute;
        top: 0;
        left: 0;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #d5d5d5;
        border: 2px solid #ff9999;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }
    
    .p-gui__switch-checkbox {
        width: 5px;
        height: 5px;
        background-color: rgba(0, 0, 0, .5);
        border: 1px solid grey;
        position: absolute;
        top: 0;
        right: 10px;
        bottom: 0;
        margin: auto;
        border-radius: 50%;
        pointer-events: none;
    }
    
    .p-gui__switch-checkbox--active {
        background-color: #00ff89;
        box-shadow: 0 0 7px #00ff89;
    }
    
    .p-gui__list,
    .p-gui__color {
        cursor: default;
    }
    
    .p-gui__list-dropdown,
    .p-gui__color-picker {
        position: absolute;
        right: 5px;
        top: 0;
        bottom: 0;
        margin: auto;
        height: 21px;
        cursor: pointer;
        border-radius: 3px;
        border: 1px solid var(--color-border-2);
        outline: none;
    }
    
    .p-gui__list-dropdown {
        background: rgba(255, 255, 255,.05);
        color: white;
        padding: 0 12px;
        top: 0px;
    }
    
    .p-gui__list-dropdown:hover {
        background: rgba(255, 255, 255, .1);
    }
    
    .p-gui__color-picker {
        -webkit-appearance: none;
        padding: 0;
        background-color: transparent;
        border: 1px solid #222222;
        overflow: hidden;
    }
    
    .p-gui__color-picker::-webkit-color-swatch-wrapper {
        padding: 0;
    }
    .p-gui__color-picker::-webkit-color-swatch {
        border: none;
    }
    
    .p-gui__slider {
        width: 100%;
        margin-bottom: 10px;
        padding: 7px;
        color: white;
        position: relative;
        min-height: 14px;
    }
    
    .p-gui__slider-ctrl {
        -webkit-appearance: none;
        padding: 0;
        font: inherit;
        outline: none;
        opacity: .8;
        background: var(--color-accent);
        box-sizing: border-box;
        cursor: pointer;
        position: absolute;
        bottom: -4px; /* 5px height -1px de dépassement du curseur */
        right: 0;
        height: 5px;
        width: 100%;
        margin: 0;
    }
    
    /* la zone de déplacement */
    .p-gui__slider-ctrl::-webkit-slider-runnable-track {
        height: 13px;
        border: none;
        border-radius: 0;
        background-color: transparent;  /* supprimé définie sur l'input */
    }
    
    /* Curseur */
    .p-gui__slider-ctrl::-webkit-slider-thumb {
        -webkit-appearance: none;       /* également nécessaire sur le curseur */
        width: 15px;
        height: 7px;
        border: none;             /* pris en compte sur Webkit et Edge */
        background: white;       /* pris en compte sur Webkit only */
        position: relative;
        top: 3px;
        border-radius: 1px;
    }
    
    .p-gui__slider-value,
    .p-gui__vector-value {
        display: inline-block;
        position: absolute;
        right: 7px;
    }
    
    .p-gui__folder {
        width: 100%;
        position: relative;
        background: #434343;
        overflow: auto;
        margin-bottom: 3px;
        display: flex;
        flex-wrap: wrap;
        border: 1px solid grey;
        padding: 0 3px;
        border-radius: var(--main-border-radius);
    }
    
    .p-gui__folder:last-of-type {
        margin-bottom: 0;
        border-bottom: none;
    }
    
    .p-gui__folder--first {
        margin-top: 0;
    }
    
    .p-gui__folder--closed {
        height: 32px;
        overflow: hidden;
    }
    
    .p-gui__folder-header {
        padding: 10px 5px;
        background-color: rgba(0, 0, 0, .5);
        color: white;
        cursor: pointer;
        width: 100%;
        margin: 0 -2px 2px -3px;
    }
    
    .p-gui__folder-header:hover {
        background-color: rgba(0, 0, 0, .75);
    }
    
    .p-gui__folder-arrow {
        width: 8px;
        height: 8px;
        display: inline-block;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAHlBMVEUAAAD///////////////////////////////////8kfJuVAAAACXRSTlMA9Z1fCdMo1yxEJnA0AAAAK0lEQVQI12PABlRgjKkJUMZMYRhjpgqMAZSEMICSaIzpDWiKhdENhEhgAgATSg5jyWnYewAAAABJRU5ErkJggg==);
        background-size: contain;
        margin-right: 5px;
        transform: rotate(90deg)
    }
    
    .p-gui__folder--closed .p-gui__folder-arrow {
        transform: rotate(0deg);
    }
    `;
}
class GUI {
  constructor(ze = {}) {
    if (
      (ze.container
        ? ((this.container =
            typeof ze.container == "string"
              ? document.querySelector(ze.container)
              : ze.container),
          (this.position_type = "absolute"))
        : ((this.container = document.body), (this.position_type = "fixed")),
      typeof ze.onUpdate == "function" && (this.onUpdate = ze.onUpdate),
      (this.propReferences = []),
      (this.folders = []),
      ze.isFolder)
    ) {
      this._folderConstructor(ze.folderOptions);
      return;
    }
    (this.name = ze != null && typeof ze.name == "string" ? ze.name : ""),
      (this.backgroundColor = ze.color || null),
      this.container == document.body
        ? (this.maxHeight = window.innerHeight)
        : (this.maxHeight = Math.min(
            this.container.clientHeight,
            window.innerHeight
          )),
      ze.maxHeight &&
        ((this.initMaxHeight = ze.maxHeight),
        (this.maxHeight = Math.min(this.initMaxHeight, this.maxHeight))),
      (this.screenCorner = this._parseScreenCorner(ze.position)),
      window.perfectGUI || (window.perfectGUI = {}),
      window.perfectGUI.instanceCounter == null
        ? (window.perfectGUI.instanceCounter = 0)
        : window.perfectGUI.instanceCounter++,
      (this.instanceId = window.perfectGUI.instanceCounter),
      (this.wrapperWidth = ze.width || 290),
      (this.stylesheet = document.createElement("style")),
      this.stylesheet.setAttribute("type", "text/css"),
      this.stylesheet.setAttribute("id", "lm-gui-stylesheet"),
      document.head.append(this.stylesheet),
      this.instanceId == 0 && this._addStyles(`${styles(this.position_type)}`),
      this._styleInstance(),
      this._addWrapper(),
      this.wrapper.setAttribute("data-corner-x", this.screenCorner.x),
      this.wrapper.setAttribute("data-corner-y", this.screenCorner.y),
      ze.autoRepositioning != !1 &&
        window.addEventListener("resize", this._handleResize.bind(this)),
      this._handleResize(),
      (this.hasBeenDragged = !1),
      ze.draggable == !0 && this._makeDraggable(),
      (this.closed = !1),
      ze.closed && this.toggleClose();
  }
  _styleInstance() {
    let ze = this._getScrollbarWidth(this.container);
    if (
      (this.screenCorner.x == "left"
        ? (this.xOffset = 0)
        : (this.xOffset = this.container.clientWidth - this.wrapperWidth - ze),
      this.instanceId > 0)
    ) {
      let Gr = this.container.querySelectorAll(".p-gui");
      for (let Yr = 0; Yr < Gr.length; Yr++)
        this.screenCorner.y == Gr[Yr].dataset.cornerY &&
          (this.screenCorner.x == "left" && Gr[Yr].dataset.cornerX == "left"
            ? (this.xOffset += Gr[Yr].offsetWidth)
            : this.screenCorner.x == "right" &&
              Gr[Yr].dataset.cornerX == "right" &&
              (this.xOffset -= Gr[Yr].offsetWidth));
    }
    (this.yOffset = 0),
      (this.position = {
        prevX: this.xOffset,
        prevY: this.yOffset,
        x: this.xOffset,
        y: this.yOffset,
      }),
      this._addStyles(`#p-gui-${this.instanceId} {
            width: ${this.wrapperWidth}px;
            max-height: ${this.maxHeight}px;
            transform: translate3d(${this.xOffset}px,${this.yOffset}px,0);
            ${this.screenCorner.y == "top" ? "" : "top: auto; bottom: 0;"}
            ${
              this.backgroundColor
                ? "background: " + this.backgroundColor + ";"
                : ""
            }
        }`);
  }
  _folderConstructor(ze) {
    (this.wrapper = ze.wrapper),
      typeof ze.onUpdate == "function" && (this.onUpdate = ze.onUpdate);
  }
  _parseScreenCorner(ze) {
    let Gr = {
      x: "right",
      y: "top",
    };
    return (
      ze == null ||
        (typeof ze != "string" &&
          console.error("[perfect-gui] Position must be a string."),
        ze.includes("left") && (Gr.x = "left"),
        ze.includes("bottom") && (Gr.y = "bottom")),
      Gr
    );
  }
  _getScrollbarWidth(ze) {
    return ze === document.body
      ? window.innerWidth - document.documentElement.clientWidth
      : ze.offsetWidth - ze.clientWidth;
  }
  _handleResize() {
    if (
      (this.container == document.body
        ? (this.maxHeight = window.innerHeight)
        : (this.maxHeight = Math.min(
            this.container.clientHeight,
            window.innerHeight
          )),
      this.initMaxHeight &&
        (this.maxHeight = Math.min(this.initMaxHeight, this.maxHeight)),
      (this.wrapper.style.maxHeight = this.maxHeight + "px"),
      this.hasBeenDragged)
    )
      return;
    let ze = this._getScrollbarWidth(this.container);
    if (
      ((this.xOffset =
        this.screenCorner.x == "left"
          ? 0
          : this.container.clientWidth - this.wrapperWidth - ze),
      this.instanceId > 0)
    ) {
      let Gr = this.container.querySelectorAll(
        `.p-gui:not(#${this.wrapper.id}):not([data-dragged])`
      );
      for (
        let Yr = 0;
        Yr < Gr.length &&
        !(parseInt(Gr[Yr].id.replace("p-gui-", "")) > this.instanceId);
        Yr++
      )
        this.screenCorner.y == Gr[Yr].dataset.cornerY &&
          (this.screenCorner.x == "left" && Gr[Yr].dataset.cornerX == "left"
            ? (this.xOffset += Gr[Yr].offsetWidth)
            : this.screenCorner.x == "right" &&
              Gr[Yr].dataset.cornerX == "right" &&
              (this.xOffset -= Gr[Yr].offsetWidth));
    }
    (this.position = {
      prevX: this.xOffset,
      prevY: this.yOffset,
      x: this.xOffset,
      y: this.yOffset,
    }),
      (this.wrapper.style.transform = `translate3d(${this.position.x}px, ${this.position.y}px, 0)`);
  }
  _addStyles(ze) {
    this.stylesheet.innerHTML += ze;
  }
  _addWrapper() {
    (this.wrapper = document.createElement("div")),
      (this.wrapper.id = "p-gui-" + this.instanceId),
      (this.wrapper.className = "p-gui"),
      this.container.append(this.wrapper),
      (this.header = document.createElement("div")),
      (this.header.className = "p-gui__header"),
      (this.header.textContent = this.name),
      (this.header.style = `${
        this.backgroundColor
          ? "border-color: " + this.backgroundColor + ";"
          : ""
      }`),
      this.wrapper.append(this.header);
    const ze = document.createElement("div");
    (ze.className = "p-gui__header-close"),
      ze.addEventListener("click", this.toggleClose.bind(this)),
      this.header.append(ze);
  }
  button(ze, Gr) {
    let Yr = "";
    typeof ze != "string"
      ? typeof ze == "object" && ze != null && ze.hasOwnProperty("name")
        ? (Yr = ze.name == "" ? " " : ze.name)
        : (Yr = " ")
      : (Yr = ze == "" ? " " : ze),
      (this.imageContainer = null);
    const Kr = document.createElement("div");
    (Kr.className = "p-gui__button"),
      (Kr.textContent = Yr),
      Kr.addEventListener("click", () => {
        this.onUpdate && this.onUpdate(), Gr && Gr();
      }),
      this.wrapper.append(Kr),
      typeof ze.color == "string" &&
        (Kr.style.setProperty("--color-accent", ze.color),
        Kr.style.setProperty(
          "--color-accent-hover",
          ze.hoverColor || ze.color
        ));
  }
  image(ze = {}, Gr) {
    if (typeof ze != "object")
      throw Error(
        `[GUI] image() first parameter must be an object. Received: ${typeof ze}.`
      );
    let Yr;
    if (typeof ze.path == "string") Yr = ze.path;
    else
      throw typeof ze.path == null
        ? Error("[GUI] image() path must be provided.")
        : Error("[GUI] image() path must be a string.");
    let Kr = Yr.replace(/^.*[\\\/]/, ""),
      Zr;
    ze.name == null
      ? (Zr = Kr)
      : (Zr = (typeof ze.name == "string" && ze.name) || " ");
    const Jr = ze.selected === !0,
      Qr = ze.selectionBorder !== !1;
    let ei = "";
    ze.width &&
      (typeof ze.width == "number" && (ze.width += "px"),
      (ei += `flex: 0 0 calc(${ze.width} - 5px); `)),
      ze.height &&
        (typeof ze.height == "number" && (ze.height += "px"),
        (ei += `height: ${ze.height}; `)),
      this.imageContainer ||
        ((this.imageContainer = document.createElement("div")),
        (this.imageContainer.className = "p-gui__image-container"),
        this.wrapper.append(this.imageContainer));
    const ti = document.createElement("div");
    (ti.className = "p-gui__image"),
      (ti.style = "background-image: url(" + Yr + "); " + ei),
      this.imageContainer.append(ti),
      Jr && Qr && ti.classList.add("p-gui__image--selected");
    const ri = document.createElement("div");
    return (
      (ri.className = "p-gui__image-text"),
      (ri.textContent = Zr),
      ti.append(ri),
      ti.addEventListener("click", () => {
        let ni = ti.parentElement.querySelectorAll(".p-gui__image--selected");
        for (let ii = 0; ii < ni.length; ii++)
          ni[ii].classList.remove("p-gui__image--selected");
        Qr && ti.classList.add("p-gui__image--selected"),
          typeof Gr == "function" &&
            Gr({
              path: Yr,
              text: Zr,
            }),
          this.onUpdate && this.onUpdate();
      }),
      ti
    );
  }
  slider(ze = {}, Gr) {
    var oi, ui;
    if (typeof ze != "object")
      throw Error(
        `[GUI] slider() first parameter must be an object. Received: ${typeof ze}.`
      );
    let Yr = (typeof ze.name == "string" && ze.name) || " ",
      Kr = !1,
      Zr = null,
      Jr = ze.obj,
      Qr = ze.prop,
      ei = typeof ze.value == "number" ? ze.value : null,
      ti = (oi = ze.min) != null ? oi : 0,
      ri = (ui = ze.max) != null ? ui : 1,
      ni = ze.step || (ri - ti) / 100;
    if (ei !== null)
      (Qr != null || Jr != null) &&
        console.warn(
          '[GUI] slider() "obj" and "prop" parameters are ignored when a "value" parameter is used.'
        );
    else if (Qr != null && Jr != null) {
      if (typeof Qr != "string")
        throw Error(
          `[GUI] slider() "prop" parameter must be an string. Received: ${typeof Qr}.`
        );
      if (typeof Jr != "object")
        throw Error(
          `[GUI] slider() "obj" parameter must be an object. Received: ${typeof Jr}.`
        );
      Yr == " " && (Yr = Qr),
        (Zr = this.propReferences.push(Jr[Qr]) - 1),
        (Kr = !0);
    } else
      ((Qr != null && Jr == null) || (Qr == null && Jr == null)) &&
        console.warn(
          '[GUI] slider() "obj" and "prop" parameters must be used together.'
        ),
        (ei = (ri - ti) / 2);
    this.imageContainer = null;
    const ii = document.createElement("div");
    (ii.className = "p-gui__slider"),
      (ii.textContent = Yr),
      this.wrapper.append(ii);
    const si = document.createElement("input");
    (si.className = "p-gui__slider-ctrl"),
      si.setAttribute("type", "range"),
      si.setAttribute("min", ti),
      si.setAttribute("max", ri),
      si.setAttribute("step", ni),
      si.setAttribute("value", Kr ? Jr[Qr] : ei),
      ii.append(si);
    const li = document.createElement("div");
    (li.className = "p-gui__slider-value"),
      (li.textContent = String(Kr ? Jr[Qr] : ei)),
      ii.append(li),
      si.addEventListener("input", () => {
        (li.textContent = si.value),
          Kr
            ? (Jr[Qr] = parseFloat(si.value))
            : typeof Gr == "function" && Gr(parseFloat(si.value)),
          this.onUpdate && this.onUpdate();
      }),
      Kr &&
        Object.defineProperty(Jr, Qr, {
          set: (ai) => {
            (this.propReferences[Zr] = ai),
              (si.value = ai),
              (li.textContent = String(ai)),
              typeof Gr == "function" && Gr(parseFloat(si.value));
          },
          get: () => this.propReferences[Zr],
        });
  }
  toggle(ze = {}, Gr) {
    if (typeof ze != "object")
      throw Error(
        `[GUI] toggle() first parameter must be an object. Received: ${typeof ze}.`
      );
    let Yr = (typeof ze.name == "string" && ze.name) || " ",
      Kr = !1,
      Zr = null,
      Jr = ze.obj,
      Qr = ze.prop,
      ei = typeof ze.value == "boolean" ? ze.value : null;
    if (ei !== null)
      (Qr != null || Jr != null) &&
        console.warn(
          '[GUI] toggle() "obj" and "prop" parameters are ignored when a "value" parameter is used.'
        );
    else if (Qr != null && Jr != null) {
      if (typeof Qr != "string")
        throw Error(
          `[GUI] toggle() "prop" parameter must be an string. Received: ${typeof Qr}.`
        );
      if (typeof Jr != "object")
        throw Error(
          `[GUI] toggle() "obj" parameter must be an object. Received: ${typeof Jr}.`
        );
      Yr == " " && (Yr = Qr),
        (Zr = this.propReferences.push(Jr[Qr]) - 1),
        (Kr = !0);
    } else
      ((Qr != null && Jr == null) || (Qr == null && Jr == null)) &&
        console.warn(
          '[GUI] toggle() "obj" and "prop" parameters must be used together.'
        );
    this.imageContainer = null;
    const ti = document.createElement("div");
    (ti.textContent = Yr),
      (ti.className = "p-gui__switch"),
      this.wrapper.append(ti),
      ti.addEventListener("click", (ii) => {
        const si = ii.target.childNodes[1];
        let li = !0;
        si.classList.contains("p-gui__switch-checkbox--active") && (li = !1),
          si.classList.toggle("p-gui__switch-checkbox--active"),
          Kr ? (Jr[Qr] = li) : typeof Gr == "function" && Gr(li),
          this.onUpdate && this.onUpdate();
      });
    let ri = (() =>
      Kr
        ? Jr[Qr]
          ? " p-gui__switch-checkbox--active"
          : ""
        : ei
        ? " p-gui__switch-checkbox--active"
        : "")();
    const ni = document.createElement("div");
    (ni.className = "p-gui__switch-checkbox" + ri),
      ti.append(ni),
      Kr &&
        Object.defineProperty(Jr, Qr, {
          set: (ii) => {
            (this.propReferences[Zr] = ii),
              ii
                ? ni.classList.add("p-gui__switch-checkbox--active")
                : ni.classList.remove("p-gui__switch-checkbox--active"),
              typeof Gr == "function" && Gr(ii);
          },
          get: () => this.propReferences[Zr],
        });
  }
  list(ze = {}, Gr) {
    if (typeof ze != "object")
      throw Error(
        `[GUI] list() first parameter must be an object. Received: ${typeof ze}.`
      );
    let Yr = typeof ze.name == "string" ? ze.name : " ",
      Kr = !1,
      Zr = null,
      Jr = ze.obj,
      Qr = ze.prop,
      ei = Array.isArray(ze.values) ? ze.values : null,
      ti,
      ri = typeof ei[0] != "string";
    if (
      ((Gr = typeof Gr == "function" ? Gr : null),
      ze.value !== void 0 ||
        (ze.value === void 0 && Jr === void 0 && Qr === void 0))
    )
      (Qr != null || Jr != null) &&
        console.warn(
          '[GUI] list() "obj" and "prop" parameters are ignored when a "value" parameter is used.'
        ),
        (ti = (() => {
          if (!ei) return null;
          if (typeof ze.value == "string") return ei.indexOf(ze.value);
          if (typeof ze.value == "number") return ze.value;
        })());
    else if (Qr != null && Jr != null) {
      if (typeof Qr != "string")
        throw Error(
          `[GUI] list() "prop" parameter must be an string. Received: ${typeof Qr}.`
        );
      if (typeof Jr != "object")
        throw Error(
          `[GUI] list() "obj" parameter must be an object. Received: ${typeof Jr}.`
        );
      (ti = (() => {
        if (!ei) return null;
        if (typeof Jr[Qr] == "string")
          return ri
            ? ei.find((si) => si.value === Jr[Qr]).value
            : ei.indexOf(Jr[Qr]);
        if (typeof Jr[Qr] == "number")
          return ri ? ei.find((si) => si.value === Jr[Qr]).value : Jr[Qr];
      })()),
        (Zr = this.propReferences.push(Jr[Qr]) - 1),
        (Kr = !0);
    } else
      ((Qr != null && Jr == null) || (Qr == null && Jr == null)) &&
        console.warn(
          '[GUI] list() "obj" and "prop" parameters must be used together.'
        );
    this.imageContainer = null;
    let ni = document.createElement("div");
    (ni.className = "p-gui__list"),
      (ni.textContent = Yr),
      this.wrapper.append(ni);
    let ii = document.createElement("select");
    ni.append(ii),
      (ii.className = "p-gui__list-dropdown"),
      ii.addEventListener("change", (si) => {
        Kr ? (Jr[Qr] = si.target.value) : Gr && Gr(si.target.value),
          this.onUpdate && this.onUpdate();
      }),
      ei &&
        ei.forEach((si, li) => {
          const oi = ri ? si.name : si,
            ui = ri ? si.value : si;
          let ai = document.createElement("option");
          ai.setAttribute("value", ui),
            (ai.textContent = oi),
            ii.append(ai),
            ((!ri && ti == li) || (ri && ti == ui)) &&
              ai.setAttribute("selected", "");
        }),
      Kr &&
        Object.defineProperty(Jr, Qr, {
          set: (si) => {
            let li, oi, ui;
            ri
              ? ((ui = ei.find((hi) => hi.value == si)),
                (oi = (ui == null ? void 0 : ui.value) || ei[0].value),
                (li = ei.indexOf(ui)))
              : (typeof si == "string" && ((li = ei.indexOf(si)), (oi = si)),
                typeof si == "number" && ((li = si), (oi = ei[si]))),
              (this.propReferences[Zr] = ri ? oi : si);
            const ai = ii.querySelector("[selected]");
            ai && ai.removeAttribute("selected"),
              ii.querySelectorAll("option")[li].setAttribute("selected", ""),
              typeof Gr == "function" && Gr(ri ? ui : oi, li);
          },
          get: () => this.propReferences[Zr],
        });
  }
  vector2(ze = {}, Gr) {
    var di, pi, mi, Si;
    if (typeof ze != "object")
      throw Error(
        `[GUI] vector2() first parameter must be an object. Received: ${typeof ze}.`
      );
    let Yr = (typeof ze.name == "string" && ze.name) || " ";
    const Kr = (di = ze.x.min) != null ? di : 0,
      Zr = (pi = ze.x.max) != null ? pi : 1,
      Jr = (mi = ze.y.min) != null ? mi : 0,
      Qr = (Si = ze.y.max) != null ? Si : 1,
      ei = ze.x.obj,
      ti = ze.x.prop,
      ri = this.propReferences.push(ei[ti]) - 1,
      ni = ze.y.obj,
      ii = ze.y.prop,
      si = this.propReferences.push(ni[ii]) - 1;
    (Gr = typeof Gr == "function" ? Gr : null), (this.imageContainer = null);
    const li = document.createElement("div");
    (li.className = "p-gui__vector2"),
      (li.textContent = Yr),
      this.wrapper.append(li);
    const oi = document.createElement("div");
    (oi.className = "p-gui__vector-value"),
      (oi.textContent = ei[ti] + ", " + ni[ii]),
      li.append(oi);
    const ui = document.createElement("div");
    (ui.className = "p-gui__vector2-area"),
      li.append(ui),
      ui.addEventListener("click", (yi) => {
        (ei[ti] = parseFloat(
          this._mapLinear(yi.offsetX, 0, ui.clientWidth, Kr, Zr).toFixed(2)
        )),
          (ni[ii] = parseFloat(
            this._mapLinear(yi.offsetY, 0, ui.clientHeight, Qr, Jr).toFixed(2)
          )),
          Gr && Gr(ei[ti], ei[ii]),
          this.onUpdate && this.onUpdate();
      });
    let ai = !1;
    ui.addEventListener("pointerdown", (yi) => {
      ai = !0;
    }),
      ui.addEventListener("pointerup", () => {
        ai = !1;
      }),
      ui.addEventListener("pointermove", (yi) => {
        ai &&
          ((ei[ti] = parseFloat(
            this._mapLinear(yi.offsetX, 0, ui.clientWidth, Kr, Zr).toFixed(2)
          )),
          (ni[ii] = parseFloat(
            this._mapLinear(yi.offsetY, 0, ui.clientHeight, Qr, Jr).toFixed(2)
          )),
          Gr && Gr(ei[ti], ei[ii])),
          this.onUpdate && this.onUpdate();
      });
    const hi = document.createElement("div");
    (hi.className = "p-gui__vector2-line p-gui__vector2-line-x"), ui.append(hi);
    const ci = document.createElement("div");
    (ci.className = "p-gui__vector2-line p-gui__vector2-line-y"), ui.append(ci);
    const fi = document.createElement("div");
    (fi.className = "p-gui__vector2-dot"),
      ui.append(fi),
      (fi.style.left =
        this._mapLinear(ei[ti], Kr, Zr, 0, ui.clientWidth) + "px"),
      (fi.style.top =
        this._mapLinear(ni[ii], Jr, Qr, ui.clientHeight, 0) + "px"),
      Object.defineProperty(ei, ti, {
        set: (yi) => {
          (this.propReferences[ri] = yi),
            (fi.style.left =
              this._mapLinear(yi, Kr, Zr, 0, ui.clientWidth) + "px"),
            (oi.textContent = String(yi) + ", " + ni[ii]);
        },
        get: () => this.propReferences[ri],
      }),
      Object.defineProperty(ni, ii, {
        set: (yi) => {
          (this.propReferences[si] = yi),
            (fi.style.top =
              this._mapLinear(yi, Jr, Qr, ui.clientHeight, 0) + "px"),
            (oi.textContent = ei[ti] + ", " + String(yi));
        },
        get: () => this.propReferences[si],
      });
  }
  color(ze = {}, Gr) {
    if (typeof ze != "object")
      throw Error(
        `[GUI] color() first parameter must be an object. Received: ${typeof ze}.`
      );
    let Yr = (typeof ze.name == "string" && ze.name) || " ",
      Kr = !1,
      Zr = null,
      Jr = ze.obj,
      Qr = ze.prop,
      ei;
    if (
      (typeof ze.value == "string" &&
        (ze.value.length != 7 || ze.value[0] != "#"
          ? console.error(
              `[GUI] color() 'value' parameter must be an hexadecimal string in the format "#ffffff". Received: "${ze.value}".`
            )
          : (ei = ze.value)),
      ei || (ei = "#000000"),
      ze.value !== void 0)
    )
      (Qr != null || Jr != null) &&
        console.warn(
          '[GUI] color() "obj" and "prop" parameters are ignored when a "value" parameter is used.'
        );
    else if (Qr != null && Jr != null) {
      if (typeof Qr != "string")
        throw Error(
          `[GUI] color() "prop" parameter must be an string. Received: ${typeof Qr}.`
        );
      if (typeof Jr != "object")
        throw Error(
          `[GUI] color() "obj" parameter must be an object. Received: ${typeof Jr}.`
        );
      Yr == " " && (Yr = Qr),
        (Zr = this.propReferences.push(Jr[Qr]) - 1),
        (Kr = !0);
    } else
      ((Qr != null && Jr == null) || (Qr == null && Jr == null)) &&
        console.warn(
          '[GUI] color() "obj" and "prop" parameters must be used together.'
        );
    this.imageContainer = null;
    const ti = document.createElement("div");
    (ti.className = "p-gui__color"),
      (ti.textContent = Yr),
      this.wrapper.append(ti);
    const ri = document.createElement("input");
    (ri.className = "p-gui__color-picker"),
      ri.setAttribute("type", "color"),
      (ri.value = ei),
      ti.append(ri),
      typeof Gr == "function" &&
        ri.addEventListener("input", () => {
          Kr ? (Jr[Qr] = ri.value) : typeof Gr == "function" && Gr(ri.value),
            this.onUpdate && this.onUpdate();
        }),
      Kr &&
        Object.defineProperty(Jr, Qr, {
          set: (ni) => {
            (this.propReferences[Zr] = ni),
              (ri.value = ni),
              typeof Gr == "function" && Gr(ni);
          },
          get: () => this.propReferences[Zr],
        });
  }
  folder(ze = {}) {
    let Gr = typeof ze.closed == "boolean" ? ze.closed : !1,
      Yr = ze.name || "",
      Kr = ze.color || null,
      Zr = ze.maxHeight || null;
    this.imageContainer = null;
    let Jr = "p-gui__folder";
    this.folders.length == 0 && (Jr += " p-gui__folder--first"),
      Gr && (Jr += " p-gui__folder--closed");
    let Qr = Kr ? `background-color: ${Kr};` : "";
    Qr += Zr ? `max-height: ${Zr}px;` : "";
    const ei = document.createElement("div");
    (ei.className = Jr), (ei.style = Qr), this.wrapper.append(ei);
    const ti = document.createElement("div");
    (ti.innerHTML = `<span class="p-gui__folder-arrow"></span>${Yr}`),
      (ti.className = "p-gui__folder-header"),
      ei.append(ti),
      ti.addEventListener("click", () => {
        ei.classList.toggle("p-gui__folder--closed");
      });
    let ri = new GUI({
      isFolder: !0,
      folderOptions: {
        wrapper: ei,
        onUpdate: this.onUpdate,
      },
    });
    return this.folders.push(ri), ri;
  }
  _makeDraggable() {
    var ze = this;
    this.header.addEventListener("pointerdown", Gr),
      this.header.addEventListener("pointerup", Kr);
    function Gr(Zr) {
      Zr.preventDefault(),
        (ze.position.initX = ze.position.x),
        (ze.position.initY = ze.position.y),
        (ze.position.prevX = Zr.clientX),
        (ze.position.prevY = Zr.clientY),
        document.addEventListener("pointermove", Yr);
    }
    function Yr(Zr) {
      Zr.preventDefault(),
        ze.hasBeenDragged ||
          ((ze.hasBeenDragged = !0),
          ze.wrapper.setAttribute("data-dragged", "true")),
        (ze.position.x = ze.position.initX + Zr.clientX - ze.position.prevX),
        (ze.position.y = ze.position.initY + Zr.clientY - ze.position.prevY),
        (ze.wrapper.style.transform =
          "translate3d(" + ze.position.x + "px," + ze.position.y + "px,0)");
    }
    function Kr(Zr) {
      document.removeEventListener("pointermove", Yr);
    }
  }
  toggleClose() {
    (this.closed = !this.closed),
      this.wrapper.classList.toggle("p-gui--collapsed");
  }
  kill() {
    this.wrapper.remove();
  }
  _mapLinear(ze, Gr, Yr, Kr, Zr) {
    return Kr + ((ze - Gr) * (Zr - Kr)) / (Yr - Gr);
  }
}
const noiseImageUrl = "/dist/assets/3seamless-7f29af5e.png",
  uTime = new Uniform(0),
  uSize = new Uniform(0.2),
  uOffset = new Uniform(new Vector2(0.42, 0.6)),
  uSpeed = new Uniform(0.02),
  uColor1 = new Uniform(new Color("rgb(65,66,73)")),
  uColor2 = new Uniform(new Color("rgb(36,39,51)")),
  uColor3 = new Uniform(new Color("rgb(49,103,160)")),
  uColor4 = new Uniform(new Color("rgb(117,153,245)")),
  noiseTexture = new TextureLoader().load(noiseImageUrl);
noiseTexture.wrapS = noiseTexture.wrapT = RepeatWrapping;
const uNoiseTexture = new Uniform(noiseTexture),
  uColorMixer = new Uniform(0),
  uMenuMode = new Uniform(0),
  uAdditionalZoom = new Uniform(0),
  uAdditionalOffset = new Uniform(new Vector2(0, 0));
gsapWithCSS.ticker.add((Wr) => (uTime.value = Wr));
let gui$1;
const debug$1 = {
    mount: () => {
      gui$1 ||
        ((gui$1 = new GUI({
          name: "gradient",
          closed: !0,
        })),
        gui$1.slider({
          name: "size",
          obj: uSize,
          prop: "value",
          max: 2,
        }),
        gui$1.vector2({
          name: "Position",
          x: {
            obj: uOffset.value,
            prop: "x",
            min: uOffset.value.x - 2,
            max: uOffset.value.x + 2,
          },
          y: {
            obj: uOffset.value,
            prop: "y",
            min: uOffset.value.y - 2,
            max: uOffset.value.y + 2,
          },
        }),
        gui$1.slider({
          name: "speed",
          obj: uSpeed,
          prop: "value",
          min: 0,
          max: 0.1,
        }),
        gui$1.color(
          {
            name: "color1",
            value: "#" + uColor1.value.getHexString(),
          },
          (Wr) => {
            uColor1.value.set(Wr);
          }
        ),
        gui$1.color(
          {
            name: "color2",
            value: "#" + uColor2.value.getHexString(),
          },
          (Wr) => {
            uColor2.value.set(Wr);
          }
        ),
        gui$1.color(
          {
            name: "color3",
            value: "#" + uColor3.value.getHexString(),
          },
          (Wr) => {
            uColor3.value.set(Wr);
          }
        ),
        gui$1.color(
          {
            name: "color4",
            value: "#" + uColor4.value.getHexString(),
          },
          (Wr) => {
            uColor4.value.set(Wr);
          }
        ),
        gui$1.slider({
          name: "uColorMixer",
          obj: uColorMixer,
          prop: "value",
        }));
    },
    unmount: () => {
      gui$1 && gui$1.kill(), (gui$1 = void 0);
    },
  },
  // na here eh
  material = new ShaderMaterial({
    vertexShader: `
    varying vec2 vUv;

    void main() {
      gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
      vUv = uv;
    }`,
    fragmentShader: glsl`
    varying vec2 vUv;

    uniform float uTime;
    uniform vec3 uColor1;
    uniform vec3 uColor2;
    uniform vec3 uColor3;
    uniform vec3 uColor4;
    uniform float uSize;
    uniform vec2 uOffset;
    uniform float uSpeed;
    uniform sampler2D uNoiseTexture;
    uniform sampler2D uSimulationTexture;
    uniform vec2 uResolution;
    uniform float uColorMixer;
    uniform float uMenuMode;
    uniform float uAdditionalZoom;
    uniform vec2 uAdditionalOffset;
    uniform float uScrollOffset;

    void main() {
        vec2 nUv = (-.5 + vUv) * 2.;
        if( uResolution.x < uResolution.y ) {
            nUv.x *= uResolution.x / uResolution.y;
        } else {
            nUv.y *= uResolution.y / uResolution.x;
        }
        nUv = nUv / 2. + .5;

        float additionalZoom = uAdditionalZoom * (1. - uMenuMode);
        vec2 offset = uOffset + uAdditionalOffset * (1. - uMenuMode);
        offset.y -= uScrollOffset;

        vec2 bUv = nUv * (uSize * 2. + additionalZoom) + offset * uMenuMode; // dUv
        vec2 nUv1 = bUv + offset * (1. - uMenuMode) + uTime * uSpeed;
        bUv.y -= .5;
        vec2 nUv2 = bUv + offset * (1. - uMenuMode) - uTime * uSpeed;

        vec4 noiseColor1 = texture2D(uNoiseTexture, nUv1);
        float noise1 = noiseColor1.r;

        vec4 noiseColor2 = texture2D(uNoiseTexture, nUv2);
        float noise2 = noiseColor2.r;

        //float noise = clamp(noise1 * .5 + noise2 * .5, 0., 1.);
        float noise = clamp((noise1 + noise2) / 2., 0., 1.);

        vec2 nUv3 = bUv + noise * .5;
        noise = texture2D(uNoiseTexture, nUv3).r;


        // coloring
        vec3 color = vec3(0.);
        noise = mix(noise, noise * 1.25 + .15, uMenuMode);
        if (noise < 0.25) {
            color = mix(uColor1, uColor2, noise / 0.25);
        } else if (noise < 0.5) {
            color = mix(uColor2, uColor3, (noise - 0.25) / 0.25);
        } else if (noise < 0.75) {
            color = mix(uColor3, uColor4, (noise - 0.5) / 0.25);
        } else {
            color = uColor4;
        }

        //color = step(.5, color);

        //color = mix(color, pow(color, vec3(2.)), uColorMixer);
        vec3 alt = pow(color, vec3(2.));
        alt = alt * 1. - step(.01, color);
        color = mix(color, alt, uColorMixer);

        gl_FragColor = vec4(color, 1.);
        //gl_FragColor = gpgpuColor;

        #include <tonemapping_fragment>
        #include <colorspace_fragment>
    }`,
    uniforms: {
      uMouse: uLerpedMouseUv,
      uTime,
      uColor1,
      uColor2,
      uColor3,
      uColor4,
      uSize,
      uOffset,
      uSpeed,
      uNoiseTexture,
      uSimulationTexture,
      uResolution,
      uColorMixer,
      uMenuMode,
      uAdditionalZoom,
      uAdditionalOffset,
      uScrollOffset,
    },
  });
/**
 * postprocessing v6.35.4 build Fri Apr 26 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rüschen
 * @license Zlib
 */
var MILLISECONDS_TO_SECONDS = 1 / 1e3,
  SECONDS_TO_MILLISECONDS = 1e3,
  Timer = class {
    constructor() {
      (this.startTime = performance.now()),
        (this.previousTime = 0),
        (this.currentTime = 0),
        (this._delta = 0),
        (this._elapsed = 0),
        (this._fixedDelta = 1e3 / 60),
        (this.timescale = 1),
        (this.useFixedDelta = !1),
        (this._autoReset = !1);
    }
    get autoReset() {
      return this._autoReset;
    }
    set autoReset(Wr) {
      typeof document < "u" &&
        document.hidden !== void 0 &&
        (Wr
          ? document.addEventListener("visibilitychange", this)
          : document.removeEventListener("visibilitychange", this),
        (this._autoReset = Wr));
    }
    get delta() {
      return this._delta * MILLISECONDS_TO_SECONDS;
    }
    get fixedDelta() {
      return this._fixedDelta * MILLISECONDS_TO_SECONDS;
    }
    set fixedDelta(Wr) {
      this._fixedDelta = Wr * SECONDS_TO_MILLISECONDS;
    }
    get elapsed() {
      return this._elapsed * MILLISECONDS_TO_SECONDS;
    }
    update(Wr) {
      this.useFixedDelta
        ? (this._delta = this.fixedDelta)
        : ((this.previousTime = this.currentTime),
          (this.currentTime =
            (Wr !== void 0 ? Wr : performance.now()) - this.startTime),
          (this._delta = this.currentTime - this.previousTime)),
        (this._delta *= this.timescale),
        (this._elapsed += this._delta);
    }
    reset() {
      (this._delta = 0),
        (this._elapsed = 0),
        (this.currentTime = performance.now() - this.startTime);
    }
    getDelta() {
      return this.delta;
    }
    getElapsed() {
      return this.elapsed;
    }
    handleEvent(Wr) {
      document.hidden ||
        (this.currentTime = performance.now() - this.startTime);
    }
    dispose() {
      this.autoReset = !1;
    }
  },
  dummyCamera = new Camera(),
  geometry = null;
function getFullscreenTriangle() {
  if (geometry === null) {
    const Wr = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
      ze = new Float32Array([0, 0, 2, 0, 0, 2]);
    (geometry = new BufferGeometry()),
      geometry.setAttribute !== void 0
        ? (geometry.setAttribute("position", new BufferAttribute(Wr, 3)),
          geometry.setAttribute("uv", new BufferAttribute(ze, 2)))
        : (geometry.addAttribute("position", new BufferAttribute(Wr, 3)),
          geometry.addAttribute("uv", new BufferAttribute(ze, 2)));
  }
  return geometry;
}
var Pass = class gs {
    constructor(ze = "Pass", Gr = new Scene(), Yr = dummyCamera) {
      (this.name = ze),
        (this.renderer = null),
        (this.scene = Gr),
        (this.camera = Yr),
        (this.screen = null),
        (this.rtt = !0),
        (this.needsSwap = !0),
        (this.needsDepthTexture = !1),
        (this.enabled = !0);
    }
    get renderToScreen() {
      return !this.rtt;
    }
    set renderToScreen(ze) {
      if (this.rtt === ze) {
        const Gr = this.fullscreenMaterial;
        Gr !== null && (Gr.needsUpdate = !0), (this.rtt = !ze);
      }
    }
    set mainScene(ze) {}
    set mainCamera(ze) {}
    setRenderer(ze) {
      this.renderer = ze;
    }
    isEnabled() {
      return this.enabled;
    }
    setEnabled(ze) {
      this.enabled = ze;
    }
    get fullscreenMaterial() {
      return this.screen !== null ? this.screen.material : null;
    }
    set fullscreenMaterial(ze) {
      let Gr = this.screen;
      Gr !== null
        ? (Gr.material = ze)
        : ((Gr = new Mesh(getFullscreenTriangle(), ze)),
          (Gr.frustumCulled = !1),
          this.scene === null && (this.scene = new Scene()),
          this.scene.add(Gr),
          (this.screen = Gr));
    }
    getFullscreenMaterial() {
      return this.fullscreenMaterial;
    }
    setFullscreenMaterial(ze) {
      this.fullscreenMaterial = ze;
    }
    getDepthTexture() {
      return null;
    }
    setDepthTexture(ze, Gr = BasicDepthPacking) {}
    render(ze, Gr, Yr, Kr, Zr) {
      throw new Error("Render method not implemented!");
    }
    setSize(ze, Gr) {}
    initialize(ze, Gr, Yr) {}
    dispose() {
      for (const ze of Object.keys(this)) {
        const Gr = this[ze];
        (Gr instanceof WebGLRenderTarget ||
          Gr instanceof Material ||
          Gr instanceof Texture ||
          Gr instanceof gs) &&
          this[ze].dispose();
      }
    }
  },
  ClearMaskPass = class extends Pass {
    constructor() {
      super("ClearMaskPass", null, null), (this.needsSwap = !1);
    }
    render(Wr, ze, Gr, Yr, Kr) {
      const Zr = Wr.state.buffers.stencil;
      Zr.setLocked(!1), Zr.setTest(!1);
    }
  },
  revision = Number(REVISION.replace(/\D+/g, ""));
function updateFragmentShader(Wr) {
  return revision < 154
    ? Wr.replace("colorspace_fragment", "encodings_fragment")
    : Wr;
}
var copy_default = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,
  common_default =
    "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
  CopyMaterial = class extends ShaderMaterial {
    constructor() {
      super({
        name: "CopyMaterial",
        uniforms: {
          inputBuffer: new Uniform(null),
          opacity: new Uniform(1),
        },
        blending: NoBlending,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: copy_default,
        vertexShader: common_default,
      }),
        (this.fragmentShader = updateFragmentShader(this.fragmentShader));
    }
    set inputBuffer(Wr) {
      this.uniforms.inputBuffer.value = Wr;
    }
    setInputBuffer(Wr) {
      this.uniforms.inputBuffer.value = Wr;
    }
    getOpacity(Wr) {
      return this.uniforms.opacity.value;
    }
    setOpacity(Wr) {
      this.uniforms.opacity.value = Wr;
    }
  },
  CopyPass = class extends Pass {
    constructor(Wr, ze = !0) {
      super("CopyPass"),
        (this.fullscreenMaterial = new CopyMaterial()),
        (this.needsSwap = !1),
        (this.renderTarget = Wr),
        Wr === void 0 &&
          ((this.renderTarget = new WebGLRenderTarget(1, 1, {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            stencilBuffer: !1,
            depthBuffer: !1,
          })),
          (this.renderTarget.texture.name = "CopyPass.Target")),
        (this.autoResize = ze);
    }
    get resize() {
      return this.autoResize;
    }
    set resize(Wr) {
      this.autoResize = Wr;
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getTexture() {
      return this.renderTarget.texture;
    }
    setAutoResizeEnabled(Wr) {
      this.autoResize = Wr;
    }
    render(Wr, ze, Gr, Yr, Kr) {
      (this.fullscreenMaterial.inputBuffer = ze.texture),
        Wr.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        Wr.render(this.scene, this.camera);
    }
    setSize(Wr, ze) {
      this.autoResize && this.renderTarget.setSize(Wr, ze);
    }
    initialize(Wr, ze, Gr) {
      Gr !== void 0 &&
        ((this.renderTarget.texture.type = Gr),
        Gr !== UnsignedByteType
          ? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
          : Wr !== null &&
            Wr.outputColorSpace === SRGBColorSpace &&
            (this.renderTarget.texture.colorSpace = SRGBColorSpace));
    }
  },
  color = new Color(),
  ClearPass = class extends Pass {
    constructor(Wr = !0, ze = !0, Gr = !1) {
      super("ClearPass", null, null),
        (this.needsSwap = !1),
        (this.color = Wr),
        (this.depth = ze),
        (this.stencil = Gr),
        (this.overrideClearColor = null),
        (this.overrideClearAlpha = -1);
    }
    setClearFlags(Wr, ze, Gr) {
      (this.color = Wr), (this.depth = ze), (this.stencil = Gr);
    }
    getOverrideClearColor() {
      return this.overrideClearColor;
    }
    setOverrideClearColor(Wr) {
      this.overrideClearColor = Wr;
    }
    getOverrideClearAlpha() {
      return this.overrideClearAlpha;
    }
    setOverrideClearAlpha(Wr) {
      this.overrideClearAlpha = Wr;
    }
    render(Wr, ze, Gr, Yr, Kr) {
      const Zr = this.overrideClearColor,
        Jr = this.overrideClearAlpha,
        Qr = Wr.getClearAlpha(),
        ei = Zr !== null,
        ti = Jr >= 0;
      ei
        ? (Wr.getClearColor(color), Wr.setClearColor(Zr, ti ? Jr : Qr))
        : ti && Wr.setClearAlpha(Jr),
        Wr.setRenderTarget(this.renderToScreen ? null : ze),
        Wr.clear(this.color, this.depth, this.stencil),
        ei ? Wr.setClearColor(color, Qr) : ti && Wr.setClearAlpha(Qr);
    }
  },
  MaskPass = class extends Pass {
    constructor(Wr, ze) {
      super("MaskPass", Wr, ze),
        (this.needsSwap = !1),
        (this.clearPass = new ClearPass(!1, !1, !0)),
        (this.inverse = !1);
    }
    set mainScene(Wr) {
      this.scene = Wr;
    }
    set mainCamera(Wr) {
      this.camera = Wr;
    }
    get inverted() {
      return this.inverse;
    }
    set inverted(Wr) {
      this.inverse = Wr;
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(Wr) {
      this.clearPass.enabled = Wr;
    }
    getClearPass() {
      return this.clearPass;
    }
    isInverted() {
      return this.inverted;
    }
    setInverted(Wr) {
      this.inverted = Wr;
    }
    render(Wr, ze, Gr, Yr, Kr) {
      const Zr = Wr.getContext(),
        Jr = Wr.state.buffers,
        Qr = this.scene,
        ei = this.camera,
        ti = this.clearPass,
        ri = this.inverted ? 0 : 1,
        ni = 1 - ri;
      Jr.color.setMask(!1),
        Jr.depth.setMask(!1),
        Jr.color.setLocked(!0),
        Jr.depth.setLocked(!0),
        Jr.stencil.setTest(!0),
        Jr.stencil.setOp(Zr.REPLACE, Zr.REPLACE, Zr.REPLACE),
        Jr.stencil.setFunc(Zr.ALWAYS, ri, 4294967295),
        Jr.stencil.setClear(ni),
        Jr.stencil.setLocked(!0),
        this.clearPass.enabled &&
          (this.renderToScreen
            ? ti.render(Wr, null)
            : (ti.render(Wr, ze), ti.render(Wr, Gr))),
        this.renderToScreen
          ? (Wr.setRenderTarget(null), Wr.render(Qr, ei))
          : (Wr.setRenderTarget(ze),
            Wr.render(Qr, ei),
            Wr.setRenderTarget(Gr),
            Wr.render(Qr, ei)),
        Jr.color.setLocked(!1),
        Jr.depth.setLocked(!1),
        Jr.stencil.setLocked(!1),
        Jr.stencil.setFunc(Zr.EQUAL, 1, 4294967295),
        Jr.stencil.setOp(Zr.KEEP, Zr.KEEP, Zr.KEEP),
        Jr.stencil.setLocked(!0);
    }
  },
  EffectComposer = class {
    constructor(
      Wr = null,
      {
        depthBuffer: ze = !0,
        stencilBuffer: Gr = !1,
        multisampling: Yr = 0,
        frameBufferType: Kr,
      } = {}
    ) {
      (this.renderer = null),
        (this.inputBuffer = this.createBuffer(ze, Gr, Kr, Yr)),
        (this.outputBuffer = this.inputBuffer.clone()),
        (this.copyPass = new CopyPass()),
        (this.depthTexture = null),
        (this.passes = []),
        (this.timer = new Timer()),
        (this.autoRenderToScreen = !0),
        this.setRenderer(Wr);
    }
    get multisampling() {
      return this.inputBuffer.samples || 0;
    }
    set multisampling(Wr) {
      const ze = this.inputBuffer,
        Gr = this.multisampling;
      Gr > 0 && Wr > 0
        ? ((this.inputBuffer.samples = Wr),
          (this.outputBuffer.samples = Wr),
          this.inputBuffer.dispose(),
          this.outputBuffer.dispose())
        : Gr !== Wr &&
          (this.inputBuffer.dispose(),
          this.outputBuffer.dispose(),
          (this.inputBuffer = this.createBuffer(
            ze.depthBuffer,
            ze.stencilBuffer,
            ze.texture.type,
            Wr
          )),
          (this.inputBuffer.depthTexture = this.depthTexture),
          (this.outputBuffer = this.inputBuffer.clone()));
    }
    getTimer() {
      return this.timer;
    }
    getRenderer() {
      return this.renderer;
    }
    setRenderer(Wr) {
      if (((this.renderer = Wr), Wr !== null)) {
        const ze = Wr.getSize(new Vector2()),
          Gr = Wr.getContext().getContextAttributes().alpha,
          Yr = this.inputBuffer.texture.type;
        Yr === UnsignedByteType &&
          Wr.outputColorSpace === SRGBColorSpace &&
          ((this.inputBuffer.texture.colorSpace = SRGBColorSpace),
          (this.outputBuffer.texture.colorSpace = SRGBColorSpace),
          this.inputBuffer.dispose(),
          this.outputBuffer.dispose()),
          (Wr.autoClear = !1),
          this.setSize(ze.width, ze.height);
        for (const Kr of this.passes) Kr.initialize(Wr, Gr, Yr);
      }
    }
    replaceRenderer(Wr, ze = !0) {
      const Gr = this.renderer,
        Yr = Gr.domElement.parentNode;
      return (
        this.setRenderer(Wr),
        ze &&
          Yr !== null &&
          (Yr.removeChild(Gr.domElement), Yr.appendChild(Wr.domElement)),
        Gr
      );
    }
    createDepthTexture() {
      const Wr = (this.depthTexture = new DepthTexture());
      return (
        (this.inputBuffer.depthTexture = Wr),
        this.inputBuffer.dispose(),
        this.inputBuffer.stencilBuffer
          ? ((Wr.format = DepthStencilFormat), (Wr.type = UnsignedInt248Type))
          : (Wr.type = UnsignedIntType),
        Wr
      );
    }
    deleteDepthTexture() {
      if (this.depthTexture !== null) {
        this.depthTexture.dispose(),
          (this.depthTexture = null),
          (this.inputBuffer.depthTexture = null),
          this.inputBuffer.dispose();
        for (const Wr of this.passes) Wr.setDepthTexture(null);
      }
    }
    createBuffer(Wr, ze, Gr, Yr) {
      const Kr = this.renderer,
        Zr =
          Kr === null ? new Vector2() : Kr.getDrawingBufferSize(new Vector2()),
        Jr = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          stencilBuffer: ze,
          depthBuffer: Wr,
          type: Gr,
        },
        Qr = new WebGLRenderTarget(Zr.width, Zr.height, Jr);
      return (
        Yr > 0 && ((Qr.ignoreDepthForMultisampleCopy = !1), (Qr.samples = Yr)),
        Gr === UnsignedByteType &&
          Kr !== null &&
          Kr.outputColorSpace === SRGBColorSpace &&
          (Qr.texture.colorSpace = SRGBColorSpace),
        (Qr.texture.name = "EffectComposer.Buffer"),
        (Qr.texture.generateMipmaps = !1),
        Qr
      );
    }
    setMainScene(Wr) {
      for (const ze of this.passes) ze.mainScene = Wr;
    }
    setMainCamera(Wr) {
      for (const ze of this.passes) ze.mainCamera = Wr;
    }
    addPass(Wr, ze) {
      const Gr = this.passes,
        Yr = this.renderer,
        Kr = Yr.getDrawingBufferSize(new Vector2()),
        Zr = Yr.getContext().getContextAttributes().alpha,
        Jr = this.inputBuffer.texture.type;
      if (
        (Wr.setRenderer(Yr),
        Wr.setSize(Kr.width, Kr.height),
        Wr.initialize(Yr, Zr, Jr),
        this.autoRenderToScreen &&
          (Gr.length > 0 && (Gr[Gr.length - 1].renderToScreen = !1),
          Wr.renderToScreen && (this.autoRenderToScreen = !1)),
        ze !== void 0 ? Gr.splice(ze, 0, Wr) : Gr.push(Wr),
        this.autoRenderToScreen && (Gr[Gr.length - 1].renderToScreen = !0),
        Wr.needsDepthTexture || this.depthTexture !== null)
      )
        if (this.depthTexture === null) {
          const Qr = this.createDepthTexture();
          for (Wr of Gr) Wr.setDepthTexture(Qr);
        } else Wr.setDepthTexture(this.depthTexture);
    }
    removePass(Wr) {
      const ze = this.passes,
        Gr = ze.indexOf(Wr);
      if (Gr !== -1 && ze.splice(Gr, 1).length > 0) {
        if (this.depthTexture !== null) {
          const Zr = (Qr, ei) => Qr || ei.needsDepthTexture;
          ze.reduce(Zr, !1) ||
            (Wr.getDepthTexture() === this.depthTexture &&
              Wr.setDepthTexture(null),
            this.deleteDepthTexture());
        }
        this.autoRenderToScreen &&
          Gr === ze.length &&
          ((Wr.renderToScreen = !1),
          ze.length > 0 && (ze[ze.length - 1].renderToScreen = !0));
      }
    }
    removeAllPasses() {
      const Wr = this.passes;
      this.deleteDepthTexture(),
        Wr.length > 0 &&
          (this.autoRenderToScreen && (Wr[Wr.length - 1].renderToScreen = !1),
          (this.passes = []));
    }
    render(Wr) {
      const ze = this.renderer,
        Gr = this.copyPass;
      let Yr = this.inputBuffer,
        Kr = this.outputBuffer,
        Zr = !1,
        Jr,
        Qr,
        ei;
      Wr === void 0 && (this.timer.update(), (Wr = this.timer.getDelta()));
      for (const ti of this.passes)
        ti.enabled &&
          (ti.render(ze, Yr, Kr, Wr, Zr),
          ti.needsSwap &&
            (Zr &&
              ((Gr.renderToScreen = ti.renderToScreen),
              (Jr = ze.getContext()),
              (Qr = ze.state.buffers.stencil),
              Qr.setFunc(Jr.NOTEQUAL, 1, 4294967295),
              Gr.render(ze, Yr, Kr, Wr, Zr),
              Qr.setFunc(Jr.EQUAL, 1, 4294967295)),
            (ei = Yr),
            (Yr = Kr),
            (Kr = ei)),
          ti instanceof MaskPass
            ? (Zr = !0)
            : ti instanceof ClearMaskPass && (Zr = !1));
    }
    setSize(Wr, ze, Gr) {
      const Yr = this.renderer,
        Kr = Yr.getSize(new Vector2());
      (Wr === void 0 || ze === void 0) && ((Wr = Kr.width), (ze = Kr.height)),
        (Kr.width !== Wr || Kr.height !== ze) && Yr.setSize(Wr, ze, Gr);
      const Zr = Yr.getDrawingBufferSize(new Vector2());
      this.inputBuffer.setSize(Zr.width, Zr.height),
        this.outputBuffer.setSize(Zr.width, Zr.height);
      for (const Jr of this.passes) Jr.setSize(Zr.width, Zr.height);
    }
    reset() {
      this.dispose(), (this.autoRenderToScreen = !0);
    }
    dispose() {
      for (const Wr of this.passes) Wr.dispose();
      (this.passes = []),
        this.inputBuffer !== null && this.inputBuffer.dispose(),
        this.outputBuffer !== null && this.outputBuffer.dispose(),
        this.deleteDepthTexture(),
        this.copyPass.dispose(),
        this.timer.dispose();
    }
  },
  EffectAttribute = {
    NONE: 0,
    DEPTH: 1,
    CONVOLUTION: 2,
  },
  EffectShaderSection = {
    FRAGMENT_HEAD: "FRAGMENT_HEAD",
    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
    VERTEX_HEAD: "VERTEX_HEAD",
    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT",
  },
  EffectShaderData = class {
    constructor() {
      (this.shaderParts = new Map([
        [EffectShaderSection.FRAGMENT_HEAD, null],
        [EffectShaderSection.FRAGMENT_MAIN_UV, null],
        [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],
        [EffectShaderSection.VERTEX_HEAD, null],
        [EffectShaderSection.VERTEX_MAIN_SUPPORT, null],
      ])),
        (this.defines = new Map()),
        (this.uniforms = new Map()),
        (this.blendModes = new Map()),
        (this.extensions = new Set()),
        (this.attributes = EffectAttribute.NONE),
        (this.varyings = new Set()),
        (this.uvTransformation = !1),
        (this.readDepth = !1),
        (this.colorSpace = LinearSRGBColorSpace);
    }
  },
  workaroundEnabled = !1,
  OverrideMaterialManager = class {
    constructor(Wr = null) {
      (this.originalMaterials = new Map()),
        (this.material = null),
        (this.materials = null),
        (this.materialsBackSide = null),
        (this.materialsDoubleSide = null),
        (this.materialsFlatShaded = null),
        (this.materialsFlatShadedBackSide = null),
        (this.materialsFlatShadedDoubleSide = null),
        this.setMaterial(Wr),
        (this.meshCount = 0),
        (this.replaceMaterial = (ze) => {
          if (ze.isMesh) {
            let Gr;
            if (ze.material.flatShading)
              switch (ze.material.side) {
                case DoubleSide:
                  Gr = this.materialsFlatShadedDoubleSide;
                  break;
                case BackSide:
                  Gr = this.materialsFlatShadedBackSide;
                  break;
                default:
                  Gr = this.materialsFlatShaded;
                  break;
              }
            else
              switch (ze.material.side) {
                case DoubleSide:
                  Gr = this.materialsDoubleSide;
                  break;
                case BackSide:
                  Gr = this.materialsBackSide;
                  break;
                default:
                  Gr = this.materials;
                  break;
              }
            this.originalMaterials.set(ze, ze.material),
              ze.isSkinnedMesh
                ? (ze.material = Gr[2])
                : ze.isInstancedMesh
                ? (ze.material = Gr[1])
                : (ze.material = Gr[0]),
              ++this.meshCount;
          }
        });
    }
    cloneMaterial(Wr) {
      if (!(Wr instanceof ShaderMaterial)) return Wr.clone();
      const ze = Wr.uniforms,
        Gr = new Map();
      for (const Kr in ze) {
        const Zr = ze[Kr].value;
        Zr.isRenderTargetTexture && ((ze[Kr].value = null), Gr.set(Kr, Zr));
      }
      const Yr = Wr.clone();
      for (const Kr of Gr)
        (ze[Kr[0]].value = Kr[1]), (Yr.uniforms[Kr[0]].value = Kr[1]);
      return Yr;
    }
    setMaterial(Wr) {
      if ((this.disposeMaterials(), (this.material = Wr), Wr !== null)) {
        const ze = (this.materials = [
          this.cloneMaterial(Wr),
          this.cloneMaterial(Wr),
          this.cloneMaterial(Wr),
        ]);
        for (const Gr of ze)
          (Gr.uniforms = Object.assign({}, Wr.uniforms)), (Gr.side = FrontSide);
        (ze[2].skinning = !0),
          (this.materialsBackSide = ze.map((Gr) => {
            const Yr = this.cloneMaterial(Gr);
            return (
              (Yr.uniforms = Object.assign({}, Wr.uniforms)),
              (Yr.side = BackSide),
              Yr
            );
          })),
          (this.materialsDoubleSide = ze.map((Gr) => {
            const Yr = this.cloneMaterial(Gr);
            return (
              (Yr.uniforms = Object.assign({}, Wr.uniforms)),
              (Yr.side = DoubleSide),
              Yr
            );
          })),
          (this.materialsFlatShaded = ze.map((Gr) => {
            const Yr = this.cloneMaterial(Gr);
            return (
              (Yr.uniforms = Object.assign({}, Wr.uniforms)),
              (Yr.flatShading = !0),
              Yr
            );
          })),
          (this.materialsFlatShadedBackSide = ze.map((Gr) => {
            const Yr = this.cloneMaterial(Gr);
            return (
              (Yr.uniforms = Object.assign({}, Wr.uniforms)),
              (Yr.flatShading = !0),
              (Yr.side = BackSide),
              Yr
            );
          })),
          (this.materialsFlatShadedDoubleSide = ze.map((Gr) => {
            const Yr = this.cloneMaterial(Gr);
            return (
              (Yr.uniforms = Object.assign({}, Wr.uniforms)),
              (Yr.flatShading = !0),
              (Yr.side = DoubleSide),
              Yr
            );
          }));
      }
    }
    render(Wr, ze, Gr) {
      const Yr = Wr.shadowMap.enabled;
      if (((Wr.shadowMap.enabled = !1), workaroundEnabled)) {
        const Kr = this.originalMaterials;
        (this.meshCount = 0),
          ze.traverse(this.replaceMaterial),
          Wr.render(ze, Gr);
        for (const Zr of Kr) Zr[0].material = Zr[1];
        this.meshCount !== Kr.size && Kr.clear();
      } else {
        const Kr = ze.overrideMaterial;
        (ze.overrideMaterial = this.material),
          Wr.render(ze, Gr),
          (ze.overrideMaterial = Kr);
      }
      Wr.shadowMap.enabled = Yr;
    }
    disposeMaterials() {
      if (this.material !== null) {
        const Wr = this.materials
          .concat(this.materialsBackSide)
          .concat(this.materialsDoubleSide)
          .concat(this.materialsFlatShaded)
          .concat(this.materialsFlatShadedBackSide)
          .concat(this.materialsFlatShadedDoubleSide);
        for (const ze of Wr) ze.dispose();
      }
    }
    dispose() {
      this.originalMaterials.clear(), this.disposeMaterials();
    }
    static get workaroundEnabled() {
      return workaroundEnabled;
    }
    static set workaroundEnabled(Wr) {
      workaroundEnabled = Wr;
    }
  },
  AUTO_SIZE = -1,
  Resolution = class extends EventDispatcher {
    constructor(Wr, ze = AUTO_SIZE, Gr = AUTO_SIZE, Yr = 1) {
      super(),
        (this.resizable = Wr),
        (this.baseSize = new Vector2(1, 1)),
        (this.preferredSize = new Vector2(ze, Gr)),
        (this.target = this.preferredSize),
        (this.s = Yr),
        (this.effectiveSize = new Vector2()),
        this.addEventListener("change", () => this.updateEffectiveSize()),
        this.updateEffectiveSize();
    }
    updateEffectiveSize() {
      const Wr = this.baseSize,
        ze = this.preferredSize,
        Gr = this.effectiveSize,
        Yr = this.scale;
      ze.width !== AUTO_SIZE
        ? (Gr.width = ze.width)
        : ze.height !== AUTO_SIZE
        ? (Gr.width = Math.round(
            ze.height * (Wr.width / Math.max(Wr.height, 1))
          ))
        : (Gr.width = Math.round(Wr.width * Yr)),
        ze.height !== AUTO_SIZE
          ? (Gr.height = ze.height)
          : ze.width !== AUTO_SIZE
          ? (Gr.height = Math.round(
              ze.width / Math.max(Wr.width / Math.max(Wr.height, 1), 1)
            ))
          : (Gr.height = Math.round(Wr.height * Yr));
    }
    get width() {
      return this.effectiveSize.width;
    }
    set width(Wr) {
      this.preferredWidth = Wr;
    }
    get height() {
      return this.effectiveSize.height;
    }
    set height(Wr) {
      this.preferredHeight = Wr;
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    get scale() {
      return this.s;
    }
    set scale(Wr) {
      this.s !== Wr &&
        ((this.s = Wr),
        this.preferredSize.setScalar(AUTO_SIZE),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getScale() {
      return this.scale;
    }
    setScale(Wr) {
      this.scale = Wr;
    }
    get baseWidth() {
      return this.baseSize.width;
    }
    set baseWidth(Wr) {
      this.baseSize.width !== Wr &&
        ((this.baseSize.width = Wr),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getBaseWidth() {
      return this.baseWidth;
    }
    setBaseWidth(Wr) {
      this.baseWidth = Wr;
    }
    get baseHeight() {
      return this.baseSize.height;
    }
    set baseHeight(Wr) {
      this.baseSize.height !== Wr &&
        ((this.baseSize.height = Wr),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getBaseHeight() {
      return this.baseHeight;
    }
    setBaseHeight(Wr) {
      this.baseHeight = Wr;
    }
    setBaseSize(Wr, ze) {
      (this.baseSize.width !== Wr || this.baseSize.height !== ze) &&
        (this.baseSize.set(Wr, ze),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    get preferredWidth() {
      return this.preferredSize.width;
    }
    set preferredWidth(Wr) {
      this.preferredSize.width !== Wr &&
        ((this.preferredSize.width = Wr),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getPreferredWidth() {
      return this.preferredWidth;
    }
    setPreferredWidth(Wr) {
      this.preferredWidth = Wr;
    }
    get preferredHeight() {
      return this.preferredSize.height;
    }
    set preferredHeight(Wr) {
      this.preferredSize.height !== Wr &&
        ((this.preferredSize.height = Wr),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getPreferredHeight() {
      return this.preferredHeight;
    }
    setPreferredHeight(Wr) {
      this.preferredHeight = Wr;
    }
    setPreferredSize(Wr, ze) {
      (this.preferredSize.width !== Wr || this.preferredSize.height !== ze) &&
        (this.preferredSize.set(Wr, ze),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    copy(Wr) {
      (this.s = Wr.scale),
        this.baseSize.set(Wr.baseWidth, Wr.baseHeight),
        this.preferredSize.set(Wr.preferredWidth, Wr.preferredHeight),
        this.dispatchEvent({
          type: "change",
        }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
    static get AUTO_SIZE() {
      return AUTO_SIZE;
    }
  },
  BlendFunction = {
    SKIP: 9,
    SET: 30,
    ADD: 0,
    ALPHA: 1,
    AVERAGE: 2,
    COLOR: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    DIVIDE: 8,
    DST: 9,
    EXCLUSION: 10,
    HARD_LIGHT: 11,
    HARD_MIX: 12,
    HUE: 13,
    INVERT: 14,
    INVERT_RGB: 15,
    LIGHTEN: 16,
    LINEAR_BURN: 17,
    LINEAR_DODGE: 18,
    LINEAR_LIGHT: 19,
    LUMINOSITY: 20,
    MULTIPLY: 21,
    NEGATION: 22,
    NORMAL: 23,
    OVERLAY: 24,
    PIN_LIGHT: 25,
    REFLECT: 26,
    SATURATION: 27,
    SCREEN: 28,
    SOFT_LIGHT: 29,
    SRC: 30,
    SUBTRACT: 31,
    VIVID_LIGHT: 32,
  },
  add_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",
  alpha_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",
  average_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",
  color_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
  color_burn_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",
  color_dodge_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",
  darken_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",
  difference_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",
  divide_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",
  exclusion_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",
  hard_light_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",
  hard_mix_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",
  hue_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",
  invert_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",
  invert_rgb_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",
  lighten_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",
  linear_burn_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",
  linear_dodge_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",
  linear_light_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",
  luminosity_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
  multiply_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",
  negation_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",
  normal_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",
  overlay_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",
  pin_light_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",
  reflect_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",
  saturation_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
  screen_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",
  soft_light_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",
  src_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",
  subtract_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",
  vivid_light_default =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",
  blendFunctions = new Map([
    [BlendFunction.ADD, add_default],
    [BlendFunction.ALPHA, alpha_default],
    [BlendFunction.AVERAGE, average_default],
    [BlendFunction.COLOR, color_default],
    [BlendFunction.COLOR_BURN, color_burn_default],
    [BlendFunction.COLOR_DODGE, color_dodge_default],
    [BlendFunction.DARKEN, darken_default],
    [BlendFunction.DIFFERENCE, difference_default],
    [BlendFunction.DIVIDE, divide_default],
    [BlendFunction.DST, null],
    [BlendFunction.EXCLUSION, exclusion_default],
    [BlendFunction.HARD_LIGHT, hard_light_default],
    [BlendFunction.HARD_MIX, hard_mix_default],
    [BlendFunction.HUE, hue_default],
    [BlendFunction.INVERT, invert_default],
    [BlendFunction.INVERT_RGB, invert_rgb_default],
    [BlendFunction.LIGHTEN, lighten_default],
    [BlendFunction.LINEAR_BURN, linear_burn_default],
    [BlendFunction.LINEAR_DODGE, linear_dodge_default],
    [BlendFunction.LINEAR_LIGHT, linear_light_default],
    [BlendFunction.LUMINOSITY, luminosity_default],
    [BlendFunction.MULTIPLY, multiply_default],
    [BlendFunction.NEGATION, negation_default],
    [BlendFunction.NORMAL, normal_default],
    [BlendFunction.OVERLAY, overlay_default],
    [BlendFunction.PIN_LIGHT, pin_light_default],
    [BlendFunction.REFLECT, reflect_default],
    [BlendFunction.SATURATION, saturation_default],
    [BlendFunction.SCREEN, screen_default],
    [BlendFunction.SOFT_LIGHT, soft_light_default],
    [BlendFunction.SRC, src_default],
    [BlendFunction.SUBTRACT, subtract_default],
    [BlendFunction.VIVID_LIGHT, vivid_light_default],
  ]),
  BlendMode = class extends EventDispatcher {
    constructor(Wr, ze = 1) {
      super(), (this._blendFunction = Wr), (this.opacity = new Uniform(ze));
    }
    getOpacity() {
      return this.opacity.value;
    }
    setOpacity(Wr) {
      this.opacity.value = Wr;
    }
    get blendFunction() {
      return this._blendFunction;
    }
    set blendFunction(Wr) {
      (this._blendFunction = Wr),
        this.dispatchEvent({
          type: "change",
        });
    }
    getBlendFunction() {
      return this.blendFunction;
    }
    setBlendFunction(Wr) {
      this.blendFunction = Wr;
    }
    getShaderCode() {
      return blendFunctions.get(this.blendFunction);
    }
  },
  KernelSize = {
    VERY_SMALL: 0,
    SMALL: 1,
    MEDIUM: 2,
    LARGE: 3,
    VERY_LARGE: 4,
    HUGE: 5,
  },
  convolution_kawase_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,
  convolution_kawase_default2 =
    "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
  kernelPresets = [
    new Float32Array([0, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([0, 1, 1, 2]),
    new Float32Array([0, 1, 2, 2, 3]),
    new Float32Array([0, 1, 2, 3, 4, 4, 5]),
    new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
  ],
  KawaseBlurMaterial = class extends ShaderMaterial {
    constructor(Wr = new Vector4()) {
      super({
        name: "KawaseBlurMaterial",
        uniforms: {
          inputBuffer: new Uniform(null),
          texelSize: new Uniform(new Vector4()),
          scale: new Uniform(1),
          kernel: new Uniform(0),
        },
        blending: NoBlending,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: convolution_kawase_default,
        vertexShader: convolution_kawase_default2,
      }),
        (this.fragmentShader = updateFragmentShader(this.fragmentShader)),
        this.setTexelSize(Wr.x, Wr.y),
        (this.kernelSize = KernelSize.MEDIUM);
    }
    set inputBuffer(Wr) {
      this.uniforms.inputBuffer.value = Wr;
    }
    setInputBuffer(Wr) {
      this.inputBuffer = Wr;
    }
    get kernelSequence() {
      return kernelPresets[this.kernelSize];
    }
    get scale() {
      return this.uniforms.scale.value;
    }
    set scale(Wr) {
      this.uniforms.scale.value = Wr;
    }
    getScale() {
      return this.uniforms.scale.value;
    }
    setScale(Wr) {
      this.uniforms.scale.value = Wr;
    }
    getKernel() {
      return null;
    }
    get kernel() {
      return this.uniforms.kernel.value;
    }
    set kernel(Wr) {
      this.uniforms.kernel.value = Wr;
    }
    setKernel(Wr) {
      this.kernel = Wr;
    }
    setTexelSize(Wr, ze) {
      this.uniforms.texelSize.value.set(Wr, ze, Wr * 0.5, ze * 0.5);
    }
    setSize(Wr, ze) {
      const Gr = 1 / Wr,
        Yr = 1 / ze;
      this.uniforms.texelSize.value.set(Gr, Yr, Gr * 0.5, Yr * 0.5);
    }
  },
  KawaseBlurPass = class extends Pass {
    constructor({
      kernelSize: Wr = KernelSize.MEDIUM,
      resolutionScale: ze = 0.5,
      width: Gr = Resolution.AUTO_SIZE,
      height: Yr = Resolution.AUTO_SIZE,
      resolutionX: Kr = Gr,
      resolutionY: Zr = Yr,
    } = {}) {
      super("KawaseBlurPass"),
        (this.renderTargetA = new WebGLRenderTarget(1, 1, {
          depthBuffer: !1,
        })),
        (this.renderTargetA.texture.name = "Blur.Target.A"),
        (this.renderTargetB = this.renderTargetA.clone()),
        (this.renderTargetB.texture.name = "Blur.Target.B");
      const Jr = (this.resolution = new Resolution(this, Kr, Zr, ze));
      Jr.addEventListener("change", (Qr) =>
        this.setSize(Jr.baseWidth, Jr.baseHeight)
      ),
        (this._blurMaterial = new KawaseBlurMaterial()),
        (this._blurMaterial.kernelSize = Wr),
        (this.copyMaterial = new CopyMaterial());
    }
    getResolution() {
      return this.resolution;
    }
    get blurMaterial() {
      return this._blurMaterial;
    }
    set blurMaterial(Wr) {
      this._blurMaterial = Wr;
    }
    get dithering() {
      return this.copyMaterial.dithering;
    }
    set dithering(Wr) {
      this.copyMaterial.dithering = Wr;
    }
    get kernelSize() {
      return this.blurMaterial.kernelSize;
    }
    set kernelSize(Wr) {
      this.blurMaterial.kernelSize = Wr;
    }
    get width() {
      return this.resolution.width;
    }
    set width(Wr) {
      this.resolution.preferredWidth = Wr;
    }
    get height() {
      return this.resolution.height;
    }
    set height(Wr) {
      this.resolution.preferredHeight = Wr;
    }
    get scale() {
      return this.blurMaterial.scale;
    }
    set scale(Wr) {
      this.blurMaterial.scale = Wr;
    }
    getScale() {
      return this.blurMaterial.scale;
    }
    setScale(Wr) {
      this.blurMaterial.scale = Wr;
    }
    getKernelSize() {
      return this.kernelSize;
    }
    setKernelSize(Wr) {
      this.kernelSize = Wr;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(Wr) {
      this.resolution.scale = Wr;
    }
    render(Wr, ze, Gr, Yr, Kr) {
      const Zr = this.scene,
        Jr = this.camera,
        Qr = this.renderTargetA,
        ei = this.renderTargetB,
        ti = this.blurMaterial,
        ri = ti.kernelSequence;
      let ni = ze;
      this.fullscreenMaterial = ti;
      for (let ii = 0, si = ri.length; ii < si; ++ii) {
        const li = ii & 1 ? ei : Qr;
        (ti.kernel = ri[ii]),
          (ti.inputBuffer = ni.texture),
          Wr.setRenderTarget(li),
          Wr.render(Zr, Jr),
          (ni = li);
      }
      (this.fullscreenMaterial = this.copyMaterial),
        (this.copyMaterial.inputBuffer = ni.texture),
        Wr.setRenderTarget(this.renderToScreen ? null : Gr),
        Wr.render(Zr, Jr);
    }
    setSize(Wr, ze) {
      const Gr = this.resolution;
      Gr.setBaseSize(Wr, ze);
      const Yr = Gr.width,
        Kr = Gr.height;
      this.renderTargetA.setSize(Yr, Kr),
        this.renderTargetB.setSize(Yr, Kr),
        this.blurMaterial.setSize(Wr, ze);
    }
    initialize(Wr, ze, Gr) {
      Gr !== void 0 &&
        ((this.renderTargetA.texture.type = Gr),
        (this.renderTargetB.texture.type = Gr),
        Gr !== UnsignedByteType
          ? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"),
            (this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"))
          : Wr !== null &&
            Wr.outputColorSpace === SRGBColorSpace &&
            ((this.renderTargetA.texture.colorSpace = SRGBColorSpace),
            (this.renderTargetB.texture.colorSpace = SRGBColorSpace)));
    }
    static get AUTO_SIZE() {
      return Resolution.AUTO_SIZE;
    }
  },
  Effect = class extends EventDispatcher {
    constructor(
      Wr,
      ze,
      {
        attributes: Gr = EffectAttribute.NONE,
        blendFunction: Yr = BlendFunction.NORMAL,
        defines: Kr = new Map(),
        uniforms: Zr = new Map(),
        extensions: Jr = null,
        vertexShader: Qr = null,
      } = {}
    ) {
      super(),
        (this.name = Wr),
        (this.renderer = null),
        (this.attributes = Gr),
        (this.fragmentShader = ze),
        (this.vertexShader = Qr),
        (this.defines = Kr),
        (this.uniforms = Zr),
        (this.extensions = Jr),
        (this.blendMode = new BlendMode(Yr)),
        this.blendMode.addEventListener("change", (ei) => this.setChanged()),
        (this._inputColorSpace = LinearSRGBColorSpace),
        (this._outputColorSpace = NoColorSpace);
    }
    get inputColorSpace() {
      return this._inputColorSpace;
    }
    set inputColorSpace(Wr) {
      (this._inputColorSpace = Wr), this.setChanged();
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(Wr) {
      (this._outputColorSpace = Wr), this.setChanged();
    }
    set mainScene(Wr) {}
    set mainCamera(Wr) {}
    getName() {
      return this.name;
    }
    setRenderer(Wr) {
      this.renderer = Wr;
    }
    getDefines() {
      return this.defines;
    }
    getUniforms() {
      return this.uniforms;
    }
    getExtensions() {
      return this.extensions;
    }
    getBlendMode() {
      return this.blendMode;
    }
    getAttributes() {
      return this.attributes;
    }
    setAttributes(Wr) {
      (this.attributes = Wr), this.setChanged();
    }
    getFragmentShader() {
      return this.fragmentShader;
    }
    setFragmentShader(Wr) {
      (this.fragmentShader = Wr), this.setChanged();
    }
    getVertexShader() {
      return this.vertexShader;
    }
    setVertexShader(Wr) {
      (this.vertexShader = Wr), this.setChanged();
    }
    setChanged() {
      this.dispatchEvent({
        type: "change",
      });
    }
    setDepthTexture(Wr, ze = BasicDepthPacking) {}
    update(Wr, ze, Gr) {}
    setSize(Wr, ze) {}
    initialize(Wr, ze, Gr) {}
    dispose() {
      for (const Wr of Object.keys(this)) {
        const ze = this[Wr];
        (ze instanceof WebGLRenderTarget ||
          ze instanceof Material ||
          ze instanceof Texture ||
          ze instanceof Pass) &&
          this[Wr].dispose();
      }
    }
  },
  RenderPass = class extends Pass {
    constructor(Wr, ze, Gr = null) {
      super("RenderPass", Wr, ze),
        (this.needsSwap = !1),
        (this.clearPass = new ClearPass()),
        (this.overrideMaterialManager =
          Gr === null ? null : new OverrideMaterialManager(Gr)),
        (this.ignoreBackground = !1),
        (this.skipShadowMapUpdate = !1),
        (this.selection = null);
    }
    set mainScene(Wr) {
      this.scene = Wr;
    }
    set mainCamera(Wr) {
      this.camera = Wr;
    }
    get renderToScreen() {
      return super.renderToScreen;
    }
    set renderToScreen(Wr) {
      (super.renderToScreen = Wr), (this.clearPass.renderToScreen = Wr);
    }
    get overrideMaterial() {
      const Wr = this.overrideMaterialManager;
      return Wr !== null ? Wr.material : null;
    }
    set overrideMaterial(Wr) {
      const ze = this.overrideMaterialManager;
      Wr !== null
        ? ze !== null
          ? ze.setMaterial(Wr)
          : (this.overrideMaterialManager = new OverrideMaterialManager(Wr))
        : ze !== null && (ze.dispose(), (this.overrideMaterialManager = null));
    }
    getOverrideMaterial() {
      return this.overrideMaterial;
    }
    setOverrideMaterial(Wr) {
      this.overrideMaterial = Wr;
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(Wr) {
      this.clearPass.enabled = Wr;
    }
    getSelection() {
      return this.selection;
    }
    setSelection(Wr) {
      this.selection = Wr;
    }
    isBackgroundDisabled() {
      return this.ignoreBackground;
    }
    setBackgroundDisabled(Wr) {
      this.ignoreBackground = Wr;
    }
    isShadowMapDisabled() {
      return this.skipShadowMapUpdate;
    }
    setShadowMapDisabled(Wr) {
      this.skipShadowMapUpdate = Wr;
    }
    getClearPass() {
      return this.clearPass;
    }
    render(Wr, ze, Gr, Yr, Kr) {
      const Zr = this.scene,
        Jr = this.camera,
        Qr = this.selection,
        ei = Jr.layers.mask,
        ti = Zr.background,
        ri = Wr.shadowMap.autoUpdate,
        ni = this.renderToScreen ? null : ze;
      Qr !== null && Jr.layers.set(Qr.getLayer()),
        this.skipShadowMapUpdate && (Wr.shadowMap.autoUpdate = !1),
        (this.ignoreBackground || this.clearPass.overrideClearColor !== null) &&
          (Zr.background = null),
        this.clearPass.enabled && this.clearPass.render(Wr, ze),
        Wr.setRenderTarget(ni),
        this.overrideMaterialManager !== null
          ? this.overrideMaterialManager.render(Wr, Zr, Jr)
          : Wr.render(Zr, Jr),
        (Jr.layers.mask = ei),
        (Zr.background = ti),
        (Wr.shadowMap.autoUpdate = ri);
    }
  },
  effect_default = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,
  effect_default2 =
    "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",
  EffectMaterial = class extends ShaderMaterial {
    constructor(Wr, ze, Gr, Yr, Kr = !1) {
      super({
        name: "EffectMaterial",
        defines: {
          THREE_REVISION: REVISION.replace(/\D+/g, ""),
          DEPTH_PACKING: "0",
          ENCODE_OUTPUT: "1",
        },
        uniforms: {
          inputBuffer: new Uniform(null),
          depthBuffer: new Uniform(null),
          resolution: new Uniform(new Vector2()),
          texelSize: new Uniform(new Vector2()),
          cameraNear: new Uniform(0.3),
          cameraFar: new Uniform(1e3),
          aspect: new Uniform(1),
          time: new Uniform(0),
        },
        blending: NoBlending,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        dithering: Kr,
      }),
        Wr && this.setShaderParts(Wr),
        ze && this.setDefines(ze),
        Gr && this.setUniforms(Gr),
        this.copyCameraSettings(Yr);
    }
    set inputBuffer(Wr) {
      this.uniforms.inputBuffer.value = Wr;
    }
    setInputBuffer(Wr) {
      this.uniforms.inputBuffer.value = Wr;
    }
    get depthBuffer() {
      return this.uniforms.depthBuffer.value;
    }
    set depthBuffer(Wr) {
      this.uniforms.depthBuffer.value = Wr;
    }
    get depthPacking() {
      return Number(this.defines.DEPTH_PACKING);
    }
    set depthPacking(Wr) {
      (this.defines.DEPTH_PACKING = Wr.toFixed(0)), (this.needsUpdate = !0);
    }
    setDepthBuffer(Wr, ze = BasicDepthPacking) {
      (this.depthBuffer = Wr), (this.depthPacking = ze);
    }
    setShaderData(Wr) {
      this.setShaderParts(Wr.shaderParts),
        this.setDefines(Wr.defines),
        this.setUniforms(Wr.uniforms),
        this.setExtensions(Wr.extensions);
    }
    setShaderParts(Wr) {
      return (
        (this.fragmentShader = effect_default
          .replace(
            EffectShaderSection.FRAGMENT_HEAD,
            Wr.get(EffectShaderSection.FRAGMENT_HEAD) || ""
          )
          .replace(
            EffectShaderSection.FRAGMENT_MAIN_UV,
            Wr.get(EffectShaderSection.FRAGMENT_MAIN_UV) || ""
          )
          .replace(
            EffectShaderSection.FRAGMENT_MAIN_IMAGE,
            Wr.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || ""
          )),
        (this.vertexShader = effect_default2
          .replace(
            EffectShaderSection.VERTEX_HEAD,
            Wr.get(EffectShaderSection.VERTEX_HEAD) || ""
          )
          .replace(
            EffectShaderSection.VERTEX_MAIN_SUPPORT,
            Wr.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || ""
          )),
        (this.fragmentShader = updateFragmentShader(this.fragmentShader)),
        (this.needsUpdate = !0),
        this
      );
    }
    setDefines(Wr) {
      for (const ze of Wr.entries()) this.defines[ze[0]] = ze[1];
      return (this.needsUpdate = !0), this;
    }
    setUniforms(Wr) {
      for (const ze of Wr.entries()) this.uniforms[ze[0]] = ze[1];
      return this;
    }
    setExtensions(Wr) {
      this.extensions = {};
      for (const ze of Wr) this.extensions[ze] = !0;
      return this;
    }
    get encodeOutput() {
      return this.defines.ENCODE_OUTPUT !== void 0;
    }
    set encodeOutput(Wr) {
      this.encodeOutput !== Wr &&
        (Wr
          ? (this.defines.ENCODE_OUTPUT = "1")
          : delete this.defines.ENCODE_OUTPUT,
        (this.needsUpdate = !0));
    }
    isOutputEncodingEnabled(Wr) {
      return this.encodeOutput;
    }
    setOutputEncodingEnabled(Wr) {
      this.encodeOutput = Wr;
    }
    get time() {
      return this.uniforms.time.value;
    }
    set time(Wr) {
      this.uniforms.time.value = Wr;
    }
    setDeltaTime(Wr) {
      this.uniforms.time.value += Wr;
    }
    adoptCameraSettings(Wr) {
      this.copyCameraSettings(Wr);
    }
    copyCameraSettings(Wr) {
      Wr &&
        ((this.uniforms.cameraNear.value = Wr.near),
        (this.uniforms.cameraFar.value = Wr.far),
        Wr instanceof PerspectiveCamera
          ? (this.defines.PERSPECTIVE_CAMERA = "1")
          : delete this.defines.PERSPECTIVE_CAMERA,
        (this.needsUpdate = !0));
    }
    setSize(Wr, ze) {
      const Gr = this.uniforms;
      Gr.resolution.value.set(Wr, ze),
        Gr.texelSize.value.set(1 / Wr, 1 / ze),
        (Gr.aspect.value = Wr / ze);
    }
    static get Section() {
      return EffectShaderSection;
    }
  };
function prefixSubstrings(Wr, ze, Gr) {
  for (const Yr of ze) {
    const Kr = "$1" + Wr + Yr.charAt(0).toUpperCase() + Yr.slice(1),
      Zr = new RegExp("([^\\.])(\\b" + Yr + "\\b)", "g");
    for (const Jr of Gr.entries())
      Jr[1] !== null && Gr.set(Jr[0], Jr[1].replace(Zr, Kr));
  }
}
function integrateEffect(Wr, ze, Gr) {
  let Yr = ze.getFragmentShader(),
    Kr = ze.getVertexShader();
  const Zr = Yr !== void 0 && /mainImage/.test(Yr),
    Jr = Yr !== void 0 && /mainUv/.test(Yr);
  if (((Gr.attributes |= ze.getAttributes()), Yr === void 0))
    throw new Error(`Missing fragment shader (${ze.name})`);
  if (Jr && Gr.attributes & EffectAttribute.CONVOLUTION)
    throw new Error(
      `Effects that transform UVs are incompatible with convolution effects (${ze.name})`
    );
  if (!Zr && !Jr)
    throw new Error(`Could not find mainImage or mainUv function (${ze.name})`);
  {
    const Qr = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
      ei = Gr.shaderParts;
    let ti = ei.get(EffectShaderSection.FRAGMENT_HEAD) || "",
      ri = ei.get(EffectShaderSection.FRAGMENT_MAIN_UV) || "",
      ni = ei.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || "",
      ii = ei.get(EffectShaderSection.VERTEX_HEAD) || "",
      si = ei.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || "";
    const li = new Set(),
      oi = new Set();
    if (
      (Jr &&
        ((ri += `	${Wr}MainUv(UV);
`),
        (Gr.uvTransformation = !0)),
      Kr !== null && /mainSupport/.test(Kr))
    ) {
      const hi = /mainSupport *\([\w\s]*?uv\s*?\)/.test(Kr);
      (si += `	${Wr}MainSupport(`),
        (si += hi
          ? `vUv);
`
          : `);
`);
      for (const ci of Kr.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
        for (const fi of ci[1].split(/\s*,\s*/))
          Gr.varyings.add(fi), li.add(fi), oi.add(fi);
      for (const ci of Kr.matchAll(Qr)) oi.add(ci[1]);
    }
    for (const hi of Yr.matchAll(Qr)) oi.add(hi[1]);
    for (const hi of ze.defines.keys()) oi.add(hi.replace(/\([\w\s,]*\)/g, ""));
    for (const hi of ze.uniforms.keys()) oi.add(hi);
    oi.delete("while"),
      oi.delete("for"),
      oi.delete("if"),
      ze.uniforms.forEach((hi, ci) =>
        Gr.uniforms.set(Wr + ci.charAt(0).toUpperCase() + ci.slice(1), hi)
      ),
      ze.defines.forEach((hi, ci) =>
        Gr.defines.set(Wr + ci.charAt(0).toUpperCase() + ci.slice(1), hi)
      );
    const ui = new Map([
      ["fragment", Yr],
      ["vertex", Kr],
    ]);
    prefixSubstrings(Wr, oi, Gr.defines),
      prefixSubstrings(Wr, oi, ui),
      (Yr = ui.get("fragment")),
      (Kr = ui.get("vertex"));
    const ai = ze.blendMode;
    if ((Gr.blendModes.set(ai.blendFunction, ai), Zr)) {
      ze.inputColorSpace !== null &&
        ze.inputColorSpace !== Gr.colorSpace &&
        (ni +=
          ze.inputColorSpace === SRGBColorSpace
            ? `color0 = LinearTosRGB(color0);
	`
            : `color0 = sRGBToLinear(color0);
	`),
        ze.outputColorSpace !== NoColorSpace
          ? (Gr.colorSpace = ze.outputColorSpace)
          : ze.inputColorSpace !== null && (Gr.colorSpace = ze.inputColorSpace);
      const hi = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      (ni += `${Wr}MainImage(color0, UV, `),
        Gr.attributes & EffectAttribute.DEPTH &&
          hi.test(Yr) &&
          ((ni += "depth, "), (Gr.readDepth = !0)),
        (ni += `color1);
	`);
      const ci = Wr + "BlendOpacity";
      Gr.uniforms.set(ci, ai.opacity),
        (ni += `color0 = blend${ai.blendFunction}(color0, color1, ${ci});

	`),
        (ti += `uniform float ${ci};

`);
    }
    if (
      ((ti +=
        Yr +
        `
`),
      Kr !== null &&
        (ii +=
          Kr +
          `
`),
      ei.set(EffectShaderSection.FRAGMENT_HEAD, ti),
      ei.set(EffectShaderSection.FRAGMENT_MAIN_UV, ri),
      ei.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, ni),
      ei.set(EffectShaderSection.VERTEX_HEAD, ii),
      ei.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, si),
      ze.extensions !== null)
    )
      for (const hi of ze.extensions) Gr.extensions.add(hi);
  }
}
var EffectPass = class extends Pass {
  constructor(Wr, ...ze) {
    super("EffectPass"),
      (this.fullscreenMaterial = new EffectMaterial(null, null, null, Wr)),
      (this.listener = (Gr) => this.handleEvent(Gr)),
      (this.effects = []),
      this.setEffects(ze),
      (this.skipRendering = !1),
      (this.minTime = 1),
      (this.maxTime = Number.POSITIVE_INFINITY),
      (this.timeScale = 1);
  }
  set mainScene(Wr) {
    for (const ze of this.effects) ze.mainScene = Wr;
  }
  set mainCamera(Wr) {
    this.fullscreenMaterial.copyCameraSettings(Wr);
    for (const ze of this.effects) ze.mainCamera = Wr;
  }
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(Wr) {
    this.fullscreenMaterial.encodeOutput = Wr;
  }
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(Wr) {
    const ze = this.fullscreenMaterial;
    (ze.dithering = Wr), (ze.needsUpdate = !0);
  }
  setEffects(Wr) {
    for (const ze of this.effects)
      ze.removeEventListener("change", this.listener);
    this.effects = Wr.sort((ze, Gr) => Gr.attributes - ze.attributes);
    for (const ze of this.effects) ze.addEventListener("change", this.listener);
  }
  updateMaterial() {
    const Wr = new EffectShaderData();
    let ze = 0;
    for (const Jr of this.effects)
      if (Jr.blendMode.blendFunction === BlendFunction.DST)
        Wr.attributes |= Jr.getAttributes() & EffectAttribute.DEPTH;
      else {
        if (Wr.attributes & Jr.getAttributes() & EffectAttribute.CONVOLUTION)
          throw new Error(`Convolution effects cannot be merged (${Jr.name})`);
        integrateEffect("e" + ze++, Jr, Wr);
      }
    let Gr = Wr.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD),
      Yr = Wr.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE),
      Kr = Wr.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);
    const Zr = /\bblend\b/g;
    for (const Jr of Wr.blendModes.values())
      Gr +=
        Jr.getShaderCode().replace(Zr, `blend${Jr.blendFunction}`) +
        `
`;
    Wr.attributes & EffectAttribute.DEPTH
      ? (Wr.readDepth &&
          (Yr =
            `float depth = readDepth(UV);

	` + Yr),
        (this.needsDepthTexture = this.getDepthTexture() === null))
      : (this.needsDepthTexture = !1),
      Wr.colorSpace === SRGBColorSpace &&
        (Yr += `color0 = sRGBToLinear(color0);
	`),
      Wr.uvTransformation
        ? ((Kr =
            `vec2 transformedUv = vUv;
` + Kr),
          Wr.defines.set("UV", "transformedUv"))
        : Wr.defines.set("UV", "vUv"),
      Wr.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, Gr),
      Wr.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, Yr),
      Wr.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, Kr);
    for (const [Jr, Qr] of Wr.shaderParts)
      Qr !== null &&
        Wr.shaderParts.set(
          Jr,
          Qr.trim().replace(
            /^#/,
            `
#`
          )
        );
    (this.skipRendering = ze === 0),
      (this.needsSwap = !this.skipRendering),
      this.fullscreenMaterial.setShaderData(Wr);
  }
  recompile() {
    this.updateMaterial();
  }
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  setDepthTexture(Wr, ze = BasicDepthPacking) {
    (this.fullscreenMaterial.depthBuffer = Wr),
      (this.fullscreenMaterial.depthPacking = ze);
    for (const Gr of this.effects) Gr.setDepthTexture(Wr, ze);
  }
  render(Wr, ze, Gr, Yr, Kr) {
    for (const Zr of this.effects) Zr.update(Wr, ze, Yr);
    if (!this.skipRendering || this.renderToScreen) {
      const Zr = this.fullscreenMaterial;
      (Zr.inputBuffer = ze.texture),
        (Zr.time += Yr * this.timeScale),
        Wr.setRenderTarget(this.renderToScreen ? null : Gr),
        Wr.render(this.scene, this.camera);
    }
  }
  setSize(Wr, ze) {
    this.fullscreenMaterial.setSize(Wr, ze);
    for (const Gr of this.effects) Gr.setSize(Wr, ze);
  }
  initialize(Wr, ze, Gr) {
    this.renderer = Wr;
    for (const Yr of this.effects) Yr.initialize(Wr, ze, Gr);
    this.updateMaterial(),
      Gr !== void 0 &&
        Gr !== UnsignedByteType &&
        (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
  dispose() {
    super.dispose();
    for (const Wr of this.effects)
      Wr.removeEventListener("change", this.listener), Wr.dispose();
  }
  handleEvent(Wr) {
    switch (Wr.type) {
      case "change":
        this.recompile();
        break;
    }
  }
};
const grain = `uniform float uXCount;
uniform float uYCount;
uniform float uIntensity;

vec2 hash(vec2 p) // replace this by something better
{
  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float noise(in vec2 p) {
  const float K1 = 0.366025404; // (sqrt(3)-1)/2;
  const float K2 = 0.211324865; // (3-sqrt(3))/6;

  vec2 i = floor(p + (p.x + p.y) * K1);
  vec2 a = p - i + (i.x + i.y) * K2;
  float m = step(a.y, a.x);
  vec2 o = vec2(m, 1.0 - m);
  vec2 b = a - o + K2;
  vec2 c = a - 1.0 + 2.0 * K2;
  vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
  vec3 n =
      h * h * h * h *
      vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));
  return dot(n, vec3(70.0));
}

float speed = 12.;
// float intensity = .01;

float random2d(vec2 coord) {
  return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float blendSoftLight(float base, float blend) {
  return (blend < 0.5)
             ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend))
             : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
}

vec3 blendSoftLight(vec3 base, vec3 blend) {
  return vec3(blendSoftLight(base.r, blend.r), blendSoftLight(base.g, blend.g),
              blendSoftLight(base.b, blend.b));
}

vec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {
  return (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));
}

void mainImage(const in vec4 inputColor, const in vec2 uv,
               out vec4 outputColor) {
  float gridX = floor(uv.x * uXCount) / uXCount;
  float gridY = 1.0 - floor(uv.y * uYCount) / uYCount;
  float t = mod(time, 1.);
  // float timeSpeed = time; // -> fluide (it's random, so we cant control the
  // speed)
  float timeSpeed = floor(t * 8.); // -> saccadé
  // float timeSpeed = 1.;
  // float intensity = (inputColor.r + inputColor.g + inputColor.b) / 3.;
  float grain = random2d(vec2(gridX + timeSpeed, gridY));

  grain -= grain / 2.;
  grain *= .1;

  vec3 resultColor =
      blendSoftLight(inputColor.rgb, inputColor.rgb + grain, uIntensity);

  outputColor = vec4(resultColor, 1.0);
  // outputColor = vec4(inputColor.rgb, 1.0);
}
`,
  pixelSize = window.devicePixelRatio,
  uXCount = new Uniform(canvas$1.offsetWidth / pixelSize),
  uYCount = new Uniform(canvas$1.offsetHeight / pixelSize),
  uIntensity = new Uniform(1.29),
  renderPass = new RenderPass(scene, camera),
  grainEffect = new Effect("grain", grain, {
    blendFunction: BlendFunction.NORMAL,
    uniforms: new Map([
      ["uXCount", uXCount],
      ["uYCount", uYCount],
      ["uIntensity", uIntensity],
    ]),
  }),
  blurPass = new KawaseBlurPass();
blurPass.scale = 2;
const displacementEffect = new Effect(
    "displacement",
    `
    uniform sampler2D uSimulationTexture;
    uniform vec2 uDisplacementStrength;
    uniform float uCursorColoring;

    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        // UV aspect fix
        /* vec2 nUv = (-.5 + uv) * 2.;
        if( resolution.x < resolution.y ) {
            nUv.x *= resolution.x / resolution.y;
        } else {
            nUv.y *= resolution.y / resolution.x;
        }
        nUv = nUv / 2. + .5; */

        vec4 gpgpuColor = texture2D(uSimulationTexture, vUv);

        vec2 dUv = vec2(
            uv.x - (-0.5 + gpgpuColor.r) * uDisplacementStrength.x * gpgpuColor.b,
            uv.y - (-0.5 + gpgpuColor.g) * uDisplacementStrength.y * gpgpuColor.b
        );

        vec4 color = texture2D(inputBuffer, dUv);

        color.rgb += color.rgb * gpgpuColor.b * uCursorColoring;

        outputColor = vec4(color.rgb, 1.0);
    }`,
    {
      blendFunction: BlendFunction.NORMAL,
      uniforms: new Map([
        ["uSimulationTexture", uSimulationTexture],
        ["uDisplacementStrength", new Uniform(new Vector2(2, 2))],
        ["uCursorColoring", new Uniform(1.5)],
      ]),
    }
  ),
  effectPass = new EffectPass(camera, displacementEffect, grainEffect),
  passes = [renderPass, blurPass, effectPass];
let gui;
function debug() {
  function Wr() {
    (gui = new GUI({
      name: "grain",
      closed: !0,
    })),
      gui.slider({
        name: "intensity",
        obj: uIntensity,
        prop: "value",
        max: 100,
      });
  }
  function ze() {
    gui && gui.kill(), (gui = void 0);
  }
  return {
    mount: Wr,
    unmount: ze,
  };
}
let background;
class PresetManager {
  static registerChange() {
    background || (background = canvasManager.getEffect("gradient")),
      this.current && (this.previous = this.current);
  }
  static set(ze) {
    switch (ze) {
      case "menu":
        this.menu();
        break;
      case "culture":
        this.culture();
        break;
      default:
        this.normal();
    }
  }
  static normal(ze = !1) {
    if ((this.registerChange(), (this.current = "normal"), !ze))
      background.setSize(0.2),
        background.setGrainIntensity(1.29),
        background.setColor1("rgb(65,66,73)"),
        background.setColor2("rgb(36,39,51)"),
        background.setColor3("rgb(49,103,160)"),
        background.setColor4("rgb(117,153,245)"),
        (blurPass.scale = 2),
        (uColorMixer.value = 0),
        (uMenuMode.value = 0);
    else {
      const Gr = gsapWithCSS.timeline({
        defaults: {
          ease: "power2.inOut",
          duration: 1,
        },
      });
      Gr.to(
        uSize,
        {
          value: 0.2,
        },
        0
      ),
        Gr.to(
          uIntensity,
          {
            value: 1.29,
          },
          0
        ),
        Gr.to(
          uColor1.value,
          {
            r: 0.05286064,
            g: 0.05448027,
            b: 0.06662593,
          },
          0
        ),
        Gr.to(
          uColor2.value,
          {
            r: 0.01764195,
            g: 0.02028856,
            b: 0.03310476,
          },
          0
        ),
        Gr.to(
          uColor3.value,
          {
            r: 0.03071344,
            g: 0.13563332,
            b: 0.35153259,
          },
          0
        ),
        Gr.to(
          uColor4.value,
          {
            r: 0.17788841,
            g: 0.31854677,
            b: 0.91309865,
          },
          0
        ),
        Gr.to(
          blurPass,
          {
            scale: 2,
          },
          0
        ),
        Gr.to(
          uColorMixer,
          {
            value: 0,
          },
          0
        ),
        Gr.to(
          uMenuMode,
          {
            value: 0,
          },
          0
        );
    }
  }
  static menu() {
    this.registerChange(),
      (this.current = "menu"),
      background.setSize(0.1),
      background.setGrainIntensity(1.29),
      background.setColor1("rgb(65,66,73)"),
      background.setColor2("rgb(36,39,51)"),
      background.setColor3("rgb(49,103,160)"),
      background.setColor4("rgb(117,153,245)"),
      (blurPass.scale = 5),
      (uColorMixer.value = 0.32),
      (uMenuMode.value = 1);
  }
  static culture(ze) {
    if ((this.registerChange(), (this.current = "culture"), !ze))
      background.setSize(0.13),
        background.setGrainIntensity(1.32),
        background.setColor1(0.02624122, 0.02732089, 0.0343398),
        background.setColor2(0.00913405, 0.00972121, 0.01520851),
        background.setColor3(0.01096009, 0.07036009, 0.20863687),
        background.setColor4(0.00477695, 0.01370208, 0.06480326),
        (blurPass.scale = 2),
        (uColorMixer.value = 0),
        (uMenuMode.value = 0);
    else {
      const Gr = gsapWithCSS.timeline({
        defaults: {
          ease: "power2.inOut",
          duration: 1,
        },
      });
      Gr.to(
        uSize,
        {
          value: 0.13,
        },
        0
      ),
        Gr.to(
          uIntensity,
          {
            value: 1.32,
          },
          0
        ),
        Gr.to(
          uColor1.value,
          {
            r: 0.02624122,
            g: 0.02732089,
            b: 0.0343398,
          },
          0
        ),
        Gr.to(
          uColor2.value,
          {
            r: 0.00913405,
            g: 0.00972121,
            b: 0.01520851,
          },
          0
        ),
        Gr.to(
          uColor3.value,
          {
            r: 0.01096009,
            g: 0.07036009,
            b: 0.20863687,
          },
          0
        ),
        Gr.to(
          uColor4.value,
          {
            r: 0.00477695,
            g: 0.01370208,
            b: 0.06480326,
          },
          0
        ),
        Gr.to(
          blurPass,
          {
            scale: 2,
          },
          0
        ),
        Gr.to(
          uColorMixer,
          {
            value: 0,
          },
          0
        ),
        Gr.to(
          uMenuMode,
          {
            value: 0,
          },
          0
        );
    }
  }
}
ds(PresetManager, "previous"), ds(PresetManager, "current");
gsapWithCSS.registerPlugin(ScrollTrigger, CustomEase);
CustomEase.create("inOutCubic", "0.65, 0, 0.35, 1)");
CustomEase.create("outCubic", "0.16, 1, 0.3, 1");
const menu = () => {
    const Wr = document.querySelector(".header-left"),
      ze = document.querySelector(".header-menu"),
      Gr = document.querySelector(".header-aside"),
      Yr = document.querySelector(".toggle-menu"),
      Kr = document.querySelector("main").getAttribute("data-anim");
    let Zr = parseFloat(Kr) + 1,
      Jr,
      Qr,
      ei;
    Kr || (Zr = 0),
      Wr &&
        gsapWithCSS.from(Wr, {
          y: "200%",
          opacity: 0,
          duration: 1.5,
          ease: "expo.inOut",
          delay: Zr,
        }),
      ze &&
        gsapWithCSS.from(ze, {
          y: "200%",
          duration: 1.5,
          ease: "expo.inOut",
          delay: Zr + 0.05,
        }),
      Gr &&
        gsapWithCSS.from(Gr, {
          y: "200%",
          duration: 1.5,
          ease: "expo.inOut",
          delay: Zr + 0.1,
        }),
      Yr &&
        gsapWithCSS.from(Yr, {
          y: "200%",
          duration: 1.5,
          ease: "expo.inOut",
          delay: Zr + 0.1,
        });
    const ti = document.querySelector(".js-menu"),
      ri = document.querySelector(".js-menu-container"),
      ni = ti.querySelector(".js-menu-background"),
      ii = ti.querySelectorAll(".js-menu-link"),
      si = ti.querySelectorAll(".js-menu-bg-banner"),
      li = document.querySelectorAll(".js-menu-link-text"),
      oi = ti.querySelector(".js-menu-logo"),
      ui = ti.querySelectorAll(".js-toggle-menu .toggle-menu__bar"),
      ai = () => {
        (document.body.style.pointerEvents = "none"),
          (Gr.style.pointerEvents = "none");
      },
      hi = () => {
        (document.body.style.pointerEvents = ""), (Gr.style.pointerEvents = "");
      },
      ci = gsapWithCSS.matchMedia();
    ci.add("(max-width: 767px)", () => {
      Ei(), Pi();
    }),
      ci.add("(min-width: 768px)", () => {
        Ei(), Pi();
      });
    const fi = () => {
        gsapWithCSS.set(si, {
          transformOrigin: "bottom",
        }),
          gsapWithCSS.set(ii, {
            "--scale": "0",
          }),
          setTimeout(() => {
            Jr.play(0);
          }, 300);
      },
      di = (Ai, Ri) => {
        (ei = Ri),
          gsapWithCSS.set(si, {
            transformOrigin: "top",
          }),
          setTimeout(() => {
            Qr.play(0);
          }, Ai * 1e3);
      },
      pi = (Ai, Ri) => {
        ai(),
          di(Ai, Ri),
          document.body.classList.remove("menu-is-open"),
          lenis$1.unblockScroll();
      },
      mi = () => {
        ai(),
          document.body.classList.add("menu-is-active"),
          document.body.classList.add("menu-is-open"),
          lenis$1.blockScroll(),
          fi();
      },
      Si = document.querySelectorAll(".js-toggle-menu");
    Si.length > 0 &&
      Si.forEach((Ai) => {
        Ai.addEventListener("click", () => {
          document.body.classList.contains("menu-is-active") ? pi(0.2) : mi();
        });
      });
    const yi = ti.querySelectorAll("a");
    yi.length > 0 &&
      yi.forEach((Ai) => {
        Ai.addEventListener("click", () => {
          document.querySelector("main").setAttribute("data-anim-delay", 2),
            pi(0.5, Ai);
        });
      }),
      ii.length > 0 &&
        ii.forEach((Ai) => {
          Ai.querySelector("svg") &&
            Ai.querySelectorAll(".js-menu-link-text .slice-el").forEach(
              (wi) => {
                const Ci = wi.querySelector(".js-menu-link-icon"),
                  bi = wi.childNodes[0].textContent.trim();
                let Mi = bi.indexOf(" ");
                if (Mi > 0) {
                  var gi = bi.slice(0, Mi).trim(),
                    xi = bi.slice(Mi + 1, bi.length).trim();
                  wi.removeChild(wi.childNodes[0]),
                    wi.appendChild(document.createTextNode(gi)),
                    wi.appendChild(Ci),
                    wi.appendChild(document.createTextNode(xi));
                }
              }
            ),
            Ai.addEventListener("mouseenter", () => {
              ii.forEach((Ri) => {
                Ri !== Ai &&
                  gsapWithCSS.to(Ri, {
                    opacity: 0.6,
                    duration: 0.5,
                  });
              });
            }),
            Ai.addEventListener("mouseleave", () => {
              ii.forEach((Ri) => {
                gsapWithCSS.to(Ri, {
                  opacity: 1,
                  duration: 0.5,
                });
              });
            });
        });
    function Ei(Ai) {
      Jr && Jr.kill(),
        (Jr = gsapWithCSS.timeline({
          paused: !0,
        })),
        Jr.fromTo(
          ni,
          {
            scaleY: 0,
            opacity: 1,
          },
          {
            scaleY: 1,
            opacity: 1,
            duration: 0.8,
            ease: "inOutCubic",
            onComplete: () => {
              PresetManager.current != "menu" && PresetManager.menu(),
                document.querySelector(".js-menu-webgl").append(canvas$1);
            },
          }
        )
          .fromTo(
            si,
            {
              opacity: 0,
            },
            {
              opacity: 1,
              duration: 0.01,
              ease: "none",
            },
            ">"
          )
          .to(
            ni,
            {
              opacity: 0,
              duration: 1,
              ease: "none",
            },
            "<"
          )
          .to(
            ui,
            {
              "--color": "#f0f1f5",
              duration: 0.5,
              ease: "outSine",
            },
            0
          )
          .fromTo(
            oi,
            {
              opacity: 0,
            },
            {
              opacity: 1,
              duration: 0.5,
              ease: "outCubic",
            },
            "<"
          )
          .fromTo(
            ii,
            {
              "--scale": "0",
            },
            {
              "--scale": "1",
              duration: 0.8,
              ease: "outCubic",
            },
            "<0.4"
          )
          .fromTo(
            li,
            {
              y: "-115%",
            },
            {
              y: "0%",
              duration: 1,
              stagger: 0.05,
              ease: "outCubic",
            },
            "<"
          )
          .add(hi);
    }
    function Pi(Ai) {
      Qr && Qr.kill(),
        (Qr = gsapWithCSS.timeline({
          paused: !0,
          defaults: {
            ease: "inOutCubic",
          },
        })),
        Qr.to(ni, {
          opacity: 1,
          duration: 0.1,
          ease: "none",
        })
          .add(() => {
            document.querySelector(".webgl").append(canvas$1),
              gsapWithCSS.set(si, {
                transformOrigin: "bottom",
              }),
              ei != null && ei.href.includes("culture")
                ? PresetManager.culture()
                : PresetManager.set(PresetManager.previous);
          })
          .to(ti, {
            "--bottom-path": "0%",
            duration: 0.8,
            ease: CustomEase.create("easeOutCubic", ".25,.93,.87,1.01"),
            onComplete: () => {
              gsapWithCSS.set(ni, {
                opacity: 0,
                ease: "none",
              });
            },
          })
          .fromTo(
            ti,
            {
              filter: "brightness(100%)",
            },
            {
              filter: "brightness(20%)",
              duration: 0.8,
              ease: "none",
              onComplete: () => {
                gsapWithCSS.set(ti, {
                  filter: "brightness(100%)",
                });
              },
            },
            "<"
          )
          .to(
            li,
            {
              y: "-115%",
              duration: 0.9,
              ease: CustomEase.create("easeOutCubic", ".25,.93,.87,1.01"),
            },
            "<"
          )
          .to(
            ri,
            {
              y: "-20%",
              duration: 0.8,
              ease: CustomEase.create("easeOutCubic", ".25,.93,.87,1.01"),
              onComplete: () => {
                gsapWithCSS.set(ri, {
                  y: 0,
                  duration: 0,
                  ease: "none",
                });
              },
            },
            "<"
          )
          .add(() => {
            gsapWithCSS.set(ti, {
              "--bottom-path": "100%",
              ease: "none",
            }),
              gsapWithCSS.set(li, {
                y: "115%",
              }),
              gsapWithCSS.set(ii, {
                "--scale": "0",
              }),
              gsapWithCSS.set(oi, {
                opacity: 0,
              }),
              hi(),
              document.body.classList.remove("menu-is-active");
          });
    }
  },
  imagesTrail = () => {
    const Wr = document.body,
      ze = document.querySelector(".js-images-trail-container"),
      Gr = {
        lerp: (ri, ni, ii) => (1 - ii) * ri + ii * ni,
        distance: (ri, ni, ii, si) => Math.hypot(ii - ri, si - ni),
      },
      Yr = (ri) => {
        let ni = 0,
          ii = 0;
        return (
          ri.pageX || ri.pageY
            ? ((ni = ri.pageX), (ii = ri.pageY))
            : (ri.clientX || ri.clientY) &&
              ((ni = ri.clientX + Wr.scrollLeft),
              (ii = ri.clientY + Wr.scrollTop)),
          {
            x: ni,
            y: ii,
          }
        );
      };
    let Kr,
      Zr,
      Jr =
        (Kr =
        Zr =
          {
            x: 0,
            y: 0,
          });
    ze.addEventListener("mousemove", (ri) => {
      ri.target.closest("a") || (Jr = Yr(ri));
    });
    const Qr = () => Gr.distance(Jr.x, Jr.y, Kr.x, Kr.y);
    class ei {
      constructor(ni) {
        (this.DOM = {
          el: ni,
        }),
          (this.defaultStyle = {
            scale: 1,
            x: 0,
            y: 0,
            opacity: 0,
          }),
          this.getRect(),
          this.initEvents();
      }
      initEvents() {
        window.addEventListener("resize", () => this.resize());
      }
      resize() {
        gsapWithCSS.set(this.DOM.el, this.defaultStyle), this.getRect();
      }
      getRect() {
        this.rect = this.DOM.el.getBoundingClientRect();
      }
      isActive() {
        return (
          gsapWithCSS.isTweening(this.DOM.el) || this.DOM.el.style.opacity != 0
        );
      }
    }
    class ti {
      constructor() {
        (this.DOM = {
          content: ze,
        }),
          (this.contentPos = this.DOM.content.offsetTop),
          (this.images = []),
          [...this.DOM.content.querySelectorAll("img")].forEach((ni) =>
            this.images.push(new ei(ni))
          ),
          (this.imagesTotal = this.images.length),
          (this.imgPosition = 0),
          (this.zIndexVal = 1),
          (this.threshold = 100),
          gsapWithCSS.ticker.add(this.render.bind(this));
      }
      render() {
        let ni = Qr();
        (Zr.x = Gr.lerp(Zr.x || Jr.x, Jr.x, 0.1)),
          (Zr.y = Gr.lerp(Zr.y || Jr.y, Jr.y, 0.1)),
          ni > this.threshold &&
            (this.showNextImage(),
            ++this.zIndexVal,
            (this.imgPosition =
              this.imgPosition < this.imagesTotal - 1
                ? this.imgPosition + 1
                : 0),
            (Kr = Jr));
        let ii = !0;
        for (let si of this.images)
          if (si.isActive()) {
            ii = !1;
            break;
          }
        ii && this.zIndexVal !== 1 && (this.zIndexVal = 1);
      }
      showNextImage() {
        const ni = this.images[this.imgPosition];
        gsapWithCSS.killTweensOf(ni.DOM.el);
        var ii = gsapWithCSS.timeline();
        ii.set(
          ni.DOM.el,
          {
            opacity: 1,
            scale: 1,
            zIndex: this.zIndexVal,
            x: Zr.x - ni.rect.width / 2,
            y: Zr.y - ni.rect.height / 2 - this.contentPos,
          },
          0
        )
          .to(
            ni.DOM.el,
            {
              ease: "expo.out",
              x: Jr.x - ni.rect.width / 2,
              y: Jr.y - ni.rect.height / 2 - this.contentPos,
              duration: 0.9,
            },
            0
          )
          .to(
            ni.DOM.el,
            {
              ease: "power1.out",
              opacity: 0,
              duration: 1,
            },
            0.8
          )
          .to(
            ni.DOM.el,
            {
              ease: "sine.out",
              scale: 0.2,
              duration: 1,
            },
            0.8
          );
      }
    }
    new ti();
  };
gsapWithCSS.registerPlugin(ScrollTrigger);
const revealText = (Wr) => {
    function ze(Zr, Jr) {
      const Qr = Wr.querySelectorAll(Zr);
      Qr.length > 0 &&
        (Qr.forEach((ei) => {
          let ti = "lines";
          ei.dataset.split === "chars" && (ti = "lines, chars"),
            new SplitType(ei, {
              types: ti,
            }).lines.map((ni) => {
              const ii = document.createElement("div");
              ii.classList.add("line-wrapper"),
                (ii.style.overflow = "hidden"),
                ni.parentNode.appendChild(ii),
                ii.appendChild(ni);
            });
        }),
        gsapWithCSS.utils.toArray(Zr).forEach((ei) => {
          const ti = ei.querySelector(".js-horizontal-reveal-text");
          let ri = ei.getAttribute("data-reveal");
          if ((ri || (ri = 0), !ei.closest(".s-timeline"))) {
            const ni = ei.querySelectorAll(".line"),
              ii = ei.querySelectorAll(".char");
            let si = ni;
            ii.length > 0 && (si = ii),
              ni.length > 0 &&
                gsapWithCSS.fromTo(
                  si,
                  {
                    y: "115%",
                  },
                  {
                    y: 0,
                    duration: 1,
                    stagger: Jr,
                    ease: "power3.out",
                    scrollTrigger: {
                      trigger: ei,
                      start: "top 75%",
                    },
                    delay: parseFloat(ri),
                    onComplete: function () {
                      ei.classList.contains("is-revert") &&
                        SplitType.revert(ei);
                    },
                  }
                );
            const li = ei.querySelector(".slice-wrapper");
            li &&
              gsapWithCSS.to(
                li,
                {
                  x: "-0.7rem",
                  duration: 1,
                  ease: "power3.out",
                  delay: parseFloat(ri + 1),
                },
                ">-0.2"
              ),
              ti &&
                gsapWithCSS.fromTo(
                  ti,
                  {
                    width: 0,
                  },
                  {
                    scrollTrigger: {
                      trigger: ei,
                      start: "top 75%",
                    },
                    width: ti.querySelector("span").offsetWidth,
                    duration: 1.5,
                    ease: "expo.inOut",
                    delay: parseFloat(ri + 0.5),
                  }
                );
          }
          ei.closest(".a--auto") &&
            gsapWithCSS.fromTo(
              ei.querySelectorAll(".line"),
              {
                y: "115%",
              },
              {
                y: 0,
                duration: 1,
                stagger: Jr,
                ease: "power3.out",
                delay: parseFloat(ri),
              }
            );
        }));
    }
    const Gr = ".a--text";
    Wr.querySelector(Gr) && ze(Gr, "0.08");
    const Yr = ".a--sm-text p";
    Wr.querySelector(Yr) && ze(Yr, "0.05");
    const Kr = () => {
      const Zr = Wr.querySelectorAll(".a--text, .a--sm-text p");
      Zr.length > 0 &&
        Zr.forEach((Jr) => {
          Jr.closest(".a--sm-text")
            ? Jr.closest(".a--sm-text").classList.contains("no-resize") ||
              SplitType.revert(Jr)
            : Jr.classList.contains("no-resize") || SplitType.revert(Jr);
        });
    };
    window.addEventListener("resize", Kr);
  },
  removeRevealText = (Wr) => {
    const ze = Wr.querySelectorAll(".a--text");
    ze &&
      ze.forEach((Gr) => {
        Gr.classList.remove("a--text");
      });
  };
gsapWithCSS.registerPlugin(ScrollTrigger);
const reveal = (Wr, ze) => {
  const Gr = gsapWithCSS.utils.toArray(Wr);
  Gr.length > 0 &&
    Gr.forEach((Yr) => {
      const Kr = Yr.querySelectorAll(ze);
      Kr.length > 0 &&
        gsapWithCSS.from(Kr, {
          opacity: 0,
          duration: 1,
          ease: "power1.inOut",
          stagger: 0.15,
          scrollTrigger: {
            trigger: Yr,
            start: "top bottom-=3%",
          },
        });
    });
};
gsapWithCSS.registerPlugin(ScrollTrigger);
function forceScrollTop$1() {
  window.scrollTo(0, 0),
    typeof lenis$1 < "u" &&
      (lenis$1.scrollTo(0, {
        immediate: !0,
      }),
      lenis$1.stop());
}
const caseStudyHeader = () => {
  const Wr = document.querySelectorAll(".js-case-study-main-title"),
    ze = document.querySelectorAll(".js-case-study-h .a--text .line"),
    Gr = document.querySelectorAll(".v-show-text-el"),
    Yr = document.querySelector(".js-slice-image"),
    Kr = document.querySelectorAll(".js-slice-image .img"),
    Zr = document.querySelectorAll(".js-case-study-h .slice-image"),
    Jr = document.querySelectorAll(".js-transition-overlay-slice"),
    Qr = document.querySelectorAll(".js-case-study-h-bottom");
  gsapWithCSS.ticker.add(forceScrollTop$1);
  function ei() {
    setTimeout(() => {
      gsapWithCSS.ticker.remove(forceScrollTop$1),
        lenis$1.start(),
        lenis$1.resize(),
        window.innerWidth > 1023 && ri();
    }, 500);
  }
  let ti = gsapWithCSS.timeline();
  Jr.length > 0 &&
    ti.from(Jr, {
      x: "200%",
      duration: 1,
      stagger: -0.1,
      ease: "power3.out",
    }),
    Zr.length > 0 &&
      ti.from(
        Zr,
        {
          x: "100%",
          duration: 1,
          stagger: -0.1,
          ease: "power3.out",
        },
        "<"
      ),
    ze.length > 0 &&
      ti.from(
        ze,
        {
          y: "100%",
          duration: 1,
          stagger: 0.08,
          ease: "power3.out",
        },
        ">-0.7"
      ),
    Gr.length > 0 &&
      ti.to(
        Gr,
        {
          y: 0,
          duration: 1,
          ease: "power3.out",
        },
        "<"
      ),
    ti.add(ei),
    Kr.length > 0 &&
      ti.to(
        Kr,
        {
          opacity: 1,
          duration: 0,
        },
        ">-0.1"
      ),
    Zr.length > 0 &&
      ti.to(Zr, {
        opacity: 0,
        duration: 1,
      }),
    ti.delay(0.5);
  const ri = () => {
    let ni = gsapWithCSS.timeline({
      scrollTrigger: {
        trigger: Yr,
        scrub: !0,
        pin: !1,
        start: "top top",
        end: window.innerHeight * 1.5 + " bottom",
      },
    });
    ni.to(Yr, {
      x: 0,
      ease: "power3.outIn",
      duration: 0.95,
    }),
      ni.to(
        Jr[0],
        {
          x: "-101%",
          duration: 1,
          ease: "power3.outIn",
        },
        "<"
      ),
      ni.to(
        Wr,
        {
          x: (-window.innerWidth * 0.9) / 2,
          duration: 1.1,
          ease: "power3.outIn",
        },
        "<"
      ),
      ni.to(
        Jr[1],
        {
          x: "-101%",
          duration: 1.1,
          ease: "power3.outIn",
        },
        "<+=0.05"
      ),
      ni.to(
        Jr[2],
        {
          x: "-101%",
          duration: 1.2,
          ease: "power3.outIn",
        },
        "<+=0.1"
      ),
      ni.to(
        Qr,
        {
          x: (-window.innerWidth * 0.9) / 2,
          duration: 1.1,
          ease: "power3.outIn",
        },
        "<"
      );
  };
  if (Yr && window.innerWidth > 767) {
    const ni = Yr.offsetHeight;
    gsapWithCSS.to(Yr, {
      scrollTrigger: {
        trigger: Yr,
        scrub: !0,
        start: "top top",
        end: () => `+=${ni * 2}`,
      },
      y: "25%",
      duration: 1,
      ease: "power3.out",
    }),
      gsapWithCSS.fromTo(
        Yr,
        {
          filter: "brightness(1)",
        },
        {
          scrollTrigger: {
            trigger: Yr,
            scrub: !0,
            start: "85% 50%",
            end: () => `+=${ni / 2}`,
          },
          filter: "brightness(0.4)",
          duration: 1,
          ease: "power3.outIn",
        }
      );
  }
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const parallax = (Wr) => {
  const ze = gsapWithCSS.utils.toArray(".js-parallax");
  ze.length > 0 &&
    ze.forEach((Gr) => {
      let Yr = Gr.dataset.depth;
      const Kr = Gr.dataset.depthmb;
      window.innerWidth < 768 && Kr && (Yr = Kr);
      const Zr = -(Gr.offsetHeight * Yr);
      Wr.to(
        Gr,
        {
          y: Zr,
          ease: "none",
        },
        0
      );
    });
};
gsapWithCSS.registerPlugin(ScrollTrigger);
class FeaturedProject {
  constructor(ze) {
    (this.featuredProjectsWrapper = ze.querySelector(".js-featured-projects")),
      (this.featuredProjectSections = ze.querySelectorAll(
        ".js-featured-project"
      )),
      (this.featuredProjectContents = ze.querySelectorAll(
        ".js-featured-project-content"
      )),
      (this.timelines = []),
      (this.loops = []),
      this.resized,
      document.documentElement.clientWidth > 767 && this.init(),
      this.resize();
  }
  tlParallax() {
    gsapWithCSS.utils.toArray(this.featuredProjectSections).forEach((ze) => {
      (this.tl = gsapWithCSS.timeline({
        scrollTrigger: {
          id: "featuredProject",
          trigger: ze,
          start: "top bottom",
          end: "bottom top",
          scrub: !0,
        },
      })),
        parallax(this.tl),
        this.timelines.push(this.tl);
    });
  }
  sectionsParallax() {
    gsapWithCSS.utils
      .toArray(this.featuredProjectSections)
      .forEach((ze, Gr) => {
        const Yr = ze.querySelector(".js-featured-project-image"),
          Kr = ze.querySelector(".js-featured-project-content"),
          Zr = ze.querySelector(".js-featured-project-heading"),
          Jr = Gr === this.featuredProjectSections.length - 1;
        let Qr = Jr ? "" : -Yr.offsetHeight * 0.4,
          ei = Jr ? "-1.5" : "0.7",
          ti = gsapWithCSS.timeline({
            scrollTrigger: {
              trigger: ze,
              start: "top top",
              end: "bottom top",
              scrub: !0,
              pin: !Jr,
              pinSpacing: !1,
            },
          });
        ti.to(Yr, {
          y: Qr,
        }),
          ti.to(
            Zr,
            {
              y: -Kr.offsetHeight * ei,
              ease: "none",
            },
            "<"
          ),
          ti.to(
            ze,
            {
              ease: "none",
              startAt: {
                filter: "brightness(100%) contrast(100%)",
              },
              filter: Jr
                ? "brightness(40%) contrast(135%)"
                : "brightness(60%) contrast(135%)",
              yPercent: Jr ? 0 : -15,
            },
            "-=0.1"
          );
        let ri = (window.innerHeight * 0.4) / 100,
          ni = Jr ? "0.25" : ri,
          ii = window.innerWidth > 1920,
          si = gsapWithCSS
            .timeline({
              scrollTrigger: {
                trigger: ze,
                start: `top ${ii ? 7 : 5}%`,
                end: "bottom top",
                scrub: !0,
              },
            })
            .to(
              Kr,
              {
                y: -Kr.offsetHeight * ni * (ii ? 0.6 : 0.9),
              },
              "<"
            );
        this.timelines.push(ti), this.timelines.push(si);
      });
  }
  tlDestroy() {
    if (
      (this.timelines.length > 0 &&
        this.timelines.forEach((ze) => {
          ze == null || ze.kill(), (ze = null);
        }),
      this.loops.length > 0)
    ) {
      for (let ze = 0; ze < this.loops.length; ze++)
        gsapWithCSS.ticker.remove(this.loops[ze]);
      this.loops = [];
    }
  }
  init() {
    this.featuredProjectSections.length > 0 &&
      (this.featuredProjectSections.length == 1
        ? this.tlParallax()
        : this.sectionsParallax()),
      this.featuredProjectContents.length > 0 && this.interactions();
  }
  resize() {
    window.addEventListener("resize", () => {
      clearTimeout(this.resized),
        (this.resized = setTimeout(() => {
          document.documentElement.clientWidth < 768
            ? this.tlDestroy()
            : this.timelines.length == 0 && this.init();
        }, 1e3));
    });
  }
  interactions() {
    if (document.querySelectorAll(".l-cursor").length > 0) {
      const Gr = function (Kr) {
        const Zr = Kr.target
          .closest(".l-cursor__container")
          .querySelector(".l-cursor");
        Zr &&
          (Zr.classList.add("is--active"),
          Kr.type === "mouseleave" && Zr.classList.remove("is--active"));
      };
      this.featuredProjectContents.forEach((Kr) =>
        Kr.addEventListener("mousemove", Gr)
      ),
        this.featuredProjectContents.forEach((Kr) =>
          Kr.addEventListener("mouseleave", Gr)
        );
      const Yr = (Kr) => {
        const { clientX: Zr, clientY: Jr } = Kr;
        this.featuredProjectContents.forEach((Qr) => {
          const ei = Qr.closest(".l-cursor__container").querySelector(
            ".l-cursor"
          );
          ei && ((ei.style.left = Zr + "px"), (ei.style.top = Jr + "px"));
        });
      };
      this.featuredProjectContents.forEach((Kr) =>
        Kr.addEventListener("mousemove", Yr)
      );
    }
  }
}
gsapWithCSS.registerPlugin(ScrollTrigger);
const medias = (Wr) => {
  Wr.querySelectorAll(".js-video-player").forEach((Zr) => {
    Zr.addEventListener("click", (Jr) => {
      let Qr = Jr.target.closest(".js-media-video");
      if (Qr.querySelector("iframe")) {
        const ei = Qr.querySelector("iframe");
        let ti = ei.getAttribute("src");
        ei.setAttribute("src", ti + "?rel=0&autoplay=1");
      } else Qr.querySelector("video") && Qr.querySelector("video").play();
      setTimeout(() => {
        Jr.target.remove();
      }, 300);
    });
  });
  function Gr(Zr) {
    Zr.forEach((Jr) => {
      const Qr = Jr.querySelector("iframe"),
        ei = Qr.getAttribute("src"),
        ti = Qr.cloneNode(!0);
      Qr.parentNode.replaceChildren(Qr, ti);
      let ri = "&autoplay=1&mute=1&loop=1&controls=0",
        ni = "?rel=0";
      ei.includes("vimeo") &&
        (ri = "&autoplay=1&controls=0&loop=1&muted=1&autopause=false"),
        ei.includes("?") && ei.includes("=") && (ni = "&rel=0"),
        (ti.src = ei + ni + ri),
        (ti.style.pointerEvents = "none");
    });
  }
  const Yr = Wr.querySelectorAll(".js-autoplay");
  Yr.length > 0 &&
    setTimeout(function () {
      Gr(Yr);
    }, 500);
  const Kr = gsapWithCSS.utils.toArray(".js-media-container");
  Kr.length > 0 &&
    Kr.forEach((Zr) => {
      const Jr = Zr.querySelectorAll(".js-media");
      Jr.length > 0 &&
        gsapWithCSS.from(Jr, {
          opacity: 0,
          duration: 1,
          ease: "power1.inOut",
          stagger: 0.15,
          scrollTrigger: {
            trigger: Zr,
            start: "top bottom-=3%",
          },
        });
    });
};
function isObject$1(Wr) {
  return (
    Wr !== null &&
    typeof Wr == "object" &&
    "constructor" in Wr &&
    Wr.constructor === Object
  );
}
function extend$1(Wr, ze) {
  Wr === void 0 && (Wr = {}),
    ze === void 0 && (ze = {}),
    Object.keys(ze).forEach((Gr) => {
      typeof Wr[Gr] > "u"
        ? (Wr[Gr] = ze[Gr])
        : isObject$1(ze[Gr]) &&
          isObject$1(Wr[Gr]) &&
          Object.keys(ze[Gr]).length > 0 &&
          extend$1(Wr[Gr], ze[Gr]);
    });
}
const ssrDocument = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
    blur() {},
    nodeName: "",
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {},
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      },
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: "",
  },
};
function getDocument() {
  const Wr = typeof document < "u" ? document : {};
  return extend$1(Wr, ssrDocument), Wr;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: "",
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: "",
  },
  history: {
    replaceState() {},
    pushState() {},
    go() {},
    back() {},
  },
  CustomEvent: function Wr() {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      },
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(Wr) {
    return typeof setTimeout > "u" ? (Wr(), null) : setTimeout(Wr, 0);
  },
  cancelAnimationFrame(Wr) {
    typeof setTimeout > "u" || clearTimeout(Wr);
  },
};
function getWindow() {
  const Wr = typeof window < "u" ? window : {};
  return extend$1(Wr, ssrWindow), Wr;
}
function classesToTokens(Wr) {
  return (
    Wr === void 0 && (Wr = ""),
    Wr.trim()
      .split(" ")
      .filter((ze) => !!ze.trim())
  );
}
function deleteProps(Wr) {
  const ze = Wr;
  Object.keys(ze).forEach((Gr) => {
    try {
      ze[Gr] = null;
    } catch (Yr) {}
    try {
      delete ze[Gr];
    } catch (Yr) {}
  });
}
function nextTick(Wr, ze) {
  return ze === void 0 && (ze = 0), setTimeout(Wr, ze);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(Wr) {
  const ze = getWindow();
  let Gr;
  return (
    ze.getComputedStyle && (Gr = ze.getComputedStyle(Wr, null)),
    !Gr && Wr.currentStyle && (Gr = Wr.currentStyle),
    Gr || (Gr = Wr.style),
    Gr
  );
}
function getTranslate(Wr, ze) {
  ze === void 0 && (ze = "x");
  const Gr = getWindow();
  let Yr, Kr, Zr;
  const Jr = getComputedStyle$1(Wr);
  return (
    Gr.WebKitCSSMatrix
      ? ((Kr = Jr.transform || Jr.webkitTransform),
        Kr.split(",").length > 6 &&
          (Kr = Kr.split(", ")
            .map((Qr) => Qr.replace(",", "."))
            .join(", ")),
        (Zr = new Gr.WebKitCSSMatrix(Kr === "none" ? "" : Kr)))
      : ((Zr =
          Jr.MozTransform ||
          Jr.OTransform ||
          Jr.MsTransform ||
          Jr.msTransform ||
          Jr.transform ||
          Jr.getPropertyValue("transform").replace(
            "translate(",
            "matrix(1, 0, 0, 1,"
          )),
        (Yr = Zr.toString().split(","))),
    ze === "x" &&
      (Gr.WebKitCSSMatrix
        ? (Kr = Zr.m41)
        : Yr.length === 16
        ? (Kr = parseFloat(Yr[12]))
        : (Kr = parseFloat(Yr[4]))),
    ze === "y" &&
      (Gr.WebKitCSSMatrix
        ? (Kr = Zr.m42)
        : Yr.length === 16
        ? (Kr = parseFloat(Yr[13]))
        : (Kr = parseFloat(Yr[5]))),
    Kr || 0
  );
}
function isObject(Wr) {
  return (
    typeof Wr == "object" &&
    Wr !== null &&
    Wr.constructor &&
    Object.prototype.toString.call(Wr).slice(8, -1) === "Object"
  );
}
function isNode(Wr) {
  return typeof window < "u" && typeof window.HTMLElement < "u"
    ? Wr instanceof HTMLElement
    : Wr && (Wr.nodeType === 1 || Wr.nodeType === 11);
}
function extend() {
  const Wr = Object(arguments.length <= 0 ? void 0 : arguments[0]),
    ze = ["__proto__", "constructor", "prototype"];
  for (let Gr = 1; Gr < arguments.length; Gr += 1) {
    const Yr = Gr < 0 || arguments.length <= Gr ? void 0 : arguments[Gr];
    if (Yr != null && !isNode(Yr)) {
      const Kr = Object.keys(Object(Yr)).filter((Zr) => ze.indexOf(Zr) < 0);
      for (let Zr = 0, Jr = Kr.length; Zr < Jr; Zr += 1) {
        const Qr = Kr[Zr],
          ei = Object.getOwnPropertyDescriptor(Yr, Qr);
        ei !== void 0 &&
          ei.enumerable &&
          (isObject(Wr[Qr]) && isObject(Yr[Qr])
            ? Yr[Qr].__swiper__
              ? (Wr[Qr] = Yr[Qr])
              : extend(Wr[Qr], Yr[Qr])
            : !isObject(Wr[Qr]) && isObject(Yr[Qr])
            ? ((Wr[Qr] = {}),
              Yr[Qr].__swiper__ ? (Wr[Qr] = Yr[Qr]) : extend(Wr[Qr], Yr[Qr]))
            : (Wr[Qr] = Yr[Qr]));
      }
    }
  }
  return Wr;
}
function setCSSProperty(Wr, ze, Gr) {
  Wr.style.setProperty(ze, Gr);
}
function animateCSSModeScroll(Wr) {
  let { swiper: ze, targetPosition: Gr, side: Yr } = Wr;
  const Kr = getWindow(),
    Zr = -ze.translate;
  let Jr = null,
    Qr;
  const ei = ze.params.speed;
  (ze.wrapperEl.style.scrollSnapType = "none"),
    Kr.cancelAnimationFrame(ze.cssModeFrameID);
  const ti = Gr > Zr ? "next" : "prev",
    ri = (ii, si) => (ti === "next" && ii >= si) || (ti === "prev" && ii <= si),
    ni = () => {
      (Qr = new Date().getTime()), Jr === null && (Jr = Qr);
      const ii = Math.max(Math.min((Qr - Jr) / ei, 1), 0),
        si = 0.5 - Math.cos(ii * Math.PI) / 2;
      let li = Zr + si * (Gr - Zr);
      if (
        (ri(li, Gr) && (li = Gr),
        ze.wrapperEl.scrollTo({
          [Yr]: li,
        }),
        ri(li, Gr))
      ) {
        (ze.wrapperEl.style.overflow = "hidden"),
          (ze.wrapperEl.style.scrollSnapType = ""),
          setTimeout(() => {
            (ze.wrapperEl.style.overflow = ""),
              ze.wrapperEl.scrollTo({
                [Yr]: li,
              });
          }),
          Kr.cancelAnimationFrame(ze.cssModeFrameID);
        return;
      }
      ze.cssModeFrameID = Kr.requestAnimationFrame(ni);
    };
  ni();
}
function elementChildren(Wr, ze) {
  return (
    ze === void 0 && (ze = ""), [...Wr.children].filter((Gr) => Gr.matches(ze))
  );
}
function showWarning(Wr) {
  try {
    console.warn(Wr);
    return;
  } catch (ze) {}
}
function createElement(Wr, ze) {
  ze === void 0 && (ze = []);
  const Gr = document.createElement(Wr);
  return (
    Gr.classList.add(...(Array.isArray(ze) ? ze : classesToTokens(ze))), Gr
  );
}
function elementPrevAll(Wr, ze) {
  const Gr = [];
  for (; Wr.previousElementSibling; ) {
    const Yr = Wr.previousElementSibling;
    ze ? Yr.matches(ze) && Gr.push(Yr) : Gr.push(Yr), (Wr = Yr);
  }
  return Gr;
}
function elementNextAll(Wr, ze) {
  const Gr = [];
  for (; Wr.nextElementSibling; ) {
    const Yr = Wr.nextElementSibling;
    ze ? Yr.matches(ze) && Gr.push(Yr) : Gr.push(Yr), (Wr = Yr);
  }
  return Gr;
}
function elementStyle(Wr, ze) {
  return getWindow().getComputedStyle(Wr, null).getPropertyValue(ze);
}
function elementIndex(Wr) {
  let ze = Wr,
    Gr;
  if (ze) {
    for (Gr = 0; (ze = ze.previousSibling) !== null; )
      ze.nodeType === 1 && (Gr += 1);
    return Gr;
  }
}
function elementParents(Wr, ze) {
  const Gr = [];
  let Yr = Wr.parentElement;
  for (; Yr; )
    ze ? Yr.matches(ze) && Gr.push(Yr) : Gr.push(Yr), (Yr = Yr.parentElement);
  return Gr;
}
function elementOuterSize(Wr, ze, Gr) {
  const Yr = getWindow();
  return Gr
    ? Wr[ze === "width" ? "offsetWidth" : "offsetHeight"] +
        parseFloat(
          Yr.getComputedStyle(Wr, null).getPropertyValue(
            ze === "width" ? "margin-right" : "margin-top"
          )
        ) +
        parseFloat(
          Yr.getComputedStyle(Wr, null).getPropertyValue(
            ze === "width" ? "margin-left" : "margin-bottom"
          )
        )
    : Wr.offsetWidth;
}
let support;
function calcSupport() {
  const Wr = getWindow(),
    ze = getDocument();
  return {
    smoothScroll:
      ze.documentElement &&
      ze.documentElement.style &&
      "scrollBehavior" in ze.documentElement.style,
    touch: !!(
      "ontouchstart" in Wr ||
      (Wr.DocumentTouch && ze instanceof Wr.DocumentTouch)
    ),
  };
}
function getSupport() {
  return support || (support = calcSupport()), support;
}
let deviceCached;
function calcDevice(Wr) {
  let { userAgent: ze } = Wr === void 0 ? {} : Wr;
  const Gr = getSupport(),
    Yr = getWindow(),
    Kr = Yr.navigator.platform,
    Zr = ze || Yr.navigator.userAgent,
    Jr = {
      ios: !1,
      android: !1,
    },
    Qr = Yr.screen.width,
    ei = Yr.screen.height,
    ti = Zr.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ri = Zr.match(/(iPad).*OS\s([\d_]+)/);
  const ni = Zr.match(/(iPod)(.*OS\s([\d_]+))?/),
    ii = !ri && Zr.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
    si = Kr === "Win32";
  let li = Kr === "MacIntel";
  const oi = [
    "1024x1366",
    "1366x1024",
    "834x1194",
    "1194x834",
    "834x1112",
    "1112x834",
    "768x1024",
    "1024x768",
    "820x1180",
    "1180x820",
    "810x1080",
    "1080x810",
  ];
  return (
    !ri &&
      li &&
      Gr.touch &&
      oi.indexOf(`${Qr}x${ei}`) >= 0 &&
      ((ri = Zr.match(/(Version)\/([\d.]+)/)),
      ri || (ri = [0, 1, "13_0_0"]),
      (li = !1)),
    ti && !si && ((Jr.os = "android"), (Jr.android = !0)),
    (ri || ii || ni) && ((Jr.os = "ios"), (Jr.ios = !0)),
    Jr
  );
}
function getDevice(Wr) {
  return (
    Wr === void 0 && (Wr = {}),
    deviceCached || (deviceCached = calcDevice(Wr)),
    deviceCached
  );
}
let browser;
function calcBrowser() {
  const Wr = getWindow();
  let ze = !1;
  function Gr() {
    const Yr = Wr.navigator.userAgent.toLowerCase();
    return (
      Yr.indexOf("safari") >= 0 &&
      Yr.indexOf("chrome") < 0 &&
      Yr.indexOf("android") < 0
    );
  }
  if (Gr()) {
    const Yr = String(Wr.navigator.userAgent);
    if (Yr.includes("Version/")) {
      const [Kr, Zr] = Yr.split("Version/")[1]
        .split(" ")[0]
        .split(".")
        .map((Jr) => Number(Jr));
      ze = Kr < 16 || (Kr === 16 && Zr < 2);
    }
  }
  return {
    isSafari: ze || Gr(),
    needPerspectiveFix: ze,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
      Wr.navigator.userAgent
    ),
  };
}
function getBrowser() {
  return browser || (browser = calcBrowser()), browser;
}
function Resize(Wr) {
  let { swiper: ze, on: Gr, emit: Yr } = Wr;
  const Kr = getWindow();
  let Zr = null,
    Jr = null;
  const Qr = () => {
      !ze ||
        ze.destroyed ||
        !ze.initialized ||
        (Yr("beforeResize"), Yr("resize"));
    },
    ei = () => {
      !ze ||
        ze.destroyed ||
        !ze.initialized ||
        ((Zr = new ResizeObserver((ni) => {
          Jr = Kr.requestAnimationFrame(() => {
            const { width: ii, height: si } = ze;
            let li = ii,
              oi = si;
            ni.forEach((ui) => {
              let { contentBoxSize: ai, contentRect: hi, target: ci } = ui;
              (ci && ci !== ze.el) ||
                ((li = hi ? hi.width : (ai[0] || ai).inlineSize),
                (oi = hi ? hi.height : (ai[0] || ai).blockSize));
            }),
              (li !== ii || oi !== si) && Qr();
          });
        })),
        Zr.observe(ze.el));
    },
    ti = () => {
      Jr && Kr.cancelAnimationFrame(Jr),
        Zr && Zr.unobserve && ze.el && (Zr.unobserve(ze.el), (Zr = null));
    },
    ri = () => {
      !ze || ze.destroyed || !ze.initialized || Yr("orientationchange");
    };
  Gr("init", () => {
    if (ze.params.resizeObserver && typeof Kr.ResizeObserver < "u") {
      ei();
      return;
    }
    Kr.addEventListener("resize", Qr),
      Kr.addEventListener("orientationchange", ri);
  }),
    Gr("destroy", () => {
      ti(),
        Kr.removeEventListener("resize", Qr),
        Kr.removeEventListener("orientationchange", ri);
    });
}
function Observer(Wr) {
  let { swiper: ze, extendParams: Gr, on: Yr, emit: Kr } = Wr;
  const Zr = [],
    Jr = getWindow(),
    Qr = function (ri, ni) {
      ni === void 0 && (ni = {});
      const ii = Jr.MutationObserver || Jr.WebkitMutationObserver,
        si = new ii((li) => {
          if (ze.__preventObserver__) return;
          if (li.length === 1) {
            Kr("observerUpdate", li[0]);
            return;
          }
          const oi = function () {
            Kr("observerUpdate", li[0]);
          };
          Jr.requestAnimationFrame
            ? Jr.requestAnimationFrame(oi)
            : Jr.setTimeout(oi, 0);
        });
      si.observe(ri, {
        attributes: typeof ni.attributes > "u" ? !0 : ni.attributes,
        childList: typeof ni.childList > "u" ? !0 : ni.childList,
        characterData: typeof ni.characterData > "u" ? !0 : ni.characterData,
      }),
        Zr.push(si);
    },
    ei = () => {
      if (ze.params.observer) {
        if (ze.params.observeParents) {
          const ri = elementParents(ze.hostEl);
          for (let ni = 0; ni < ri.length; ni += 1) Qr(ri[ni]);
        }
        Qr(ze.hostEl, {
          childList: ze.params.observeSlideChildren,
        }),
          Qr(ze.wrapperEl, {
            attributes: !1,
          });
      }
    },
    ti = () => {
      Zr.forEach((ri) => {
        ri.disconnect();
      }),
        Zr.splice(0, Zr.length);
    };
  Gr({
    observer: !1,
    observeParents: !1,
    observeSlideChildren: !1,
  }),
    Yr("init", ei),
    Yr("destroy", ti);
}
var eventsEmitter = {
  on(Wr, ze, Gr) {
    const Yr = this;
    if (!Yr.eventsListeners || Yr.destroyed || typeof ze != "function")
      return Yr;
    const Kr = Gr ? "unshift" : "push";
    return (
      Wr.split(" ").forEach((Zr) => {
        Yr.eventsListeners[Zr] || (Yr.eventsListeners[Zr] = []),
          Yr.eventsListeners[Zr][Kr](ze);
      }),
      Yr
    );
  },
  once(Wr, ze, Gr) {
    const Yr = this;
    if (!Yr.eventsListeners || Yr.destroyed || typeof ze != "function")
      return Yr;
    function Kr() {
      Yr.off(Wr, Kr), Kr.__emitterProxy && delete Kr.__emitterProxy;
      for (var Zr = arguments.length, Jr = new Array(Zr), Qr = 0; Qr < Zr; Qr++)
        Jr[Qr] = arguments[Qr];
      ze.apply(Yr, Jr);
    }
    return (Kr.__emitterProxy = ze), Yr.on(Wr, Kr, Gr);
  },
  onAny(Wr, ze) {
    const Gr = this;
    if (!Gr.eventsListeners || Gr.destroyed || typeof Wr != "function")
      return Gr;
    const Yr = ze ? "unshift" : "push";
    return (
      Gr.eventsAnyListeners.indexOf(Wr) < 0 && Gr.eventsAnyListeners[Yr](Wr), Gr
    );
  },
  offAny(Wr) {
    const ze = this;
    if (!ze.eventsListeners || ze.destroyed || !ze.eventsAnyListeners)
      return ze;
    const Gr = ze.eventsAnyListeners.indexOf(Wr);
    return Gr >= 0 && ze.eventsAnyListeners.splice(Gr, 1), ze;
  },
  off(Wr, ze) {
    const Gr = this;
    return (
      !Gr.eventsListeners ||
        Gr.destroyed ||
        !Gr.eventsListeners ||
        Wr.split(" ").forEach((Yr) => {
          typeof ze > "u"
            ? (Gr.eventsListeners[Yr] = [])
            : Gr.eventsListeners[Yr] &&
              Gr.eventsListeners[Yr].forEach((Kr, Zr) => {
                (Kr === ze ||
                  (Kr.__emitterProxy && Kr.__emitterProxy === ze)) &&
                  Gr.eventsListeners[Yr].splice(Zr, 1);
              });
        }),
      Gr
    );
  },
  emit() {
    const Wr = this;
    if (!Wr.eventsListeners || Wr.destroyed || !Wr.eventsListeners) return Wr;
    let ze, Gr, Yr;
    for (var Kr = arguments.length, Zr = new Array(Kr), Jr = 0; Jr < Kr; Jr++)
      Zr[Jr] = arguments[Jr];
    return (
      typeof Zr[0] == "string" || Array.isArray(Zr[0])
        ? ((ze = Zr[0]), (Gr = Zr.slice(1, Zr.length)), (Yr = Wr))
        : ((ze = Zr[0].events), (Gr = Zr[0].data), (Yr = Zr[0].context || Wr)),
      Gr.unshift(Yr),
      (Array.isArray(ze) ? ze : ze.split(" ")).forEach((ei) => {
        Wr.eventsAnyListeners &&
          Wr.eventsAnyListeners.length &&
          Wr.eventsAnyListeners.forEach((ti) => {
            ti.apply(Yr, [ei, ...Gr]);
          }),
          Wr.eventsListeners &&
            Wr.eventsListeners[ei] &&
            Wr.eventsListeners[ei].forEach((ti) => {
              ti.apply(Yr, Gr);
            });
      }),
      Wr
    );
  },
};
function updateSize() {
  const Wr = this;
  let ze, Gr;
  const Yr = Wr.el;
  typeof Wr.params.width < "u" && Wr.params.width !== null
    ? (ze = Wr.params.width)
    : (ze = Yr.clientWidth),
    typeof Wr.params.height < "u" && Wr.params.height !== null
      ? (Gr = Wr.params.height)
      : (Gr = Yr.clientHeight),
    !((ze === 0 && Wr.isHorizontal()) || (Gr === 0 && Wr.isVertical())) &&
      ((ze =
        ze -
        parseInt(elementStyle(Yr, "padding-left") || 0, 10) -
        parseInt(elementStyle(Yr, "padding-right") || 0, 10)),
      (Gr =
        Gr -
        parseInt(elementStyle(Yr, "padding-top") || 0, 10) -
        parseInt(elementStyle(Yr, "padding-bottom") || 0, 10)),
      Number.isNaN(ze) && (ze = 0),
      Number.isNaN(Gr) && (Gr = 0),
      Object.assign(Wr, {
        width: ze,
        height: Gr,
        size: Wr.isHorizontal() ? ze : Gr,
      }));
}
function updateSlides() {
  const Wr = this;
  function ze(Ei, Pi) {
    return parseFloat(Ei.getPropertyValue(Wr.getDirectionLabel(Pi)) || 0);
  }
  const Gr = Wr.params,
    {
      wrapperEl: Yr,
      slidesEl: Kr,
      size: Zr,
      rtlTranslate: Jr,
      wrongRTL: Qr,
    } = Wr,
    ei = Wr.virtual && Gr.virtual.enabled,
    ti = ei ? Wr.virtual.slides.length : Wr.slides.length,
    ri = elementChildren(Kr, `.${Wr.params.slideClass}, swiper-slide`),
    ni = ei ? Wr.virtual.slides.length : ri.length;
  let ii = [];
  const si = [],
    li = [];
  let oi = Gr.slidesOffsetBefore;
  typeof oi == "function" && (oi = Gr.slidesOffsetBefore.call(Wr));
  let ui = Gr.slidesOffsetAfter;
  typeof ui == "function" && (ui = Gr.slidesOffsetAfter.call(Wr));
  const ai = Wr.snapGrid.length,
    hi = Wr.slidesGrid.length;
  let ci = Gr.spaceBetween,
    fi = -oi,
    di = 0,
    pi = 0;
  if (typeof Zr > "u") return;
  typeof ci == "string" && ci.indexOf("%") >= 0
    ? (ci = (parseFloat(ci.replace("%", "")) / 100) * Zr)
    : typeof ci == "string" && (ci = parseFloat(ci)),
    (Wr.virtualSize = -ci),
    ri.forEach((Ei) => {
      Jr ? (Ei.style.marginLeft = "") : (Ei.style.marginRight = ""),
        (Ei.style.marginBottom = ""),
        (Ei.style.marginTop = "");
    }),
    Gr.centeredSlides &&
      Gr.cssMode &&
      (setCSSProperty(Yr, "--swiper-centered-offset-before", ""),
      setCSSProperty(Yr, "--swiper-centered-offset-after", ""));
  const mi = Gr.grid && Gr.grid.rows > 1 && Wr.grid;
  mi ? Wr.grid.initSlides(ri) : Wr.grid && Wr.grid.unsetSlides();
  let Si;
  const yi =
    Gr.slidesPerView === "auto" &&
    Gr.breakpoints &&
    Object.keys(Gr.breakpoints).filter(
      (Ei) => typeof Gr.breakpoints[Ei].slidesPerView < "u"
    ).length > 0;
  for (let Ei = 0; Ei < ni; Ei += 1) {
    Si = 0;
    let Pi;
    if (
      (ri[Ei] && (Pi = ri[Ei]),
      mi && Wr.grid.updateSlide(Ei, Pi, ri),
      !(ri[Ei] && elementStyle(Pi, "display") === "none"))
    ) {
      if (Gr.slidesPerView === "auto") {
        yi && (ri[Ei].style[Wr.getDirectionLabel("width")] = "");
        const Ai = getComputedStyle(Pi),
          Ri = Pi.style.transform,
          wi = Pi.style.webkitTransform;
        if (
          (Ri && (Pi.style.transform = "none"),
          wi && (Pi.style.webkitTransform = "none"),
          Gr.roundLengths)
        )
          Si = Wr.isHorizontal()
            ? elementOuterSize(Pi, "width", !0)
            : elementOuterSize(Pi, "height", !0);
        else {
          const Ci = ze(Ai, "width"),
            bi = ze(Ai, "padding-left"),
            Mi = ze(Ai, "padding-right"),
            gi = ze(Ai, "margin-left"),
            xi = ze(Ai, "margin-right"),
            Ti = Ai.getPropertyValue("box-sizing");
          if (Ti && Ti === "border-box") Si = Ci + gi + xi;
          else {
            const { clientWidth: vi, offsetWidth: Ii } = Pi;
            Si = Ci + bi + Mi + gi + xi + (Ii - vi);
          }
        }
        Ri && (Pi.style.transform = Ri),
          wi && (Pi.style.webkitTransform = wi),
          Gr.roundLengths && (Si = Math.floor(Si));
      } else
        (Si = (Zr - (Gr.slidesPerView - 1) * ci) / Gr.slidesPerView),
          Gr.roundLengths && (Si = Math.floor(Si)),
          ri[Ei] && (ri[Ei].style[Wr.getDirectionLabel("width")] = `${Si}px`);
      ri[Ei] && (ri[Ei].swiperSlideSize = Si),
        li.push(Si),
        Gr.centeredSlides
          ? ((fi = fi + Si / 2 + di / 2 + ci),
            di === 0 && Ei !== 0 && (fi = fi - Zr / 2 - ci),
            Ei === 0 && (fi = fi - Zr / 2 - ci),
            Math.abs(fi) < 1 / 1e3 && (fi = 0),
            Gr.roundLengths && (fi = Math.floor(fi)),
            pi % Gr.slidesPerGroup === 0 && ii.push(fi),
            si.push(fi))
          : (Gr.roundLengths && (fi = Math.floor(fi)),
            (pi - Math.min(Wr.params.slidesPerGroupSkip, pi)) %
              Wr.params.slidesPerGroup ===
              0 && ii.push(fi),
            si.push(fi),
            (fi = fi + Si + ci)),
        (Wr.virtualSize += Si + ci),
        (di = Si),
        (pi += 1);
    }
  }
  if (
    ((Wr.virtualSize = Math.max(Wr.virtualSize, Zr) + ui),
    Jr &&
      Qr &&
      (Gr.effect === "slide" || Gr.effect === "coverflow") &&
      (Yr.style.width = `${Wr.virtualSize + ci}px`),
    Gr.setWrapperSize &&
      (Yr.style[Wr.getDirectionLabel("width")] = `${Wr.virtualSize + ci}px`),
    mi && Wr.grid.updateWrapperSize(Si, ii),
    !Gr.centeredSlides)
  ) {
    const Ei = [];
    for (let Pi = 0; Pi < ii.length; Pi += 1) {
      let Ai = ii[Pi];
      Gr.roundLengths && (Ai = Math.floor(Ai)),
        ii[Pi] <= Wr.virtualSize - Zr && Ei.push(Ai);
    }
    (ii = Ei),
      Math.floor(Wr.virtualSize - Zr) - Math.floor(ii[ii.length - 1]) > 1 &&
        ii.push(Wr.virtualSize - Zr);
  }
  if (ei && Gr.loop) {
    const Ei = li[0] + ci;
    if (Gr.slidesPerGroup > 1) {
      const Pi = Math.ceil(
          (Wr.virtual.slidesBefore + Wr.virtual.slidesAfter) / Gr.slidesPerGroup
        ),
        Ai = Ei * Gr.slidesPerGroup;
      for (let Ri = 0; Ri < Pi; Ri += 1) ii.push(ii[ii.length - 1] + Ai);
    }
    for (
      let Pi = 0;
      Pi < Wr.virtual.slidesBefore + Wr.virtual.slidesAfter;
      Pi += 1
    )
      Gr.slidesPerGroup === 1 && ii.push(ii[ii.length - 1] + Ei),
        si.push(si[si.length - 1] + Ei),
        (Wr.virtualSize += Ei);
  }
  if ((ii.length === 0 && (ii = [0]), ci !== 0)) {
    const Ei =
      Wr.isHorizontal() && Jr
        ? "marginLeft"
        : Wr.getDirectionLabel("marginRight");
    ri.filter((Pi, Ai) =>
      !Gr.cssMode || Gr.loop ? !0 : Ai !== ri.length - 1
    ).forEach((Pi) => {
      Pi.style[Ei] = `${ci}px`;
    });
  }
  if (Gr.centeredSlides && Gr.centeredSlidesBounds) {
    let Ei = 0;
    li.forEach((Ai) => {
      Ei += Ai + (ci || 0);
    }),
      (Ei -= ci);
    const Pi = Ei - Zr;
    ii = ii.map((Ai) => (Ai <= 0 ? -oi : Ai > Pi ? Pi + ui : Ai));
  }
  if (Gr.centerInsufficientSlides) {
    let Ei = 0;
    if (
      (li.forEach((Pi) => {
        Ei += Pi + (ci || 0);
      }),
      (Ei -= ci),
      Ei < Zr)
    ) {
      const Pi = (Zr - Ei) / 2;
      ii.forEach((Ai, Ri) => {
        ii[Ri] = Ai - Pi;
      }),
        si.forEach((Ai, Ri) => {
          si[Ri] = Ai + Pi;
        });
    }
  }
  if (
    (Object.assign(Wr, {
      slides: ri,
      snapGrid: ii,
      slidesGrid: si,
      slidesSizesGrid: li,
    }),
    Gr.centeredSlides && Gr.cssMode && !Gr.centeredSlidesBounds)
  ) {
    setCSSProperty(Yr, "--swiper-centered-offset-before", `${-ii[0]}px`),
      setCSSProperty(
        Yr,
        "--swiper-centered-offset-after",
        `${Wr.size / 2 - li[li.length - 1] / 2}px`
      );
    const Ei = -Wr.snapGrid[0],
      Pi = -Wr.slidesGrid[0];
    (Wr.snapGrid = Wr.snapGrid.map((Ai) => Ai + Ei)),
      (Wr.slidesGrid = Wr.slidesGrid.map((Ai) => Ai + Pi));
  }
  if (
    (ni !== ti && Wr.emit("slidesLengthChange"),
    ii.length !== ai &&
      (Wr.params.watchOverflow && Wr.checkOverflow(),
      Wr.emit("snapGridLengthChange")),
    si.length !== hi && Wr.emit("slidesGridLengthChange"),
    Gr.watchSlidesProgress && Wr.updateSlidesOffset(),
    !ei && !Gr.cssMode && (Gr.effect === "slide" || Gr.effect === "fade"))
  ) {
    const Ei = `${Gr.containerModifierClass}backface-hidden`,
      Pi = Wr.el.classList.contains(Ei);
    ni <= Gr.maxBackfaceHiddenSlides
      ? Pi || Wr.el.classList.add(Ei)
      : Pi && Wr.el.classList.remove(Ei);
  }
}
function updateAutoHeight(Wr) {
  const ze = this,
    Gr = [],
    Yr = ze.virtual && ze.params.virtual.enabled;
  let Kr = 0,
    Zr;
  typeof Wr == "number"
    ? ze.setTransition(Wr)
    : Wr === !0 && ze.setTransition(ze.params.speed);
  const Jr = (Qr) =>
    Yr ? ze.slides[ze.getSlideIndexByData(Qr)] : ze.slides[Qr];
  if (ze.params.slidesPerView !== "auto" && ze.params.slidesPerView > 1)
    if (ze.params.centeredSlides)
      (ze.visibleSlides || []).forEach((Qr) => {
        Gr.push(Qr);
      });
    else
      for (Zr = 0; Zr < Math.ceil(ze.params.slidesPerView); Zr += 1) {
        const Qr = ze.activeIndex + Zr;
        if (Qr > ze.slides.length && !Yr) break;
        Gr.push(Jr(Qr));
      }
  else Gr.push(Jr(ze.activeIndex));
  for (Zr = 0; Zr < Gr.length; Zr += 1)
    if (typeof Gr[Zr] < "u") {
      const Qr = Gr[Zr].offsetHeight;
      Kr = Qr > Kr ? Qr : Kr;
    }
  (Kr || Kr === 0) && (ze.wrapperEl.style.height = `${Kr}px`);
}
function updateSlidesOffset() {
  const Wr = this,
    ze = Wr.slides,
    Gr = Wr.isElement
      ? Wr.isHorizontal()
        ? Wr.wrapperEl.offsetLeft
        : Wr.wrapperEl.offsetTop
      : 0;
  for (let Yr = 0; Yr < ze.length; Yr += 1)
    ze[Yr].swiperSlideOffset =
      (Wr.isHorizontal() ? ze[Yr].offsetLeft : ze[Yr].offsetTop) -
      Gr -
      Wr.cssOverflowAdjustment();
}
function updateSlidesProgress(Wr) {
  Wr === void 0 && (Wr = (this && this.translate) || 0);
  const ze = this,
    Gr = ze.params,
    { slides: Yr, rtlTranslate: Kr, snapGrid: Zr } = ze;
  if (Yr.length === 0) return;
  typeof Yr[0].swiperSlideOffset > "u" && ze.updateSlidesOffset();
  let Jr = -Wr;
  Kr && (Jr = Wr),
    Yr.forEach((ei) => {
      ei.classList.remove(Gr.slideVisibleClass, Gr.slideFullyVisibleClass);
    }),
    (ze.visibleSlidesIndexes = []),
    (ze.visibleSlides = []);
  let Qr = Gr.spaceBetween;
  typeof Qr == "string" && Qr.indexOf("%") >= 0
    ? (Qr = (parseFloat(Qr.replace("%", "")) / 100) * ze.size)
    : typeof Qr == "string" && (Qr = parseFloat(Qr));
  for (let ei = 0; ei < Yr.length; ei += 1) {
    const ti = Yr[ei];
    let ri = ti.swiperSlideOffset;
    Gr.cssMode && Gr.centeredSlides && (ri -= Yr[0].swiperSlideOffset);
    const ni =
        (Jr + (Gr.centeredSlides ? ze.minTranslate() : 0) - ri) /
        (ti.swiperSlideSize + Qr),
      ii =
        (Jr - Zr[0] + (Gr.centeredSlides ? ze.minTranslate() : 0) - ri) /
        (ti.swiperSlideSize + Qr),
      si = -(Jr - ri),
      li = si + ze.slidesSizesGrid[ei],
      oi = si >= 0 && si <= ze.size - ze.slidesSizesGrid[ei];
    ((si >= 0 && si < ze.size - 1) ||
      (li > 1 && li <= ze.size) ||
      (si <= 0 && li >= ze.size)) &&
      (ze.visibleSlides.push(ti),
      ze.visibleSlidesIndexes.push(ei),
      Yr[ei].classList.add(Gr.slideVisibleClass)),
      oi && Yr[ei].classList.add(Gr.slideFullyVisibleClass),
      (ti.progress = Kr ? -ni : ni),
      (ti.originalProgress = Kr ? -ii : ii);
  }
}
function updateProgress(Wr) {
  const ze = this;
  if (typeof Wr > "u") {
    const ri = ze.rtlTranslate ? -1 : 1;
    Wr = (ze && ze.translate && ze.translate * ri) || 0;
  }
  const Gr = ze.params,
    Yr = ze.maxTranslate() - ze.minTranslate();
  let { progress: Kr, isBeginning: Zr, isEnd: Jr, progressLoop: Qr } = ze;
  const ei = Zr,
    ti = Jr;
  if (Yr === 0) (Kr = 0), (Zr = !0), (Jr = !0);
  else {
    Kr = (Wr - ze.minTranslate()) / Yr;
    const ri = Math.abs(Wr - ze.minTranslate()) < 1,
      ni = Math.abs(Wr - ze.maxTranslate()) < 1;
    (Zr = ri || Kr <= 0), (Jr = ni || Kr >= 1), ri && (Kr = 0), ni && (Kr = 1);
  }
  if (Gr.loop) {
    const ri = ze.getSlideIndexByData(0),
      ni = ze.getSlideIndexByData(ze.slides.length - 1),
      ii = ze.slidesGrid[ri],
      si = ze.slidesGrid[ni],
      li = ze.slidesGrid[ze.slidesGrid.length - 1],
      oi = Math.abs(Wr);
    oi >= ii ? (Qr = (oi - ii) / li) : (Qr = (oi + li - si) / li),
      Qr > 1 && (Qr -= 1);
  }
  Object.assign(ze, {
    progress: Kr,
    progressLoop: Qr,
    isBeginning: Zr,
    isEnd: Jr,
  }),
    (Gr.watchSlidesProgress || (Gr.centeredSlides && Gr.autoHeight)) &&
      ze.updateSlidesProgress(Wr),
    Zr && !ei && ze.emit("reachBeginning toEdge"),
    Jr && !ti && ze.emit("reachEnd toEdge"),
    ((ei && !Zr) || (ti && !Jr)) && ze.emit("fromEdge"),
    ze.emit("progress", Kr);
}
function updateSlidesClasses() {
  const Wr = this,
    { slides: ze, params: Gr, slidesEl: Yr, activeIndex: Kr } = Wr,
    Zr = Wr.virtual && Gr.virtual.enabled,
    Jr = Wr.grid && Gr.grid && Gr.grid.rows > 1,
    Qr = (ni) =>
      elementChildren(Yr, `.${Gr.slideClass}${ni}, swiper-slide${ni}`)[0];
  ze.forEach((ni) => {
    ni.classList.remove(
      Gr.slideActiveClass,
      Gr.slideNextClass,
      Gr.slidePrevClass
    );
  });
  let ei, ti, ri;
  if (Zr)
    if (Gr.loop) {
      let ni = Kr - Wr.virtual.slidesBefore;
      ni < 0 && (ni = Wr.virtual.slides.length + ni),
        ni >= Wr.virtual.slides.length && (ni -= Wr.virtual.slides.length),
        (ei = Qr(`[data-swiper-slide-index="${ni}"]`));
    } else ei = Qr(`[data-swiper-slide-index="${Kr}"]`);
  else
    Jr
      ? ((ei = ze.filter((ni) => ni.column === Kr)[0]),
        (ri = ze.filter((ni) => ni.column === Kr + 1)[0]),
        (ti = ze.filter((ni) => ni.column === Kr - 1)[0]))
      : (ei = ze[Kr]);
  ei &&
    (ei.classList.add(Gr.slideActiveClass),
    Jr
      ? (ri && ri.classList.add(Gr.slideNextClass),
        ti && ti.classList.add(Gr.slidePrevClass))
      : ((ri = elementNextAll(ei, `.${Gr.slideClass}, swiper-slide`)[0]),
        Gr.loop && !ri && (ri = ze[0]),
        ri && ri.classList.add(Gr.slideNextClass),
        (ti = elementPrevAll(ei, `.${Gr.slideClass}, swiper-slide`)[0]),
        Gr.loop && !ti === 0 && (ti = ze[ze.length - 1]),
        ti && ti.classList.add(Gr.slidePrevClass))),
    Wr.emitSlidesClasses();
}
const processLazyPreloader = (Wr, ze) => {
    if (!Wr || Wr.destroyed || !Wr.params) return;
    const Gr = () =>
        Wr.isElement ? "swiper-slide" : `.${Wr.params.slideClass}`,
      Yr = ze.closest(Gr());
    if (Yr) {
      let Kr = Yr.querySelector(`.${Wr.params.lazyPreloaderClass}`);
      !Kr &&
        Wr.isElement &&
        (Yr.shadowRoot
          ? (Kr = Yr.shadowRoot.querySelector(
              `.${Wr.params.lazyPreloaderClass}`
            ))
          : requestAnimationFrame(() => {
              Yr.shadowRoot &&
                ((Kr = Yr.shadowRoot.querySelector(
                  `.${Wr.params.lazyPreloaderClass}`
                )),
                Kr && Kr.remove());
            })),
        Kr && Kr.remove();
    }
  },
  unlazy = (Wr, ze) => {
    if (!Wr.slides[ze]) return;
    const Gr = Wr.slides[ze].querySelector('[loading="lazy"]');
    Gr && Gr.removeAttribute("loading");
  },
  preload = (Wr) => {
    if (!Wr || Wr.destroyed || !Wr.params) return;
    let ze = Wr.params.lazyPreloadPrevNext;
    const Gr = Wr.slides.length;
    if (!Gr || !ze || ze < 0) return;
    ze = Math.min(ze, Gr);
    const Yr =
        Wr.params.slidesPerView === "auto"
          ? Wr.slidesPerViewDynamic()
          : Math.ceil(Wr.params.slidesPerView),
      Kr = Wr.activeIndex;
    if (Wr.params.grid && Wr.params.grid.rows > 1) {
      const Jr = Kr,
        Qr = [Jr - ze];
      Qr.push(
        ...Array.from({
          length: ze,
        }).map((ei, ti) => Jr + Yr + ti)
      ),
        Wr.slides.forEach((ei, ti) => {
          Qr.includes(ei.column) && unlazy(Wr, ti);
        });
      return;
    }
    const Zr = Kr + Yr - 1;
    if (Wr.params.rewind || Wr.params.loop)
      for (let Jr = Kr - ze; Jr <= Zr + ze; Jr += 1) {
        const Qr = ((Jr % Gr) + Gr) % Gr;
        (Qr < Kr || Qr > Zr) && unlazy(Wr, Qr);
      }
    else
      for (
        let Jr = Math.max(Kr - ze, 0);
        Jr <= Math.min(Zr + ze, Gr - 1);
        Jr += 1
      )
        Jr !== Kr && (Jr > Zr || Jr < Kr) && unlazy(Wr, Jr);
  };
function getActiveIndexByTranslate(Wr) {
  const { slidesGrid: ze, params: Gr } = Wr,
    Yr = Wr.rtlTranslate ? Wr.translate : -Wr.translate;
  let Kr;
  for (let Zr = 0; Zr < ze.length; Zr += 1)
    typeof ze[Zr + 1] < "u"
      ? Yr >= ze[Zr] && Yr < ze[Zr + 1] - (ze[Zr + 1] - ze[Zr]) / 2
        ? (Kr = Zr)
        : Yr >= ze[Zr] && Yr < ze[Zr + 1] && (Kr = Zr + 1)
      : Yr >= ze[Zr] && (Kr = Zr);
  return Gr.normalizeSlideIndex && (Kr < 0 || typeof Kr > "u") && (Kr = 0), Kr;
}
function updateActiveIndex(Wr) {
  const ze = this,
    Gr = ze.rtlTranslate ? ze.translate : -ze.translate,
    {
      snapGrid: Yr,
      params: Kr,
      activeIndex: Zr,
      realIndex: Jr,
      snapIndex: Qr,
    } = ze;
  let ei = Wr,
    ti;
  const ri = (si) => {
    let li = si - ze.virtual.slidesBefore;
    return (
      li < 0 && (li = ze.virtual.slides.length + li),
      li >= ze.virtual.slides.length && (li -= ze.virtual.slides.length),
      li
    );
  };
  if (
    (typeof ei > "u" && (ei = getActiveIndexByTranslate(ze)),
    Yr.indexOf(Gr) >= 0)
  )
    ti = Yr.indexOf(Gr);
  else {
    const si = Math.min(Kr.slidesPerGroupSkip, ei);
    ti = si + Math.floor((ei - si) / Kr.slidesPerGroup);
  }
  if ((ti >= Yr.length && (ti = Yr.length - 1), ei === Zr && !ze.params.loop)) {
    ti !== Qr && ((ze.snapIndex = ti), ze.emit("snapIndexChange"));
    return;
  }
  if (ei === Zr && ze.params.loop && ze.virtual && ze.params.virtual.enabled) {
    ze.realIndex = ri(ei);
    return;
  }
  const ni = ze.grid && Kr.grid && Kr.grid.rows > 1;
  let ii;
  if (ze.virtual && Kr.virtual.enabled && Kr.loop) ii = ri(ei);
  else if (ni) {
    const si = ze.slides.filter((oi) => oi.column === ei)[0];
    let li = parseInt(si.getAttribute("data-swiper-slide-index"), 10);
    Number.isNaN(li) && (li = Math.max(ze.slides.indexOf(si), 0)),
      (ii = Math.floor(li / Kr.grid.rows));
  } else if (ze.slides[ei]) {
    const si = ze.slides[ei].getAttribute("data-swiper-slide-index");
    si ? (ii = parseInt(si, 10)) : (ii = ei);
  } else ii = ei;
  Object.assign(ze, {
    previousSnapIndex: Qr,
    snapIndex: ti,
    previousRealIndex: Jr,
    realIndex: ii,
    previousIndex: Zr,
    activeIndex: ei,
  }),
    ze.initialized && preload(ze),
    ze.emit("activeIndexChange"),
    ze.emit("snapIndexChange"),
    (ze.initialized || ze.params.runCallbacksOnInit) &&
      (Jr !== ii && ze.emit("realIndexChange"), ze.emit("slideChange"));
}
function updateClickedSlide(Wr, ze) {
  const Gr = this,
    Yr = Gr.params;
  let Kr = Wr.closest(`.${Yr.slideClass}, swiper-slide`);
  !Kr &&
    Gr.isElement &&
    ze &&
    ze.length > 1 &&
    ze.includes(Wr) &&
    [...ze.slice(ze.indexOf(Wr) + 1, ze.length)].forEach((Qr) => {
      !Kr &&
        Qr.matches &&
        Qr.matches(`.${Yr.slideClass}, swiper-slide`) &&
        (Kr = Qr);
    });
  let Zr = !1,
    Jr;
  if (Kr) {
    for (let Qr = 0; Qr < Gr.slides.length; Qr += 1)
      if (Gr.slides[Qr] === Kr) {
        (Zr = !0), (Jr = Qr);
        break;
      }
  }
  if (Kr && Zr)
    (Gr.clickedSlide = Kr),
      Gr.virtual && Gr.params.virtual.enabled
        ? (Gr.clickedIndex = parseInt(
            Kr.getAttribute("data-swiper-slide-index"),
            10
          ))
        : (Gr.clickedIndex = Jr);
  else {
    (Gr.clickedSlide = void 0), (Gr.clickedIndex = void 0);
    return;
  }
  Yr.slideToClickedSlide &&
    Gr.clickedIndex !== void 0 &&
    Gr.clickedIndex !== Gr.activeIndex &&
    Gr.slideToClickedSlide();
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};
function getSwiperTranslate(Wr) {
  Wr === void 0 && (Wr = this.isHorizontal() ? "x" : "y");
  const ze = this,
    { params: Gr, rtlTranslate: Yr, translate: Kr, wrapperEl: Zr } = ze;
  if (Gr.virtualTranslate) return Yr ? -Kr : Kr;
  if (Gr.cssMode) return Kr;
  let Jr = getTranslate(Zr, Wr);
  return (Jr += ze.cssOverflowAdjustment()), Yr && (Jr = -Jr), Jr || 0;
}
function setTranslate(Wr, ze) {
  const Gr = this,
    { rtlTranslate: Yr, params: Kr, wrapperEl: Zr, progress: Jr } = Gr;
  let Qr = 0,
    ei = 0;
  const ti = 0;
  Gr.isHorizontal() ? (Qr = Yr ? -Wr : Wr) : (ei = Wr),
    Kr.roundLengths && ((Qr = Math.floor(Qr)), (ei = Math.floor(ei))),
    (Gr.previousTranslate = Gr.translate),
    (Gr.translate = Gr.isHorizontal() ? Qr : ei),
    Kr.cssMode
      ? (Zr[Gr.isHorizontal() ? "scrollLeft" : "scrollTop"] = Gr.isHorizontal()
          ? -Qr
          : -ei)
      : Kr.virtualTranslate ||
        (Gr.isHorizontal()
          ? (Qr -= Gr.cssOverflowAdjustment())
          : (ei -= Gr.cssOverflowAdjustment()),
        (Zr.style.transform = `translate3d(${Qr}px, ${ei}px, ${ti}px)`));
  let ri;
  const ni = Gr.maxTranslate() - Gr.minTranslate();
  ni === 0 ? (ri = 0) : (ri = (Wr - Gr.minTranslate()) / ni),
    ri !== Jr && Gr.updateProgress(Wr),
    Gr.emit("setTranslate", Gr.translate, ze);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(Wr, ze, Gr, Yr, Kr) {
  Wr === void 0 && (Wr = 0),
    ze === void 0 && (ze = this.params.speed),
    Gr === void 0 && (Gr = !0),
    Yr === void 0 && (Yr = !0);
  const Zr = this,
    { params: Jr, wrapperEl: Qr } = Zr;
  if (Zr.animating && Jr.preventInteractionOnTransition) return !1;
  const ei = Zr.minTranslate(),
    ti = Zr.maxTranslate();
  let ri;
  if (
    (Yr && Wr > ei ? (ri = ei) : Yr && Wr < ti ? (ri = ti) : (ri = Wr),
    Zr.updateProgress(ri),
    Jr.cssMode)
  ) {
    const ni = Zr.isHorizontal();
    if (ze === 0) Qr[ni ? "scrollLeft" : "scrollTop"] = -ri;
    else {
      if (!Zr.support.smoothScroll)
        return (
          animateCSSModeScroll({
            swiper: Zr,
            targetPosition: -ri,
            side: ni ? "left" : "top",
          }),
          !0
        );
      Qr.scrollTo({
        [ni ? "left" : "top"]: -ri,
        behavior: "smooth",
      });
    }
    return !0;
  }
  return (
    ze === 0
      ? (Zr.setTransition(0),
        Zr.setTranslate(ri),
        Gr &&
          (Zr.emit("beforeTransitionStart", ze, Kr), Zr.emit("transitionEnd")))
      : (Zr.setTransition(ze),
        Zr.setTranslate(ri),
        Gr &&
          (Zr.emit("beforeTransitionStart", ze, Kr),
          Zr.emit("transitionStart")),
        Zr.animating ||
          ((Zr.animating = !0),
          Zr.onTranslateToWrapperTransitionEnd ||
            (Zr.onTranslateToWrapperTransitionEnd = function (ii) {
              !Zr ||
                Zr.destroyed ||
                (ii.target === this &&
                  (Zr.wrapperEl.removeEventListener(
                    "transitionend",
                    Zr.onTranslateToWrapperTransitionEnd
                  ),
                  (Zr.onTranslateToWrapperTransitionEnd = null),
                  delete Zr.onTranslateToWrapperTransitionEnd,
                  Gr && Zr.emit("transitionEnd")));
            }),
          Zr.wrapperEl.addEventListener(
            "transitionend",
            Zr.onTranslateToWrapperTransitionEnd
          ))),
    !0
  );
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo,
};
function setTransition(Wr, ze) {
  const Gr = this;
  Gr.params.cssMode ||
    ((Gr.wrapperEl.style.transitionDuration = `${Wr}ms`),
    (Gr.wrapperEl.style.transitionDelay = Wr === 0 ? "0ms" : "")),
    Gr.emit("setTransition", Wr, ze);
}
function transitionEmit(Wr) {
  let { swiper: ze, runCallbacks: Gr, direction: Yr, step: Kr } = Wr;
  const { activeIndex: Zr, previousIndex: Jr } = ze;
  let Qr = Yr;
  if (
    (Qr || (Zr > Jr ? (Qr = "next") : Zr < Jr ? (Qr = "prev") : (Qr = "reset")),
    ze.emit(`transition${Kr}`),
    Gr && Zr !== Jr)
  ) {
    if (Qr === "reset") {
      ze.emit(`slideResetTransition${Kr}`);
      return;
    }
    ze.emit(`slideChangeTransition${Kr}`),
      Qr === "next"
        ? ze.emit(`slideNextTransition${Kr}`)
        : ze.emit(`slidePrevTransition${Kr}`);
  }
}
function transitionStart(Wr, ze) {
  Wr === void 0 && (Wr = !0);
  const Gr = this,
    { params: Yr } = Gr;
  Yr.cssMode ||
    (Yr.autoHeight && Gr.updateAutoHeight(),
    transitionEmit({
      swiper: Gr,
      runCallbacks: Wr,
      direction: ze,
      step: "Start",
    }));
}
function transitionEnd(Wr, ze) {
  Wr === void 0 && (Wr = !0);
  const Gr = this,
    { params: Yr } = Gr;
  (Gr.animating = !1),
    !Yr.cssMode &&
      (Gr.setTransition(0),
      transitionEmit({
        swiper: Gr,
        runCallbacks: Wr,
        direction: ze,
        step: "End",
      }));
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd,
};
function slideTo(Wr, ze, Gr, Yr, Kr) {
  Wr === void 0 && (Wr = 0),
    ze === void 0 && (ze = this.params.speed),
    Gr === void 0 && (Gr = !0),
    typeof Wr == "string" && (Wr = parseInt(Wr, 10));
  const Zr = this;
  let Jr = Wr;
  Jr < 0 && (Jr = 0);
  const {
    params: Qr,
    snapGrid: ei,
    slidesGrid: ti,
    previousIndex: ri,
    activeIndex: ni,
    rtlTranslate: ii,
    wrapperEl: si,
    enabled: li,
  } = Zr;
  if (
    (Zr.animating && Qr.preventInteractionOnTransition) ||
    (!li && !Yr && !Kr)
  )
    return !1;
  const oi = Math.min(Zr.params.slidesPerGroupSkip, Jr);
  let ui = oi + Math.floor((Jr - oi) / Zr.params.slidesPerGroup);
  ui >= ei.length && (ui = ei.length - 1);
  const ai = -ei[ui];
  if (Qr.normalizeSlideIndex)
    for (let ci = 0; ci < ti.length; ci += 1) {
      const fi = -Math.floor(ai * 100),
        di = Math.floor(ti[ci] * 100),
        pi = Math.floor(ti[ci + 1] * 100);
      typeof ti[ci + 1] < "u"
        ? fi >= di && fi < pi - (pi - di) / 2
          ? (Jr = ci)
          : fi >= di && fi < pi && (Jr = ci + 1)
        : fi >= di && (Jr = ci);
    }
  if (
    Zr.initialized &&
    Jr !== ni &&
    ((!Zr.allowSlideNext &&
      (ii
        ? ai > Zr.translate && ai > Zr.minTranslate()
        : ai < Zr.translate && ai < Zr.minTranslate())) ||
      (!Zr.allowSlidePrev &&
        ai > Zr.translate &&
        ai > Zr.maxTranslate() &&
        (ni || 0) !== Jr))
  )
    return !1;
  Jr !== (ri || 0) && Gr && Zr.emit("beforeSlideChangeStart"),
    Zr.updateProgress(ai);
  let hi;
  if (
    (Jr > ni ? (hi = "next") : Jr < ni ? (hi = "prev") : (hi = "reset"),
    (ii && -ai === Zr.translate) || (!ii && ai === Zr.translate))
  )
    return (
      Zr.updateActiveIndex(Jr),
      Qr.autoHeight && Zr.updateAutoHeight(),
      Zr.updateSlidesClasses(),
      Qr.effect !== "slide" && Zr.setTranslate(ai),
      hi !== "reset" && (Zr.transitionStart(Gr, hi), Zr.transitionEnd(Gr, hi)),
      !1
    );
  if (Qr.cssMode) {
    const ci = Zr.isHorizontal(),
      fi = ii ? ai : -ai;
    if (ze === 0) {
      const di = Zr.virtual && Zr.params.virtual.enabled;
      di &&
        ((Zr.wrapperEl.style.scrollSnapType = "none"),
        (Zr._immediateVirtual = !0)),
        di && !Zr._cssModeVirtualInitialSet && Zr.params.initialSlide > 0
          ? ((Zr._cssModeVirtualInitialSet = !0),
            requestAnimationFrame(() => {
              si[ci ? "scrollLeft" : "scrollTop"] = fi;
            }))
          : (si[ci ? "scrollLeft" : "scrollTop"] = fi),
        di &&
          requestAnimationFrame(() => {
            (Zr.wrapperEl.style.scrollSnapType = ""),
              (Zr._immediateVirtual = !1);
          });
    } else {
      if (!Zr.support.smoothScroll)
        return (
          animateCSSModeScroll({
            swiper: Zr,
            targetPosition: fi,
            side: ci ? "left" : "top",
          }),
          !0
        );
      si.scrollTo({
        [ci ? "left" : "top"]: fi,
        behavior: "smooth",
      });
    }
    return !0;
  }
  return (
    Zr.setTransition(ze),
    Zr.setTranslate(ai),
    Zr.updateActiveIndex(Jr),
    Zr.updateSlidesClasses(),
    Zr.emit("beforeTransitionStart", ze, Yr),
    Zr.transitionStart(Gr, hi),
    ze === 0
      ? Zr.transitionEnd(Gr, hi)
      : Zr.animating ||
        ((Zr.animating = !0),
        Zr.onSlideToWrapperTransitionEnd ||
          (Zr.onSlideToWrapperTransitionEnd = function (fi) {
            !Zr ||
              Zr.destroyed ||
              (fi.target === this &&
                (Zr.wrapperEl.removeEventListener(
                  "transitionend",
                  Zr.onSlideToWrapperTransitionEnd
                ),
                (Zr.onSlideToWrapperTransitionEnd = null),
                delete Zr.onSlideToWrapperTransitionEnd,
                Zr.transitionEnd(Gr, hi)));
          }),
        Zr.wrapperEl.addEventListener(
          "transitionend",
          Zr.onSlideToWrapperTransitionEnd
        )),
    !0
  );
}
function slideToLoop(Wr, ze, Gr, Yr) {
  Wr === void 0 && (Wr = 0),
    ze === void 0 && (ze = this.params.speed),
    Gr === void 0 && (Gr = !0),
    typeof Wr == "string" && (Wr = parseInt(Wr, 10));
  const Kr = this,
    Zr = Kr.grid && Kr.params.grid && Kr.params.grid.rows > 1;
  let Jr = Wr;
  if (Kr.params.loop)
    if (Kr.virtual && Kr.params.virtual.enabled)
      Jr = Jr + Kr.virtual.slidesBefore;
    else {
      let Qr;
      if (Zr) {
        const ii = Jr * Kr.params.grid.rows;
        Qr = Kr.slides.filter(
          (si) => si.getAttribute("data-swiper-slide-index") * 1 === ii
        )[0].column;
      } else Qr = Kr.getSlideIndexByData(Jr);
      const ei = Zr
          ? Math.ceil(Kr.slides.length / Kr.params.grid.rows)
          : Kr.slides.length,
        { centeredSlides: ti } = Kr.params;
      let ri = Kr.params.slidesPerView;
      ri === "auto"
        ? (ri = Kr.slidesPerViewDynamic())
        : ((ri = Math.ceil(parseFloat(Kr.params.slidesPerView, 10))),
          ti && ri % 2 === 0 && (ri = ri + 1));
      let ni = ei - Qr < ri;
      if ((ti && (ni = ni || Qr < Math.ceil(ri / 2)), ni)) {
        const ii = ti
          ? Qr < Kr.activeIndex
            ? "prev"
            : "next"
          : Qr - Kr.activeIndex - 1 < Kr.params.slidesPerView
          ? "next"
          : "prev";
        Kr.loopFix({
          direction: ii,
          slideTo: !0,
          activeSlideIndex: ii === "next" ? Qr + 1 : Qr - ei + 1,
          slideRealIndex: ii === "next" ? Kr.realIndex : void 0,
        });
      }
      if (Zr) {
        const ii = Jr * Kr.params.grid.rows;
        Jr = Kr.slides.filter(
          (si) => si.getAttribute("data-swiper-slide-index") * 1 === ii
        )[0].column;
      } else Jr = Kr.getSlideIndexByData(Jr);
    }
  return (
    requestAnimationFrame(() => {
      Kr.slideTo(Jr, ze, Gr, Yr);
    }),
    Kr
  );
}
function slideNext(Wr, ze, Gr) {
  Wr === void 0 && (Wr = this.params.speed), ze === void 0 && (ze = !0);
  const Yr = this,
    { enabled: Kr, params: Zr, animating: Jr } = Yr;
  if (!Kr) return Yr;
  let Qr = Zr.slidesPerGroup;
  Zr.slidesPerView === "auto" &&
    Zr.slidesPerGroup === 1 &&
    Zr.slidesPerGroupAuto &&
    (Qr = Math.max(Yr.slidesPerViewDynamic("current", !0), 1));
  const ei = Yr.activeIndex < Zr.slidesPerGroupSkip ? 1 : Qr,
    ti = Yr.virtual && Zr.virtual.enabled;
  if (Zr.loop) {
    if (Jr && !ti && Zr.loopPreventsSliding) return !1;
    if (
      (Yr.loopFix({
        direction: "next",
      }),
      (Yr._clientLeft = Yr.wrapperEl.clientLeft),
      Yr.activeIndex === Yr.slides.length - 1 && Zr.cssMode)
    )
      return (
        requestAnimationFrame(() => {
          Yr.slideTo(Yr.activeIndex + ei, Wr, ze, Gr);
        }),
        !0
      );
  }
  return Zr.rewind && Yr.isEnd
    ? Yr.slideTo(0, Wr, ze, Gr)
    : Yr.slideTo(Yr.activeIndex + ei, Wr, ze, Gr);
}
function slidePrev(Wr, ze, Gr) {
  Wr === void 0 && (Wr = this.params.speed), ze === void 0 && (ze = !0);
  const Yr = this,
    {
      params: Kr,
      snapGrid: Zr,
      slidesGrid: Jr,
      rtlTranslate: Qr,
      enabled: ei,
      animating: ti,
    } = Yr;
  if (!ei) return Yr;
  const ri = Yr.virtual && Kr.virtual.enabled;
  if (Kr.loop) {
    if (ti && !ri && Kr.loopPreventsSliding) return !1;
    Yr.loopFix({
      direction: "prev",
    }),
      (Yr._clientLeft = Yr.wrapperEl.clientLeft);
  }
  const ni = Qr ? Yr.translate : -Yr.translate;
  function ii(ai) {
    return ai < 0 ? -Math.floor(Math.abs(ai)) : Math.floor(ai);
  }
  const si = ii(ni),
    li = Zr.map((ai) => ii(ai));
  let oi = Zr[li.indexOf(si) - 1];
  if (typeof oi > "u" && Kr.cssMode) {
    let ai;
    Zr.forEach((hi, ci) => {
      si >= hi && (ai = ci);
    }),
      typeof ai < "u" && (oi = Zr[ai > 0 ? ai - 1 : ai]);
  }
  let ui = 0;
  if (
    (typeof oi < "u" &&
      ((ui = Jr.indexOf(oi)),
      ui < 0 && (ui = Yr.activeIndex - 1),
      Kr.slidesPerView === "auto" &&
        Kr.slidesPerGroup === 1 &&
        Kr.slidesPerGroupAuto &&
        ((ui = ui - Yr.slidesPerViewDynamic("previous", !0) + 1),
        (ui = Math.max(ui, 0)))),
    Kr.rewind && Yr.isBeginning)
  ) {
    const ai =
      Yr.params.virtual && Yr.params.virtual.enabled && Yr.virtual
        ? Yr.virtual.slides.length - 1
        : Yr.slides.length - 1;
    return Yr.slideTo(ai, Wr, ze, Gr);
  } else if (Kr.loop && Yr.activeIndex === 0 && Kr.cssMode)
    return (
      requestAnimationFrame(() => {
        Yr.slideTo(ui, Wr, ze, Gr);
      }),
      !0
    );
  return Yr.slideTo(ui, Wr, ze, Gr);
}
function slideReset(Wr, ze, Gr) {
  Wr === void 0 && (Wr = this.params.speed), ze === void 0 && (ze = !0);
  const Yr = this;
  return Yr.slideTo(Yr.activeIndex, Wr, ze, Gr);
}
function slideToClosest(Wr, ze, Gr, Yr) {
  Wr === void 0 && (Wr = this.params.speed),
    ze === void 0 && (ze = !0),
    Yr === void 0 && (Yr = 0.5);
  const Kr = this;
  let Zr = Kr.activeIndex;
  const Jr = Math.min(Kr.params.slidesPerGroupSkip, Zr),
    Qr = Jr + Math.floor((Zr - Jr) / Kr.params.slidesPerGroup),
    ei = Kr.rtlTranslate ? Kr.translate : -Kr.translate;
  if (ei >= Kr.snapGrid[Qr]) {
    const ti = Kr.snapGrid[Qr],
      ri = Kr.snapGrid[Qr + 1];
    ei - ti > (ri - ti) * Yr && (Zr += Kr.params.slidesPerGroup);
  } else {
    const ti = Kr.snapGrid[Qr - 1],
      ri = Kr.snapGrid[Qr];
    ei - ti <= (ri - ti) * Yr && (Zr -= Kr.params.slidesPerGroup);
  }
  return (
    (Zr = Math.max(Zr, 0)),
    (Zr = Math.min(Zr, Kr.slidesGrid.length - 1)),
    Kr.slideTo(Zr, Wr, ze, Gr)
  );
}
function slideToClickedSlide() {
  const Wr = this,
    { params: ze, slidesEl: Gr } = Wr,
    Yr =
      ze.slidesPerView === "auto"
        ? Wr.slidesPerViewDynamic()
        : ze.slidesPerView;
  let Kr = Wr.clickedIndex,
    Zr;
  const Jr = Wr.isElement ? "swiper-slide" : `.${ze.slideClass}`;
  if (ze.loop) {
    if (Wr.animating) return;
    (Zr = parseInt(
      Wr.clickedSlide.getAttribute("data-swiper-slide-index"),
      10
    )),
      ze.centeredSlides
        ? Kr < Wr.loopedSlides - Yr / 2 ||
          Kr > Wr.slides.length - Wr.loopedSlides + Yr / 2
          ? (Wr.loopFix(),
            (Kr = Wr.getSlideIndex(
              elementChildren(Gr, `${Jr}[data-swiper-slide-index="${Zr}"]`)[0]
            )),
            nextTick(() => {
              Wr.slideTo(Kr);
            }))
          : Wr.slideTo(Kr)
        : Kr > Wr.slides.length - Yr
        ? (Wr.loopFix(),
          (Kr = Wr.getSlideIndex(
            elementChildren(Gr, `${Jr}[data-swiper-slide-index="${Zr}"]`)[0]
          )),
          nextTick(() => {
            Wr.slideTo(Kr);
          }))
        : Wr.slideTo(Kr);
  } else Wr.slideTo(Kr);
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};
function loopCreate(Wr) {
  const ze = this,
    { params: Gr, slidesEl: Yr } = ze;
  if (!Gr.loop || (ze.virtual && ze.params.virtual.enabled)) return;
  const Kr = () => {
      elementChildren(Yr, `.${Gr.slideClass}, swiper-slide`).forEach(
        (ni, ii) => {
          ni.setAttribute("data-swiper-slide-index", ii);
        }
      );
    },
    Zr = ze.grid && Gr.grid && Gr.grid.rows > 1,
    Jr = Gr.slidesPerGroup * (Zr ? Gr.grid.rows : 1),
    Qr = ze.slides.length % Jr !== 0,
    ei = Zr && ze.slides.length % Gr.grid.rows !== 0,
    ti = (ri) => {
      for (let ni = 0; ni < ri; ni += 1) {
        const ii = ze.isElement
          ? createElement("swiper-slide", [Gr.slideBlankClass])
          : createElement("div", [Gr.slideClass, Gr.slideBlankClass]);
        ze.slidesEl.append(ii);
      }
    };
  if (Qr) {
    if (Gr.loopAddBlankSlides) {
      const ri = Jr - (ze.slides.length % Jr);
      ti(ri), ze.recalcSlides(), ze.updateSlides();
    } else
      showWarning(
        "Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"
      );
    Kr();
  } else if (ei) {
    if (Gr.loopAddBlankSlides) {
      const ri = Gr.grid.rows - (ze.slides.length % Gr.grid.rows);
      ti(ri), ze.recalcSlides(), ze.updateSlides();
    } else
      showWarning(
        "Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"
      );
    Kr();
  } else Kr();
  ze.loopFix({
    slideRealIndex: Wr,
    direction: Gr.centeredSlides ? void 0 : "next",
  });
}
function loopFix(Wr) {
  let {
    slideRealIndex: ze,
    slideTo: Gr = !0,
    direction: Yr,
    setTranslate: Kr,
    activeSlideIndex: Zr,
    byController: Jr,
    byMousewheel: Qr,
  } = Wr === void 0 ? {} : Wr;
  const ei = this;
  if (!ei.params.loop) return;
  ei.emit("beforeLoopFix");
  const {
      slides: ti,
      allowSlidePrev: ri,
      allowSlideNext: ni,
      slidesEl: ii,
      params: si,
    } = ei,
    { centeredSlides: li } = si;
  if (
    ((ei.allowSlidePrev = !0),
    (ei.allowSlideNext = !0),
    ei.virtual && si.virtual.enabled)
  ) {
    Gr &&
      (!si.centeredSlides && ei.snapIndex === 0
        ? ei.slideTo(ei.virtual.slides.length, 0, !1, !0)
        : si.centeredSlides && ei.snapIndex < si.slidesPerView
        ? ei.slideTo(ei.virtual.slides.length + ei.snapIndex, 0, !1, !0)
        : ei.snapIndex === ei.snapGrid.length - 1 &&
          ei.slideTo(ei.virtual.slidesBefore, 0, !1, !0)),
      (ei.allowSlidePrev = ri),
      (ei.allowSlideNext = ni),
      ei.emit("loopFix");
    return;
  }
  let oi = si.slidesPerView;
  oi === "auto"
    ? (oi = ei.slidesPerViewDynamic())
    : ((oi = Math.ceil(parseFloat(si.slidesPerView, 10))),
      li && oi % 2 === 0 && (oi = oi + 1));
  const ui = si.slidesPerGroupAuto ? oi : si.slidesPerGroup;
  let ai = ui;
  ai % ui !== 0 && (ai += ui - (ai % ui)),
    (ai += si.loopAdditionalSlides),
    (ei.loopedSlides = ai);
  const hi = ei.grid && si.grid && si.grid.rows > 1;
  ti.length < oi + ai
    ? showWarning(
        "Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"
      )
    : hi &&
      si.grid.fill === "row" &&
      showWarning(
        "Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"
      );
  const ci = [],
    fi = [];
  let di = ei.activeIndex;
  typeof Zr > "u"
    ? (Zr = ei.getSlideIndex(
        ti.filter((Ri) => Ri.classList.contains(si.slideActiveClass))[0]
      ))
    : (di = Zr);
  const pi = Yr === "next" || !Yr,
    mi = Yr === "prev" || !Yr;
  let Si = 0,
    yi = 0;
  const Ei = hi ? Math.ceil(ti.length / si.grid.rows) : ti.length,
    Ai =
      (hi ? ti[Zr].column : Zr) + (li && typeof Kr > "u" ? -oi / 2 + 0.5 : 0);
  if (Ai < ai) {
    Si = Math.max(ai - Ai, ui);
    for (let Ri = 0; Ri < ai - Ai; Ri += 1) {
      const wi = Ri - Math.floor(Ri / Ei) * Ei;
      if (hi) {
        const Ci = Ei - wi - 1;
        for (let bi = ti.length - 1; bi >= 0; bi -= 1)
          ti[bi].column === Ci && ci.push(bi);
      } else ci.push(Ei - wi - 1);
    }
  } else if (Ai + oi > Ei - ai) {
    yi = Math.max(Ai - (Ei - ai * 2), ui);
    for (let Ri = 0; Ri < yi; Ri += 1) {
      const wi = Ri - Math.floor(Ri / Ei) * Ei;
      hi
        ? ti.forEach((Ci, bi) => {
            Ci.column === wi && fi.push(bi);
          })
        : fi.push(wi);
    }
  }
  if (
    ((ei.__preventObserver__ = !0),
    requestAnimationFrame(() => {
      ei.__preventObserver__ = !1;
    }),
    mi &&
      ci.forEach((Ri) => {
        (ti[Ri].swiperLoopMoveDOM = !0),
          ii.prepend(ti[Ri]),
          (ti[Ri].swiperLoopMoveDOM = !1);
      }),
    pi &&
      fi.forEach((Ri) => {
        (ti[Ri].swiperLoopMoveDOM = !0),
          ii.append(ti[Ri]),
          (ti[Ri].swiperLoopMoveDOM = !1);
      }),
    ei.recalcSlides(),
    si.slidesPerView === "auto"
      ? ei.updateSlides()
      : hi &&
        ((ci.length > 0 && mi) || (fi.length > 0 && pi)) &&
        ei.slides.forEach((Ri, wi) => {
          ei.grid.updateSlide(wi, Ri, ei.slides);
        }),
    si.watchSlidesProgress && ei.updateSlidesOffset(),
    Gr)
  ) {
    if (ci.length > 0 && mi) {
      if (typeof ze > "u") {
        const Ri = ei.slidesGrid[di],
          Ci = ei.slidesGrid[di + Si] - Ri;
        Qr
          ? ei.setTranslate(ei.translate - Ci)
          : (ei.slideTo(di + Si, 0, !1, !0),
            Kr &&
              ((ei.touchEventsData.startTranslate =
                ei.touchEventsData.startTranslate - Ci),
              (ei.touchEventsData.currentTranslate =
                ei.touchEventsData.currentTranslate - Ci)));
      } else if (Kr) {
        const Ri = hi ? ci.length / si.grid.rows : ci.length;
        ei.slideTo(ei.activeIndex + Ri, 0, !1, !0),
          (ei.touchEventsData.currentTranslate = ei.translate);
      }
    } else if (fi.length > 0 && pi)
      if (typeof ze > "u") {
        const Ri = ei.slidesGrid[di],
          Ci = ei.slidesGrid[di - yi] - Ri;
        Qr
          ? ei.setTranslate(ei.translate - Ci)
          : (ei.slideTo(di - yi, 0, !1, !0),
            Kr &&
              ((ei.touchEventsData.startTranslate =
                ei.touchEventsData.startTranslate - Ci),
              (ei.touchEventsData.currentTranslate =
                ei.touchEventsData.currentTranslate - Ci)));
      } else {
        const Ri = hi ? fi.length / si.grid.rows : fi.length;
        ei.slideTo(ei.activeIndex - Ri, 0, !1, !0);
      }
  }
  if (
    ((ei.allowSlidePrev = ri),
    (ei.allowSlideNext = ni),
    ei.controller && ei.controller.control && !Jr)
  ) {
    const Ri = {
      slideRealIndex: ze,
      direction: Yr,
      setTranslate: Kr,
      activeSlideIndex: Zr,
      byController: !0,
    };
    Array.isArray(ei.controller.control)
      ? ei.controller.control.forEach((wi) => {
          !wi.destroyed &&
            wi.params.loop &&
            wi.loopFix({
              ...Ri,
              slideTo: wi.params.slidesPerView === si.slidesPerView ? Gr : !1,
            });
        })
      : ei.controller.control instanceof ei.constructor &&
        ei.controller.control.params.loop &&
        ei.controller.control.loopFix({
          ...Ri,
          slideTo:
            ei.controller.control.params.slidesPerView === si.slidesPerView
              ? Gr
              : !1,
        });
  }
  ei.emit("loopFix");
}
function loopDestroy() {
  const Wr = this,
    { params: ze, slidesEl: Gr } = Wr;
  if (!ze.loop || (Wr.virtual && Wr.params.virtual.enabled)) return;
  Wr.recalcSlides();
  const Yr = [];
  Wr.slides.forEach((Kr) => {
    const Zr =
      typeof Kr.swiperSlideIndex > "u"
        ? Kr.getAttribute("data-swiper-slide-index") * 1
        : Kr.swiperSlideIndex;
    Yr[Zr] = Kr;
  }),
    Wr.slides.forEach((Kr) => {
      Kr.removeAttribute("data-swiper-slide-index");
    }),
    Yr.forEach((Kr) => {
      Gr.append(Kr);
    }),
    Wr.recalcSlides(),
    Wr.slideTo(Wr.realIndex, 0);
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};
function setGrabCursor(Wr) {
  const ze = this;
  if (
    !ze.params.simulateTouch ||
    (ze.params.watchOverflow && ze.isLocked) ||
    ze.params.cssMode
  )
    return;
  const Gr = ze.params.touchEventsTarget === "container" ? ze.el : ze.wrapperEl;
  ze.isElement && (ze.__preventObserver__ = !0),
    (Gr.style.cursor = "move"),
    (Gr.style.cursor = Wr ? "grabbing" : "grab"),
    ze.isElement &&
      requestAnimationFrame(() => {
        ze.__preventObserver__ = !1;
      });
}
function unsetGrabCursor() {
  const Wr = this;
  (Wr.params.watchOverflow && Wr.isLocked) ||
    Wr.params.cssMode ||
    (Wr.isElement && (Wr.__preventObserver__ = !0),
    (Wr[
      Wr.params.touchEventsTarget === "container" ? "el" : "wrapperEl"
    ].style.cursor = ""),
    Wr.isElement &&
      requestAnimationFrame(() => {
        Wr.__preventObserver__ = !1;
      }));
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};
function closestElement(Wr, ze) {
  ze === void 0 && (ze = this);
  function Gr(Yr) {
    if (!Yr || Yr === getDocument() || Yr === getWindow()) return null;
    Yr.assignedSlot && (Yr = Yr.assignedSlot);
    const Kr = Yr.closest(Wr);
    return !Kr && !Yr.getRootNode ? null : Kr || Gr(Yr.getRootNode().host);
  }
  return Gr(ze);
}
function preventEdgeSwipe(Wr, ze, Gr) {
  const Yr = getWindow(),
    { params: Kr } = Wr,
    Zr = Kr.edgeSwipeDetection,
    Jr = Kr.edgeSwipeThreshold;
  return Zr && (Gr <= Jr || Gr >= Yr.innerWidth - Jr)
    ? Zr === "prevent"
      ? (ze.preventDefault(), !0)
      : !1
    : !0;
}
function onTouchStart(Wr) {
  const ze = this,
    Gr = getDocument();
  let Yr = Wr;
  Yr.originalEvent && (Yr = Yr.originalEvent);
  const Kr = ze.touchEventsData;
  if (Yr.type === "pointerdown") {
    if (Kr.pointerId !== null && Kr.pointerId !== Yr.pointerId) return;
    Kr.pointerId = Yr.pointerId;
  } else
    Yr.type === "touchstart" &&
      Yr.targetTouches.length === 1 &&
      (Kr.touchId = Yr.targetTouches[0].identifier);
  if (Yr.type === "touchstart") {
    preventEdgeSwipe(ze, Yr, Yr.targetTouches[0].pageX);
    return;
  }
  const { params: Zr, touches: Jr, enabled: Qr } = ze;
  if (
    !Qr ||
    (!Zr.simulateTouch && Yr.pointerType === "mouse") ||
    (ze.animating && Zr.preventInteractionOnTransition)
  )
    return;
  !ze.animating && Zr.cssMode && Zr.loop && ze.loopFix();
  let ei = Yr.target;
  if (
    (Zr.touchEventsTarget === "wrapper" && !ze.wrapperEl.contains(ei)) ||
    ("which" in Yr && Yr.which === 3) ||
    ("button" in Yr && Yr.button > 0) ||
    (Kr.isTouched && Kr.isMoved)
  )
    return;
  const ti = !!Zr.noSwipingClass && Zr.noSwipingClass !== "",
    ri = Yr.composedPath ? Yr.composedPath() : Yr.path;
  ti && Yr.target && Yr.target.shadowRoot && ri && (ei = ri[0]);
  const ni = Zr.noSwipingSelector
      ? Zr.noSwipingSelector
      : `.${Zr.noSwipingClass}`,
    ii = !!(Yr.target && Yr.target.shadowRoot);
  if (Zr.noSwiping && (ii ? closestElement(ni, ei) : ei.closest(ni))) {
    ze.allowClick = !0;
    return;
  }
  if (Zr.swipeHandler && !ei.closest(Zr.swipeHandler)) return;
  (Jr.currentX = Yr.pageX), (Jr.currentY = Yr.pageY);
  const si = Jr.currentX,
    li = Jr.currentY;
  if (!preventEdgeSwipe(ze, Yr, si)) return;
  Object.assign(Kr, {
    isTouched: !0,
    isMoved: !1,
    allowTouchCallbacks: !0,
    isScrolling: void 0,
    startMoving: void 0,
  }),
    (Jr.startX = si),
    (Jr.startY = li),
    (Kr.touchStartTime = now()),
    (ze.allowClick = !0),
    ze.updateSize(),
    (ze.swipeDirection = void 0),
    Zr.threshold > 0 && (Kr.allowThresholdMove = !1);
  let oi = !0;
  ei.matches(Kr.focusableElements) &&
    ((oi = !1), ei.nodeName === "SELECT" && (Kr.isTouched = !1)),
    Gr.activeElement &&
      Gr.activeElement.matches(Kr.focusableElements) &&
      Gr.activeElement !== ei &&
      Gr.activeElement.blur();
  const ui = oi && ze.allowTouchMove && Zr.touchStartPreventDefault;
  (Zr.touchStartForcePreventDefault || ui) &&
    !ei.isContentEditable &&
    Yr.preventDefault(),
    Zr.freeMode &&
      Zr.freeMode.enabled &&
      ze.freeMode &&
      ze.animating &&
      !Zr.cssMode &&
      ze.freeMode.onTouchStart(),
    ze.emit("touchStart", Yr);
}
function onTouchMove(Wr) {
  const ze = getDocument(),
    Gr = this,
    Yr = Gr.touchEventsData,
    { params: Kr, touches: Zr, rtlTranslate: Jr, enabled: Qr } = Gr;
  if (!Qr || (!Kr.simulateTouch && Wr.pointerType === "mouse")) return;
  let ei = Wr;
  if (
    (ei.originalEvent && (ei = ei.originalEvent),
    ei.type === "pointermove" &&
      (Yr.touchId !== null || ei.pointerId !== Yr.pointerId))
  )
    return;
  let ti;
  if (ei.type === "touchmove") {
    if (
      ((ti = [...ei.changedTouches].filter(
        (pi) => pi.identifier === Yr.touchId
      )[0]),
      !ti || ti.identifier !== Yr.touchId)
    )
      return;
  } else ti = ei;
  if (!Yr.isTouched) {
    Yr.startMoving && Yr.isScrolling && Gr.emit("touchMoveOpposite", ei);
    return;
  }
  const ri = ti.pageX,
    ni = ti.pageY;
  if (ei.preventedByNestedSwiper) {
    (Zr.startX = ri), (Zr.startY = ni);
    return;
  }
  if (!Gr.allowTouchMove) {
    ei.target.matches(Yr.focusableElements) || (Gr.allowClick = !1),
      Yr.isTouched &&
        (Object.assign(Zr, {
          startX: ri,
          startY: ni,
          currentX: ri,
          currentY: ni,
        }),
        (Yr.touchStartTime = now()));
    return;
  }
  if (Kr.touchReleaseOnEdges && !Kr.loop) {
    if (Gr.isVertical()) {
      if (
        (ni < Zr.startY && Gr.translate <= Gr.maxTranslate()) ||
        (ni > Zr.startY && Gr.translate >= Gr.minTranslate())
      ) {
        (Yr.isTouched = !1), (Yr.isMoved = !1);
        return;
      }
    } else if (
      (ri < Zr.startX && Gr.translate <= Gr.maxTranslate()) ||
      (ri > Zr.startX && Gr.translate >= Gr.minTranslate())
    )
      return;
  }
  if (
    ze.activeElement &&
    ei.target === ze.activeElement &&
    ei.target.matches(Yr.focusableElements)
  ) {
    (Yr.isMoved = !0), (Gr.allowClick = !1);
    return;
  }
  Yr.allowTouchCallbacks && Gr.emit("touchMove", ei),
    (Zr.previousX = Zr.currentX),
    (Zr.previousY = Zr.currentY),
    (Zr.currentX = ri),
    (Zr.currentY = ni);
  const ii = Zr.currentX - Zr.startX,
    si = Zr.currentY - Zr.startY;
  if (Gr.params.threshold && Math.sqrt(ii ** 2 + si ** 2) < Gr.params.threshold)
    return;
  if (typeof Yr.isScrolling > "u") {
    let pi;
    (Gr.isHorizontal() && Zr.currentY === Zr.startY) ||
    (Gr.isVertical() && Zr.currentX === Zr.startX)
      ? (Yr.isScrolling = !1)
      : ii * ii + si * si >= 25 &&
        ((pi = (Math.atan2(Math.abs(si), Math.abs(ii)) * 180) / Math.PI),
        (Yr.isScrolling = Gr.isHorizontal()
          ? pi > Kr.touchAngle
          : 90 - pi > Kr.touchAngle));
  }
  if (
    (Yr.isScrolling && Gr.emit("touchMoveOpposite", ei),
    typeof Yr.startMoving > "u" &&
      (Zr.currentX !== Zr.startX || Zr.currentY !== Zr.startY) &&
      (Yr.startMoving = !0),
    Yr.isScrolling)
  ) {
    Yr.isTouched = !1;
    return;
  }
  if (!Yr.startMoving) return;
  (Gr.allowClick = !1),
    !Kr.cssMode && ei.cancelable && ei.preventDefault(),
    Kr.touchMoveStopPropagation && !Kr.nested && ei.stopPropagation();
  let li = Gr.isHorizontal() ? ii : si,
    oi = Gr.isHorizontal()
      ? Zr.currentX - Zr.previousX
      : Zr.currentY - Zr.previousY;
  Kr.oneWayMovement &&
    ((li = Math.abs(li) * (Jr ? 1 : -1)), (oi = Math.abs(oi) * (Jr ? 1 : -1))),
    (Zr.diff = li),
    (li *= Kr.touchRatio),
    Jr && ((li = -li), (oi = -oi));
  const ui = Gr.touchesDirection;
  (Gr.swipeDirection = li > 0 ? "prev" : "next"),
    (Gr.touchesDirection = oi > 0 ? "prev" : "next");
  const ai = Gr.params.loop && !Kr.cssMode,
    hi =
      (Gr.touchesDirection === "next" && Gr.allowSlideNext) ||
      (Gr.touchesDirection === "prev" && Gr.allowSlidePrev);
  if (!Yr.isMoved) {
    if (
      (ai &&
        hi &&
        Gr.loopFix({
          direction: Gr.swipeDirection,
        }),
      (Yr.startTranslate = Gr.getTranslate()),
      Gr.setTransition(0),
      Gr.animating)
    ) {
      const pi = new window.CustomEvent("transitionend", {
        bubbles: !0,
        cancelable: !0,
      });
      Gr.wrapperEl.dispatchEvent(pi);
    }
    (Yr.allowMomentumBounce = !1),
      Kr.grabCursor &&
        (Gr.allowSlideNext === !0 || Gr.allowSlidePrev === !0) &&
        Gr.setGrabCursor(!0),
      Gr.emit("sliderFirstMove", ei);
  }
  let ci;
  if (
    (new Date().getTime(),
    Yr.isMoved &&
      Yr.allowThresholdMove &&
      ui !== Gr.touchesDirection &&
      ai &&
      hi &&
      Math.abs(li) >= 1)
  ) {
    Object.assign(Zr, {
      startX: ri,
      startY: ni,
      currentX: ri,
      currentY: ni,
      startTranslate: Yr.currentTranslate,
    }),
      (Yr.loopSwapReset = !0),
      (Yr.startTranslate = Yr.currentTranslate);
    return;
  }
  Gr.emit("sliderMove", ei),
    (Yr.isMoved = !0),
    (Yr.currentTranslate = li + Yr.startTranslate);
  let fi = !0,
    di = Kr.resistanceRatio;
  if (
    (Kr.touchReleaseOnEdges && (di = 0),
    li > 0
      ? (ai &&
          hi &&
          !ci &&
          Yr.allowThresholdMove &&
          Yr.currentTranslate >
            (Kr.centeredSlides
              ? Gr.minTranslate() - Gr.slidesSizesGrid[Gr.activeIndex + 1]
              : Gr.minTranslate()) &&
          Gr.loopFix({
            direction: "prev",
            setTranslate: !0,
            activeSlideIndex: 0,
          }),
        Yr.currentTranslate > Gr.minTranslate() &&
          ((fi = !1),
          Kr.resistance &&
            (Yr.currentTranslate =
              Gr.minTranslate() -
              1 +
              (-Gr.minTranslate() + Yr.startTranslate + li) ** di)))
      : li < 0 &&
        (ai &&
          hi &&
          !ci &&
          Yr.allowThresholdMove &&
          Yr.currentTranslate <
            (Kr.centeredSlides
              ? Gr.maxTranslate() +
                Gr.slidesSizesGrid[Gr.slidesSizesGrid.length - 1]
              : Gr.maxTranslate()) &&
          Gr.loopFix({
            direction: "next",
            setTranslate: !0,
            activeSlideIndex:
              Gr.slides.length -
              (Kr.slidesPerView === "auto"
                ? Gr.slidesPerViewDynamic()
                : Math.ceil(parseFloat(Kr.slidesPerView, 10))),
          }),
        Yr.currentTranslate < Gr.maxTranslate() &&
          ((fi = !1),
          Kr.resistance &&
            (Yr.currentTranslate =
              Gr.maxTranslate() +
              1 -
              (Gr.maxTranslate() - Yr.startTranslate - li) ** di))),
    fi && (ei.preventedByNestedSwiper = !0),
    !Gr.allowSlideNext &&
      Gr.swipeDirection === "next" &&
      Yr.currentTranslate < Yr.startTranslate &&
      (Yr.currentTranslate = Yr.startTranslate),
    !Gr.allowSlidePrev &&
      Gr.swipeDirection === "prev" &&
      Yr.currentTranslate > Yr.startTranslate &&
      (Yr.currentTranslate = Yr.startTranslate),
    !Gr.allowSlidePrev &&
      !Gr.allowSlideNext &&
      (Yr.currentTranslate = Yr.startTranslate),
    Kr.threshold > 0)
  )
    if (Math.abs(li) > Kr.threshold || Yr.allowThresholdMove) {
      if (!Yr.allowThresholdMove) {
        (Yr.allowThresholdMove = !0),
          (Zr.startX = Zr.currentX),
          (Zr.startY = Zr.currentY),
          (Yr.currentTranslate = Yr.startTranslate),
          (Zr.diff = Gr.isHorizontal()
            ? Zr.currentX - Zr.startX
            : Zr.currentY - Zr.startY);
        return;
      }
    } else {
      Yr.currentTranslate = Yr.startTranslate;
      return;
    }
  !Kr.followFinger ||
    Kr.cssMode ||
    (((Kr.freeMode && Kr.freeMode.enabled && Gr.freeMode) ||
      Kr.watchSlidesProgress) &&
      (Gr.updateActiveIndex(), Gr.updateSlidesClasses()),
    Kr.freeMode &&
      Kr.freeMode.enabled &&
      Gr.freeMode &&
      Gr.freeMode.onTouchMove(),
    Gr.updateProgress(Yr.currentTranslate),
    Gr.setTranslate(Yr.currentTranslate));
}
function onTouchEnd(Wr) {
  const ze = this,
    Gr = ze.touchEventsData;
  let Yr = Wr;
  Yr.originalEvent && (Yr = Yr.originalEvent);
  let Kr;
  if (Yr.type === "touchend" || Yr.type === "touchcancel") {
    if (
      ((Kr = [...Yr.changedTouches].filter(
        (fi) => fi.identifier === Gr.touchId
      )[0]),
      !Kr || Kr.identifier !== Gr.touchId)
    )
      return;
  } else {
    if (Gr.touchId !== null || Yr.pointerId !== Gr.pointerId) return;
    Kr = Yr;
  }
  if (
    ["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(
      Yr.type
    ) &&
    !(
      ["pointercancel", "contextmenu"].includes(Yr.type) &&
      (ze.browser.isSafari || ze.browser.isWebView)
    )
  )
    return;
  (Gr.pointerId = null), (Gr.touchId = null);
  const {
    params: Jr,
    touches: Qr,
    rtlTranslate: ei,
    slidesGrid: ti,
    enabled: ri,
  } = ze;
  if (!ri || (!Jr.simulateTouch && Yr.pointerType === "mouse")) return;
  if (
    (Gr.allowTouchCallbacks && ze.emit("touchEnd", Yr),
    (Gr.allowTouchCallbacks = !1),
    !Gr.isTouched)
  ) {
    Gr.isMoved && Jr.grabCursor && ze.setGrabCursor(!1),
      (Gr.isMoved = !1),
      (Gr.startMoving = !1);
    return;
  }
  Jr.grabCursor &&
    Gr.isMoved &&
    Gr.isTouched &&
    (ze.allowSlideNext === !0 || ze.allowSlidePrev === !0) &&
    ze.setGrabCursor(!1);
  const ni = now(),
    ii = ni - Gr.touchStartTime;
  if (ze.allowClick) {
    const fi = Yr.path || (Yr.composedPath && Yr.composedPath());
    ze.updateClickedSlide((fi && fi[0]) || Yr.target, fi),
      ze.emit("tap click", Yr),
      ii < 300 &&
        ni - Gr.lastClickTime < 300 &&
        ze.emit("doubleTap doubleClick", Yr);
  }
  if (
    ((Gr.lastClickTime = now()),
    nextTick(() => {
      ze.destroyed || (ze.allowClick = !0);
    }),
    !Gr.isTouched ||
      !Gr.isMoved ||
      !ze.swipeDirection ||
      (Qr.diff === 0 && !Gr.loopSwapReset) ||
      (Gr.currentTranslate === Gr.startTranslate && !Gr.loopSwapReset))
  ) {
    (Gr.isTouched = !1), (Gr.isMoved = !1), (Gr.startMoving = !1);
    return;
  }
  (Gr.isTouched = !1), (Gr.isMoved = !1), (Gr.startMoving = !1);
  let si;
  if (
    (Jr.followFinger
      ? (si = ei ? ze.translate : -ze.translate)
      : (si = -Gr.currentTranslate),
    Jr.cssMode)
  )
    return;
  if (Jr.freeMode && Jr.freeMode.enabled) {
    ze.freeMode.onTouchEnd({
      currentPos: si,
    });
    return;
  }
  let li = 0,
    oi = ze.slidesSizesGrid[0];
  for (
    let fi = 0;
    fi < ti.length;
    fi += fi < Jr.slidesPerGroupSkip ? 1 : Jr.slidesPerGroup
  ) {
    const di = fi < Jr.slidesPerGroupSkip - 1 ? 1 : Jr.slidesPerGroup;
    typeof ti[fi + di] < "u"
      ? si >= ti[fi] &&
        si < ti[fi + di] &&
        ((li = fi), (oi = ti[fi + di] - ti[fi]))
      : si >= ti[fi] &&
        ((li = fi), (oi = ti[ti.length - 1] - ti[ti.length - 2]));
  }
  let ui = null,
    ai = null;
  Jr.rewind &&
    (ze.isBeginning
      ? (ai =
          Jr.virtual && Jr.virtual.enabled && ze.virtual
            ? ze.virtual.slides.length - 1
            : ze.slides.length - 1)
      : ze.isEnd && (ui = 0));
  const hi = (si - ti[li]) / oi,
    ci = li < Jr.slidesPerGroupSkip - 1 ? 1 : Jr.slidesPerGroup;
  if (ii > Jr.longSwipesMs) {
    if (!Jr.longSwipes) {
      ze.slideTo(ze.activeIndex);
      return;
    }
    ze.swipeDirection === "next" &&
      (hi >= Jr.longSwipesRatio
        ? ze.slideTo(Jr.rewind && ze.isEnd ? ui : li + ci)
        : ze.slideTo(li)),
      ze.swipeDirection === "prev" &&
        (hi > 1 - Jr.longSwipesRatio
          ? ze.slideTo(li + ci)
          : ai !== null && hi < 0 && Math.abs(hi) > Jr.longSwipesRatio
          ? ze.slideTo(ai)
          : ze.slideTo(li));
  } else {
    if (!Jr.shortSwipes) {
      ze.slideTo(ze.activeIndex);
      return;
    }
    ze.navigation &&
    (Yr.target === ze.navigation.nextEl || Yr.target === ze.navigation.prevEl)
      ? Yr.target === ze.navigation.nextEl
        ? ze.slideTo(li + ci)
        : ze.slideTo(li)
      : (ze.swipeDirection === "next" && ze.slideTo(ui !== null ? ui : li + ci),
        ze.swipeDirection === "prev" && ze.slideTo(ai !== null ? ai : li));
  }
}
function onResize() {
  const Wr = this,
    { params: ze, el: Gr } = Wr;
  if (Gr && Gr.offsetWidth === 0) return;
  ze.breakpoints && Wr.setBreakpoint();
  const { allowSlideNext: Yr, allowSlidePrev: Kr, snapGrid: Zr } = Wr,
    Jr = Wr.virtual && Wr.params.virtual.enabled;
  (Wr.allowSlideNext = !0),
    (Wr.allowSlidePrev = !0),
    Wr.updateSize(),
    Wr.updateSlides(),
    Wr.updateSlidesClasses();
  const Qr = Jr && ze.loop;
  (ze.slidesPerView === "auto" || ze.slidesPerView > 1) &&
  Wr.isEnd &&
  !Wr.isBeginning &&
  !Wr.params.centeredSlides &&
  !Qr
    ? Wr.slideTo(Wr.slides.length - 1, 0, !1, !0)
    : Wr.params.loop && !Jr
    ? Wr.slideToLoop(Wr.realIndex, 0, !1, !0)
    : Wr.slideTo(Wr.activeIndex, 0, !1, !0),
    Wr.autoplay &&
      Wr.autoplay.running &&
      Wr.autoplay.paused &&
      (clearTimeout(Wr.autoplay.resizeTimeout),
      (Wr.autoplay.resizeTimeout = setTimeout(() => {
        Wr.autoplay &&
          Wr.autoplay.running &&
          Wr.autoplay.paused &&
          Wr.autoplay.resume();
      }, 500))),
    (Wr.allowSlidePrev = Kr),
    (Wr.allowSlideNext = Yr),
    Wr.params.watchOverflow && Zr !== Wr.snapGrid && Wr.checkOverflow();
}
function onClick(Wr) {
  const ze = this;
  ze.enabled &&
    (ze.allowClick ||
      (ze.params.preventClicks && Wr.preventDefault(),
      ze.params.preventClicksPropagation &&
        ze.animating &&
        (Wr.stopPropagation(), Wr.stopImmediatePropagation())));
}
function onScroll() {
  const Wr = this,
    { wrapperEl: ze, rtlTranslate: Gr, enabled: Yr } = Wr;
  if (!Yr) return;
  (Wr.previousTranslate = Wr.translate),
    Wr.isHorizontal()
      ? (Wr.translate = -ze.scrollLeft)
      : (Wr.translate = -ze.scrollTop),
    Wr.translate === 0 && (Wr.translate = 0),
    Wr.updateActiveIndex(),
    Wr.updateSlidesClasses();
  let Kr;
  const Zr = Wr.maxTranslate() - Wr.minTranslate();
  Zr === 0 ? (Kr = 0) : (Kr = (Wr.translate - Wr.minTranslate()) / Zr),
    Kr !== Wr.progress && Wr.updateProgress(Gr ? -Wr.translate : Wr.translate),
    Wr.emit("setTranslate", Wr.translate, !1);
}
function onLoad(Wr) {
  const ze = this;
  processLazyPreloader(ze, Wr.target),
    !(
      ze.params.cssMode ||
      (ze.params.slidesPerView !== "auto" && !ze.params.autoHeight)
    ) && ze.update();
}
function onDocumentTouchStart() {
  const Wr = this;
  Wr.documentTouchHandlerProceeded ||
    ((Wr.documentTouchHandlerProceeded = !0),
    Wr.params.touchReleaseOnEdges && (Wr.el.style.touchAction = "auto"));
}
const events = (Wr, ze) => {
  const Gr = getDocument(),
    { params: Yr, el: Kr, wrapperEl: Zr, device: Jr } = Wr,
    Qr = !!Yr.nested,
    ei = ze === "on" ? "addEventListener" : "removeEventListener",
    ti = ze;
  Gr[ei]("touchstart", Wr.onDocumentTouchStart, {
    passive: !1,
    capture: Qr,
  }),
    Kr[ei]("touchstart", Wr.onTouchStart, {
      passive: !1,
    }),
    Kr[ei]("pointerdown", Wr.onTouchStart, {
      passive: !1,
    }),
    Gr[ei]("touchmove", Wr.onTouchMove, {
      passive: !1,
      capture: Qr,
    }),
    Gr[ei]("pointermove", Wr.onTouchMove, {
      passive: !1,
      capture: Qr,
    }),
    Gr[ei]("touchend", Wr.onTouchEnd, {
      passive: !0,
    }),
    Gr[ei]("pointerup", Wr.onTouchEnd, {
      passive: !0,
    }),
    Gr[ei]("pointercancel", Wr.onTouchEnd, {
      passive: !0,
    }),
    Gr[ei]("touchcancel", Wr.onTouchEnd, {
      passive: !0,
    }),
    Gr[ei]("pointerout", Wr.onTouchEnd, {
      passive: !0,
    }),
    Gr[ei]("pointerleave", Wr.onTouchEnd, {
      passive: !0,
    }),
    Gr[ei]("contextmenu", Wr.onTouchEnd, {
      passive: !0,
    }),
    (Yr.preventClicks || Yr.preventClicksPropagation) &&
      Kr[ei]("click", Wr.onClick, !0),
    Yr.cssMode && Zr[ei]("scroll", Wr.onScroll),
    Yr.updateOnWindowResize
      ? Wr[ti](
          Jr.ios || Jr.android
            ? "resize orientationchange observerUpdate"
            : "resize observerUpdate",
          onResize,
          !0
        )
      : Wr[ti]("observerUpdate", onResize, !0),
    Kr[ei]("load", Wr.onLoad, {
      capture: !0,
    });
};
function attachEvents() {
  const Wr = this,
    { params: ze } = Wr;
  (Wr.onTouchStart = onTouchStart.bind(Wr)),
    (Wr.onTouchMove = onTouchMove.bind(Wr)),
    (Wr.onTouchEnd = onTouchEnd.bind(Wr)),
    (Wr.onDocumentTouchStart = onDocumentTouchStart.bind(Wr)),
    ze.cssMode && (Wr.onScroll = onScroll.bind(Wr)),
    (Wr.onClick = onClick.bind(Wr)),
    (Wr.onLoad = onLoad.bind(Wr)),
    events(Wr, "on");
}
function detachEvents() {
  events(this, "off");
}
var events$1 = {
  attachEvents,
  detachEvents,
};
const isGridEnabled = (Wr, ze) => Wr.grid && ze.grid && ze.grid.rows > 1;
function setBreakpoint() {
  const Wr = this,
    { realIndex: ze, initialized: Gr, params: Yr, el: Kr } = Wr,
    Zr = Yr.breakpoints;
  if (!Zr || (Zr && Object.keys(Zr).length === 0)) return;
  const Jr = Wr.getBreakpoint(Zr, Wr.params.breakpointsBase, Wr.el);
  if (!Jr || Wr.currentBreakpoint === Jr) return;
  const ei = (Jr in Zr ? Zr[Jr] : void 0) || Wr.originalParams,
    ti = isGridEnabled(Wr, Yr),
    ri = isGridEnabled(Wr, ei),
    ni = Yr.enabled;
  ti && !ri
    ? (Kr.classList.remove(
        `${Yr.containerModifierClass}grid`,
        `${Yr.containerModifierClass}grid-column`
      ),
      Wr.emitContainerClasses())
    : !ti &&
      ri &&
      (Kr.classList.add(`${Yr.containerModifierClass}grid`),
      ((ei.grid.fill && ei.grid.fill === "column") ||
        (!ei.grid.fill && Yr.grid.fill === "column")) &&
        Kr.classList.add(`${Yr.containerModifierClass}grid-column`),
      Wr.emitContainerClasses()),
    ["navigation", "pagination", "scrollbar"].forEach((ai) => {
      if (typeof ei[ai] > "u") return;
      const hi = Yr[ai] && Yr[ai].enabled,
        ci = ei[ai] && ei[ai].enabled;
      hi && !ci && Wr[ai].disable(), !hi && ci && Wr[ai].enable();
    });
  const ii = ei.direction && ei.direction !== Yr.direction,
    si = Yr.loop && (ei.slidesPerView !== Yr.slidesPerView || ii),
    li = Yr.loop;
  ii && Gr && Wr.changeDirection(), extend(Wr.params, ei);
  const oi = Wr.params.enabled,
    ui = Wr.params.loop;
  Object.assign(Wr, {
    allowTouchMove: Wr.params.allowTouchMove,
    allowSlideNext: Wr.params.allowSlideNext,
    allowSlidePrev: Wr.params.allowSlidePrev,
  }),
    ni && !oi ? Wr.disable() : !ni && oi && Wr.enable(),
    (Wr.currentBreakpoint = Jr),
    Wr.emit("_beforeBreakpoint", ei),
    Gr &&
      (si
        ? (Wr.loopDestroy(), Wr.loopCreate(ze), Wr.updateSlides())
        : !li && ui
        ? (Wr.loopCreate(ze), Wr.updateSlides())
        : li && !ui && Wr.loopDestroy()),
    Wr.emit("breakpoint", ei);
}
function getBreakpoint(Wr, ze, Gr) {
  if ((ze === void 0 && (ze = "window"), !Wr || (ze === "container" && !Gr)))
    return;
  let Yr = !1;
  const Kr = getWindow(),
    Zr = ze === "window" ? Kr.innerHeight : Gr.clientHeight,
    Jr = Object.keys(Wr).map((Qr) => {
      if (typeof Qr == "string" && Qr.indexOf("@") === 0) {
        const ei = parseFloat(Qr.substr(1));
        return {
          value: Zr * ei,
          point: Qr,
        };
      }
      return {
        value: Qr,
        point: Qr,
      };
    });
  Jr.sort((Qr, ei) => parseInt(Qr.value, 10) - parseInt(ei.value, 10));
  for (let Qr = 0; Qr < Jr.length; Qr += 1) {
    const { point: ei, value: ti } = Jr[Qr];
    ze === "window"
      ? Kr.matchMedia(`(min-width: ${ti}px)`).matches && (Yr = ei)
      : ti <= Gr.clientWidth && (Yr = ei);
  }
  return Yr || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint,
};
function prepareClasses(Wr, ze) {
  const Gr = [];
  return (
    Wr.forEach((Yr) => {
      typeof Yr == "object"
        ? Object.keys(Yr).forEach((Kr) => {
            Yr[Kr] && Gr.push(ze + Kr);
          })
        : typeof Yr == "string" && Gr.push(ze + Yr);
    }),
    Gr
  );
}
function addClasses() {
  const Wr = this,
    { classNames: ze, params: Gr, rtl: Yr, el: Kr, device: Zr } = Wr,
    Jr = prepareClasses(
      [
        "initialized",
        Gr.direction,
        {
          "free-mode": Wr.params.freeMode && Gr.freeMode.enabled,
        },
        {
          autoheight: Gr.autoHeight,
        },
        {
          rtl: Yr,
        },
        {
          grid: Gr.grid && Gr.grid.rows > 1,
        },
        {
          "grid-column":
            Gr.grid && Gr.grid.rows > 1 && Gr.grid.fill === "column",
        },
        {
          android: Zr.android,
        },
        {
          ios: Zr.ios,
        },
        {
          "css-mode": Gr.cssMode,
        },
        {
          centered: Gr.cssMode && Gr.centeredSlides,
        },
        {
          "watch-progress": Gr.watchSlidesProgress,
        },
      ],
      Gr.containerModifierClass
    );
  ze.push(...Jr), Kr.classList.add(...ze), Wr.emitContainerClasses();
}
function removeClasses() {
  const Wr = this,
    { el: ze, classNames: Gr } = Wr;
  ze.classList.remove(...Gr), Wr.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses,
};
function checkOverflow() {
  const Wr = this,
    { isLocked: ze, params: Gr } = Wr,
    { slidesOffsetBefore: Yr } = Gr;
  if (Yr) {
    const Kr = Wr.slides.length - 1,
      Zr = Wr.slidesGrid[Kr] + Wr.slidesSizesGrid[Kr] + Yr * 2;
    Wr.isLocked = Wr.size > Zr;
  } else Wr.isLocked = Wr.snapGrid.length === 1;
  Gr.allowSlideNext === !0 && (Wr.allowSlideNext = !Wr.isLocked),
    Gr.allowSlidePrev === !0 && (Wr.allowSlidePrev = !Wr.isLocked),
    ze && ze !== Wr.isLocked && (Wr.isEnd = !1),
    ze !== Wr.isLocked && Wr.emit(Wr.isLocked ? "lock" : "unlock");
}
var checkOverflow$1 = {
    checkOverflow,
  },
  defaults = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: 0.85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1,
  };
function moduleExtendParams(Wr, ze) {
  return function (Yr) {
    Yr === void 0 && (Yr = {});
    const Kr = Object.keys(Yr)[0],
      Zr = Yr[Kr];
    if (typeof Zr != "object" || Zr === null) {
      extend(ze, Yr);
      return;
    }
    if (
      (Wr[Kr] === !0 &&
        (Wr[Kr] = {
          enabled: !0,
        }),
      Kr === "navigation" &&
        Wr[Kr] &&
        Wr[Kr].enabled &&
        !Wr[Kr].prevEl &&
        !Wr[Kr].nextEl &&
        (Wr[Kr].auto = !0),
      ["pagination", "scrollbar"].indexOf(Kr) >= 0 &&
        Wr[Kr] &&
        Wr[Kr].enabled &&
        !Wr[Kr].el &&
        (Wr[Kr].auto = !0),
      !(Kr in Wr && "enabled" in Zr))
    ) {
      extend(ze, Yr);
      return;
    }
    typeof Wr[Kr] == "object" &&
      !("enabled" in Wr[Kr]) &&
      (Wr[Kr].enabled = !0),
      Wr[Kr] ||
        (Wr[Kr] = {
          enabled: !1,
        }),
      extend(ze, Yr);
  };
}
const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes,
  },
  extendedDefaults = {};
class Swiper {
  constructor() {
    let ze, Gr;
    for (var Yr = arguments.length, Kr = new Array(Yr), Zr = 0; Zr < Yr; Zr++)
      Kr[Zr] = arguments[Zr];
    Kr.length === 1 &&
    Kr[0].constructor &&
    Object.prototype.toString.call(Kr[0]).slice(8, -1) === "Object"
      ? (Gr = Kr[0])
      : ([ze, Gr] = Kr),
      Gr || (Gr = {}),
      (Gr = extend({}, Gr)),
      ze && !Gr.el && (Gr.el = ze);
    const Jr = getDocument();
    if (
      Gr.el &&
      typeof Gr.el == "string" &&
      Jr.querySelectorAll(Gr.el).length > 1
    ) {
      const ri = [];
      return (
        Jr.querySelectorAll(Gr.el).forEach((ni) => {
          const ii = extend({}, Gr, {
            el: ni,
          });
          ri.push(new Swiper(ii));
        }),
        ri
      );
    }
    const Qr = this;
    (Qr.__swiper__ = !0),
      (Qr.support = getSupport()),
      (Qr.device = getDevice({
        userAgent: Gr.userAgent,
      })),
      (Qr.browser = getBrowser()),
      (Qr.eventsListeners = {}),
      (Qr.eventsAnyListeners = []),
      (Qr.modules = [...Qr.__modules__]),
      Gr.modules && Array.isArray(Gr.modules) && Qr.modules.push(...Gr.modules);
    const ei = {};
    Qr.modules.forEach((ri) => {
      ri({
        params: Gr,
        swiper: Qr,
        extendParams: moduleExtendParams(Gr, ei),
        on: Qr.on.bind(Qr),
        once: Qr.once.bind(Qr),
        off: Qr.off.bind(Qr),
        emit: Qr.emit.bind(Qr),
      });
    });
    const ti = extend({}, defaults, ei);
    return (
      (Qr.params = extend({}, ti, extendedDefaults, Gr)),
      (Qr.originalParams = extend({}, Qr.params)),
      (Qr.passedParams = extend({}, Gr)),
      Qr.params &&
        Qr.params.on &&
        Object.keys(Qr.params.on).forEach((ri) => {
          Qr.on(ri, Qr.params.on[ri]);
        }),
      Qr.params && Qr.params.onAny && Qr.onAny(Qr.params.onAny),
      Object.assign(Qr, {
        enabled: Qr.params.enabled,
        el: ze,
        classNames: [],
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal() {
          return Qr.params.direction === "horizontal";
        },
        isVertical() {
          return Qr.params.direction === "vertical";
        },
        activeIndex: 0,
        realIndex: 0,
        isBeginning: !0,
        isEnd: !1,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        allowSlideNext: Qr.params.allowSlideNext,
        allowSlidePrev: Qr.params.allowSlidePrev,
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          focusableElements: Qr.params.focusableElements,
          lastClickTime: 0,
          clickTimeout: void 0,
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null,
        },
        allowClick: !0,
        allowTouchMove: Qr.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0,
        },
        imagesToLoad: [],
        imagesLoaded: 0,
      }),
      Qr.emit("_swiper"),
      Qr.params.init && Qr.init(),
      Qr
    );
  }
  getDirectionLabel(ze) {
    return this.isHorizontal()
      ? ze
      : {
          width: "height",
          "margin-top": "margin-left",
          "margin-bottom ": "margin-right",
          "margin-left": "margin-top",
          "margin-right": "margin-bottom",
          "padding-left": "padding-top",
          "padding-right": "padding-bottom",
          marginRight: "marginBottom",
        }[ze];
  }
  getSlideIndex(ze) {
    const { slidesEl: Gr, params: Yr } = this,
      Kr = elementChildren(Gr, `.${Yr.slideClass}, swiper-slide`),
      Zr = elementIndex(Kr[0]);
    return elementIndex(ze) - Zr;
  }
  getSlideIndexByData(ze) {
    return this.getSlideIndex(
      this.slides.filter(
        (Gr) => Gr.getAttribute("data-swiper-slide-index") * 1 === ze
      )[0]
    );
  }
  recalcSlides() {
    const ze = this,
      { slidesEl: Gr, params: Yr } = ze;
    ze.slides = elementChildren(Gr, `.${Yr.slideClass}, swiper-slide`);
  }
  enable() {
    const ze = this;
    ze.enabled ||
      ((ze.enabled = !0),
      ze.params.grabCursor && ze.setGrabCursor(),
      ze.emit("enable"));
  }
  disable() {
    const ze = this;
    ze.enabled &&
      ((ze.enabled = !1),
      ze.params.grabCursor && ze.unsetGrabCursor(),
      ze.emit("disable"));
  }
  setProgress(ze, Gr) {
    const Yr = this;
    ze = Math.min(Math.max(ze, 0), 1);
    const Kr = Yr.minTranslate(),
      Jr = (Yr.maxTranslate() - Kr) * ze + Kr;
    Yr.translateTo(Jr, typeof Gr > "u" ? 0 : Gr),
      Yr.updateActiveIndex(),
      Yr.updateSlidesClasses();
  }
  emitContainerClasses() {
    const ze = this;
    if (!ze.params._emitClasses || !ze.el) return;
    const Gr = ze.el.className
      .split(" ")
      .filter(
        (Yr) =>
          Yr.indexOf("swiper") === 0 ||
          Yr.indexOf(ze.params.containerModifierClass) === 0
      );
    ze.emit("_containerClasses", Gr.join(" "));
  }
  getSlideClasses(ze) {
    const Gr = this;
    return Gr.destroyed
      ? ""
      : ze.className
          .split(" ")
          .filter(
            (Yr) =>
              Yr.indexOf("swiper-slide") === 0 ||
              Yr.indexOf(Gr.params.slideClass) === 0
          )
          .join(" ");
  }
  emitSlidesClasses() {
    const ze = this;
    if (!ze.params._emitClasses || !ze.el) return;
    const Gr = [];
    ze.slides.forEach((Yr) => {
      const Kr = ze.getSlideClasses(Yr);
      Gr.push({
        slideEl: Yr,
        classNames: Kr,
      }),
        ze.emit("_slideClass", Yr, Kr);
    }),
      ze.emit("_slideClasses", Gr);
  }
  slidesPerViewDynamic(ze, Gr) {
    ze === void 0 && (ze = "current"), Gr === void 0 && (Gr = !1);
    const Yr = this,
      {
        params: Kr,
        slides: Zr,
        slidesGrid: Jr,
        slidesSizesGrid: Qr,
        size: ei,
        activeIndex: ti,
      } = Yr;
    let ri = 1;
    if (typeof Kr.slidesPerView == "number") return Kr.slidesPerView;
    if (Kr.centeredSlides) {
      let ni = Zr[ti] ? Zr[ti].swiperSlideSize : 0,
        ii;
      for (let si = ti + 1; si < Zr.length; si += 1)
        Zr[si] &&
          !ii &&
          ((ni += Zr[si].swiperSlideSize), (ri += 1), ni > ei && (ii = !0));
      for (let si = ti - 1; si >= 0; si -= 1)
        Zr[si] &&
          !ii &&
          ((ni += Zr[si].swiperSlideSize), (ri += 1), ni > ei && (ii = !0));
    } else if (ze === "current")
      for (let ni = ti + 1; ni < Zr.length; ni += 1)
        (Gr ? Jr[ni] + Qr[ni] - Jr[ti] < ei : Jr[ni] - Jr[ti] < ei) &&
          (ri += 1);
    else
      for (let ni = ti - 1; ni >= 0; ni -= 1) Jr[ti] - Jr[ni] < ei && (ri += 1);
    return ri;
  }
  update() {
    const ze = this;
    if (!ze || ze.destroyed) return;
    const { snapGrid: Gr, params: Yr } = ze;
    Yr.breakpoints && ze.setBreakpoint(),
      [...ze.el.querySelectorAll('[loading="lazy"]')].forEach((Jr) => {
        Jr.complete && processLazyPreloader(ze, Jr);
      }),
      ze.updateSize(),
      ze.updateSlides(),
      ze.updateProgress(),
      ze.updateSlidesClasses();
    function Kr() {
      const Jr = ze.rtlTranslate ? ze.translate * -1 : ze.translate,
        Qr = Math.min(Math.max(Jr, ze.maxTranslate()), ze.minTranslate());
      ze.setTranslate(Qr), ze.updateActiveIndex(), ze.updateSlidesClasses();
    }
    let Zr;
    if (Yr.freeMode && Yr.freeMode.enabled && !Yr.cssMode)
      Kr(), Yr.autoHeight && ze.updateAutoHeight();
    else {
      if (
        (Yr.slidesPerView === "auto" || Yr.slidesPerView > 1) &&
        ze.isEnd &&
        !Yr.centeredSlides
      ) {
        const Jr =
          ze.virtual && Yr.virtual.enabled ? ze.virtual.slides : ze.slides;
        Zr = ze.slideTo(Jr.length - 1, 0, !1, !0);
      } else Zr = ze.slideTo(ze.activeIndex, 0, !1, !0);
      Zr || Kr();
    }
    Yr.watchOverflow && Gr !== ze.snapGrid && ze.checkOverflow(),
      ze.emit("update");
  }
  changeDirection(ze, Gr) {
    Gr === void 0 && (Gr = !0);
    const Yr = this,
      Kr = Yr.params.direction;
    return (
      ze || (ze = Kr === "horizontal" ? "vertical" : "horizontal"),
      ze === Kr ||
        (ze !== "horizontal" && ze !== "vertical") ||
        (Yr.el.classList.remove(`${Yr.params.containerModifierClass}${Kr}`),
        Yr.el.classList.add(`${Yr.params.containerModifierClass}${ze}`),
        Yr.emitContainerClasses(),
        (Yr.params.direction = ze),
        Yr.slides.forEach((Zr) => {
          ze === "vertical" ? (Zr.style.width = "") : (Zr.style.height = "");
        }),
        Yr.emit("changeDirection"),
        Gr && Yr.update()),
      Yr
    );
  }
  changeLanguageDirection(ze) {
    const Gr = this;
    (Gr.rtl && ze === "rtl") ||
      (!Gr.rtl && ze === "ltr") ||
      ((Gr.rtl = ze === "rtl"),
      (Gr.rtlTranslate = Gr.params.direction === "horizontal" && Gr.rtl),
      Gr.rtl
        ? (Gr.el.classList.add(`${Gr.params.containerModifierClass}rtl`),
          (Gr.el.dir = "rtl"))
        : (Gr.el.classList.remove(`${Gr.params.containerModifierClass}rtl`),
          (Gr.el.dir = "ltr")),
      Gr.update());
  }
  mount(ze) {
    const Gr = this;
    if (Gr.mounted) return !0;
    let Yr = ze || Gr.params.el;
    if ((typeof Yr == "string" && (Yr = document.querySelector(Yr)), !Yr))
      return !1;
    (Yr.swiper = Gr),
      Yr.parentNode &&
        Yr.parentNode.host &&
        Yr.parentNode.host.nodeName === "SWIPER-CONTAINER" &&
        (Gr.isElement = !0);
    const Kr = () =>
      `.${(Gr.params.wrapperClass || "").trim().split(" ").join(".")}`;
    let Jr = (() =>
      Yr && Yr.shadowRoot && Yr.shadowRoot.querySelector
        ? Yr.shadowRoot.querySelector(Kr())
        : elementChildren(Yr, Kr())[0])();
    return (
      !Jr &&
        Gr.params.createElements &&
        ((Jr = createElement("div", Gr.params.wrapperClass)),
        Yr.append(Jr),
        elementChildren(Yr, `.${Gr.params.slideClass}`).forEach((Qr) => {
          Jr.append(Qr);
        })),
      Object.assign(Gr, {
        el: Yr,
        wrapperEl: Jr,
        slidesEl:
          Gr.isElement && !Yr.parentNode.host.slideSlots
            ? Yr.parentNode.host
            : Jr,
        hostEl: Gr.isElement ? Yr.parentNode.host : Yr,
        mounted: !0,
        rtl:
          Yr.dir.toLowerCase() === "rtl" ||
          elementStyle(Yr, "direction") === "rtl",
        rtlTranslate:
          Gr.params.direction === "horizontal" &&
          (Yr.dir.toLowerCase() === "rtl" ||
            elementStyle(Yr, "direction") === "rtl"),
        wrongRTL: elementStyle(Jr, "display") === "-webkit-box",
      }),
      !0
    );
  }
  init(ze) {
    const Gr = this;
    if (Gr.initialized || Gr.mount(ze) === !1) return Gr;
    Gr.emit("beforeInit"),
      Gr.params.breakpoints && Gr.setBreakpoint(),
      Gr.addClasses(),
      Gr.updateSize(),
      Gr.updateSlides(),
      Gr.params.watchOverflow && Gr.checkOverflow(),
      Gr.params.grabCursor && Gr.enabled && Gr.setGrabCursor(),
      Gr.params.loop && Gr.virtual && Gr.params.virtual.enabled
        ? Gr.slideTo(
            Gr.params.initialSlide + Gr.virtual.slidesBefore,
            0,
            Gr.params.runCallbacksOnInit,
            !1,
            !0
          )
        : Gr.slideTo(
            Gr.params.initialSlide,
            0,
            Gr.params.runCallbacksOnInit,
            !1,
            !0
          ),
      Gr.params.loop && Gr.loopCreate(),
      Gr.attachEvents();
    const Kr = [...Gr.el.querySelectorAll('[loading="lazy"]')];
    return (
      Gr.isElement &&
        Kr.push(...Gr.hostEl.querySelectorAll('[loading="lazy"]')),
      Kr.forEach((Zr) => {
        Zr.complete
          ? processLazyPreloader(Gr, Zr)
          : Zr.addEventListener("load", (Jr) => {
              processLazyPreloader(Gr, Jr.target);
            });
      }),
      preload(Gr),
      (Gr.initialized = !0),
      preload(Gr),
      Gr.emit("init"),
      Gr.emit("afterInit"),
      Gr
    );
  }
  destroy(ze, Gr) {
    ze === void 0 && (ze = !0), Gr === void 0 && (Gr = !0);
    const Yr = this,
      { params: Kr, el: Zr, wrapperEl: Jr, slides: Qr } = Yr;
    return (
      typeof Yr.params > "u" ||
        Yr.destroyed ||
        (Yr.emit("beforeDestroy"),
        (Yr.initialized = !1),
        Yr.detachEvents(),
        Kr.loop && Yr.loopDestroy(),
        Gr &&
          (Yr.removeClasses(),
          Zr.removeAttribute("style"),
          Jr.removeAttribute("style"),
          Qr &&
            Qr.length &&
            Qr.forEach((ei) => {
              ei.classList.remove(
                Kr.slideVisibleClass,
                Kr.slideFullyVisibleClass,
                Kr.slideActiveClass,
                Kr.slideNextClass,
                Kr.slidePrevClass
              ),
                ei.removeAttribute("style"),
                ei.removeAttribute("data-swiper-slide-index");
            })),
        Yr.emit("destroy"),
        Object.keys(Yr.eventsListeners).forEach((ei) => {
          Yr.off(ei);
        }),
        ze !== !1 && ((Yr.el.swiper = null), deleteProps(Yr)),
        (Yr.destroyed = !0)),
      null
    );
  }
  static extendDefaults(ze) {
    extend(extendedDefaults, ze);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(ze) {
    Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []);
    const Gr = Swiper.prototype.__modules__;
    typeof ze == "function" && Gr.indexOf(ze) < 0 && Gr.push(ze);
  }
  static use(ze) {
    return Array.isArray(ze)
      ? (ze.forEach((Gr) => Swiper.installModule(Gr)), Swiper)
      : (Swiper.installModule(ze), Swiper);
  }
}
Object.keys(prototypes).forEach((Wr) => {
  Object.keys(prototypes[Wr]).forEach((ze) => {
    Swiper.prototype[ze] = prototypes[Wr][ze];
  });
});
Swiper.use([Resize, Observer]);
const swiper = "",
  gallery = (Wr) => {
    Wr.querySelectorAll(".js-gallery-swiper").forEach((Gr) => {
      new Swiper(Gr, {
        slidesPerView: "auto",
        spaceBetween: 4,
        centeredSlides: !0,
        breakpoints: {
          480: {
            centeredSlides: !1,
            spaceBetween: 4,
          },
        },
      });
    });
  };
var n = function () {
  return (
    (n =
      Object.assign ||
      function (Wr) {
        for (var ze, Gr = 1, Yr = arguments.length; Gr < Yr; Gr++)
          for (var Kr in (ze = arguments[Gr]))
            Object.prototype.hasOwnProperty.call(ze, Kr) && (Wr[Kr] = ze[Kr]);
        return Wr;
      }),
    n.apply(this, arguments)
  );
};
function t$1(Wr, ze, Gr) {
  if (Gr || arguments.length === 2)
    for (var Yr, Kr = 0, Zr = ze.length; Kr < Zr; Kr++)
      (!Yr && Kr in ze) ||
        (Yr || (Yr = Array.prototype.slice.call(ze, 0, Kr)), (Yr[Kr] = ze[Kr]));
  return Wr.concat(Yr || Array.prototype.slice.call(ze));
}
function i(Wr) {
  return Array.prototype.slice.call(Wr);
}
function e(Wr, ze) {
  var Gr = Math.floor(Wr);
  return Gr === ze || Gr + 1 === ze ? Wr : ze;
}
function r() {
  return Date.now();
}
function a(Wr, ze, Gr) {
  if (((ze = "data-keen-slider-" + ze), Gr === null))
    return Wr.removeAttribute(ze);
  Wr.setAttribute(ze, Gr || "");
}
function o(Wr, ze) {
  return (
    (ze = ze || document),
    typeof Wr == "function" && (Wr = Wr(ze)),
    Array.isArray(Wr)
      ? Wr
      : typeof Wr == "string"
      ? i(ze.querySelectorAll(Wr))
      : Wr instanceof HTMLElement
      ? [Wr]
      : Wr instanceof NodeList
      ? i(Wr)
      : []
  );
}
function u(Wr) {
  Wr.raw && (Wr = Wr.raw),
    Wr.cancelable && !Wr.defaultPrevented && Wr.preventDefault();
}
function s(Wr) {
  Wr.raw && (Wr = Wr.raw), Wr.stopPropagation && Wr.stopPropagation();
}
function c() {
  var Wr = [];
  return {
    add: function (ze, Gr, Yr, Kr) {
      ze.addListener ? ze.addListener(Yr) : ze.addEventListener(Gr, Yr, Kr),
        Wr.push([ze, Gr, Yr, Kr]);
    },
    input: function (ze, Gr, Yr, Kr) {
      this.add(
        ze,
        Gr,
        (function (Zr) {
          return function (Jr) {
            Jr.nativeEvent && (Jr = Jr.nativeEvent);
            var Qr = Jr.changedTouches || [],
              ei = Jr.targetTouches || [],
              ti = Jr.detail && Jr.detail.x ? Jr.detail : null;
            return Zr({
              id: ti
                ? ti.identifier
                  ? ti.identifier
                  : "i"
                : ei[0]
                ? ei[0]
                  ? ei[0].identifier
                  : "e"
                : "d",
              idChanged: ti
                ? ti.identifier
                  ? ti.identifier
                  : "i"
                : Qr[0]
                ? Qr[0]
                  ? Qr[0].identifier
                  : "e"
                : "d",
              raw: Jr,
              x:
                ti && ti.x
                  ? ti.x
                  : ei[0]
                  ? ei[0].screenX
                  : ti
                  ? ti.x
                  : Jr.pageX,
              y:
                ti && ti.y
                  ? ti.y
                  : ei[0]
                  ? ei[0].screenY
                  : ti
                  ? ti.y
                  : Jr.pageY,
            });
          };
        })(Yr),
        Kr
      );
    },
    purge: function () {
      Wr.forEach(function (ze) {
        ze[0].removeListener
          ? ze[0].removeListener(ze[2])
          : ze[0].removeEventListener(ze[1], ze[2], ze[3]);
      }),
        (Wr = []);
    },
  };
}
function d(Wr, ze, Gr) {
  return Math.min(Math.max(Wr, ze), Gr);
}
function l(Wr) {
  return (Wr > 0 ? 1 : 0) - (Wr < 0 ? 1 : 0) || +Wr;
}
function f(Wr) {
  var ze = Wr.getBoundingClientRect();
  return {
    height: e(ze.height, Wr.offsetHeight),
    width: e(ze.width, Wr.offsetWidth),
  };
}
function p(Wr, ze, Gr, Yr) {
  var Kr = Wr && Wr[ze];
  return Kr == null ? Gr : Yr && typeof Kr == "function" ? Kr() : Kr;
}
function v(Wr) {
  return Math.round(1e6 * Wr) / 1e6;
}
function h(Wr) {
  var ze, Gr, Yr, Kr, Zr, Jr;
  function Qr(ii) {
    Jr || (Jr = ii), ei(!0);
    var si = ii - Jr;
    si > Yr && (si = Yr);
    var li = Kr[Gr];
    if (li[3] < si) return Gr++, Qr(ii);
    var oi = li[2],
      ui = li[4],
      ai = li[0],
      hi = li[1] * (0, li[5])(ui === 0 ? 1 : (si - oi) / ui);
    if ((hi && Wr.track.to(ai + hi), si < Yr)) return ri();
    (Jr = null), ei(!1), ti(null), Wr.emit("animationEnded");
  }
  function ei(ii) {
    ze.active = ii;
  }
  function ti(ii) {
    ze.targetIdx = ii;
  }
  function ri() {
    var ii;
    (ii = Qr), (Zr = window.requestAnimationFrame(ii));
  }
  function ni() {
    var ii;
    (ii = Zr),
      window.cancelAnimationFrame(ii),
      ei(!1),
      ti(null),
      Jr && Wr.emit("animationStopped"),
      (Jr = null);
  }
  return (ze = {
    active: !1,
    start: function (ii) {
      if ((ni(), Wr.track.details)) {
        var si = 0,
          li = Wr.track.details.position;
        (Gr = 0),
          (Yr = 0),
          (Kr = ii.map(function (oi) {
            var ui,
              ai = Number(li),
              hi =
                (ui = oi.earlyExit) !== null && ui !== void 0
                  ? ui
                  : oi.duration,
              ci = oi.easing,
              fi = oi.distance * ci(hi / oi.duration) || 0;
            li += fi;
            var di = Yr;
            return (
              (Yr += hi), (si += fi), [ai, oi.distance, di, Yr, oi.duration, ci]
            );
          })),
          ti(Wr.track.distToIdx(si)),
          ri(),
          Wr.emit("animationStarted");
      }
    },
    stop: ni,
    targetIdx: null,
  });
}
function m(Wr) {
  var ze,
    Gr,
    Yr,
    Kr,
    Zr,
    Jr,
    Qr,
    ei,
    ti,
    ri,
    ni,
    ii,
    si,
    li,
    oi = 1 / 0,
    ui = [],
    ai = null,
    hi = 0;
  function ci(wi) {
    Ai(hi + wi);
  }
  function fi(wi) {
    var Ci = di(hi + wi).abs;
    return Si(Ci) ? Ci : null;
  }
  function di(wi) {
    var Ci = Math.floor(Math.abs(v(wi / Gr))),
      bi = v(((wi % Gr) + Gr) % Gr);
    bi === Gr && (bi = 0);
    var Mi = l(wi),
      gi = Qr.indexOf(
        t$1([], Qr, !0).reduce(function (Ti, vi) {
          return Math.abs(vi - bi) < Math.abs(Ti - bi) ? vi : Ti;
        })
      ),
      xi = gi;
    return (
      Mi < 0 && Ci++,
      gi === Jr && ((xi = 0), (Ci += Mi > 0 ? 1 : -1)),
      {
        abs: xi + Ci * Jr * Mi,
        origin: gi,
        rel: xi,
      }
    );
  }
  function pi(wi, Ci, bi) {
    var Mi;
    if (Ci || !Ei()) return mi(wi, bi);
    if (!Si(wi)) return null;
    var gi = di(bi != null ? bi : hi),
      xi = gi.abs,
      Ti = wi - gi.rel,
      vi = xi + Ti;
    Mi = mi(vi);
    var Ii = mi(vi - Jr * l(Ti));
    return (
      ((Ii !== null && Math.abs(Ii) < Math.abs(Mi)) || Mi === null) &&
        (Mi = Ii),
      v(Mi)
    );
  }
  function mi(wi, Ci) {
    if ((Ci == null && (Ci = v(hi)), !Si(wi) || wi === null)) return null;
    wi = Math.round(wi);
    var bi = di(Ci),
      Mi = bi.abs,
      gi = bi.rel,
      xi = bi.origin,
      Ti = Pi(wi),
      vi = ((Ci % Gr) + Gr) % Gr,
      Ii = Qr[xi],
      Oi = Math.floor((wi - (Mi - gi)) / Jr) * Gr;
    return v(Ii - vi - Ii + Qr[Ti] + Oi + (xi === Jr ? Gr : 0));
  }
  function Si(wi) {
    return yi(wi) === wi;
  }
  function yi(wi) {
    return d(wi, ti, ri);
  }
  function Ei() {
    return Kr.loop;
  }
  function Pi(wi) {
    return ((wi % Jr) + Jr) % Jr;
  }
  function Ai(wi) {
    var Ci;
    (Ci = wi - hi),
      ui.push({
        distance: Ci,
        timestamp: r(),
      }),
      ui.length > 6 && (ui = ui.slice(-6)),
      (hi = v(wi));
    var bi = Ri().abs;
    if (bi !== ai) {
      var Mi = ai !== null;
      (ai = bi), Mi && Wr.emit("slideChanged");
    }
  }
  function Ri(wi) {
    var Ci = wi
      ? null
      : (function () {
          if (Jr) {
            var bi = Ei(),
              Mi = bi ? ((hi % Gr) + Gr) % Gr : hi,
              gi = (bi ? hi % Gr : hi) - Zr[0][2],
              xi = 0 - (gi < 0 && bi ? Gr - Math.abs(gi) : gi),
              Ti = 0,
              vi = di(hi),
              Ii = vi.abs,
              Oi = vi.rel,
              ki = Zr[Oi][2],
              Bi = Zr.map(function (Xi, an) {
                var Qi = xi + Ti;
                (Qi < 0 - Xi[0] || Qi > 1) &&
                  (Qi += (Math.abs(Qi) > Gr - 1 && bi ? Gr : 0) * l(-Qi));
                var ln = an - Oi,
                  yn = l(ln),
                  un = ln + Ii;
                bi &&
                  (yn === -1 && Qi > ki && (un += Jr),
                  yn === 1 && Qi < ki && (un -= Jr),
                  ni !== null && un < ni && (Qi += Gr),
                  ii !== null && un > ii && (Qi -= Gr));
                var Vi = Qi + Xi[0] + Xi[1],
                  rn = Math.max(
                    Qi >= 0 && Vi <= 1
                      ? 1
                      : Vi < 0 || Qi > 1
                      ? 0
                      : Qi < 0
                      ? Math.min(1, (Xi[0] + Qi) / Xi[0])
                      : (1 - Qi) / Xi[0],
                    0
                  );
                return (
                  (Ti += Xi[0] + Xi[1]),
                  {
                    abs: un,
                    distance: Kr.rtl ? -1 * Qi + 1 - Xi[0] : Qi,
                    portion: rn,
                    size: Xi[0],
                  }
                );
              });
            return (
              (Ii = yi(Ii)),
              (Oi = Pi(Ii)),
              {
                abs: yi(Ii),
                length: Yr,
                max: li,
                maxIdx: ri,
                min: si,
                minIdx: ti,
                position: hi,
                progress: bi ? Mi / Gr : hi / Yr,
                rel: Oi,
                slides: Bi,
                slidesLength: Gr,
              }
            );
          }
        })();
    return (ze.details = Ci), Wr.emit("detailsChanged"), Ci;
  }
  return (ze = {
    absToRel: Pi,
    add: ci,
    details: null,
    distToIdx: fi,
    idxToDist: pi,
    init: function (wi) {
      if (
        ((function () {
          if (
            ((Kr = Wr.options),
            (Zr = (Kr.trackConfig || []).map(function (gi) {
              return [
                p(gi, "size", 1),
                p(gi, "spacing", 0),
                p(gi, "origin", 0),
              ];
            })),
            (Jr = Zr.length))
          ) {
            Gr = v(
              Zr.reduce(function (gi, xi) {
                return gi + xi[0] + xi[1];
              }, 0)
            );
            var bi,
              Mi = Jr - 1;
            (Yr = v(Gr + Zr[0][2] - Zr[Mi][0] - Zr[Mi][2] - Zr[Mi][1])),
              (Qr = Zr.reduce(function (gi, xi) {
                if (!gi) return [0];
                var Ti = Zr[gi.length - 1],
                  vi = gi[gi.length - 1] + (Ti[0] + Ti[2]) + Ti[1];
                return (
                  (vi -= xi[2]),
                  gi[gi.length - 1] > vi && (vi = gi[gi.length - 1]),
                  (vi = v(vi)),
                  gi.push(vi),
                  (!bi || bi < vi) && (ei = gi.length - 1),
                  (bi = vi),
                  gi
                );
              }, null)),
              Yr === 0 && (ei = 0),
              Qr.push(v(Gr));
          }
        })(),
        !Jr)
      )
        return Ri(!0);
      var Ci;
      (function () {
        var bi = Wr.options.range,
          Mi = Wr.options.loop;
        (ni = ti = Mi ? p(Mi, "min", -1 / 0) : 0),
          (ii = ri = Mi ? p(Mi, "max", oi) : ei);
        var gi = p(bi, "min", null),
          xi = p(bi, "max", null);
        gi !== null && (ti = gi),
          xi !== null && (ri = xi),
          (si = ti === -1 / 0 ? ti : Wr.track.idxToDist(ti || 0, !0, 0)),
          (li = ri === oi ? ri : pi(ri, !0, 0)),
          xi === null && (ii = ri),
          p(bi, "align", !1) &&
            ri !== oi &&
            Zr[Pi(ri)][2] === 0 &&
            ((li -= 1 - Zr[Pi(ri)][0]), (ri = fi(li - hi))),
          (si = v(si)),
          (li = v(li));
      })(),
        (Ci = wi),
        Number(Ci) === Ci ? ci(mi(yi(wi))) : Ri();
    },
    to: Ai,
    velocity: function () {
      var wi = r(),
        Ci = ui.reduce(
          function (bi, Mi) {
            var gi = Mi.distance,
              xi = Mi.timestamp;
            return (
              wi - xi > 200 ||
                (l(gi) !== l(bi.distance) &&
                  bi.distance &&
                  (bi = {
                    distance: 0,
                    lastTimestamp: 0,
                    time: 0,
                  }),
                bi.time && (bi.distance += gi),
                bi.lastTimestamp && (bi.time += xi - bi.lastTimestamp),
                (bi.lastTimestamp = xi)),
              bi
            );
          },
          {
            distance: 0,
            lastTimestamp: 0,
            time: 0,
          }
        );
      return Ci.distance / Ci.time || 0;
    },
  });
}
function g(Wr) {
  var ze, Gr, Yr, Kr, Zr, Jr, Qr, ei;
  function ti(ai) {
    return 2 * ai;
  }
  function ri(ai) {
    return d(ai, Qr, ei);
  }
  function ni(ai) {
    return 1 - Math.pow(1 - ai, 3);
  }
  function ii() {
    return Yr ? Wr.track.velocity() : 0;
  }
  function si() {
    ui();
    var ai = Wr.options.mode === "free-snap",
      hi = Wr.track,
      ci = ii();
    Kr = l(ci);
    var fi = Wr.track.details,
      di = [];
    if (ci || !ai) {
      var pi = li(ci),
        mi = pi.dist,
        Si = pi.dur;
      if (((Si = ti(Si)), (mi *= Kr), ai)) {
        var yi = hi.idxToDist(hi.distToIdx(mi), !0);
        yi && (mi = yi);
      }
      di.push({
        distance: mi,
        duration: Si,
        easing: ni,
      });
      var Ei = fi.position,
        Pi = Ei + mi;
      if (Pi < Zr || Pi > Jr) {
        var Ai = Pi < Zr ? Zr - Ei : Jr - Ei,
          Ri = 0,
          wi = ci;
        if (l(Ai) === Kr) {
          var Ci = Math.min(Math.abs(Ai) / Math.abs(mi), 1),
            bi =
              (function (xi) {
                return 1 - Math.pow(1 - xi, 1 / 3);
              })(Ci) * Si;
          (di[0].earlyExit = bi), (wi = ci * (1 - Ci));
        } else (di[0].earlyExit = 0), (Ri += Ai);
        var Mi = li(wi, 100),
          gi = Mi.dist * Kr;
        Wr.options.rubberband &&
          (di.push({
            distance: gi,
            duration: ti(Mi.dur),
            easing: ni,
          }),
          di.push({
            distance: -gi + Ri,
            duration: 500,
            easing: ni,
          }));
      }
      Wr.animator.start(di);
    } else
      Wr.moveToIdx(ri(fi.abs), !0, {
        duration: 500,
        easing: function (xi) {
          return 1 + --xi * xi * xi * xi * xi;
        },
      });
  }
  function li(ai, hi) {
    hi === void 0 && (hi = 1e3);
    var ci = 147e-9 + (ai = Math.abs(ai)) / hi;
    return {
      dist: Math.pow(ai, 2) / ci,
      dur: ai / ci,
    };
  }
  function oi() {
    var ai = Wr.track.details;
    ai && ((Zr = ai.min), (Jr = ai.max), (Qr = ai.minIdx), (ei = ai.maxIdx));
  }
  function ui() {
    Wr.animator.stop();
  }
  Wr.on("updated", oi),
    Wr.on("optionsChanged", oi),
    Wr.on("created", oi),
    Wr.on("dragStarted", function () {
      (Yr = !1), ui(), (ze = Gr = Wr.track.details.abs);
    }),
    Wr.on("dragChecked", function () {
      Yr = !0;
    }),
    Wr.on("dragEnded", function () {
      var ai = Wr.options.mode;
      ai === "snap" &&
        (function () {
          var hi = Wr.track,
            ci = Wr.track.details,
            fi = ci.position,
            di = l(ii());
          (fi > Jr || fi < Zr) && (di = 0);
          var pi = ze + di;
          ci.slides[hi.absToRel(pi)].portion === 0 && (pi -= di),
            ze !== Gr && (pi = Gr),
            l(hi.idxToDist(pi, !0)) !== di && (pi += di),
            (pi = ri(pi));
          var mi = hi.idxToDist(pi, !0);
          Wr.animator.start([
            {
              distance: mi,
              duration: 500,
              easing: function (Si) {
                return 1 + --Si * Si * Si * Si * Si;
              },
            },
          ]);
        })(),
        (ai !== "free" && ai !== "free-snap") || si();
    }),
    Wr.on("dragged", function () {
      Gr = Wr.track.details.abs;
    });
}
function b(Wr) {
  var ze,
    Gr,
    Yr,
    Kr,
    Zr,
    Jr,
    Qr,
    ei,
    ti,
    ri,
    ni,
    ii,
    si,
    li,
    oi,
    ui,
    ai,
    hi,
    ci = c();
  function fi(Ri) {
    if (Jr && ei === Ri.id) {
      var wi = Si(Ri);
      if (ti) {
        if (!mi(Ri)) return pi(Ri);
        (ri = wi), (ti = !1), Wr.emit("dragChecked");
      }
      if (ui) return (ri = wi);
      u(Ri);
      var Ci = (function (Mi) {
        if (ai === -1 / 0 && hi === 1 / 0) return Mi;
        var gi = Wr.track.details,
          xi = gi.length,
          Ti = gi.position,
          vi = d(Mi, ai - Ti, hi - Ti);
        if (xi === 0) return 0;
        if (!Wr.options.rubberband) return vi;
        if (
          (Ti <= hi && Ti >= ai) ||
          (Ti < ai && Gr > 0) ||
          (Ti > hi && Gr < 0)
        )
          return Mi;
        var Ii = (Ti < ai ? Ti - ai : Ti - hi) / xi,
          Oi = Kr * xi,
          ki = Math.abs(Ii * Oi),
          Bi = Math.max(0, 1 - (ki / Zr) * 2);
        return Bi * Bi * Mi;
      })((Qr(ri - wi) / Kr) * Yr);
      Gr = l(Ci);
      var bi = Wr.track.details.position;
      ((bi > ai && bi < hi) ||
        (bi === ai && Gr > 0) ||
        (bi === hi && Gr < 0)) &&
        s(Ri),
        (ni += Ci),
        !ii && Math.abs(ni * Kr) > 5 && (ii = !0),
        Wr.track.add(Ci),
        (ri = wi),
        Wr.emit("dragged");
    }
  }
  function di(Ri) {
    !Jr &&
      Wr.track.details &&
      Wr.track.details.length &&
      ((ni = 0),
      (Jr = !0),
      (ii = !1),
      (ti = !0),
      (ei = Ri.id),
      mi(Ri),
      (ri = Si(Ri)),
      Wr.emit("dragStarted"));
  }
  function pi(Ri) {
    Jr && ei === Ri.idChanged && ((Jr = !1), Wr.emit("dragEnded"));
  }
  function mi(Ri) {
    var wi = yi(),
      Ci = wi ? Ri.y : Ri.x,
      bi = wi ? Ri.x : Ri.y,
      Mi =
        si !== void 0 &&
        li !== void 0 &&
        Math.abs(li - bi) <= Math.abs(si - Ci);
    return (si = Ci), (li = bi), Mi;
  }
  function Si(Ri) {
    return yi() ? Ri.y : Ri.x;
  }
  function yi() {
    return Wr.options.vertical;
  }
  function Ei() {
    (Kr = Wr.size), (Zr = yi() ? window.innerHeight : window.innerWidth);
    var Ri = Wr.track.details;
    Ri && ((ai = Ri.min), (hi = Ri.max));
  }
  function Pi(Ri) {
    ii && (s(Ri), u(Ri));
  }
  function Ai() {
    if ((ci.purge(), Wr.options.drag && !Wr.options.disabled)) {
      var Ri;
      (Ri = Wr.options.dragSpeed || 1),
        (Qr =
          typeof Ri == "function"
            ? Ri
            : function (Ci) {
                return Ci * Ri;
              }),
        (Yr = Wr.options.rtl ? -1 : 1),
        Ei(),
        (ze = Wr.container),
        (function () {
          var Ci = "data-keen-slider-clickable";
          o("[".concat(Ci, "]:not([").concat(Ci, "=false])"), ze).map(function (
            bi
          ) {
            ci.add(bi, "dragstart", s),
              ci.add(bi, "mousedown", s),
              ci.add(bi, "touchstart", s);
          });
        })(),
        ci.add(ze, "dragstart", function (Ci) {
          u(Ci);
        }),
        ci.add(ze, "click", Pi, {
          capture: !0,
        }),
        ci.input(ze, "ksDragStart", di),
        ci.input(ze, "ksDrag", fi),
        ci.input(ze, "ksDragEnd", pi),
        ci.input(ze, "mousedown", di),
        ci.input(ze, "mousemove", fi),
        ci.input(ze, "mouseleave", pi),
        ci.input(ze, "mouseup", pi),
        ci.input(ze, "touchstart", di, {
          passive: !0,
        }),
        ci.input(ze, "touchmove", fi, {
          passive: !1,
        }),
        ci.input(ze, "touchend", pi),
        ci.input(ze, "touchcancel", pi),
        ci.add(window, "wheel", function (Ci) {
          Jr && u(Ci);
        });
      var wi = "data-keen-slider-scrollable";
      o("[".concat(wi, "]:not([").concat(wi, "=false])"), Wr.container).map(
        function (Ci) {
          return (function (bi) {
            var Mi;
            ci.input(
              bi,
              "touchstart",
              function (gi) {
                (Mi = Si(gi)), (ui = !0), (oi = !0);
              },
              {
                passive: !0,
              }
            ),
              ci.input(bi, "touchmove", function (gi) {
                var xi = yi(),
                  Ti = xi
                    ? bi.scrollHeight - bi.clientHeight
                    : bi.scrollWidth - bi.clientWidth,
                  vi = Mi - Si(gi),
                  Ii = xi ? bi.scrollTop : bi.scrollLeft,
                  Oi =
                    (xi && bi.style.overflowY === "scroll") ||
                    (!xi && bi.style.overflowX === "scroll");
                if (
                  ((Mi = Si(gi)),
                  ((vi < 0 && Ii > 0) || (vi > 0 && Ii < Ti)) && oi && Oi)
                )
                  return (ui = !0);
                (oi = !1), u(gi), (ui = !1);
              }),
              ci.input(bi, "touchend", function () {
                ui = !1;
              });
          })(Ci);
        }
      );
    }
  }
  Wr.on("updated", Ei),
    Wr.on("optionsChanged", Ai),
    Wr.on("created", Ai),
    Wr.on("destroyed", ci.purge);
}
function x(Wr) {
  var ze,
    Gr,
    Yr = null;
  function Kr(si, li, oi) {
    Wr.animator.active
      ? Jr(si, li, oi)
      : requestAnimationFrame(function () {
          return Jr(si, li, oi);
        });
  }
  function Zr() {
    Kr(!1, !1, Gr);
  }
  function Jr(si, li, oi) {
    var ui = 0,
      ai = Wr.size,
      hi = Wr.track.details;
    if (hi && ze) {
      var ci = hi.slides;
      ze.forEach(function (fi, di) {
        if (si) !Yr && li && ei(fi, null, oi), ti(fi, null, oi);
        else {
          if (!ci[di]) return;
          var pi = ci[di].size * ai;
          !Yr && li && ei(fi, pi, oi),
            ti(fi, ci[di].distance * ai - ui, oi),
            (ui += pi);
        }
      });
    }
  }
  function Qr(si) {
    return Wr.options.renderMode === "performance" ? Math.round(si) : si;
  }
  function ei(si, li, oi) {
    var ui = oi ? "height" : "width";
    li !== null && (li = Qr(li) + "px"),
      (si.style["min-" + ui] = li),
      (si.style["max-" + ui] = li);
  }
  function ti(si, li, oi) {
    if (li !== null) {
      li = Qr(li);
      var ui = oi ? li : 0;
      li = "translate3d(".concat(oi ? 0 : li, "px, ").concat(ui, "px, 0)");
    }
    (si.style.transform = li), (si.style["-webkit-transform"] = li);
  }
  function ri() {
    ze && (Jr(!0, !0, Gr), (ze = null)), Wr.on("detailsChanged", Zr, !0);
  }
  function ni() {
    Kr(!1, !0, Gr);
  }
  function ii() {
    ri(),
      (Gr = Wr.options.vertical),
      Wr.options.disabled ||
        Wr.options.renderMode === "custom" ||
        ((Yr = p(Wr.options.slides, "perView", null) === "auto"),
        Wr.on("detailsChanged", Zr),
        (ze = Wr.slides).length && ni());
  }
  Wr.on("created", ii),
    Wr.on("optionsChanged", ii),
    Wr.on("beforeOptionsChanged", function () {
      ri();
    }),
    Wr.on("updated", ni),
    Wr.on("destroyed", ri);
}
function k(Wr, ze) {
  return function (Gr) {
    var Yr,
      Kr,
      Zr,
      Jr,
      Qr,
      ei = c();
    function ti(mi) {
      var Si;
      a(
        Gr.container,
        "reverse",
        ((Si = Gr.container),
        window.getComputedStyle(Si, null).getPropertyValue("direction") !==
          "rtl" || mi
          ? null
          : "")
      ),
        a(Gr.container, "v", Gr.options.vertical && !mi ? "" : null),
        a(Gr.container, "disabled", Gr.options.disabled && !mi ? "" : null);
    }
    function ri() {
      ni() && ui();
    }
    function ni() {
      var mi = null;
      if (
        (Jr.forEach(function (yi) {
          yi.matches && (mi = yi.__media);
        }),
        mi === Yr)
      )
        return !1;
      Yr || Gr.emit("beforeOptionsChanged"), (Yr = mi);
      var Si = mi ? Zr.breakpoints[mi] : Zr;
      return (Gr.options = n(n({}, Zr), Si)), ti(), di(), pi(), hi(), !0;
    }
    function ii(mi) {
      var Si = f(mi);
      return (Gr.options.vertical ? Si.height : Si.width) / Gr.size || 1;
    }
    function si() {
      return Gr.options.trackConfig.length;
    }
    function li(mi) {
      for (var Si in ((Yr = !1),
      (Zr = n(n({}, ze), mi)),
      ei.purge(),
      (Kr = Gr.size),
      (Jr = []),
      Zr.breakpoints || [])) {
        var yi = window.matchMedia(Si);
        (yi.__media = Si), Jr.push(yi), ei.add(yi, "change", ri);
      }
      ei.add(window, "orientationchange", fi),
        ei.add(window, "resize", ci),
        ni();
    }
    function oi(mi) {
      Gr.animator.stop();
      var Si = Gr.track.details;
      Gr.track.init(mi != null ? mi : Si ? Si.abs : 0);
    }
    function ui(mi) {
      oi(mi), Gr.emit("optionsChanged");
    }
    function ai(mi, Si) {
      if (mi) return li(mi), void ui(Si);
      di(), pi();
      var yi = si();
      hi(), si() !== yi ? ui(Si) : oi(Si), Gr.emit("updated");
    }
    function hi() {
      var mi = Gr.options.slides;
      if (typeof mi == "function")
        return (Gr.options.trackConfig = mi(Gr.size, Gr.slides));
      for (
        var Si = Gr.slides,
          yi = Si.length,
          Ei = typeof mi == "number" ? mi : p(mi, "number", yi, !0),
          Pi = [],
          Ai = p(mi, "perView", 1, !0),
          Ri = p(mi, "spacing", 0, !0) / Gr.size || 0,
          wi = Ai === "auto" ? Ri : Ri / Ai,
          Ci = p(mi, "origin", "auto"),
          bi = 0,
          Mi = 0;
        Mi < Ei;
        Mi++
      ) {
        var gi = Ai === "auto" ? ii(Si[Mi]) : 1 / Ai - Ri + wi,
          xi = Ci === "center" ? 0.5 - gi / 2 : Ci === "auto" ? 0 : Ci;
        Pi.push({
          origin: xi,
          size: gi,
          spacing: Ri,
        }),
          (bi += gi);
      }
      if (
        ((bi += Ri * (Ei - 1)), Ci === "auto" && !Gr.options.loop && Ai !== 1)
      ) {
        var Ti = 0;
        Pi.map(function (vi) {
          var Ii = bi - Ti;
          return (
            (Ti += vi.size + Ri),
            Ii >= 1 || (vi.origin = 1 - Ii - (bi > 1 ? 0 : 1 - bi)),
            vi
          );
        });
      }
      Gr.options.trackConfig = Pi;
    }
    function ci() {
      di();
      var mi = Gr.size;
      Gr.options.disabled || mi === Kr || ((Kr = mi), ai());
    }
    function fi() {
      ci(), setTimeout(ci, 500), setTimeout(ci, 2e3);
    }
    function di() {
      var mi = f(Gr.container);
      Gr.size = (Gr.options.vertical ? mi.height : mi.width) || 1;
    }
    function pi() {
      Gr.slides = o(Gr.options.selector, Gr.container);
    }
    (Gr.container = (Qr = o(Wr, document)).length ? Qr[0] : null),
      (Gr.destroy = function () {
        ei.purge(), Gr.emit("destroyed"), ti(!0);
      }),
      (Gr.prev = function () {
        Gr.moveToIdx(Gr.track.details.abs - 1, !0);
      }),
      (Gr.next = function () {
        Gr.moveToIdx(Gr.track.details.abs + 1, !0);
      }),
      (Gr.update = ai),
      li(Gr.options);
  };
}
var y = function (Wr, ze, Gr) {
  try {
    return (function (Yr, Kr) {
      var Zr,
        Jr = {};
      return (
        (Zr = {
          emit: function (Qr) {
            Jr[Qr] &&
              Jr[Qr].forEach(function (ti) {
                ti(Zr);
              });
            var ei = Zr.options && Zr.options[Qr];
            ei && ei(Zr);
          },
          moveToIdx: function (Qr, ei, ti) {
            var ri = Zr.track.idxToDist(Qr, ei);
            if (ri) {
              var ni = Zr.options.defaultAnimation;
              Zr.animator.start([
                {
                  distance: ri,
                  duration: p(ti || ni, "duration", 500),
                  easing: p(ti || ni, "easing", function (ii) {
                    return 1 + --ii * ii * ii * ii * ii;
                  }),
                },
              ]);
            }
          },
          on: function (Qr, ei, ti) {
            ti === void 0 && (ti = !1), Jr[Qr] || (Jr[Qr] = []);
            var ri = Jr[Qr].indexOf(ei);
            ri > -1 ? ti && delete Jr[Qr][ri] : ti || Jr[Qr].push(ei);
          },
          options: Yr,
        }),
        (function () {
          if (((Zr.track = m(Zr)), (Zr.animator = h(Zr)), Kr))
            for (var Qr = 0, ei = Kr; Qr < ei.length; Qr++) (0, ei[Qr])(Zr);
          Zr.track.init(Zr.options.initial || 0), Zr.emit("created");
        })(),
        Zr
      );
    })(
      ze,
      t$1(
        [
          k(Wr, {
            drag: !0,
            mode: "snap",
            renderMode: "precision",
            rubberband: !0,
            selector: ".keen-slider__slide",
          }),
          x,
          b,
          g,
        ],
        Gr || [],
        !0
      )
    );
  } catch (Yr) {
    console.error(Yr);
  }
};
const keenSlider_min = "",
  projectCarousel = (Wr) => {
    Wr.querySelectorAll(".js-projects-swiper").forEach((Gr) => {
      Gr.querySelectorAll(".swiper-slide").length,
        Gr.querySelector(".swiper-slide").offsetWidth;
      const Yr = new y(Gr, {
        loop: !0,
        mode: "free",
        dragSpeed: 0.5,
        renderMode: "performance",
        slides: {
          perView: "auto",
          spacing: 4,
        },
      });
      for (let Qr = 0; Qr < Yr.slides.length; Qr++) {
        const ei = Yr.slides[Qr];
        ei.parallax = ei.querySelector("horizontal-parallax");
      }
      let Kr = document.documentElement.clientWidth;
      Yr.on("updated", () => {
        Zr();
      }),
        setTimeout(() => {
          Yr.update();
        }, 0);
      function Zr() {
        Yr.track.add(-0.06), (Kr = document.documentElement.clientWidth);
        for (let Qr = 0; Qr < Yr.slides.length; Qr++) {
          const ei = Yr.slides[Qr],
            ti = Yr.track.details.slides[Qr].distance;
          (ei.parallax.bb = ei.parallax.getBoundingClientRect()),
            (ei.widthDistance = ei.parallax.bb.width / Kr),
            (ei.parallax.progress = gsapWithCSS.utils.mapRange(
              1,
              -ei.widthDistance,
              0,
              1,
              ti
            )),
            (ei.parallax.progress = gsapWithCSS.utils.clamp(
              0,
              1,
              ei.parallax.progress
            )),
            ei.parallax.update(ei.parallax.progress);
        }
      }
      Yr.on("dragged", () => {
        Jr();
      }),
        Yr.on("animationStarted", () => {
          gsapWithCSS.ticker.add(Jr);
        }),
        Yr.on("animationEnded", () => {
          gsapWithCSS.ticker.remove(Jr);
        });
      function Jr() {
        for (let Qr = 0; Qr < Yr.slides.length; Qr++) {
          const ei = Yr.slides[Qr],
            ti = ei.parallax,
            ri = Yr.track.details.slides[Qr].distance;
          (ti.progress = gsapWithCSS.utils.mapRange(
            1,
            -ei.widthDistance,
            0,
            1,
            ri
          )),
            (ti.progress = gsapWithCSS.utils.clamp(0, 1, ti.progress)),
            ti.update(ti.progress);
        }
      }
    });
  };
gsapWithCSS.registerPlugin(ScrollTrigger);
class SliceImage {
  constructor(ze, Gr = "horizontal") {
    if (
      ((this.imageWrapper = ze),
      (this.gridY = 3),
      (this.imageHeight = this.imageWrapper.offsetHeight),
      (this.imageWidth = this.imageWrapper.offsetWidth),
      (this.image = this.imageWrapper.querySelector("img")),
      window.innerWidth < 381)
    ) {
      const Yr = this.imageWrapper.querySelector("img.is--mobile");
      Yr && (this.image = Yr);
    }
    (this.imageSrc = this.image.src),
      (this.create = function () {
        for (let Yr = 0; Yr < this.gridY; Yr++) {
          let Kr = document.createElement("div");
          this.imageWrapper.appendChild(Kr),
            Kr.classList.add("slice-image"),
            (Kr.style.backgroundImage = "url(" + this.imageSrc + ")");
          let Zr = this.imageHeight,
            Jr = this.imageHeight;
          if (
            (this.image.closest(".js-case-study-h") &&
              (window.innerWidth > 380 && window.innerWidth < 1024
                ? (Jr = this.imageHeight / this.gridY + this.imageHeight + 20)
                : window.innerWidth > 1023 && (Zr = window.innerHeight)),
            Gr == "horizontal")
          ) {
            let Qr = (Yr * Zr) / this.gridY + "px",
              ei = Qr,
              ti = "auto " + Jr + "px";
            this.image.closest(".js-case-study-h") &&
              window.innerWidth > 380 &&
              window.innerWidth < 1024 &&
              ((ei = Qr), (ti = "100% auto")),
              (Kr.style.top = Qr),
              (Kr.style.left = 0),
              (Kr.style.height = Zr / this.gridY + "px"),
              (Kr.style.backgroundPositionY = "-" + ei),
              (Kr.style.backgroundSize = ti);
          }
          if (Gr == "vertical") {
            let Qr = (Yr * this.imageWidth) / this.gridY + "px";
            (Kr.style.left = Qr),
              (Kr.style.top = 0),
              (Kr.style.width = this.imageWidth / this.gridY + "px"),
              window.innerWidth > 380
                ? ((Kr.style.backgroundPositionX = "-" + Qr),
                  (Kr.style.backgroundSize = this.imageWidth + "px auto"))
                : (Kr.style.backgroundPositionX =
                    "calc(50% - " +
                    (Yr - 1) * (this.imageWidth / this.gridY) +
                    "px)");
          }
        }
      }),
      this.create(),
      (this.animation = function () {
        const Yr = ze.querySelectorAll(".slice-image");
        let Kr = this.imageWrapper.getAttribute("data-reveal");
        Kr || (Kr = 0.3);
        let Zr = gsapWithCSS.timeline();
        Zr.from(Yr, {
          y: "102%",
          duration: 2,
          stagger: 0.1,
          ease: "expo.inOut",
        }),
          Zr.to(this.image, {
            opacity: 1,
            duration: 0,
          }),
          Zr.to(Yr, {
            opacity: 0,
            duration: 1,
          }),
          Zr.delay(parseFloat(Kr));
      }),
      Gr == "vertical" && this.animation();
  }
}
const sliceImage = (Wr) => {
    const ze = Wr.querySelectorAll(".js-slice-image");
    ze.length > 0 &&
      ze.forEach((Gr) => {
        let Yr = "horizontal";
        Gr.classList.contains("js-slice-vertical") && (Yr = "vertical"),
          new SliceImage(Gr, Yr),
          window.innerWidth < 381 && Gr.classList.add("sm-screen");
      });
  },
  projectFilters = (Wr) => {
    document.body.addEventListener("click", (ni) => {
      ni.target.classList.contains("js-filter-delete") &&
        (document.querySelector(".js-filter-reset").click(),
        Wr &&
          Wr.classList.contains("is--filtered") &&
          htmx_minExports.on("htmx:afterSwap", function () {
            Wr.classList.remove("is--filtered");
          })),
        ni.target.classList.contains("js-filter-input") &&
          Wr &&
          htmx_minExports.on("htmx:afterSwap", function () {
            Wr.classList.add("is--filtered");
            const si = "?cat=" + ni.target.getAttribute("id"),
              li =
                window.location.protocol +
                "//" +
                window.location.host +
                window.location.pathname +
                si;
            window.history.pushState(
              {
                path: li,
              },
              "",
              li
            );
          });
    }),
      (window.scollToProjects = function () {
        setTimeout(() => {
          const ii = document.getElementById("projects").offsetTop - 50;
          lenis$1.scrollTo(ii, {
            duration: 2,
          });
        }, 500);
      });
    const ze = function () {
      const ni = document.querySelectorAll(".js-text-anim");
      new SplitType(ni, {
        types: "lines",
      }).lines.map((si) => {
        const li = document.createElement("div");
        li.classList.add("line-wrapper"),
          (li.style.overflow = "hidden"),
          si.parentNode.appendChild(li),
          li.appendChild(si);
      });
    };
    ze();
    const Gr = Wr.querySelectorAll(".js-filter-item");
    let Yr = 0,
      Kr = !1,
      Zr = "",
      Jr = 0;
    const Qr = (ni) => {
        Jr <= ni.pageY ? (Zr = "down") : (Zr = "up"), (Jr = ni.pageY);
      },
      ei = (ni) => {
        const ii = ni.querySelector(".js-project-filters-item-bg"),
          si = parseFloat(ni.getAttribute("data-index"));
        (Kr = !0),
          ni.classList.add("is-active"),
          setTimeout(() => {
            let li = "101%";
            si < Yr && si !== Gr.length && (li = "-101%"),
              Yr == 0 && si == Gr.length && (li = "-101%"),
              gsapWithCSS.killTweensOf(ii),
              gsapWithCSS.timeline().fromTo(
                ii,
                {
                  top: "0%",
                },
                {
                  top: li,
                  duration: 0.8,
                  ease: "outExpo",
                }
              );
          }, 0);
      },
      ti = (ni) => {
        const ii = ni.querySelector(".js-project-filters-item-bg"),
          si = parseFloat(ni.getAttribute("data-index"));
        ni.classList.remove("is-active");
        let li = "101%";
        Zr === "down" && (li = "-101%"),
          gsapWithCSS.killTweensOf(ii),
          gsapWithCSS.timeline().fromTo(
            ii,
            {
              top: li,
            },
            {
              top: 0,
              duration: 0.8,
              ease: "outExpo",
            }
          ),
          setTimeout(() => {
            Kr ? (Yr = si) : (Yr = 0);
          }, 0),
          (Kr = !1);
      },
      ri = (ni) => {
        ni.forEach((ii) => {
          ii.addEventListener("mouseenter", () => {
            ei(ii);
          }),
            ii.addEventListener("mouseleave", () => {
              ti(ii);
            });
        });
      };
    Gr.length > 0 &&
      (Gr[0].parentNode.addEventListener("mousemove", Qr, !1),
      ri(Gr),
      window.addEventListener("resize", ri(Gr))),
      htmx_minExports.on("htmx:afterSwap", function (ni) {
        (ni.target.classList.contains("js-projects-wrapper") ||
          ni.target.classList.contains("sprig-component")) &&
          setTimeout(() => {
            lenis$1.resize();
          }, 500),
          document.querySelectorAll(".js-lines-list-item").forEach((li, oi) => {
            li.setAttribute("data-index", oi);
          }),
          projectThumbnail(Wr),
          linesList(Wr),
          ze();
        const si = Wr.querySelectorAll(".js-filter-item");
        si.length > 0 &&
          (si[0].parentNode.addEventListener("mousemove", Qr, !1),
          ri(si),
          window.addEventListener("resize", ri(si)));
      });
  },
  teamNumber = () => {
    const Wr = document.querySelector("#team-number"),
      ze = (Qr) => {
        Wr.querySelectorAll("span[data-value]").forEach((ei, ti) => {
          ei.style.transform = `translateY(-${100 * parseInt(Qr[ti])}%)`;
        });
      },
      Gr = (Qr, ei) => {
        const ti = Array(10)
          .join(0)
          .split(0)
          .map((ni, ii) => `<span>${ii}</span>`)
          .join("");
        Wr.insertAdjacentHTML(
          "beforeend",
          `<span style="transform: translateY(-1000%)" data-value="${Qr}">
                ${ti}
            </span>`
        );
        const ri = Wr.lastElementChild;
        setTimeout(
          () => {
            ri.className = "visible";
          },
          ei ? 0 : 2e3
        );
      },
      Yr = (Qr) => {
        const ei = Qr.toString().split("");
        for (let ti = 0; ti < ei.length; ti++) Gr("0", !0);
        ze(["0"]), setTimeout(() => ze(ei), 500);
      },
      Kr = (Qr) => {
        Qr || (Qr = Math.round(Math.random() * 100));
        const ei = Qr.toString().split("");
        ze(ei);
      };
    let Zr = "50";
    Wr && (Zr = Wr.getAttribute("data-number"));
    let Jr = 10;
    Zr.includes(0) && (Jr = "09"), Yr(Zr), Kr(Jr);
  };
gsapWithCSS.registerPlugin(ScrollTrigger);
gsapWithCSS.registerPlugin(CustomEase);
const teamImages = () => {
  CustomEase.create("outCubic", "0.33, 1, 0.68, 1"),
    CustomEase.create("inOutQuint", "0.83, 0, 0.17, 1");
  const Wr = document.querySelector(".js-header"),
    ze = document.querySelector(".js-team"),
    Gr = document.querySelector(".js-team-container"),
    Yr = document.querySelector(".js-team-carousel-container"),
    Kr = document.querySelector(".js-team-carousel"),
    Zr = Kr.querySelectorAll(".js-team-carousel-image"),
    Jr = document.querySelectorAll(".js-close-team-carousel"),
    Qr = () => {
      pi(), si(), ui(), ci();
    };
  let ei = [],
    ti = [];
  const ri = (Ei, Pi) => Math.floor(Math.random() * (Pi - Ei + 1)) + Ei,
    ni = (Ei, Pi, Ai) => {
      let Ri = 0;
      Pi == 5 ? (Ri = "-75%") : Pi == 4 && (Ri = "75%"),
        gsapWithCSS.killTweensOf(Ei),
        gsapWithCSS.set(Ei, {
          y: Ri,
          translateZ: -ri(900, 1500) + "px",
        });
      let wi = gsapWithCSS.timeline();
      wi.to(Ei, {
        translateY: Pi == ri(0, 4) ? "-90%" : "0%",
        duration: 20,
        ease: "inOutQuint",
      }),
        wi.from(
          Ei,
          {
            filter: "blur(10px)",
            duration: 3,
            delay: ri(0, 5),
          },
          "<"
        ),
        wi.fromTo(
          Ei,
          {
            opacity: 0,
          },
          {
            opacity: 1,
            duration: 2,
            delay: ri(0, 5),
          },
          "<"
        ),
        wi.delay(Ai),
        wi.repeat(-1),
        ei.push(wi);
    },
    ii = document.querySelectorAll(".js-team-wrapper"),
    si = () => {
      const Ei = ii.length;
      gsapWithCSS.utils.toArray(ii).forEach((Pi, Ai) => {
        const Ri = (25 * Ai) / Ei,
          wi = 20;
        let Ci = "2100px";
        gsapWithCSS.killTweensOf(Pi);
        let bi = gsapWithCSS.timeline();
        bi.to(
          Pi,
          {
            translateZ: Ci,
            duration: wi,
          },
          "<"
        ),
          bi.delay(Ri),
          bi.repeat(-1),
          ti.push(bi);
        const Mi = Pi.querySelectorAll(".js-team-image");
        gsapWithCSS.utils.toArray(Mi).forEach((gi, xi) => {
          ni(gi, xi, Ri);
        });
      });
    },
    li = document.querySelectorAll(".js-team-image"),
    oi = document.querySelector(".js-team-button"),
    ui = () => {
      li.forEach((Ei) => {
        Ei.addEventListener("click", () => {
          ai();
        });
      }),
        oi &&
          oi.addEventListener("click", () => {
            ai(0.01);
          });
    },
    ai = (Ei) => {
      let Pi = ze.offsetTop;
      lenis$1.scrollTo(Pi),
        gsapWithCSS.to(Wr, {
          autoAlpha: 0,
          duration: 0.1,
        }),
        fi(),
        mi(Ei),
        setTimeout(() => {
          lenis$1.blockScroll();
        }, 800);
    },
    hi = (Ei, Pi = "") => {
      li.forEach((Ai, Ri) => {
        let wi = Ri;
        Pi && (wi = Pi),
          Ai.addEventListener("click", () => {
            Ei.moveToIdx(wi);
          });
      });
    },
    ci = () => {
      Jr.forEach((Ei) => {
        Ei.addEventListener("click", () => {
          di(),
            Si(),
            gsapWithCSS.to(Wr, {
              autoAlpha: 1,
              duration: 1,
            }),
            lenis$1.unblockScroll();
        });
      });
    },
    fi = () => {
      ti.forEach((Ei) => {
        Ei.pause();
      }),
        ei.forEach((Ei) => {
          Ei.pause();
        });
    },
    di = () => {
      ti.forEach((Ei) => {
        Ei.play();
      }),
        ei.forEach((Ei) => {
          Ei.play();
        });
    },
    pi = (Ei) => {
      let Pi = new y(Kr, {
        loop: !0,
        mode: "free",
        slides: {
          origin: "center",
          perView: "auto",
          spacing: 4,
        },
      });
      hi(Pi, Ei);
    },
    mi = (Ei) => {
      let Pi = gsapWithCSS.timeline(),
        Ai = 0.05;
      Ei && (Ai = Ei),
        Pi.to(Yr, {
          autoAlpha: 1,
        }),
        Pi.add(yi, "<"),
        Pi.fromTo(
          Zr,
          {
            "--scale-y": 0,
          },
          {
            "--scale-y": 1,
            duration: 0.9,
            ease: "outCubic",
            stagger: Ai,
          },
          "<"
        ),
        gsapWithCSS.to(Gr, {
          filter: "blur(10px)",
        });
    },
    Si = () => {
      gsapWithCSS.to(Yr, {
        autoAlpha: 0,
      }),
        gsapWithCSS.to(Gr, {
          filter: "blur(0)",
        });
    },
    yi = () => {
      const Ei = Kr.querySelectorAll(".a--sm-text .line");
      gsapWithCSS.fromTo(
        Ei,
        {
          y: "115%",
        },
        {
          y: 0,
          duration: 0.8,
          stagger: 0.008,
          ease: "outCubic",
        }
      );
    };
  Qr();
};
gsapWithCSS.registerPlugin(ScrollTrigger, CustomEase);
const teamTitle = (Wr) => {
  CustomEase.create("inOutQuint", "0.83, 0, 0.17, 1");
  const ze = Wr.querySelector(".js-team"),
    Gr = ze.querySelectorAll(
      ".js-team-header .a--text .line-wrapper:first-child .line, .js-team-header .a--sm-text .line"
    ),
    Yr = Wr.querySelector(".js-team-button");
  gsapWithCSS.set(Gr, {
    y: "115%",
  });
  const Kr = () => {
    let ti = "";
    const ri = Wr.querySelector(".js-team-header");
    return ri && (ti = ri.offsetHeight / 2 + 70), ti;
  };
  gsapWithCSS.set(Yr, {
    opacity: 0,
    y: Kr(),
  });
  const Zr = () => {
      let ti = gsapWithCSS.utils.toArray(".js-team-header-text"),
        ri = gsapWithCSS.utils.wrap(0, ti.length),
        ni = Wr.querySelector(".js-team-header-texts"),
        ii = -1;
      gsapWithCSS.set(ti, {
        opacity: 1,
      }),
        ti.forEach((li) => {
          li.remove();
        });
      const si = () => {
        (ii = ri(ii + 1)),
          ni.insertBefore(ti[ii], ni.firstChild),
          gsapWithCSS.fromTo(
            ti,
            {
              yPercent: -100,
            },
            {
              yPercent: 0,
              duration: 1.5,
              ease: "inOutQuint",
            }
          );
      };
      si(), teamNumber(), setInterval(si, 2800);
    },
    Jr = () => {
      teamImages();
    },
    Qr = () => {
      let ti = gsapWithCSS.timeline();
      gsapWithCSS.killTweensOf(ti),
        ti.fromTo(
          Gr,
          {
            y: "115%",
          },
          {
            y: 0,
            duration: 1.3,
            stagger: 0.08,
            ease: "power3.out",
          }
        ),
        ti.add(Zr, "<"),
        ti.add(ei);
    },
    ei = () => {
      let ti = gsapWithCSS.timeline();
      gsapWithCSS.killTweensOf(ti),
        ti.fromTo(
          Yr,
          {
            opacity: 0,
          },
          {
            opacity: 1,
            duration: 1.3,
            ease: "power3.out",
          }
        );
    };
  ScrollTrigger.create({
    trigger: ze,
    start: "top-=50% bottom",
    once: !0,
    onEnter: Jr,
  }),
    ScrollTrigger.create({
      trigger: ze,
      start: "top 15%",
      once: !0,
      onEnter: Qr,
    });
};
gsapWithCSS.registerPlugin(ScrollTrigger, CustomEase);
const team = (Wr) => {
  teamTitle(Wr);
  let ze = [];
  const Gr = Wr.querySelectorAll(".js-open-manifesto"),
    Yr = Wr.querySelectorAll(".js-close-manifesto");
  Gr.length > 0 && Kr(Gr, ze, "open"), Yr.length > 0 && Kr(Yr, ze, "close");
  function Kr(Zr, Jr, Qr) {
    Zr.forEach((ei) => {
      ei.addEventListener("click", () => {
        Jr.forEach((ti) => {
          Qr == "open" && ti.scrollTrigger.disable(),
            Qr == "close" && ti.scrollTrigger.enable();
        });
      });
    });
  }
};
gsapWithCSS.registerPlugin(ScrollTrigger);
gsapWithCSS.registerPlugin(CustomEase);
const leadership = () => {
  const Wr = document.querySelector(".js-leadership"),
    ze = document.querySelectorAll(".js-leadership-slide"),
    Gr = document.querySelectorAll(".js-leadership-info"),
    Yr = document.querySelector(".js-leadership-content"),
    Kr = document.querySelector(".js-leadership-info-wrapper"),
    Zr = document.querySelector(".js-leadership-slider");
  let Jr = 247,
    Qr = 1440,
    ei = (window.innerWidth * Jr) / Qr;
  window.innerWidth < 768 && (ei = 148);
  let ti = window.innerWidth,
    ri = "",
    ni,
    ii;
  CustomEase.create("inOutCubic", "0.65, 0, 0.35, 1)"),
    CustomEase.create("outCubic", "0.16, 1, 0.3, 1");
  const si = () => {
    let di = {
      duration: 3e4,
      easing: (pi) => pi,
    };
    ni = new y(Zr, {
      loop: !0,
      mode: "free",
      slides: {
        perView: "auto",
        spacing: 4,
      },
      renderMode: "performance",
      drag: !0,
      created(pi) {
        pi.moveToIdx(5, !0, di),
          (ri = pi.slides.length),
          ze.forEach((mi) => {
            mi.addEventListener("click", () => {
              setTimeout(() => {
                Zr.classList.contains("is-active")
                  ? pi.animator.stop()
                  : pi.moveToIdx(pi.track.details.abs + 5, !0, di);
              }, 500);
            }),
              window.innerWidth < 768 &&
                document.body.addEventListener("click", (Si) => {
                  Si.target.closest(".js-leadership") &&
                    !Si.target.closest(".js-leadership-slide") &&
                    (fi(mi),
                    gsapWithCSS.to(Yr, {
                      height: 0,
                      ease: "outCubic",
                      duration: 0.5,
                    }));
                });
          });
      },
      updated(pi) {
        pi.moveToIdx(pi.track.details.abs + 5, !0, di);
      },
      animationEnded(pi) {
        pi.moveToIdx(pi.track.details.abs + 5, !0, di);
      },
    });
  };
  Zr && si(),
    window.addEventListener("resize", () => {
      let di = window.innerWidth;
      di !== ti && ((ti = di), li());
    });
  const li = function () {
      Zr &&
        (window.innerWidth < 768
          ? (ei = 148)
          : (ei = (window.innerWidth * Jr) / Qr),
        ni && (ni.destroy(), (ni = "")),
        clearTimeout(ii),
        (ii = setTimeout(() => {
          si();
        }, 1e3)));
    },
    oi = function (di) {
      const pi = di.getAttribute("data-index");
      Gr.forEach((mi) => {
        mi.classList.remove("is-active"),
          mi.getAttribute("data-index") === pi && mi.classList.add("is-active");
      });
    },
    ui = function (di) {
      const pi = di.getAttribute("data-index");
      let mi = gsapWithCSS.timeline(),
        Si = 30;
      window.innerWidth < 768 && (Si = 10);
      let yi = ei + Si,
        Ei = ei - Si / (ri - 1);
      if (
        (gsapWithCSS.killTweensOf(ze),
        gsapWithCSS.killTweensOf(di),
        mi.to(
          ze,
          {
            minWidth: Ei,
            maxWidth: Ei,
            ease: "inOutCubic",
            duration: 0.4,
          },
          "<"
        ),
        mi.to(
          di,
          {
            minWidth: yi,
            maxWidth: yi,
            ease: "inOutCubic",
            duration: 0.4,
          },
          "<"
        ),
        pi)
      ) {
        const Pi = '.js-leadership-info[data-index="' + pi + '"] .line';
        gsapWithCSS.killTweensOf(Pi),
          mi.to(
            Pi,
            {
              y: 0,
              ease: "inOutCubic",
              stagger: 0.01,
              duration: 0.9,
            },
            "-=0.3"
          );
      }
      return mi;
    },
    ai = function (di) {
      const pi = di.querySelector(".js-leadership-image");
      setTimeout(() => {
        Gr.forEach((mi) => {
          mi.classList.remove("is-active");
        }),
          di.classList.remove("is-active"),
          pi.style.removeProperty("width");
      }, 500);
    },
    hi = function (di) {
      const pi = di.getAttribute("data-index");
      let mi = gsapWithCSS.timeline();
      if (
        (gsapWithCSS.killTweensOf(ze),
        mi.to(
          ze,
          {
            minWidth: ei,
            maxWidth: ei,
            ease: "power4.inOut",
            duration: 0.8,
          },
          "<"
        ),
        pi)
      ) {
        const Si = '.js-leadership-info[data-index="' + pi + '"] .line';
        gsapWithCSS.killTweensOf(Si),
          mi.to(
            Si,
            {
              y: "115%",
              ease: "inOutCubic",
              stagger: 0.01,
              duration: 0.7,
            },
            "-=0.6"
          );
      }
    },
    ci = (di) => {
      Zr.classList.add("is-active"),
        ze.forEach((Si) => {
          hi(Si), Si.classList.remove("is-active");
        }),
        ui(di),
        oi(di),
        di.classList.add("is-active");
      const pi = [];
      Wr.querySelectorAll(".js-leadership-info").forEach((Si) => {
        const yi = Si.getBoundingClientRect().height;
        pi.push(yi);
      }),
        setTimeout(() => {
          let Si = Math.max(...pi);
          window.innerWidth < 768 && (Si = Kr.getBoundingClientRect().height),
            gsapWithCSS.to(Yr, {
              height: Si,
              ease: "outCubic",
              duration: 0.8,
            }),
            setTimeout(() => {
              lenis$1.resize();
            }, 500);
        }, 10);
    },
    fi = (di) => {
      Zr.classList.remove("is-active"),
        hi(di),
        ai(di),
        window.innerWidth > 767 &&
          setTimeout(() => {
            gsapWithCSS.to(Yr, {
              height: 0,
              ease: "outCubic",
              duration: 0.8,
            });
          }, 500);
    };
  ze.length > 0 &&
    ze.forEach((pi) => {
      pi.addEventListener("click", () => {
        pi.classList.contains("is-active") ? fi(pi) : ci(pi);
      });
    });
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const awards = () => {
  const Wr = document.querySelector(".js-awards-wrapper"),
    ze = document.querySelectorAll(".js-award-item"),
    Gr = document.querySelector(".js-award-image-wrapper"),
    Yr = document.querySelector(".js-award-image-inner"),
    Kr = document.querySelectorAll(".js-award-image"),
    Zr = function () {
      ze.forEach((ri) => {
        ri.addEventListener("mouseenter", () => {
          const ni = ri.getAttribute("data-index");
          Kr.forEach((ii) => {
            const si = ii.getAttribute("data-index");
            (ii.style.zIndex = 0), ni === si && (ii.style.zIndex = 2);
          });
        });
      });
    },
    Jr = function () {
      let ri = gsapWithCSS.timeline();
      ri.to(Gr, {
        opacity: 1,
        duration: 0.3,
        ease: "power4.out",
      }),
        ri.pause(),
        Wr.addEventListener("mouseenter", () => ri.play()),
        Wr.addEventListener("mouseleave", () => ri.reverse());
    };
  function Qr(ri, ni) {
    var ii = ni.getBoundingClientRect(),
      si = ri.clientY - ii.top;
    return {
      y: si,
    };
  }
  const ei = function () {
      const ri = Wr.offsetHeight,
        ni = Yr.offsetHeight;
      if (ri > ni) {
        const ii = ri / (ri - ni);
        Wr.addEventListener("mousemove", (si) => {
          Qr(si, Wr);
          let li = Qr(si, Wr).y / ii;
          gsapWithCSS.to(Yr, {
            top: li,
            duration: 0.4,
            ease: "power1.out",
          });
        });
      }
    },
    ti = function () {
      window.innerWidth > 767 &&
        (ze.length > 0 && Zr(),
        Wr &&
          (gsapWithCSS.fromTo(
            Gr,
            {
              y: "15%",
              opacity: 0,
            },
            {
              y: 0,
              opacity: 1,
              duration: 1,
              ease: "power4.out",
              scrollTrigger: {
                trigger: Gr,
                start: "top 75%",
              },
            }
          ),
          setTimeout(() => {
            Jr();
          }, 500)),
        Wr && Yr && ei());
    };
  ti(),
    window.addEventListener("resize", () => {
      ti();
    });
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const listImage = () => {
    const Wr = document.querySelectorAll(".js-list-image-section");
    Wr.length > 0 &&
      setTimeout(() => {
        Wr.forEach((Gr) => {
          const Yr = Gr.querySelectorAll(".js-list-item"),
            Kr = Gr.querySelectorAll(".js-list-image");
          let Zr = [];
          Yr.length > 0 &&
            Kr.length > 0 &&
            gsapWithCSS.utils.toArray(Yr).forEach((ri, ni) => {
              const ii = ri.querySelectorAll(".js-lines-list-border"),
                si = ri.getAttribute("data-index"),
                li = Gr.querySelector(
                  '.js-list-image[data-index="' + (ni + 1) + '"]'
                ),
                oi = Gr.querySelector(".list-image__images-wrapper"),
                ui =
                  (window.innerHeight - oi.offsetHeight) / 2 + oi.offsetHeight;
              if (ni !== 0) {
                let hi = gsapWithCSS.fromTo(
                  li,
                  {
                    y: "100%",
                  },
                  {
                    y: 0,
                    duration: 1e-4,
                    ease: "none",
                    scrollTrigger: {
                      trigger: ri,
                      scrub: !0,
                      start: "top " + ui + "px",
                      end: () => `+=${oi.offsetHeight}`,
                      invalidateOnRefresh: !0,
                    },
                  }
                );
                Zr.push(hi.scrollTrigger);
              }
              if (ni !== Yr.length - 1) {
                let hi = gsapWithCSS.fromTo(
                  li,
                  {
                    filter: "brightness(1)",
                  },
                  {
                    scrollTrigger: {
                      trigger: ri,
                      scrub: !0,
                      start: "95% 50%",
                      end: () => `+=${oi.offsetHeight}`,
                    },
                    filter: "brightness(0.4)",
                    duration: 1,
                    ease: "power3.outIn",
                  }
                );
                Zr.push(hi.scrollTrigger);
              }
              let ai = gsapWithCSS.timeline({
                scrollTrigger: {
                  trigger: ri,
                  start: "top 80%",
                  end: () => `+=${ri.offsetHeight}`,
                  toggleClass: {
                    targets: Gr.querySelector(
                      '.js-list-item[data-index="' + si + '"]'
                    ),
                    className: "is-active",
                  },
                },
              });
              ii &&
                ai.fromTo(
                  ii,
                  {
                    scaleX: 0,
                  },
                  {
                    scaleX: 1,
                    duration: 2,
                    ease: "outExpo",
                    stagger: 0.5,
                  }
                ),
                Zr.push(ai.scrollTrigger);
            });
          const Jr = Gr.querySelector(".js-images-wrapper");
          Jr &&
            gsapWithCSS.from(Jr, {
              scrollTrigger: {
                trigger: Jr,
                start: "top 40%",
              },
              y: "-10%",
              opacity: 0,
              duration: 1.6,
              ease: "power4.out",
            });
          const Qr = Gr.querySelector(".js-list-wrapper");
          Qr &&
            gsapWithCSS.from(Qr, {
              scrollTrigger: {
                trigger: Qr,
                start: "top 95%",
              },
              y: "5%",
              opacity: 0,
              duration: 1.5,
              ease: "power4.out",
            });
          const ei = document.querySelectorAll(".js-open-manifesto"),
            ti = document.querySelectorAll(".js-close-manifesto");
          ei.length > 0 && ze(ei, Zr, "open"),
            ti.length > 0 && ze(ti, Zr, "close");
        });
      }, 800);
    function ze(Gr, Yr, Kr) {
      Gr.forEach((Zr) => {
        Zr.addEventListener("click", () => {
          Yr.forEach((Jr) => {
            Kr == "open" && Jr.disable(), Kr == "close" && Jr.enable();
          });
        });
      });
    }
  },
  formFields = () => {
    const Wr = document.querySelectorAll(
      'input[type="text"], input[type="email"], input[type="tel"], textarea'
    );
    Wr &&
      Wr.forEach((Kr) => {
        const Zr = Kr.closest(".fui-field-container");
        if (
          (Kr.value !== "" && Zr.classList.add("is-active"),
          Kr.addEventListener("focus", function () {
            Zr.classList.add("is-active");
          }),
          Kr.addEventListener("focusout", function () {
            Kr.value == "" && Zr.classList.remove("is-active");
          }),
          Kr.tagName === "TEXTAREA")
        ) {
          const Jr = Kr.scrollHeight;
          Kr.addEventListener("keydown", function () {
            setTimeout(() => {
              Kr.style.height = Jr + "px";
              var Qr = Kr.scrollHeight;
              (Kr.style.height = Qr + "px"),
                Kr.value == "" && (Kr.style.height = Jr + "px");
            }, 0);
          }),
            Kr.setAttribute("data-lenis-prevent", !0);
        }
      });
    let ze = document.querySelectorAll('input[type="file"]'),
      Gr = {};
    ze &&
      (ze.forEach((Kr) => {
        const Zr = document.createElement("div");
        Zr.classList.add("file-upload-list"),
          Kr.after(Zr),
          Kr.addEventListener("change", function () {
            (Gr = Kr.files),
              Yr(Gr, Zr),
              setTimeout(() => {
                lenis$1.resize();
              }, 500);
          });
      }),
      document.body.addEventListener("click", (Kr) => {
        if (Kr.target.classList.contains("delete-file")) {
          const Zr = Kr.target.closest(".file-field__file"),
            Jr = parseFloat(Zr.getAttribute("data-index")),
            Qr = new DataTransfer();
          for (let ti = 0; ti < Gr.length; ti++) {
            const ri = Gr[ti];
            Jr !== ti && Qr.items.add(ri);
          }
          Gr = Qr.files;
          const ei =
            Kr.target.parentElement.offsetParent.querySelector(
              'input[type="file"]'
            );
          (ei.value = null), Zr.remove();
        }
      }));
    function Yr(Kr, Zr) {
      for (; Zr.firstChild; ) Zr.removeChild(Zr.firstChild);
      if (Kr.length > 0)
        for (let Jr = 0; Jr < Kr.length; Jr++) {
          const Qr = Kr[Jr],
            ei = document.createElement("div");
          ei.classList.add("file-field__file"),
            ei.setAttribute("data-index", Jr);
          const ti = document.createElement("p");
          ti.textContent = Qr.name;
          const ri = document.createElement("img");
          (ri.src = URL.createObjectURL(Qr)), (ri.alt = ri.title = Qr.name);
          const ni = document.createElement("span");
          ni.classList.add("delete-file"),
            ei.appendChild(ri),
            ei.appendChild(ti),
            ei.appendChild(ni),
            Zr.appendChild(ei);
        }
    }
  };
gsapWithCSS.registerPlugin(ScrollTrigger);
window.ScrollTrigger = ScrollTrigger;
function cultureAnimations() {
  const Wr = document.querySelector(".js-culture"),
    ze = Wr.getBoundingClientRect().height,
    Gr = document.querySelectorAll(".js-culture-image-wrapper"),
    Yr = document.querySelectorAll(".js-culture-container .a--text");
  Yr.length > 0 &&
    gsapWithCSS.utils.toArray(Yr).forEach((Kr) => {
      let Zr = Kr.getAttribute("data-reveal");
      Zr || (Zr = 0);
      const Jr = Kr.querySelectorAll(".line"),
        Qr = Kr.querySelectorAll(".char");
      let ei = Jr,
        ti = 0.08;
      Qr.length > 0 && ((ei = Qr), (ti = 0.03)),
        gsapWithCSS.fromTo(
          ei,
          {
            y: "115%",
          },
          {
            y: 0,
            duration: 1,
            stagger: ti,
            ease: "power3.out",
            delay: parseFloat(Zr),
          }
        ),
        gsapWithCSS.to(Kr, {
          y: 50,
          duration: 2,
          ease: "0.25, 1, 0.5, 1",
          scrollTrigger: {
            trigger: Wr,
            scrub: !0,
            start: "top top",
            end: () => `+=${ze * 1.2}`,
          },
        });
    }),
    gsapWithCSS.to(Wr, {
      y: 200,
      duration: 1.5,
      ease: "0.25, 1, 0.5, 1",
      scrollTrigger: {
        trigger: Wr,
        scrub: !0,
        start: "top top",
        end: () => `+=${ze * 1.5}`,
      },
    }),
    Gr.length &&
      Gr.forEach((Kr, Zr) => {
        const Jr = Kr.querySelectorAll(".js-culture-image"),
          Qr = Zr;
        gsapWithCSS.utils.toArray(Jr).forEach((ei, ti) => {
          let ri = 1.5,
            ni = "750px",
            ii = ">-30%";
          Jr.length < 4 && ((ri = 2.5), (ni = "600px")),
            Jr.length < 3 && (ri = 5),
            Jr.length > 5 &&
              ((ni = 1e3 + (Jr.length - 5) * 400 + "px"), (ri = 1.2)),
            Jr.length > 3 && (ii = "<+40%");
          let si = Jr.length * (Jr.length - Qr * 0.5) * ri;
          const li = (si / Jr.length) * ti;
          let oi = si / 1.8;
          si > 40 && (oi = 25);
          let ui = gsapWithCSS.timeline({
            repeat: -1,
            delay: li * 0.8,
          });
          ui.fromTo(
            ei,
            {
              z: "-200px",
            },
            {
              z: ni,
              zIndex: 10,
              duration: si,
              ease: "0, 0.55, 0.45, 1",
            }
          ),
            ui.fromTo(
              ei,
              {
                opacity: 0,
              },
              {
                opacity: 3,
                duration: oi,
              },
              "<"
            ),
            ui.to(
              ei,
              {
                filter: "blur(10px)",
                duration: oi,
              },
              ii
            );
          let ai = "80%",
            hi = "50%";
          Qr == 0 && ((ai = "-80%"), [0, 1, 3].includes(ti) && (hi = "-50%")),
            Qr == 1 && [0, 2, 3].includes(ti) && (hi = "-50%"),
            gsapWithCSS
              .timeline({
                scrollTrigger: {
                  trigger: Wr,
                  scrub: !0,
                  start: "top top",
                  end: () => `+=${ze * 1.2}`,
                },
              })
              .to(ei, {
                x: ai,
                y: hi,
                ease: "0.5, 1, 0.89, 1",
                duration: 1.5,
              });
        });
      });
}
gsapWithCSS.registerPlugin(ScrollTrigger);
const overlappingSections = () => {
  const Wr = document.querySelectorAll(".js-overlappingSections"),
    ze = document.querySelector(".js-full-image-quote"),
    Gr = ze.getBoundingClientRect().height,
    Yr = ze.querySelector(".js-full-image-quote-wrapper");
  Wr.length &&
    Wr.forEach((Kr) => {
      const Zr = Kr.offsetHeight,
        Jr = Kr.getBoundingClientRect().top,
        Qr = Kr.querySelector(".js-overlappingSections-images-section"),
        ei = Kr.querySelectorAll(".js-overlappingSections-section"),
        ti = Kr.querySelector(".js-overlappingSections-images"),
        ri = ti.offsetHeight,
        ni = ti.getBoundingClientRect().top - Jr,
        ii = ti.getBoundingClientRect().bottom - Jr,
        si = Kr.querySelectorAll(".js-overlappingSections-image"),
        li = Kr.querySelectorAll(".js-overlappingSections-tab");
      let oi = [],
        ui = [];
      const ai = () => {
          let di = ScrollTrigger.create({
            trigger: Qr,
            pin: !0,
            scrub: !0,
            start: "top top",
            end: () => `+=${Zr + Gr}`,
            invalidateOnRefresh: !0,
          });
          oi.push(di);
        },
        hi = () => {
          gsapWithCSS.utils.toArray(ei).forEach((di, pi) => {
            const mi = ri,
              Si = di.querySelector(".js-overlappingSections-tab"),
              yi = Kr.querySelector(
                '.js-overlappingSections-image[data-index="' + (pi + 1) + '"]'
              );
            if (pi !== ei.length - 1) {
              let Ei = gsapWithCSS.fromTo(
                si,
                {
                  y: -mi * pi,
                },
                {
                  y: -mi * (pi + 1),
                  ease: "none",
                  scrollTrigger: {
                    trigger: di,
                    scrub: !0,
                    start: "bottom " + ii,
                    end: () => `+=${mi}`,
                    invalidateOnRefresh: !0,
                  },
                }
              );
              oi.push(Ei);
              let Pi = gsapWithCSS.fromTo(
                yi,
                {
                  filter: "brightness(1)",
                },
                {
                  scrollTrigger: {
                    trigger: di,
                    scrub: !0,
                    start: "90% 50%",
                    end: () => `+=${mi}`,
                  },
                  filter: "brightness(0.4)",
                  duration: 1,
                  ease: "power3.outIn",
                }
              );
              oi.push(Pi);
              let Ai = di.offsetHeight - Si.offsetHeight;
              pi == ei.length - 2 && (Ai = Si.offsetHeight);
              let Ri = ScrollTrigger.create({
                trigger: Si,
                pin: !0,
                scrub: !0,
                start: "top top",
                end: "+=" + Ai,
                toggleClass: "is-sticky",
              });
              oi.push(Ri);
            }
            if (pi === ei.length - 1) {
              const Ei = di.querySelector(".js-overlappingSections-title"),
                Pi = di.querySelector(".js-overlappingSections-text-wrapper"),
                Ai = Kr.querySelector(
                  '.js-overlappingSections-image[data-index="' +
                    (pi + 1) +
                    '"] img'
                );
              (Ai.style.width = window.innerWidth + "px"),
                (Ai.style.height = window.innerHeight + "px"),
                (Ai.style.transform = "translateY(-" + ni + "px)");
              let Ri = gsapWithCSS.timeline({
                scrollTrigger: {
                  trigger: di,
                  pin: !0,
                  pinSpacing: !1,
                  scrub: !0,
                  start: "top top",
                  end: () => `+=${Gr}`,
                  invalidateOnRefresh: !0,
                },
              });
              Ri.to(Ai, {
                opacity: 0,
                duration: 1e-4,
              }),
                Ri.to(
                  Ei,
                  {
                    x: -500,
                    y: -500,
                    duration: 1.5,
                    ease: "0.45, 0, 0.55, 1",
                  },
                  "<"
                ),
                Ri.to(
                  Pi,
                  {
                    x: 500,
                    y: 500,
                    duration: 1.2,
                    ease: "0.45, 0, 0.55, 1",
                  },
                  "<"
                ),
                Ri.to(
                  Si,
                  {
                    opacity: 0,
                    y: "100%",
                    ease: "0.45, 0, 0.55, 1",
                  },
                  "<"
                ),
                oi.push(Ri);
            }
          });
        };
      li.forEach((di) => {
        di.addEventListener("click", () => {
          const pi = di.getAttribute("data-index"),
            mi = Kr.querySelector(
              '.js-overlappingSections-section[data-index="' + pi + '"]'
            );
          lenis$1.scrollTo(mi, {
            duration: 2.5,
          });
        });
      });
      const ci = () => {
        const di = ti.getBoundingClientRect().left,
          pi = ti.getBoundingClientRect().bottom - Jr - window.innerHeight,
          mi = Yr.querySelector("img");
        let Si = gsapWithCSS.timeline({
          scrollTrigger: {
            trigger: ze,
            pin: !0,
            pinSpacing: !1,
            scrub: !0,
            start: "top top",
            end: () => `+=${Gr * 3}`,
            invalidateOnRefresh: !0,
          },
        });
        Si.fromTo(
          Yr,
          {
            clipPath: "inset(" + ni + "px " + di + "px " + -pi + "px)",
          },
          {
            clipPath: "inset(0px 0px 0px)",
            ease: "0.45, 0, 0.55, 1",
            duration: 1.6,
          }
        ),
          Si.fromTo(
            mi,
            {
              opacity: 0,
              duration: 1e-4,
            },
            {
              opacity: 1,
              duration: 1e-4,
            },
            "<"
          ),
          Si.to(
            ze.querySelectorAll(".a--text .line"),
            {
              y: 0,
              duration: 5,
              stagger: "0.08",
              ease: "power3.out",
            },
            "<+0.2"
          ),
          oi.push(Si);
      };
      document.documentElement.clientWidth > 767 &&
        (Qr && (ai(), hi()), ze && ci());
      let fi;
      window.addEventListener("resize", () => {
        clearTimeout(fi),
          (fi = setTimeout(() => {
            if (document.documentElement.clientWidth < 768) {
              if (oi.length > 0) {
                for (let di = 0; di < oi.length; di++)
                  oi[di].kill(), (oi[di] = null);
                oi = [];
              }
              if (ui.length > 0) {
                for (let di = 0; di < ui.length; di++)
                  gsapWithCSS.ticker.remove(ui[di]);
                ui = [];
              }
            } else oi.length == 0 && (Qr && (ai(), hi()), ze && ci());
          }, 1e3));
      });
    });
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const overlappingImages = () => {
    const Wr = document.querySelectorAll(".js-overlappingImages");
    Wr.length &&
      Wr.forEach((ze) => {
        const Gr = ze.querySelector(".js-overlappingImages-sections"),
          Yr = ze.querySelectorAll(".js-overlappingImages-container"),
          Kr = Yr[0].getBoundingClientRect().height,
          Zr = ze.querySelector(".js-overlappingImages-images");
        ze.querySelectorAll(".js-overlappingImages-image");
        const Jr = ze.querySelector(".js-overlappingImages-bg"),
          Qr = ze.querySelector(".js-overlappingImages-bg-2");
        let ei = [],
          ti = [];
        const ri = () => {
            let oi = ScrollTrigger.create({
              trigger: Gr,
              pin: !0,
              pinSpacing: !0,
              anticipatePin: 1,
              scrub: 1.5,
              start: "top top",
              end: () => `+=${Kr}`,
            });
            ei.push(oi);
          },
          ni = () => {
            let oi = ScrollTrigger.create({
              trigger: Zr,
              pin: !0,
              pinSpacing: !0,
              anticipatePin: 1,
              scrub: !0,
              start: "top top",
              end: "+=" + Kr * Yr.length,
            });
            ei.push(oi);
          },
          ii = () => {
            gsapWithCSS.utils.toArray(Yr).forEach((oi, ui) => {
              const ai = ze.querySelector(
                '.js-overlappingImages-image[data-index="' + ui + '"]'
              );
              if (ui === 0) {
                const hi = oi.querySelectorAll(".line");
                let ci = gsapWithCSS.timeline({
                  scrollTrigger: {
                    trigger: oi,
                    scrub: !0,
                    start: "top bottom",
                    end: () => `+=${Kr * 2}`,
                  },
                });
                Jr &&
                  ci.from(Jr, {
                    y: "100%",
                    ease: "0.5, 1, 0.89, 1",
                    duration: 4,
                  }),
                  Qr &&
                    ci.from(
                      Qr,
                      {
                        y: "100%",
                        ease: "0.45, 0, 0.55, 1",
                        duration: 3,
                      },
                      ">-2"
                    ),
                  hi.length > 0 &&
                    ci.from(
                      hi,
                      {
                        y: "105%",
                        ease: "0.5, 1, 0.89, 1",
                        duration: 2,
                        stagger: 0.1,
                      },
                      ">-1.5"
                    ),
                  ai &&
                    ci.from(
                      ai,
                      {
                        y: "100%",
                        ease: "0.45, 0, 0.55, 1",
                        duration: 4,
                      },
                      "<"
                    ),
                  ei.push(ci);
              }
              if (ui !== 0) {
                let hi = gsapWithCSS.to(ai, {
                  height: window.innerHeight,
                  ease: "none",
                  scrollTrigger: {
                    trigger: oi,
                    scrub: !0,
                    start: "bottom bottom",
                    end: () => `+=${Kr}`,
                  },
                });
                ei.push(hi);
                const ci = ze.querySelector(
                  '.js-overlappingImages-image[data-index="' +
                    parseFloat(ui - 1) +
                    '"]'
                );
                let fi = gsapWithCSS.fromTo(
                  ci,
                  {
                    filter: "brightness(1)",
                  },
                  {
                    scrollTrigger: {
                      trigger: oi,
                      scrub: !0,
                      start: "90% 50%",
                      end: () => `+=${Kr}`,
                    },
                    filter: "brightness(0.4)",
                    duration: 1,
                    ease: "power3.outIn",
                  }
                );
                ei.push(fi);
              }
            });
          },
          si = () => {
            Yr.length > 0 && (Gr && ri(), Zr && ni(), ii());
          };
        document.documentElement.clientWidth > 767 && si();
        let li;
        window.addEventListener("resize", () => {
          clearTimeout(li),
            (li = setTimeout(() => {
              if (document.documentElement.clientWidth < 768) {
                if (ei.length > 0) {
                  for (let oi = 0; oi < ei.length; oi++)
                    ei[oi].kill(), (ei[oi] = null);
                  ei = [];
                }
                if (ti.length > 0) {
                  for (let oi = 0; oi < ti.length; oi++)
                    gsapWithCSS.ticker.remove(ti[oi]);
                  ti = [];
                }
              } else ei.length == 0 && si();
            }, 1e3));
        });
      });
  },
  horizontalClip = (Wr, ze, Gr, Yr = !0) => {
    const Kr = Gr,
      Zr = Kr + window.innerHeight / 3,
      Jr = Kr + (window.innerHeight / 3) * 2,
      Qr = Kr + window.innerHeight;
    let ei = "-30%";
    window.innerWidth < 768 && (ei = "-100%");
    const ti = gsapWithCSS.timeline();
    ti.to(Wr.querySelector(".main-wrapper"), {
      x: ei,
      "--opacity": 0.6,
      duration: ze * 1.2,
      ease: "power3.inOut",
    }),
      ti.fromTo(
        Wr,
        {
          clipPath:
            "polygon(0% " +
            Kr +
            "px, 100% " +
            Kr +
            "px, 100% " +
            Zr +
            "px, 100% " +
            Zr +
            "px, 100% " +
            Jr +
            "px, 100% " +
            Jr +
            "px, 100% " +
            Qr +
            "px, 0% " +
            Qr +
            "px)",
        },
        {
          clipPath:
            "polygon(0% " +
            Kr +
            "px, 80% " +
            Kr +
            "px, 80% " +
            Zr +
            "px, 50% " +
            Zr +
            "px, 50% " +
            Jr +
            "px, 15% " +
            Jr +
            "px, 15% " +
            Qr +
            "px, 0% " +
            Qr +
            "px)",
          duration: ze,
          ease: "power1.inOut",
        },
        "<-=0.2"
      ),
      ti.to(
        Wr,
        {
          clipPath:
            "polygon(0% " +
            Kr +
            "px, 0% " +
            Kr +
            "px, 0% " +
            Zr +
            "px, 0% " +
            Zr +
            "px, 0% " +
            Jr +
            "px, 0% " +
            Jr +
            "px, 0% " +
            Qr +
            "px, 0% " +
            Qr +
            "px)",
          duration: ze,
          ease: "power2.out",
        },
        ">-0.3"
      ),
      Yr ? ti.add(ni, "+=1") : ti.add(ri, "+=1");
    function ri() {
      gsapWithCSS.set(Wr.querySelector(".main-wrapper"), {
        transform: "",
        "--opacity": 0,
      }),
        (Wr.querySelector(".main-wrapper").style.transform = ""),
        gsapWithCSS.set(Wr, {
          clipPath: "",
        }),
        (Wr.style.transform = "");
    }
    function ni() {
      gsapWithCSS.set(Wr.querySelector(".main-wrapper"), {
        transform: "",
        "--opacity": 0,
      }),
        gsapWithCSS.set(Wr, {
          clipPath:
            "polygon(0% " +
            Kr +
            "px, 100% " +
            Kr +
            "px, 100% " +
            Zr +
            "px, 100% " +
            Zr +
            "px, 100% " +
            Jr +
            "px, 100% " +
            Jr +
            "px, 100% " +
            Qr +
            "px, 0% " +
            Qr +
            "px)",
        });
    }
  };
gsapWithCSS.registerPlugin(ScrollTrigger);
const manifesto = (Wr) => {
  const ze = Wr.querySelectorAll(".js-open-manifesto"),
    Gr = Wr.querySelectorAll(".js-close-manifesto"),
    Yr = Wr.querySelector(".js-agency-inner"),
    Kr = Wr.querySelector(".js-manifesto"),
    Zr = Wr.querySelector("header");
  let Jr = 0;
  if (Kr && Yr) {
    let Qr = [];
    const ei = Kr.querySelector(".js-manifesto-header"),
      ti = Kr.querySelector(".js-manifesto-heading"),
      ri = function () {
        let hi = lenis$1.scroll;
        (Jr = hi),
          (Yr.style.transform = "translateY(-" + hi + "px)"),
          lenis$1.scrollTo("top", {
            immediate: !0,
          }),
          horizontalClip(Yr, 1, Jr, !1),
          Zr &&
            gsapWithCSS.set(Zr, {
              opacity: 0,
              duration: 0,
            }),
          document.body.classList.add("opening-manifesto"),
          ei.classList.add("is--light"),
          gsapWithCSS.fromTo(
            ei,
            {
              opacity: 0,
              y: "50%",
            },
            {
              opacity: 1,
              y: 0,
              duration: 1.5,
              delay: 1,
            }
          ),
          lenis$1.stop(),
          setTimeout(() => {
            document.body.classList.add("manifesto-is-active"),
              document.body.classList.remove("opening-manifesto");
          }, 1200),
          setTimeout(() => {
            lenis$1.start(), lenis$1.resize();
          }, 1600),
          Qr.forEach((fi) => {
            fi.enable();
          });
        const ci = Kr.querySelectorAll(
          ".js-manifesto-container .a--text, .js-manifesto-container .a--sm-text"
        );
        ci.length > 0 &&
          gsapWithCSS.utils.toArray(ci).forEach((fi) => {
            let di = fi.getAttribute("data-reveal");
            di || (di = 0);
            var pi = gsapWithCSS.timeline();
            pi.fromTo(
              fi.querySelectorAll(".line"),
              {
                y: "115%",
              },
              {
                y: 0,
                duration: 1,
                stagger: 0.08,
                ease: "power3.out",
                delay: parseFloat(di),
              }
            );
            const mi = fi.querySelector(".slice-wrapper");
            mi &&
              pi.to(
                mi,
                {
                  x: "0.7rem",
                  duration: 1,
                  ease: "power3.out",
                },
                ">-0.2"
              );
          });
      },
      ni = function () {
        const hi = Kr.querySelector(".js-manifesto-mainTitle"),
          ci = Kr.querySelector(".js-manifesto-indication"),
          fi = hi.querySelectorAll(".line-wrapper"),
          di = fi[0],
          pi = fi[1],
          mi = ti.getBoundingClientRect().height;
        let Si = gsapWithCSS.timeline({
          scrollTrigger: {
            trigger: ti,
            pin: !0,
            pinSpacing: !1,
            scrub: !0,
            start: "top top",
            end: () => `+=${mi}`,
          },
        });
        setTimeout(() => {
          gsapWithCSS.set(ti, {
            y: 0,
          }),
            gsapWithCSS.set(di, {
              opacity: 1,
            }),
            gsapWithCSS.set(pi, {
              opacity: 1,
            });
        }, 500),
          Si.to(di, {
            y: "-100vh",
            transform: "scale(2.5)",
            ease: "0.5, 1, 0.89, 1",
            duration: 4,
          }),
          Si.to(
            pi,
            {
              y: "100vh",
              transform: "scale(2.5)",
              ease: "0.5, 1, 0.89, 1",
              duration: 4,
            },
            "<"
          ),
          Si.to(
            ci,
            {
              opacity: 0,
              ease: "0.5, 1, 0.89, 1",
              duration: 2,
            },
            "<"
          ),
          Si.to(di, {
            opacity: 0,
            duration: 0.1,
          }),
          Si.to(pi, {
            opacity: 0,
            duration: 0.1,
          }),
          Qr.push(Si.scrollTrigger);
      },
      ii = Kr.querySelector(".js-manifesto-text"),
      si = ii.querySelectorAll("p"),
      li = new SplitType(ii, {
        types: "words",
      });
    gsapWithCSS.set(li.words, {
      opacity: 0.27,
    }),
      gsapWithCSS.utils.toArray(si).forEach((hi) => {
        const ci = hi.getBoundingClientRect().height,
          fi = hi.querySelectorAll(".word");
        document.documentElement.clientWidth > 767 &&
          gsapWithCSS.from(hi, {
            "--scale3d": "0.7, 0.7, 5",
            "--rotatex": "-3deg",
            duration: 5,
            ease: "0.5, 1, 0.89, 1",
            scrollTrigger: {
              trigger: hi,
              scrub: !0,
              start: "top bottom",
              end: () => `+=${ci * 1.7}`,
            },
          }),
          gsapWithCSS.fromTo(
            fi,
            {
              opacity: 0.27,
            },
            {
              opacity: 1,
              ease: "0.5, 1, 0.89, 1",
              duration: 0.1,
              stagger: 0.05,
              scrollTrigger: {
                trigger: hi,
                scrub: !0,
                start: "top 80%",
                end: () => `+=${ci}`,
              },
            }
          );
      });
    const oi = function () {
        const hi = document.querySelector(".webgl-wrapper");
        horizontalClip(hi, 1, 0);
        let ci = lenis$1.scroll;
        (Jr = ci),
          (Kr.style.transform = "translateY(-" + ci + "px)"),
          lenis$1.scrollTo("top", {
            immediate: !0,
          }),
          horizontalClip(Kr, 1, Jr, !1),
          document.body.classList.add("closing-manifesto"),
          setTimeout(() => {
            document.body.classList.remove("manifesto-is-active"),
              document.body.classList.remove("closing-manifesto"),
              lenis$1.resize(),
              gsapWithCSS.to(Zr, {
                opacity: 1,
                duration: 1,
              }),
              ui();
          }, 1200);
      },
      ui = function () {
        Qr.forEach((hi) => {
          hi.disable();
        });
      };
    let ai;
    ze.length > 0 &&
      ze.forEach((hi) => {
        hi.addEventListener("click", () => {
          ri(),
            ti &&
              (clearTimeout(ai),
              (ai = setTimeout(() => {
                ni();
              }, 100)));
        });
      }),
      Gr.length > 0 &&
        Gr.forEach((hi) => {
          hi.addEventListener("click", () => {
            oi();
          });
        });
  }
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const collections = (Wr) => {
  const ze = Wr.querySelectorAll(
      ".js-collections-main .a--text, .js-collections-main .a--sm-text"
    ),
    Gr = Wr.querySelectorAll(".js-collection-preview"),
    Yr = Wr.querySelector(".collection-intro img.intro-image");
  function Kr() {
    gsapWithCSS
      .timeline({
        scrollTrigger: {
          trigger: Yr,
          scrub: !0,
          pin: !1,
        },
      })
      .from(Yr, {
        yPercent: -10,
        ease: "none",
      })
      .to(Yr, {
        yPercent: 10,
        ease: "none",
      });
  }
  function Zr() {
    gsapWithCSS.utils.toArray(ze).forEach((ei) => {
      let ti = ei.getAttribute("data-reveal");
      ti || (ti = 0),
        gsapWithCSS.fromTo(
          ei.querySelectorAll(".line"),
          {
            y: "115%",
          },
          {
            y: 0,
            duration: 1,
            stagger: 0.08,
            ease: "power3.out",
            scrollTrigger: {
              trigger: ei,
              start: "top 98%",
            },
            delay: parseFloat(ti),
          }
        );
    });
  }
  function Jr() {
    gsapWithCSS.utils.toArray(Gr).forEach((ei) => {
      let ti = ei.getAttribute("data-reveal");
      ti || (ti = 0),
        gsapWithCSS.fromTo(
          ei,
          {
            "--scale": "0",
          },
          {
            "--scale": "1",
            duration: 1.5,
            stagger: 0.08,
            ease: "power3.out",
            scrollTrigger: {
              trigger: ei,
              start: "top 98%",
            },
            delay: parseFloat(ti),
          }
        );
    });
  }
  function Qr() {
    ze.length > 0 && Zr(), Gr.length > 0 && Jr(), Yr && Kr();
  }
  Qr();
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const playground = (Wr) => {
  const ze = Wr.querySelector(".js-playground"),
    Gr = Wr.querySelector(".js-playground-inner");
  let Yr;
  Gr && (Yr = Gr.getBoundingClientRect().height);
  const Kr = Wr.querySelector(".js-playground-title"),
    Zr = Wr.querySelector(".js-playground-link-block"),
    Jr = Wr.querySelector(".js-playground-wrapper");
  let Qr = 0,
    ei = 0;
  Jr &&
    ((Qr = Jr.getBoundingClientRect().top - ze.getBoundingClientRect().top),
    (ei = Jr.getBoundingClientRect().left));
  let ti = "",
    ri = [],
    ni = [];
  const ii = () => {
      new SplitType(Kr, {
        types: "lines, word",
      }).lines.map((fi) => {
        const di = document.createElement("div");
        di.classList.add("line-wrapper"),
          (di.style.overflow = "hidden"),
          fi.parentNode.appendChild(di),
          di.appendChild(fi);
      });
    },
    si = () => {
      gsapWithCSS.killTweensOf(Jr),
        (ti = gsapWithCSS.timeline({
          scrollTrigger: {
            trigger: Gr,
            pin: !0,
            pinSpacing: !0,
            scrub: !0,
            anticipatePin: 0.2,
            start: "top top",
            end: () => `+=${Yr * 3}`,
          },
        })),
        ri.push(ti);
    },
    li = () => {
      const ci = Kr.querySelectorAll(".line");
      if (ci.length > 0) {
        const fi = gsapWithCSS.fromTo(
          ci,
          {
            y: "115%",
          },
          {
            y: 0,
            duration: 0.7,
            stagger: 0.08,
            ease: "power3.out",
            scrollTrigger: {
              trigger: ze,
              start: "top 75%",
            },
            onEnter: function () {
              ti.to(Jr, {
                width: document.body.clientWidth,
                height: "102vh",
                y: -Qr + "px",
                x: -ei + "px",
                "--right-points": "0%",
                "--left-points": "100%",
                duration: 2,
              });
            },
          }
        );
        ri.push(fi);
      }
    },
    oi = (ci) => {
      const fi = ci.closest(".line-wrapper");
      (fi.style.overflow = "inherit"),
        (fi.style.position = "relative"),
        (fi.style.zIndex = 1);
    },
    ui = () => {
      (Zr.style.overflow = "inherit"), oi(Zr);
    },
    ai = () => {
      ii(),
        li(),
        si(),
        setTimeout(() => {
          ui();
        }, 1e3);
    };
  document.documentElement.clientWidth > 767 && Zr && ai();
  let hi;
  window.addEventListener("resize", () => {
    clearTimeout(hi),
      (hi = setTimeout(() => {
        if (document.documentElement.clientWidth < 768) {
          if (ri.length > 0) {
            for (let ci = 0; ci < ri.length; ci++)
              ri[ci].kill(),
                ri[ci].scrollTrigger && ri[ci].scrollTrigger.kill(!1),
                (ri[ci] = null);
            ri = [];
          }
          if (ni.length > 0) {
            for (let ci = 0; ci < ni.length; ci++)
              gsapWithCSS.ticker.remove(ni[ci]);
            ni = [];
          }
        } else ri.length == 0 && Zr && ai();
      }, 1e3));
  });
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const contact = (Wr, ze) => {
    const Gr = document.querySelector("header"),
      Yr = document.querySelector(".js-header-menu"),
      Kr = Wr.querySelector(".js-contact-start"),
      Zr = Wr.querySelector(".js-contact-end"),
      Jr = Wr.querySelector(".js-form"),
      Qr = Wr.querySelector(".js-contact-bg"),
      ei = Wr.querySelector(".js-contact-formie-wrapper"),
      ti = Wr.querySelector("form"),
      ri = Wr.querySelector(".js-contact-info"),
      ni = Wr.querySelectorAll(".fui-page"),
      ii = Wr.querySelectorAll('button[type="submit"]'),
      si = Wr.querySelector(".js-contact-mainTitle"),
      li = Wr.querySelector(".js-confirm-mainTitle"),
      oi = Wr.querySelector(".js-confirm-mainText");
    CustomEase.create("inOutCubic", "0.65, 0, 0.35, 1)");
    const ui = function () {
        Gr.classList.remove("is--light");
      },
      ai = function () {
        Gr.classList.add("is--light");
      },
      hi = function () {
        ni.forEach((wi) => {
          wi.classList.remove("is-active"),
            wi.getAttribute("data-fui-page-hidden") == null &&
              wi.classList.add("is-active");
        });
      },
      ci = function () {
        const wi = si.querySelectorAll("div"),
          Ci = wi[0],
          bi = wi[1],
          Mi = si.querySelectorAll("span");
        let gi = gsapWithCSS.timeline();
        gi.fromTo(
          Mi,
          {
            y: "115%",
          },
          {
            y: 0,
            duration: 1,
            stagger: 0.08,
            ease: "power3.out",
          }
        ),
          gi.to(Ci, {
            y: "-80vh",
            transform: "scale(2.5)",
            ease: "inOutCubic",
            duration: 2,
          }),
          gi.to(
            bi,
            {
              y: "80vh",
              transform: "scale(2.5)",
              ease: "inOutCubic",
              duration: 2,
            },
            "<"
          ),
          gi.to(Kr, {
            display: "none",
          }),
          gi.delay(ze);
      },
      fi = function () {
        let wi = gsapWithCSS.timeline();
        wi.to(Yr, {
          y: "-15vh",
          ease: "inOutCubic",
          duration: 1.5,
        }),
          document.documentElement.clientWidth > 767
            ? wi
                .from(
                  Qr,
                  {
                    "--bg-position": "101%",
                    ease: "inOutCubic",
                    duration: 1.5,
                  },
                  "<"
                )
                .from(
                  Qr,
                  {
                    "--bg-center-position": "101%",
                    ease: "inOutCubic",
                    duration: 1.3,
                  },
                  ">-1.3"
                )
            : wi
                .from(
                  ei,
                  {
                    "--left-bg-position": "101%",
                    ease: "inOutCubic",
                    duration: 1.5,
                  },
                  "<"
                )
                .from(
                  ei,
                  {
                    "--right-bg-position": "101%",
                    ease: "inOutCubic",
                    duration: 1.3,
                  },
                  ">-1.3"
                ),
          ti &&
            wi.from(
              ti,
              {
                opacity: 0,
                ease: "inOutCubic",
                duration: 1.3,
              },
              ">-0.5"
            ),
          wi.add(ui, "<"),
          wi.from(
            ri,
            {
              "--scale-y": 0,
              ease: "inOutCubic",
              duration: 0.8,
            },
            ">-0.1"
          ),
          wi.delay(2 + ze);
      },
      pi = li.innerHTML
        .split("<br>")
        .map(
          (wi) =>
            `<div class="line-wrapper"><div class="line">${wi}</div></div>`
        )
        .join("");
    li.innerHTML = pi;
    const Si = oi.innerHTML
      .split("<br>")
      .map(
        (wi) => `<div class="line-wrapper"><div class="line">${wi}</div></div>`
      )
      .join("");
    oi.innerHTML = Si;
    const yi = function () {
        const wi = li.querySelectorAll(".line"),
          Ci = oi.querySelectorAll(".line");
        Zr.classList.remove("is--hidden");
        const bi = Zr.querySelectorAll(".a--text");
        gsapWithCSS.fromTo(
          wi,
          {
            y: "115%",
          },
          {
            y: 0,
            duration: 1,
            stagger: 0.1,
            ease: "power3.out",
          }
        ),
          gsapWithCSS.fromTo(
            Ci,
            {
              y: "115%",
            },
            {
              y: 0,
              duration: 1,
              stagger: 0.1,
              ease: "power3.out",
            }
          ),
          gsapWithCSS.utils.toArray(bi).forEach((Mi) => {
            gsapWithCSS.fromTo(
              Mi,
              {
                y: "115%",
              },
              {
                y: 0,
                duration: 1,
                stagger: 0.1,
                ease: "power3.out",
              }
            );
          });
      },
      Ei = function () {
        let wi = gsapWithCSS.timeline();
        wi.to(ti, {
          opacity: "0",
          duration: 0.3,
        }),
          document.documentElement.clientWidth > 767
            ? wi
                .to(
                  Qr,
                  {
                    "--bg-position": "-101%",
                    ease: "inOutCubic",
                    duration: 1.5,
                  },
                  "<"
                )
                .to(
                  Qr,
                  {
                    "--bg-center-position": "-101%",
                    ease: "inOutCubic",
                    duration: 1.3,
                  },
                  ">-1.2"
                )
            : wi
                .to(
                  ei,
                  {
                    "--left-bg-position": "-101%",
                    ease: "inOutCubic",
                    duration: 1.5,
                  },
                  "<"
                )
                .to(
                  ei,
                  {
                    "--right-bg-position": "-101%",
                    ease: "inOutCubic",
                    duration: 1.3,
                  },
                  ">-1.2"
                ),
          wi.add(ai, "<"),
          wi.to(
            ri,
            {
              "--scale-y": 0,
              ease: "inOutCubic",
              duration: 0.8,
            },
            ">-0.1"
          ),
          wi.add(yi, ">-0.2");
      },
      Pi = () => {
        ti
          .querySelector('.fui-page[data-index="0"]')
          .hasAttribute("data-fui-page-hidden") &&
          (ri.remove(),
          setTimeout(() => {
            lenis$1.resize();
          }, 100));
      };
    if (Kr) {
      hi(),
        gsapWithCSS.to(Jr, {
          opacity: 1,
          duration: 0.5,
        });
      const Ci = si.innerHTML
        .split("<br>")
        .map((bi) => `<div><span>${bi}</span></div>`)
        .join("");
      (si.innerHTML = Ci),
        ci(),
        fi(),
        document.documentElement.clientWidth < 768 && ri && Pi();
    }
    let Ai;
    window.addEventListener("resize", () => {
      clearTimeout(Ai),
        (Ai = setTimeout(() => {
          document.documentElement.clientWidth < 768 && ri && Pi();
        }, 1e3));
    });
    let Ri = Wr.querySelector(".fui-form");
    Ri.addEventListener("onAfterFormieValidate", (wi) => {
      let Ci = wi.detail.submitHandler;
      const bi = Ri.querySelector(
          '.fui-page[data-id="' + Ci.settings.currentPageId + '"]'
        ),
        Mi = bi.querySelector(".fui-btn.fui-submit");
      (Mi.disabled = !0),
        bi.getAttribute("data-index") == ii.length - 1 &&
          Zr &&
          (Ei(), lenis$1.resize()),
        document.documentElement.clientWidth < 768 &&
          ri &&
          (ri.remove(),
          setTimeout(() => {
            lenis$1.resize();
          }, 100));
    });
  },
  hour = () => {
    function Wr() {
      const ze = document.querySelector("footer .hour");
      if (ze) {
        const Gr = new Date();
        let Yr = Gr.getHours();
        (Yr = Yr % 24 || 24), (Yr = Yr.toString().padStart(2, "0"));
        const Kr = Gr.getMinutes().toString().padStart(2, "0"),
          Zr = Gr.getSeconds().toString().padStart(2, "0"),
          Jr = `${Yr}:${Kr}:${Zr}`;
        ze.textContent = Jr;
      }
    }
    setInterval(Wr, 1e3);
  };
gsapWithCSS.registerPlugin(ScrollTrigger);
gsapWithCSS.registerPlugin(CustomEase);
CustomEase.create("outQuint", "0.22, 1, 0.36, 1");
const footer = (Wr) => {
  const ze = Wr.querySelector(".js-footer"),
    Gr = Wr.querySelectorAll(".js-footer-v-background"),
    Yr = Wr.querySelector("main");
  if (Gr.length <= 0) return;
  const Kr = () => {
    gsapWithCSS.to(Gr, {
      "--pos-1": "50%",
      "--pos-2": "50%",
      "--pos-4": "50%",
      duration: 1.5,
      ease: "outQuint",
      scrollTrigger: {
        trigger: Gr,
        start: "bottom bottom",
        scrub: !0,
      },
    });
  };
  Gr &&
    (gsapWithCSS.killTweensOf(Gr),
    setTimeout(() => {
      Kr();
    }, 500)),
    ze &&
      Yr &&
      Wr.getAttribute("data-barba-namespace") != "culture" &&
      (ze.offsetHeight,
      setTimeout(() => {
        Yr.removeAttribute("style");
      }, 0));
};
var lottieExports = {},
  lottie$1 = {
    get exports() {
      return lottieExports;
    },
    set exports(Wr) {
      lottieExports = Wr;
    },
  };
(function (module, exports) {
  typeof navigator < "u" &&
    (function (Wr, ze) {
      module.exports = ze();
    })(commonjsGlobal, function () {
      var svgNS = "http://www.w3.org/2000/svg",
        locationHref = "",
        _useWebWorker = !1,
        initialDefaultFrame = -999999,
        setWebWorker = function (ze) {
          _useWebWorker = !!ze;
        },
        getWebWorker = function () {
          return _useWebWorker;
        },
        setLocationHref = function (ze) {
          locationHref = ze;
        },
        getLocationHref = function () {
          return locationHref;
        };
      function createTag(Wr) {
        return document.createElement(Wr);
      }
      function extendPrototype(Wr, ze) {
        var Gr,
          Yr = Wr.length,
          Kr;
        for (Gr = 0; Gr < Yr; Gr += 1) {
          Kr = Wr[Gr].prototype;
          for (var Zr in Kr)
            Object.prototype.hasOwnProperty.call(Kr, Zr) &&
              (ze.prototype[Zr] = Kr[Zr]);
        }
      }
      function getDescriptor(Wr, ze) {
        return Object.getOwnPropertyDescriptor(Wr, ze);
      }
      function createProxyFunction(Wr) {
        function ze() {}
        return (ze.prototype = Wr), ze;
      }
      var audioControllerFactory = (function () {
          function Wr(ze) {
            (this.audios = []),
              (this.audioFactory = ze),
              (this._volume = 1),
              (this._isMuted = !1);
          }
          return (
            (Wr.prototype = {
              addAudio: function (Gr) {
                this.audios.push(Gr);
              },
              pause: function () {
                var Gr,
                  Yr = this.audios.length;
                for (Gr = 0; Gr < Yr; Gr += 1) this.audios[Gr].pause();
              },
              resume: function () {
                var Gr,
                  Yr = this.audios.length;
                for (Gr = 0; Gr < Yr; Gr += 1) this.audios[Gr].resume();
              },
              setRate: function (Gr) {
                var Yr,
                  Kr = this.audios.length;
                for (Yr = 0; Yr < Kr; Yr += 1) this.audios[Yr].setRate(Gr);
              },
              createAudio: function (Gr) {
                return this.audioFactory
                  ? this.audioFactory(Gr)
                  : window.Howl
                  ? new window.Howl({
                      src: [Gr],
                    })
                  : {
                      isPlaying: !1,
                      play: function () {
                        this.isPlaying = !0;
                      },
                      seek: function () {
                        this.isPlaying = !1;
                      },
                      playing: function () {},
                      rate: function () {},
                      setVolume: function () {},
                    };
              },
              setAudioFactory: function (Gr) {
                this.audioFactory = Gr;
              },
              setVolume: function (Gr) {
                (this._volume = Gr), this._updateVolume();
              },
              mute: function () {
                (this._isMuted = !0), this._updateVolume();
              },
              unmute: function () {
                (this._isMuted = !1), this._updateVolume();
              },
              getVolume: function () {
                return this._volume;
              },
              _updateVolume: function () {
                var Gr,
                  Yr = this.audios.length;
                for (Gr = 0; Gr < Yr; Gr += 1)
                  this.audios[Gr].volume(
                    this._volume * (this._isMuted ? 0 : 1)
                  );
              },
            }),
            function () {
              return new Wr();
            }
          );
        })(),
        createTypedArray = (function () {
          function Wr(Gr, Yr) {
            var Kr = 0,
              Zr = [],
              Jr;
            switch (Gr) {
              case "int16":
              case "uint8c":
                Jr = 1;
                break;
              default:
                Jr = 1.1;
                break;
            }
            for (Kr = 0; Kr < Yr; Kr += 1) Zr.push(Jr);
            return Zr;
          }
          function ze(Gr, Yr) {
            return Gr === "float32"
              ? new Float32Array(Yr)
              : Gr === "int16"
              ? new Int16Array(Yr)
              : Gr === "uint8c"
              ? new Uint8ClampedArray(Yr)
              : Wr(Gr, Yr);
          }
          return typeof Uint8ClampedArray == "function" &&
            typeof Float32Array == "function"
            ? ze
            : Wr;
        })();
      function createSizedArray(Wr) {
        return Array.apply(null, {
          length: Wr,
        });
      }
      function _typeof$6(Wr) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$6 = function (Gr) {
                return typeof Gr;
              })
            : (_typeof$6 = function (Gr) {
                return Gr &&
                  typeof Symbol == "function" &&
                  Gr.constructor === Symbol &&
                  Gr !== Symbol.prototype
                  ? "symbol"
                  : typeof Gr;
              }),
          _typeof$6(Wr)
        );
      }
      var subframeEnabled = !0,
        expressionsPlugin = null,
        expressionsInterfaces = null,
        idPrefix$1 = "",
        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        bmPow = Math.pow,
        bmSqrt = Math.sqrt,
        bmFloor = Math.floor,
        bmMax = Math.max,
        bmMin = Math.min,
        BMMath = {};
      (function () {
        var Wr = [
            "abs",
            "acos",
            "acosh",
            "asin",
            "asinh",
            "atan",
            "atanh",
            "atan2",
            "ceil",
            "cbrt",
            "expm1",
            "clz32",
            "cos",
            "cosh",
            "exp",
            "floor",
            "fround",
            "hypot",
            "imul",
            "log",
            "log1p",
            "log2",
            "log10",
            "max",
            "min",
            "pow",
            "random",
            "round",
            "sign",
            "sin",
            "sinh",
            "sqrt",
            "tan",
            "tanh",
            "trunc",
            "E",
            "LN10",
            "LN2",
            "LOG10E",
            "LOG2E",
            "PI",
            "SQRT1_2",
            "SQRT2",
          ],
          ze,
          Gr = Wr.length;
        for (ze = 0; ze < Gr; ze += 1) BMMath[Wr[ze]] = Math[Wr[ze]];
      })(),
        (BMMath.random = Math.random),
        (BMMath.abs = function (Wr) {
          var ze = _typeof$6(Wr);
          if (ze === "object" && Wr.length) {
            var Gr = createSizedArray(Wr.length),
              Yr,
              Kr = Wr.length;
            for (Yr = 0; Yr < Kr; Yr += 1) Gr[Yr] = Math.abs(Wr[Yr]);
            return Gr;
          }
          return Math.abs(Wr);
        });
      var defaultCurveSegments = 150,
        degToRads = Math.PI / 180,
        roundCorner = 0.5519;
      function styleDiv(Wr) {
        (Wr.style.position = "absolute"),
          (Wr.style.top = 0),
          (Wr.style.left = 0),
          (Wr.style.display = "block"),
          (Wr.style.transformOrigin = "0 0"),
          (Wr.style.webkitTransformOrigin = "0 0"),
          (Wr.style.backfaceVisibility = "visible"),
          (Wr.style.webkitBackfaceVisibility = "visible"),
          (Wr.style.transformStyle = "preserve-3d"),
          (Wr.style.webkitTransformStyle = "preserve-3d"),
          (Wr.style.mozTransformStyle = "preserve-3d");
      }
      function BMEnterFrameEvent(Wr, ze, Gr, Yr) {
        (this.type = Wr),
          (this.currentTime = ze),
          (this.totalTime = Gr),
          (this.direction = Yr < 0 ? -1 : 1);
      }
      function BMCompleteEvent(Wr, ze) {
        (this.type = Wr), (this.direction = ze < 0 ? -1 : 1);
      }
      function BMCompleteLoopEvent(Wr, ze, Gr, Yr) {
        (this.type = Wr),
          (this.currentLoop = Gr),
          (this.totalLoops = ze),
          (this.direction = Yr < 0 ? -1 : 1);
      }
      function BMSegmentStartEvent(Wr, ze, Gr) {
        (this.type = Wr), (this.firstFrame = ze), (this.totalFrames = Gr);
      }
      function BMDestroyEvent(Wr, ze) {
        (this.type = Wr), (this.target = ze);
      }
      function BMRenderFrameErrorEvent(Wr, ze) {
        (this.type = "renderFrameError"),
          (this.nativeError = Wr),
          (this.currentTime = ze);
      }
      function BMConfigErrorEvent(Wr) {
        (this.type = "configError"), (this.nativeError = Wr);
      }
      var createElementID = (function () {
        var Wr = 0;
        return function () {
          return (Wr += 1), idPrefix$1 + "__lottie_element_" + Wr;
        };
      })();
      function HSVtoRGB(Wr, ze, Gr) {
        var Yr, Kr, Zr, Jr, Qr, ei, ti, ri;
        switch (
          ((Jr = Math.floor(Wr * 6)),
          (Qr = Wr * 6 - Jr),
          (ei = Gr * (1 - ze)),
          (ti = Gr * (1 - Qr * ze)),
          (ri = Gr * (1 - (1 - Qr) * ze)),
          Jr % 6)
        ) {
          case 0:
            (Yr = Gr), (Kr = ri), (Zr = ei);
            break;
          case 1:
            (Yr = ti), (Kr = Gr), (Zr = ei);
            break;
          case 2:
            (Yr = ei), (Kr = Gr), (Zr = ri);
            break;
          case 3:
            (Yr = ei), (Kr = ti), (Zr = Gr);
            break;
          case 4:
            (Yr = ri), (Kr = ei), (Zr = Gr);
            break;
          case 5:
            (Yr = Gr), (Kr = ei), (Zr = ti);
            break;
        }
        return [Yr, Kr, Zr];
      }
      function RGBtoHSV(Wr, ze, Gr) {
        var Yr = Math.max(Wr, ze, Gr),
          Kr = Math.min(Wr, ze, Gr),
          Zr = Yr - Kr,
          Jr,
          Qr = Yr === 0 ? 0 : Zr / Yr,
          ei = Yr / 255;
        switch (Yr) {
          case Kr:
            Jr = 0;
            break;
          case Wr:
            (Jr = ze - Gr + Zr * (ze < Gr ? 6 : 0)), (Jr /= 6 * Zr);
            break;
          case ze:
            (Jr = Gr - Wr + Zr * 2), (Jr /= 6 * Zr);
            break;
          case Gr:
            (Jr = Wr - ze + Zr * 4), (Jr /= 6 * Zr);
            break;
        }
        return [Jr, Qr, ei];
      }
      function addSaturationToRGB(Wr, ze) {
        var Gr = RGBtoHSV(Wr[0] * 255, Wr[1] * 255, Wr[2] * 255);
        return (
          (Gr[1] += ze),
          Gr[1] > 1 ? (Gr[1] = 1) : Gr[1] <= 0 && (Gr[1] = 0),
          HSVtoRGB(Gr[0], Gr[1], Gr[2])
        );
      }
      function addBrightnessToRGB(Wr, ze) {
        var Gr = RGBtoHSV(Wr[0] * 255, Wr[1] * 255, Wr[2] * 255);
        return (
          (Gr[2] += ze),
          Gr[2] > 1 ? (Gr[2] = 1) : Gr[2] < 0 && (Gr[2] = 0),
          HSVtoRGB(Gr[0], Gr[1], Gr[2])
        );
      }
      function addHueToRGB(Wr, ze) {
        var Gr = RGBtoHSV(Wr[0] * 255, Wr[1] * 255, Wr[2] * 255);
        return (
          (Gr[0] += ze / 360),
          Gr[0] > 1 ? (Gr[0] -= 1) : Gr[0] < 0 && (Gr[0] += 1),
          HSVtoRGB(Gr[0], Gr[1], Gr[2])
        );
      }
      var rgbToHex = (function () {
          var Wr = [],
            ze,
            Gr;
          for (ze = 0; ze < 256; ze += 1)
            (Gr = ze.toString(16)), (Wr[ze] = Gr.length === 1 ? "0" + Gr : Gr);
          return function (Yr, Kr, Zr) {
            return (
              Yr < 0 && (Yr = 0),
              Kr < 0 && (Kr = 0),
              Zr < 0 && (Zr = 0),
              "#" + Wr[Yr] + Wr[Kr] + Wr[Zr]
            );
          };
        })(),
        setSubframeEnabled = function (ze) {
          subframeEnabled = !!ze;
        },
        getSubframeEnabled = function () {
          return subframeEnabled;
        },
        setExpressionsPlugin = function (ze) {
          expressionsPlugin = ze;
        },
        getExpressionsPlugin = function () {
          return expressionsPlugin;
        },
        setExpressionInterfaces = function (ze) {
          expressionsInterfaces = ze;
        },
        getExpressionInterfaces = function () {
          return expressionsInterfaces;
        },
        setDefaultCurveSegments = function (ze) {
          defaultCurveSegments = ze;
        },
        getDefaultCurveSegments = function () {
          return defaultCurveSegments;
        },
        setIdPrefix = function (ze) {
          idPrefix$1 = ze;
        };
      function createNS(Wr) {
        return document.createElementNS(svgNS, Wr);
      }
      function _typeof$5(Wr) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$5 = function (Gr) {
                return typeof Gr;
              })
            : (_typeof$5 = function (Gr) {
                return Gr &&
                  typeof Symbol == "function" &&
                  Gr.constructor === Symbol &&
                  Gr !== Symbol.prototype
                  ? "symbol"
                  : typeof Gr;
              }),
          _typeof$5(Wr)
        );
      }
      var dataManager = (function () {
          var Wr = 1,
            ze = [],
            Gr,
            Yr,
            Kr = {
              onmessage: function () {},
              postMessage: function (si) {
                Gr({
                  data: si,
                });
              },
            },
            Zr = {
              postMessage: function (si) {
                Kr.onmessage({
                  data: si,
                });
              },
            };
          function Jr(ii) {
            if (window.Worker && window.Blob && getWebWorker()) {
              var si = new Blob(
                  ["var _workerSelf = self; self.onmessage = ", ii.toString()],
                  {
                    type: "text/javascript",
                  }
                ),
                li = URL.createObjectURL(si);
              return new Worker(li);
            }
            return (Gr = ii), Kr;
          }
          function Qr() {
            Yr ||
              ((Yr = Jr(function (si) {
                function li() {
                  function ui(Ci, bi) {
                    var Mi,
                      gi,
                      xi = Ci.length,
                      Ti,
                      vi,
                      Ii,
                      Oi;
                    for (gi = 0; gi < xi; gi += 1)
                      if (((Mi = Ci[gi]), "ks" in Mi && !Mi.completed)) {
                        if (((Mi.completed = !0), Mi.hasMask)) {
                          var ki = Mi.masksProperties;
                          for (vi = ki.length, Ti = 0; Ti < vi; Ti += 1)
                            if (ki[Ti].pt.k.i) di(ki[Ti].pt.k);
                            else
                              for (
                                Oi = ki[Ti].pt.k.length, Ii = 0;
                                Ii < Oi;
                                Ii += 1
                              )
                                ki[Ti].pt.k[Ii].s && di(ki[Ti].pt.k[Ii].s[0]),
                                  ki[Ti].pt.k[Ii].e && di(ki[Ti].pt.k[Ii].e[0]);
                        }
                        Mi.ty === 0
                          ? ((Mi.layers = ci(Mi.refId, bi)), ui(Mi.layers, bi))
                          : Mi.ty === 4
                          ? fi(Mi.shapes)
                          : Mi.ty === 5 && Ri(Mi);
                      }
                  }
                  function ai(Ci, bi) {
                    if (Ci) {
                      var Mi = 0,
                        gi = Ci.length;
                      for (Mi = 0; Mi < gi; Mi += 1)
                        Ci[Mi].t === 1 &&
                          ((Ci[Mi].data.layers = ci(Ci[Mi].data.refId, bi)),
                          ui(Ci[Mi].data.layers, bi));
                    }
                  }
                  function hi(Ci, bi) {
                    for (var Mi = 0, gi = bi.length; Mi < gi; ) {
                      if (bi[Mi].id === Ci) return bi[Mi];
                      Mi += 1;
                    }
                    return null;
                  }
                  function ci(Ci, bi) {
                    var Mi = hi(Ci, bi);
                    return Mi
                      ? Mi.layers.__used
                        ? JSON.parse(JSON.stringify(Mi.layers))
                        : ((Mi.layers.__used = !0), Mi.layers)
                      : null;
                  }
                  function fi(Ci) {
                    var bi,
                      Mi = Ci.length,
                      gi,
                      xi;
                    for (bi = Mi - 1; bi >= 0; bi -= 1)
                      if (Ci[bi].ty === "sh")
                        if (Ci[bi].ks.k.i) di(Ci[bi].ks.k);
                        else
                          for (
                            xi = Ci[bi].ks.k.length, gi = 0;
                            gi < xi;
                            gi += 1
                          )
                            Ci[bi].ks.k[gi].s && di(Ci[bi].ks.k[gi].s[0]),
                              Ci[bi].ks.k[gi].e && di(Ci[bi].ks.k[gi].e[0]);
                      else Ci[bi].ty === "gr" && fi(Ci[bi].it);
                  }
                  function di(Ci) {
                    var bi,
                      Mi = Ci.i.length;
                    for (bi = 0; bi < Mi; bi += 1)
                      (Ci.i[bi][0] += Ci.v[bi][0]),
                        (Ci.i[bi][1] += Ci.v[bi][1]),
                        (Ci.o[bi][0] += Ci.v[bi][0]),
                        (Ci.o[bi][1] += Ci.v[bi][1]);
                  }
                  function pi(Ci, bi) {
                    var Mi = bi ? bi.split(".") : [100, 100, 100];
                    return Ci[0] > Mi[0]
                      ? !0
                      : Mi[0] > Ci[0]
                      ? !1
                      : Ci[1] > Mi[1]
                      ? !0
                      : Mi[1] > Ci[1]
                      ? !1
                      : Ci[2] > Mi[2]
                      ? !0
                      : Mi[2] > Ci[2]
                      ? !1
                      : null;
                  }
                  var mi = (function () {
                      var Ci = [4, 4, 14];
                      function bi(gi) {
                        var xi = gi.t.d;
                        gi.t.d = {
                          k: [
                            {
                              s: xi,
                              t: 0,
                            },
                          ],
                        };
                      }
                      function Mi(gi) {
                        var xi,
                          Ti = gi.length;
                        for (xi = 0; xi < Ti; xi += 1)
                          gi[xi].ty === 5 && bi(gi[xi]);
                      }
                      return function (gi) {
                        if (pi(Ci, gi.v) && (Mi(gi.layers), gi.assets)) {
                          var xi,
                            Ti = gi.assets.length;
                          for (xi = 0; xi < Ti; xi += 1)
                            gi.assets[xi].layers && Mi(gi.assets[xi].layers);
                        }
                      };
                    })(),
                    Si = (function () {
                      var Ci = [4, 7, 99];
                      return function (bi) {
                        if (bi.chars && !pi(Ci, bi.v)) {
                          var Mi,
                            gi = bi.chars.length;
                          for (Mi = 0; Mi < gi; Mi += 1) {
                            var xi = bi.chars[Mi];
                            xi.data &&
                              xi.data.shapes &&
                              (fi(xi.data.shapes),
                              (xi.data.ip = 0),
                              (xi.data.op = 99999),
                              (xi.data.st = 0),
                              (xi.data.sr = 1),
                              (xi.data.ks = {
                                p: {
                                  k: [0, 0],
                                  a: 0,
                                },
                                s: {
                                  k: [100, 100],
                                  a: 0,
                                },
                                a: {
                                  k: [0, 0],
                                  a: 0,
                                },
                                r: {
                                  k: 0,
                                  a: 0,
                                },
                                o: {
                                  k: 100,
                                  a: 0,
                                },
                              }),
                              bi.chars[Mi].t ||
                                (xi.data.shapes.push({
                                  ty: "no",
                                }),
                                xi.data.shapes[0].it.push({
                                  p: {
                                    k: [0, 0],
                                    a: 0,
                                  },
                                  s: {
                                    k: [100, 100],
                                    a: 0,
                                  },
                                  a: {
                                    k: [0, 0],
                                    a: 0,
                                  },
                                  r: {
                                    k: 0,
                                    a: 0,
                                  },
                                  o: {
                                    k: 100,
                                    a: 0,
                                  },
                                  sk: {
                                    k: 0,
                                    a: 0,
                                  },
                                  sa: {
                                    k: 0,
                                    a: 0,
                                  },
                                  ty: "tr",
                                })));
                          }
                        }
                      };
                    })(),
                    yi = (function () {
                      var Ci = [5, 7, 15];
                      function bi(gi) {
                        var xi = gi.t.p;
                        typeof xi.a == "number" &&
                          (xi.a = {
                            a: 0,
                            k: xi.a,
                          }),
                          typeof xi.p == "number" &&
                            (xi.p = {
                              a: 0,
                              k: xi.p,
                            }),
                          typeof xi.r == "number" &&
                            (xi.r = {
                              a: 0,
                              k: xi.r,
                            });
                      }
                      function Mi(gi) {
                        var xi,
                          Ti = gi.length;
                        for (xi = 0; xi < Ti; xi += 1)
                          gi[xi].ty === 5 && bi(gi[xi]);
                      }
                      return function (gi) {
                        if (pi(Ci, gi.v) && (Mi(gi.layers), gi.assets)) {
                          var xi,
                            Ti = gi.assets.length;
                          for (xi = 0; xi < Ti; xi += 1)
                            gi.assets[xi].layers && Mi(gi.assets[xi].layers);
                        }
                      };
                    })(),
                    Ei = (function () {
                      var Ci = [4, 1, 9];
                      function bi(gi) {
                        var xi,
                          Ti = gi.length,
                          vi,
                          Ii;
                        for (xi = 0; xi < Ti; xi += 1)
                          if (gi[xi].ty === "gr") bi(gi[xi].it);
                          else if (gi[xi].ty === "fl" || gi[xi].ty === "st")
                            if (gi[xi].c.k && gi[xi].c.k[0].i)
                              for (
                                Ii = gi[xi].c.k.length, vi = 0;
                                vi < Ii;
                                vi += 1
                              )
                                gi[xi].c.k[vi].s &&
                                  ((gi[xi].c.k[vi].s[0] /= 255),
                                  (gi[xi].c.k[vi].s[1] /= 255),
                                  (gi[xi].c.k[vi].s[2] /= 255),
                                  (gi[xi].c.k[vi].s[3] /= 255)),
                                  gi[xi].c.k[vi].e &&
                                    ((gi[xi].c.k[vi].e[0] /= 255),
                                    (gi[xi].c.k[vi].e[1] /= 255),
                                    (gi[xi].c.k[vi].e[2] /= 255),
                                    (gi[xi].c.k[vi].e[3] /= 255));
                            else
                              (gi[xi].c.k[0] /= 255),
                                (gi[xi].c.k[1] /= 255),
                                (gi[xi].c.k[2] /= 255),
                                (gi[xi].c.k[3] /= 255);
                      }
                      function Mi(gi) {
                        var xi,
                          Ti = gi.length;
                        for (xi = 0; xi < Ti; xi += 1)
                          gi[xi].ty === 4 && bi(gi[xi].shapes);
                      }
                      return function (gi) {
                        if (pi(Ci, gi.v) && (Mi(gi.layers), gi.assets)) {
                          var xi,
                            Ti = gi.assets.length;
                          for (xi = 0; xi < Ti; xi += 1)
                            gi.assets[xi].layers && Mi(gi.assets[xi].layers);
                        }
                      };
                    })(),
                    Pi = (function () {
                      var Ci = [4, 4, 18];
                      function bi(gi) {
                        var xi,
                          Ti = gi.length,
                          vi,
                          Ii;
                        for (xi = Ti - 1; xi >= 0; xi -= 1)
                          if (gi[xi].ty === "sh")
                            if (gi[xi].ks.k.i) gi[xi].ks.k.c = gi[xi].closed;
                            else
                              for (
                                Ii = gi[xi].ks.k.length, vi = 0;
                                vi < Ii;
                                vi += 1
                              )
                                gi[xi].ks.k[vi].s &&
                                  (gi[xi].ks.k[vi].s[0].c = gi[xi].closed),
                                  gi[xi].ks.k[vi].e &&
                                    (gi[xi].ks.k[vi].e[0].c = gi[xi].closed);
                          else gi[xi].ty === "gr" && bi(gi[xi].it);
                      }
                      function Mi(gi) {
                        var xi,
                          Ti,
                          vi = gi.length,
                          Ii,
                          Oi,
                          ki,
                          Bi;
                        for (Ti = 0; Ti < vi; Ti += 1) {
                          if (((xi = gi[Ti]), xi.hasMask)) {
                            var Xi = xi.masksProperties;
                            for (Oi = Xi.length, Ii = 0; Ii < Oi; Ii += 1)
                              if (Xi[Ii].pt.k.i) Xi[Ii].pt.k.c = Xi[Ii].cl;
                              else
                                for (
                                  Bi = Xi[Ii].pt.k.length, ki = 0;
                                  ki < Bi;
                                  ki += 1
                                )
                                  Xi[Ii].pt.k[ki].s &&
                                    (Xi[Ii].pt.k[ki].s[0].c = Xi[Ii].cl),
                                    Xi[Ii].pt.k[ki].e &&
                                      (Xi[Ii].pt.k[ki].e[0].c = Xi[Ii].cl);
                          }
                          xi.ty === 4 && bi(xi.shapes);
                        }
                      }
                      return function (gi) {
                        if (pi(Ci, gi.v) && (Mi(gi.layers), gi.assets)) {
                          var xi,
                            Ti = gi.assets.length;
                          for (xi = 0; xi < Ti; xi += 1)
                            gi.assets[xi].layers && Mi(gi.assets[xi].layers);
                        }
                      };
                    })();
                  function Ai(Ci) {
                    Ci.__complete ||
                      (Ei(Ci),
                      mi(Ci),
                      Si(Ci),
                      yi(Ci),
                      Pi(Ci),
                      ui(Ci.layers, Ci.assets),
                      ai(Ci.chars, Ci.assets),
                      (Ci.__complete = !0));
                  }
                  function Ri(Ci) {
                    Ci.t.a.length === 0 && "m" in Ci.t.p;
                  }
                  var wi = {};
                  return (
                    (wi.completeData = Ai),
                    (wi.checkColors = Ei),
                    (wi.checkChars = Si),
                    (wi.checkPathProperties = yi),
                    (wi.checkShapes = Pi),
                    (wi.completeLayers = ui),
                    wi
                  );
                }
                if (
                  (Zr.dataManager || (Zr.dataManager = li()),
                  Zr.assetLoader ||
                    (Zr.assetLoader = (function () {
                      function ui(hi) {
                        var ci = hi.getResponseHeader("content-type");
                        return (ci &&
                          hi.responseType === "json" &&
                          ci.indexOf("json") !== -1) ||
                          (hi.response && _typeof$5(hi.response) === "object")
                          ? hi.response
                          : hi.response && typeof hi.response == "string"
                          ? JSON.parse(hi.response)
                          : hi.responseText
                          ? JSON.parse(hi.responseText)
                          : null;
                      }
                      function ai(hi, ci, fi, di) {
                        var pi,
                          mi = new XMLHttpRequest();
                        try {
                          mi.responseType = "json";
                        } catch (Si) {}
                        mi.onreadystatechange = function () {
                          if (mi.readyState === 4)
                            if (mi.status === 200) (pi = ui(mi)), fi(pi);
                            else
                              try {
                                (pi = ui(mi)), fi(pi);
                              } catch (Si) {
                                di && di(Si);
                              }
                        };
                        try {
                          mi.open(["G", "E", "T"].join(""), hi, !0);
                        } catch (Si) {
                          mi.open(["G", "E", "T"].join(""), ci + "/" + hi, !0);
                        }
                        mi.send();
                      }
                      return {
                        load: ai,
                      };
                    })()),
                  si.data.type === "loadAnimation")
                )
                  Zr.assetLoader.load(
                    si.data.path,
                    si.data.fullPath,
                    function (ui) {
                      Zr.dataManager.completeData(ui),
                        Zr.postMessage({
                          id: si.data.id,
                          payload: ui,
                          status: "success",
                        });
                    },
                    function () {
                      Zr.postMessage({
                        id: si.data.id,
                        status: "error",
                      });
                    }
                  );
                else if (si.data.type === "complete") {
                  var oi = si.data.animation;
                  Zr.dataManager.completeData(oi),
                    Zr.postMessage({
                      id: si.data.id,
                      payload: oi,
                      status: "success",
                    });
                } else
                  si.data.type === "loadData" &&
                    Zr.assetLoader.load(
                      si.data.path,
                      si.data.fullPath,
                      function (ui) {
                        Zr.postMessage({
                          id: si.data.id,
                          payload: ui,
                          status: "success",
                        });
                      },
                      function () {
                        Zr.postMessage({
                          id: si.data.id,
                          status: "error",
                        });
                      }
                    );
              })),
              (Yr.onmessage = function (ii) {
                var si = ii.data,
                  li = si.id,
                  oi = ze[li];
                (ze[li] = null),
                  si.status === "success"
                    ? oi.onComplete(si.payload)
                    : oi.onError && oi.onError();
              }));
          }
          function ei(ii, si) {
            Wr += 1;
            var li = "processId_" + Wr;
            return (
              (ze[li] = {
                onComplete: ii,
                onError: si,
              }),
              li
            );
          }
          function ti(ii, si, li) {
            Qr();
            var oi = ei(si, li);
            Yr.postMessage({
              type: "loadAnimation",
              path: ii,
              fullPath: window.location.origin + window.location.pathname,
              id: oi,
            });
          }
          function ri(ii, si, li) {
            Qr();
            var oi = ei(si, li);
            Yr.postMessage({
              type: "loadData",
              path: ii,
              fullPath: window.location.origin + window.location.pathname,
              id: oi,
            });
          }
          function ni(ii, si, li) {
            Qr();
            var oi = ei(si, li);
            Yr.postMessage({
              type: "complete",
              animation: ii,
              id: oi,
            });
          }
          return {
            loadAnimation: ti,
            loadData: ri,
            completeAnimation: ni,
          };
        })(),
        ImagePreloader = (function () {
          var Wr = (function () {
            var ai = createTag("canvas");
            (ai.width = 1), (ai.height = 1);
            var hi = ai.getContext("2d");
            return (
              (hi.fillStyle = "rgba(0,0,0,0)"), hi.fillRect(0, 0, 1, 1), ai
            );
          })();
          function ze() {
            (this.loadedAssets += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null);
          }
          function Gr() {
            (this.loadedFootagesCount += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null);
          }
          function Yr(ai, hi, ci) {
            var fi = "";
            if (ai.e) fi = ai.p;
            else if (hi) {
              var di = ai.p;
              di.indexOf("images/") !== -1 && (di = di.split("/")[1]),
                (fi = hi + di);
            } else (fi = ci), (fi += ai.u ? ai.u : ""), (fi += ai.p);
            return fi;
          }
          function Kr(ai) {
            var hi = 0,
              ci = setInterval(
                function () {
                  var fi = ai.getBBox();
                  (fi.width || hi > 500) &&
                    (this._imageLoaded(), clearInterval(ci)),
                    (hi += 1);
                }.bind(this),
                50
              );
          }
          function Zr(ai) {
            var hi = Yr(ai, this.assetsPath, this.path),
              ci = createNS("image");
            isSafari
              ? this.testImageLoaded(ci)
              : ci.addEventListener("load", this._imageLoaded, !1),
              ci.addEventListener(
                "error",
                function () {
                  (fi.img = Wr), this._imageLoaded();
                }.bind(this),
                !1
              ),
              ci.setAttributeNS("http://www.w3.org/1999/xlink", "href", hi),
              this._elementHelper.append
                ? this._elementHelper.append(ci)
                : this._elementHelper.appendChild(ci);
            var fi = {
              img: ci,
              assetData: ai,
            };
            return fi;
          }
          function Jr(ai) {
            var hi = Yr(ai, this.assetsPath, this.path),
              ci = createTag("img");
            (ci.crossOrigin = "anonymous"),
              ci.addEventListener("load", this._imageLoaded, !1),
              ci.addEventListener(
                "error",
                function () {
                  (fi.img = Wr), this._imageLoaded();
                }.bind(this),
                !1
              ),
              (ci.src = hi);
            var fi = {
              img: ci,
              assetData: ai,
            };
            return fi;
          }
          function Qr(ai) {
            var hi = {
                assetData: ai,
              },
              ci = Yr(ai, this.assetsPath, this.path);
            return (
              dataManager.loadData(
                ci,
                function (fi) {
                  (hi.img = fi), this._footageLoaded();
                }.bind(this),
                function () {
                  (hi.img = {}), this._footageLoaded();
                }.bind(this)
              ),
              hi
            );
          }
          function ei(ai, hi) {
            this.imagesLoadedCb = hi;
            var ci,
              fi = ai.length;
            for (ci = 0; ci < fi; ci += 1)
              ai[ci].layers ||
                (!ai[ci].t || ai[ci].t === "seq"
                  ? ((this.totalImages += 1),
                    this.images.push(this._createImageData(ai[ci])))
                  : ai[ci].t === 3 &&
                    ((this.totalFootages += 1),
                    this.images.push(this.createFootageData(ai[ci]))));
          }
          function ti(ai) {
            this.path = ai || "";
          }
          function ri(ai) {
            this.assetsPath = ai || "";
          }
          function ni(ai) {
            for (var hi = 0, ci = this.images.length; hi < ci; ) {
              if (this.images[hi].assetData === ai) return this.images[hi].img;
              hi += 1;
            }
            return null;
          }
          function ii() {
            (this.imagesLoadedCb = null), (this.images.length = 0);
          }
          function si() {
            return this.totalImages === this.loadedAssets;
          }
          function li() {
            return this.totalFootages === this.loadedFootagesCount;
          }
          function oi(ai, hi) {
            ai === "svg"
              ? ((this._elementHelper = hi),
                (this._createImageData = this.createImageData.bind(this)))
              : (this._createImageData = this.createImgData.bind(this));
          }
          function ui() {
            (this._imageLoaded = ze.bind(this)),
              (this._footageLoaded = Gr.bind(this)),
              (this.testImageLoaded = Kr.bind(this)),
              (this.createFootageData = Qr.bind(this)),
              (this.assetsPath = ""),
              (this.path = ""),
              (this.totalImages = 0),
              (this.totalFootages = 0),
              (this.loadedAssets = 0),
              (this.loadedFootagesCount = 0),
              (this.imagesLoadedCb = null),
              (this.images = []);
          }
          return (
            (ui.prototype = {
              loadAssets: ei,
              setAssetsPath: ri,
              setPath: ti,
              loadedImages: si,
              loadedFootages: li,
              destroy: ii,
              getAsset: ni,
              createImgData: Jr,
              createImageData: Zr,
              imageLoaded: ze,
              footageLoaded: Gr,
              setCacheType: oi,
            }),
            ui
          );
        })();
      function BaseEvent() {}
      BaseEvent.prototype = {
        triggerEvent: function (ze, Gr) {
          if (this._cbs[ze])
            for (var Yr = this._cbs[ze], Kr = 0; Kr < Yr.length; Kr += 1)
              Yr[Kr](Gr);
        },
        addEventListener: function (ze, Gr) {
          return (
            this._cbs[ze] || (this._cbs[ze] = []),
            this._cbs[ze].push(Gr),
            function () {
              this.removeEventListener(ze, Gr);
            }.bind(this)
          );
        },
        removeEventListener: function (ze, Gr) {
          if (!Gr) this._cbs[ze] = null;
          else if (this._cbs[ze]) {
            for (var Yr = 0, Kr = this._cbs[ze].length; Yr < Kr; )
              this._cbs[ze][Yr] === Gr &&
                (this._cbs[ze].splice(Yr, 1), (Yr -= 1), (Kr -= 1)),
                (Yr += 1);
            this._cbs[ze].length || (this._cbs[ze] = null);
          }
        },
      };
      var markerParser = (function () {
          function Wr(ze) {
            for (
              var Gr = ze.split(`\r
`),
                Yr = {},
                Kr,
                Zr = 0,
                Jr = 0;
              Jr < Gr.length;
              Jr += 1
            )
              (Kr = Gr[Jr].split(":")),
                Kr.length === 2 && ((Yr[Kr[0]] = Kr[1].trim()), (Zr += 1));
            if (Zr === 0) throw new Error();
            return Yr;
          }
          return function (ze) {
            for (var Gr = [], Yr = 0; Yr < ze.length; Yr += 1) {
              var Kr = ze[Yr],
                Zr = {
                  time: Kr.tm,
                  duration: Kr.dr,
                };
              try {
                Zr.payload = JSON.parse(ze[Yr].cm);
              } catch (Jr) {
                try {
                  Zr.payload = Wr(ze[Yr].cm);
                } catch (Qr) {
                  Zr.payload = {
                    name: ze[Yr].cm,
                  };
                }
              }
              Gr.push(Zr);
            }
            return Gr;
          };
        })(),
        ProjectInterface = (function () {
          function Wr(ze) {
            this.compositions.push(ze);
          }
          return function () {
            function ze(Gr) {
              for (var Yr = 0, Kr = this.compositions.length; Yr < Kr; ) {
                if (
                  this.compositions[Yr].data &&
                  this.compositions[Yr].data.nm === Gr
                )
                  return (
                    this.compositions[Yr].prepareFrame &&
                      this.compositions[Yr].data.xt &&
                      this.compositions[Yr].prepareFrame(this.currentFrame),
                    this.compositions[Yr].compInterface
                  );
                Yr += 1;
              }
              return null;
            }
            return (
              (ze.compositions = []),
              (ze.currentFrame = 0),
              (ze.registerComposition = Wr),
              ze
            );
          };
        })(),
        renderers = {},
        registerRenderer = function (ze, Gr) {
          renderers[ze] = Gr;
        };
      function getRenderer(Wr) {
        return renderers[Wr];
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) return "canvas";
        for (var Wr in renderers) if (renderers[Wr]) return Wr;
        return "";
      }
      function _typeof$4(Wr) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$4 = function (Gr) {
                return typeof Gr;
              })
            : (_typeof$4 = function (Gr) {
                return Gr &&
                  typeof Symbol == "function" &&
                  Gr.constructor === Symbol &&
                  Gr !== Symbol.prototype
                  ? "symbol"
                  : typeof Gr;
              }),
          _typeof$4(Wr)
        );
      }
      var AnimationItem = function () {
        (this._cbs = []),
          (this.name = ""),
          (this.path = ""),
          (this.isLoaded = !1),
          (this.currentFrame = 0),
          (this.currentRawFrame = 0),
          (this.firstFrame = 0),
          (this.totalFrames = 0),
          (this.frameRate = 0),
          (this.frameMult = 0),
          (this.playSpeed = 1),
          (this.playDirection = 1),
          (this.playCount = 0),
          (this.animationData = {}),
          (this.assets = []),
          (this.isPaused = !0),
          (this.autoplay = !1),
          (this.loop = !0),
          (this.renderer = null),
          (this.animationID = createElementID()),
          (this.assetsPath = ""),
          (this.timeCompleted = 0),
          (this.segmentPos = 0),
          (this.isSubframeEnabled = getSubframeEnabled()),
          (this.segments = []),
          (this._idle = !0),
          (this._completedLoop = !1),
          (this.projectInterface = ProjectInterface()),
          (this.imagePreloader = new ImagePreloader()),
          (this.audioController = audioControllerFactory()),
          (this.markers = []),
          (this.configAnimation = this.configAnimation.bind(this)),
          (this.onSetupError = this.onSetupError.bind(this)),
          (this.onSegmentComplete = this.onSegmentComplete.bind(this)),
          (this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0)),
          (this.expressionsPlugin = getExpressionsPlugin());
      };
      extendPrototype([BaseEvent], AnimationItem),
        (AnimationItem.prototype.setParams = function (Wr) {
          (Wr.wrapper || Wr.container) &&
            (this.wrapper = Wr.wrapper || Wr.container);
          var ze = "svg";
          Wr.animType ? (ze = Wr.animType) : Wr.renderer && (ze = Wr.renderer);
          var Gr = getRenderer(ze);
          (this.renderer = new Gr(this, Wr.rendererSettings)),
            this.imagePreloader.setCacheType(ze, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            (this.animType = ze),
            Wr.loop === "" ||
            Wr.loop === null ||
            Wr.loop === void 0 ||
            Wr.loop === !0
              ? (this.loop = !0)
              : Wr.loop === !1
              ? (this.loop = !1)
              : (this.loop = parseInt(Wr.loop, 10)),
            (this.autoplay = "autoplay" in Wr ? Wr.autoplay : !0),
            (this.name = Wr.name ? Wr.name : ""),
            (this.autoloadSegments = Object.prototype.hasOwnProperty.call(
              Wr,
              "autoloadSegments"
            )
              ? Wr.autoloadSegments
              : !0),
            (this.assetsPath = Wr.assetsPath),
            (this.initialSegment = Wr.initialSegment),
            Wr.audioFactory &&
              this.audioController.setAudioFactory(Wr.audioFactory),
            Wr.animationData
              ? this.setupAnimation(Wr.animationData)
              : Wr.path &&
                (Wr.path.lastIndexOf("\\") !== -1
                  ? (this.path = Wr.path.substr(
                      0,
                      Wr.path.lastIndexOf("\\") + 1
                    ))
                  : (this.path = Wr.path.substr(
                      0,
                      Wr.path.lastIndexOf("/") + 1
                    )),
                (this.fileName = Wr.path.substr(Wr.path.lastIndexOf("/") + 1)),
                (this.fileName = this.fileName.substr(
                  0,
                  this.fileName.lastIndexOf(".json")
                )),
                dataManager.loadAnimation(
                  Wr.path,
                  this.configAnimation,
                  this.onSetupError
                ));
        }),
        (AnimationItem.prototype.onSetupError = function () {
          this.trigger("data_failed");
        }),
        (AnimationItem.prototype.setupAnimation = function (Wr) {
          dataManager.completeAnimation(Wr, this.configAnimation);
        }),
        (AnimationItem.prototype.setData = function (Wr, ze) {
          ze && _typeof$4(ze) !== "object" && (ze = JSON.parse(ze));
          var Gr = {
              wrapper: Wr,
              animationData: ze,
            },
            Yr = Wr.attributes;
          (Gr.path = Yr.getNamedItem("data-animation-path")
            ? Yr.getNamedItem("data-animation-path").value
            : Yr.getNamedItem("data-bm-path")
            ? Yr.getNamedItem("data-bm-path").value
            : Yr.getNamedItem("bm-path")
            ? Yr.getNamedItem("bm-path").value
            : ""),
            (Gr.animType = Yr.getNamedItem("data-anim-type")
              ? Yr.getNamedItem("data-anim-type").value
              : Yr.getNamedItem("data-bm-type")
              ? Yr.getNamedItem("data-bm-type").value
              : Yr.getNamedItem("bm-type")
              ? Yr.getNamedItem("bm-type").value
              : Yr.getNamedItem("data-bm-renderer")
              ? Yr.getNamedItem("data-bm-renderer").value
              : Yr.getNamedItem("bm-renderer")
              ? Yr.getNamedItem("bm-renderer").value
              : getRegisteredRenderer() || "canvas");
          var Kr = Yr.getNamedItem("data-anim-loop")
            ? Yr.getNamedItem("data-anim-loop").value
            : Yr.getNamedItem("data-bm-loop")
            ? Yr.getNamedItem("data-bm-loop").value
            : Yr.getNamedItem("bm-loop")
            ? Yr.getNamedItem("bm-loop").value
            : "";
          Kr === "false"
            ? (Gr.loop = !1)
            : Kr === "true"
            ? (Gr.loop = !0)
            : Kr !== "" && (Gr.loop = parseInt(Kr, 10));
          var Zr = Yr.getNamedItem("data-anim-autoplay")
            ? Yr.getNamedItem("data-anim-autoplay").value
            : Yr.getNamedItem("data-bm-autoplay")
            ? Yr.getNamedItem("data-bm-autoplay").value
            : Yr.getNamedItem("bm-autoplay")
            ? Yr.getNamedItem("bm-autoplay").value
            : !0;
          (Gr.autoplay = Zr !== "false"),
            (Gr.name = Yr.getNamedItem("data-name")
              ? Yr.getNamedItem("data-name").value
              : Yr.getNamedItem("data-bm-name")
              ? Yr.getNamedItem("data-bm-name").value
              : Yr.getNamedItem("bm-name")
              ? Yr.getNamedItem("bm-name").value
              : "");
          var Jr = Yr.getNamedItem("data-anim-prerender")
            ? Yr.getNamedItem("data-anim-prerender").value
            : Yr.getNamedItem("data-bm-prerender")
            ? Yr.getNamedItem("data-bm-prerender").value
            : Yr.getNamedItem("bm-prerender")
            ? Yr.getNamedItem("bm-prerender").value
            : "";
          Jr === "false" && (Gr.prerender = !1),
            Gr.path ? this.setParams(Gr) : this.trigger("destroy");
        }),
        (AnimationItem.prototype.includeLayers = function (Wr) {
          Wr.op > this.animationData.op &&
            ((this.animationData.op = Wr.op),
            (this.totalFrames = Math.floor(Wr.op - this.animationData.ip)));
          var ze = this.animationData.layers,
            Gr,
            Yr = ze.length,
            Kr = Wr.layers,
            Zr,
            Jr = Kr.length;
          for (Zr = 0; Zr < Jr; Zr += 1)
            for (Gr = 0; Gr < Yr; ) {
              if (ze[Gr].id === Kr[Zr].id) {
                ze[Gr] = Kr[Zr];
                break;
              }
              Gr += 1;
            }
          if (
            ((Wr.chars || Wr.fonts) &&
              (this.renderer.globalData.fontManager.addChars(Wr.chars),
              this.renderer.globalData.fontManager.addFonts(
                Wr.fonts,
                this.renderer.globalData.defs
              )),
            Wr.assets)
          )
            for (Yr = Wr.assets.length, Gr = 0; Gr < Yr; Gr += 1)
              this.animationData.assets.push(Wr.assets[Gr]);
          (this.animationData.__complete = !1),
            dataManager.completeAnimation(
              this.animationData,
              this.onSegmentComplete
            );
        }),
        (AnimationItem.prototype.onSegmentComplete = function (Wr) {
          this.animationData = Wr;
          var ze = getExpressionsPlugin();
          ze && ze.initExpressions(this), this.loadNextSegment();
        }),
        (AnimationItem.prototype.loadNextSegment = function () {
          var Wr = this.animationData.segments;
          if (!Wr || Wr.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready"), (this.timeCompleted = this.totalFrames);
            return;
          }
          var ze = Wr.shift();
          this.timeCompleted = ze.time * this.frameRate;
          var Gr = this.path + this.fileName + "_" + this.segmentPos + ".json";
          (this.segmentPos += 1),
            dataManager.loadData(
              Gr,
              this.includeLayers.bind(this),
              function () {
                this.trigger("data_failed");
              }.bind(this)
            );
        }),
        (AnimationItem.prototype.loadSegments = function () {
          var Wr = this.animationData.segments;
          Wr || (this.timeCompleted = this.totalFrames), this.loadNextSegment();
        }),
        (AnimationItem.prototype.imagesLoaded = function () {
          this.trigger("loaded_images"), this.checkLoaded();
        }),
        (AnimationItem.prototype.preloadImages = function () {
          this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(
              this.animationData.assets,
              this.imagesLoaded.bind(this)
            );
        }),
        (AnimationItem.prototype.configAnimation = function (Wr) {
          if (this.renderer)
            try {
              (this.animationData = Wr),
                this.initialSegment
                  ? ((this.totalFrames = Math.floor(
                      this.initialSegment[1] - this.initialSegment[0]
                    )),
                    (this.firstFrame = Math.round(this.initialSegment[0])))
                  : ((this.totalFrames = Math.floor(
                      this.animationData.op - this.animationData.ip
                    )),
                    (this.firstFrame = Math.round(this.animationData.ip))),
                this.renderer.configAnimation(Wr),
                Wr.assets || (Wr.assets = []),
                (this.assets = this.animationData.assets),
                (this.frameRate = this.animationData.fr),
                (this.frameMult = this.animationData.fr / 1e3),
                this.renderer.searchExtraCompositions(Wr.assets),
                (this.markers = markerParser(Wr.markers || [])),
                this.trigger("config_ready"),
                this.preloadImages(),
                this.loadSegments(),
                this.updaFrameModifier(),
                this.waitForFontsLoaded(),
                this.isPaused && this.audioController.pause();
            } catch (ze) {
              this.triggerConfigError(ze);
            }
        }),
        (AnimationItem.prototype.waitForFontsLoaded = function () {
          this.renderer &&
            (this.renderer.globalData.fontManager.isLoaded
              ? this.checkLoaded()
              : setTimeout(this.waitForFontsLoaded.bind(this), 20));
        }),
        (AnimationItem.prototype.checkLoaded = function () {
          if (
            !this.isLoaded &&
            this.renderer.globalData.fontManager.isLoaded &&
            (this.imagePreloader.loadedImages() ||
              this.renderer.rendererType !== "canvas") &&
            this.imagePreloader.loadedFootages()
          ) {
            this.isLoaded = !0;
            var Wr = getExpressionsPlugin();
            Wr && Wr.initExpressions(this),
              this.renderer.initItems(),
              setTimeout(
                function () {
                  this.trigger("DOMLoaded");
                }.bind(this),
                0
              ),
              this.gotoFrame(),
              this.autoplay && this.play();
          }
        }),
        (AnimationItem.prototype.resize = function (Wr, ze) {
          var Gr = typeof Wr == "number" ? Wr : void 0,
            Yr = typeof ze == "number" ? ze : void 0;
          this.renderer.updateContainerSize(Gr, Yr);
        }),
        (AnimationItem.prototype.setSubframe = function (Wr) {
          this.isSubframeEnabled = !!Wr;
        }),
        (AnimationItem.prototype.gotoFrame = function () {
          (this.currentFrame = this.isSubframeEnabled
            ? this.currentRawFrame
            : ~~this.currentRawFrame),
            this.timeCompleted !== this.totalFrames &&
              this.currentFrame > this.timeCompleted &&
              (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame");
        }),
        (AnimationItem.prototype.renderFrame = function () {
          if (!(this.isLoaded === !1 || !this.renderer))
            try {
              this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                this.renderer.renderFrame(this.currentFrame + this.firstFrame);
            } catch (Wr) {
              this.triggerRenderFrameError(Wr);
            }
        }),
        (AnimationItem.prototype.play = function (Wr) {
          (Wr && this.name !== Wr) ||
            (this.isPaused === !0 &&
              ((this.isPaused = !1),
              this.trigger("_play"),
              this.audioController.resume(),
              this._idle && ((this._idle = !1), this.trigger("_active"))));
        }),
        (AnimationItem.prototype.pause = function (Wr) {
          (Wr && this.name !== Wr) ||
            (this.isPaused === !1 &&
              ((this.isPaused = !0),
              this.trigger("_pause"),
              (this._idle = !0),
              this.trigger("_idle"),
              this.audioController.pause()));
        }),
        (AnimationItem.prototype.togglePause = function (Wr) {
          (Wr && this.name !== Wr) ||
            (this.isPaused === !0 ? this.play() : this.pause());
        }),
        (AnimationItem.prototype.stop = function (Wr) {
          (Wr && this.name !== Wr) ||
            (this.pause(),
            (this.playCount = 0),
            (this._completedLoop = !1),
            this.setCurrentRawFrameValue(0));
        }),
        (AnimationItem.prototype.getMarkerData = function (Wr) {
          for (var ze, Gr = 0; Gr < this.markers.length; Gr += 1)
            if (((ze = this.markers[Gr]), ze.payload && ze.payload.name === Wr))
              return ze;
          return null;
        }),
        (AnimationItem.prototype.goToAndStop = function (Wr, ze, Gr) {
          if (!(Gr && this.name !== Gr)) {
            var Yr = Number(Wr);
            if (isNaN(Yr)) {
              var Kr = this.getMarkerData(Wr);
              Kr && this.goToAndStop(Kr.time, !0);
            } else
              ze
                ? this.setCurrentRawFrameValue(Wr)
                : this.setCurrentRawFrameValue(Wr * this.frameModifier);
            this.pause();
          }
        }),
        (AnimationItem.prototype.goToAndPlay = function (Wr, ze, Gr) {
          if (!(Gr && this.name !== Gr)) {
            var Yr = Number(Wr);
            if (isNaN(Yr)) {
              var Kr = this.getMarkerData(Wr);
              Kr &&
                (Kr.duration
                  ? this.playSegments([Kr.time, Kr.time + Kr.duration], !0)
                  : this.goToAndStop(Kr.time, !0));
            } else this.goToAndStop(Yr, ze, Gr);
            this.play();
          }
        }),
        (AnimationItem.prototype.advanceTime = function (Wr) {
          if (!(this.isPaused === !0 || this.isLoaded === !1)) {
            var ze = this.currentRawFrame + Wr * this.frameModifier,
              Gr = !1;
            ze >= this.totalFrames - 1 && this.frameModifier > 0
              ? !this.loop || this.playCount === this.loop
                ? this.checkSegments(
                    ze > this.totalFrames ? ze % this.totalFrames : 0
                  ) || ((Gr = !0), (ze = this.totalFrames - 1))
                : ze >= this.totalFrames
                ? ((this.playCount += 1),
                  this.checkSegments(ze % this.totalFrames) ||
                    (this.setCurrentRawFrameValue(ze % this.totalFrames),
                    (this._completedLoop = !0),
                    this.trigger("loopComplete")))
                : this.setCurrentRawFrameValue(ze)
              : ze < 0
              ? this.checkSegments(ze % this.totalFrames) ||
                (this.loop && !(this.playCount-- <= 0 && this.loop !== !0)
                  ? (this.setCurrentRawFrameValue(
                      this.totalFrames + (ze % this.totalFrames)
                    ),
                    this._completedLoop
                      ? this.trigger("loopComplete")
                      : (this._completedLoop = !0))
                  : ((Gr = !0), (ze = 0)))
              : this.setCurrentRawFrameValue(ze),
              Gr &&
                (this.setCurrentRawFrameValue(ze),
                this.pause(),
                this.trigger("complete"));
          }
        }),
        (AnimationItem.prototype.adjustSegment = function (Wr, ze) {
          (this.playCount = 0),
            Wr[1] < Wr[0]
              ? (this.frameModifier > 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(-1)),
                (this.totalFrames = Wr[0] - Wr[1]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = Wr[1]),
                this.setCurrentRawFrameValue(this.totalFrames - 0.001 - ze))
              : Wr[1] > Wr[0] &&
                (this.frameModifier < 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(1)),
                (this.totalFrames = Wr[1] - Wr[0]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = Wr[0]),
                this.setCurrentRawFrameValue(0.001 + ze)),
            this.trigger("segmentStart");
        }),
        (AnimationItem.prototype.setSegment = function (Wr, ze) {
          var Gr = -1;
          this.isPaused &&
            (this.currentRawFrame + this.firstFrame < Wr
              ? (Gr = Wr)
              : this.currentRawFrame + this.firstFrame > ze && (Gr = ze - Wr)),
            (this.firstFrame = Wr),
            (this.totalFrames = ze - Wr),
            (this.timeCompleted = this.totalFrames),
            Gr !== -1 && this.goToAndStop(Gr, !0);
        }),
        (AnimationItem.prototype.playSegments = function (Wr, ze) {
          if (
            (ze && (this.segments.length = 0), _typeof$4(Wr[0]) === "object")
          ) {
            var Gr,
              Yr = Wr.length;
            for (Gr = 0; Gr < Yr; Gr += 1) this.segments.push(Wr[Gr]);
          } else this.segments.push(Wr);
          this.segments.length &&
            ze &&
            this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play();
        }),
        (AnimationItem.prototype.resetSegments = function (Wr) {
          (this.segments.length = 0),
            this.segments.push([this.animationData.ip, this.animationData.op]),
            Wr && this.checkSegments(0);
        }),
        (AnimationItem.prototype.checkSegments = function (Wr) {
          return this.segments.length
            ? (this.adjustSegment(this.segments.shift(), Wr), !0)
            : !1;
        }),
        (AnimationItem.prototype.destroy = function (Wr) {
          (Wr && this.name !== Wr) ||
            !this.renderer ||
            (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            (this._cbs = null),
            (this.onEnterFrame = null),
            (this.onLoopComplete = null),
            (this.onComplete = null),
            (this.onSegmentStart = null),
            (this.onDestroy = null),
            (this.renderer = null),
            (this.expressionsPlugin = null),
            (this.imagePreloader = null),
            (this.projectInterface = null));
        }),
        (AnimationItem.prototype.setCurrentRawFrameValue = function (Wr) {
          (this.currentRawFrame = Wr), this.gotoFrame();
        }),
        (AnimationItem.prototype.setSpeed = function (Wr) {
          (this.playSpeed = Wr), this.updaFrameModifier();
        }),
        (AnimationItem.prototype.setDirection = function (Wr) {
          (this.playDirection = Wr < 0 ? -1 : 1), this.updaFrameModifier();
        }),
        (AnimationItem.prototype.setLoop = function (Wr) {
          this.loop = Wr;
        }),
        (AnimationItem.prototype.setVolume = function (Wr, ze) {
          (ze && this.name !== ze) || this.audioController.setVolume(Wr);
        }),
        (AnimationItem.prototype.getVolume = function () {
          return this.audioController.getVolume();
        }),
        (AnimationItem.prototype.mute = function (Wr) {
          (Wr && this.name !== Wr) || this.audioController.mute();
        }),
        (AnimationItem.prototype.unmute = function (Wr) {
          (Wr && this.name !== Wr) || this.audioController.unmute();
        }),
        (AnimationItem.prototype.updaFrameModifier = function () {
          (this.frameModifier =
            this.frameMult * this.playSpeed * this.playDirection),
            this.audioController.setRate(this.playSpeed * this.playDirection);
        }),
        (AnimationItem.prototype.getPath = function () {
          return this.path;
        }),
        (AnimationItem.prototype.getAssetsPath = function (Wr) {
          var ze = "";
          if (Wr.e) ze = Wr.p;
          else if (this.assetsPath) {
            var Gr = Wr.p;
            Gr.indexOf("images/") !== -1 && (Gr = Gr.split("/")[1]),
              (ze = this.assetsPath + Gr);
          } else (ze = this.path), (ze += Wr.u ? Wr.u : ""), (ze += Wr.p);
          return ze;
        }),
        (AnimationItem.prototype.getAssetData = function (Wr) {
          for (var ze = 0, Gr = this.assets.length; ze < Gr; ) {
            if (Wr === this.assets[ze].id) return this.assets[ze];
            ze += 1;
          }
          return null;
        }),
        (AnimationItem.prototype.hide = function () {
          this.renderer.hide();
        }),
        (AnimationItem.prototype.show = function () {
          this.renderer.show();
        }),
        (AnimationItem.prototype.getDuration = function (Wr) {
          return Wr ? this.totalFrames : this.totalFrames / this.frameRate;
        }),
        (AnimationItem.prototype.updateDocumentData = function (Wr, ze, Gr) {
          try {
            var Yr = this.renderer.getElementByPath(Wr);
            Yr.updateDocumentData(ze, Gr);
          } catch (Kr) {}
        }),
        (AnimationItem.prototype.trigger = function (Wr) {
          if (this._cbs && this._cbs[Wr])
            switch (Wr) {
              case "enterFrame":
                this.triggerEvent(
                  Wr,
                  new BMEnterFrameEvent(
                    Wr,
                    this.currentFrame,
                    this.totalFrames,
                    this.frameModifier
                  )
                );
                break;
              case "drawnFrame":
                (this.drawnFrameEvent.currentTime = this.currentFrame),
                  (this.drawnFrameEvent.totalTime = this.totalFrames),
                  (this.drawnFrameEvent.direction = this.frameModifier),
                  this.triggerEvent(Wr, this.drawnFrameEvent);
                break;
              case "loopComplete":
                this.triggerEvent(
                  Wr,
                  new BMCompleteLoopEvent(
                    Wr,
                    this.loop,
                    this.playCount,
                    this.frameMult
                  )
                );
                break;
              case "complete":
                this.triggerEvent(Wr, new BMCompleteEvent(Wr, this.frameMult));
                break;
              case "segmentStart":
                this.triggerEvent(
                  Wr,
                  new BMSegmentStartEvent(Wr, this.firstFrame, this.totalFrames)
                );
                break;
              case "destroy":
                this.triggerEvent(Wr, new BMDestroyEvent(Wr, this));
                break;
              default:
                this.triggerEvent(Wr);
            }
          Wr === "enterFrame" &&
            this.onEnterFrame &&
            this.onEnterFrame.call(
              this,
              new BMEnterFrameEvent(
                Wr,
                this.currentFrame,
                this.totalFrames,
                this.frameMult
              )
            ),
            Wr === "loopComplete" &&
              this.onLoopComplete &&
              this.onLoopComplete.call(
                this,
                new BMCompleteLoopEvent(
                  Wr,
                  this.loop,
                  this.playCount,
                  this.frameMult
                )
              ),
            Wr === "complete" &&
              this.onComplete &&
              this.onComplete.call(
                this,
                new BMCompleteEvent(Wr, this.frameMult)
              ),
            Wr === "segmentStart" &&
              this.onSegmentStart &&
              this.onSegmentStart.call(
                this,
                new BMSegmentStartEvent(Wr, this.firstFrame, this.totalFrames)
              ),
            Wr === "destroy" &&
              this.onDestroy &&
              this.onDestroy.call(this, new BMDestroyEvent(Wr, this));
        }),
        (AnimationItem.prototype.triggerRenderFrameError = function (Wr) {
          var ze = new BMRenderFrameErrorEvent(Wr, this.currentFrame);
          this.triggerEvent("error", ze),
            this.onError && this.onError.call(this, ze);
        }),
        (AnimationItem.prototype.triggerConfigError = function (Wr) {
          var ze = new BMConfigErrorEvent(Wr, this.currentFrame);
          this.triggerEvent("error", ze),
            this.onError && this.onError.call(this, ze);
        });
      var animationManager = (function () {
          var Wr = {},
            ze = [],
            Gr = 0,
            Yr = 0,
            Kr = 0,
            Zr = !0,
            Jr = !1;
          function Qr(bi) {
            for (var Mi = 0, gi = bi.target; Mi < Yr; )
              ze[Mi].animation === gi &&
                (ze.splice(Mi, 1), (Mi -= 1), (Yr -= 1), gi.isPaused || ni()),
                (Mi += 1);
          }
          function ei(bi, Mi) {
            if (!bi) return null;
            for (var gi = 0; gi < Yr; ) {
              if (ze[gi].elem === bi && ze[gi].elem !== null)
                return ze[gi].animation;
              gi += 1;
            }
            var xi = new AnimationItem();
            return ii(xi, bi), xi.setData(bi, Mi), xi;
          }
          function ti() {
            var bi,
              Mi = ze.length,
              gi = [];
            for (bi = 0; bi < Mi; bi += 1) gi.push(ze[bi].animation);
            return gi;
          }
          function ri() {
            (Kr += 1), Ei();
          }
          function ni() {
            Kr -= 1;
          }
          function ii(bi, Mi) {
            bi.addEventListener("destroy", Qr),
              bi.addEventListener("_active", ri),
              bi.addEventListener("_idle", ni),
              ze.push({
                elem: Mi,
                animation: bi,
              }),
              (Yr += 1);
          }
          function si(bi) {
            var Mi = new AnimationItem();
            return ii(Mi, null), Mi.setParams(bi), Mi;
          }
          function li(bi, Mi) {
            var gi;
            for (gi = 0; gi < Yr; gi += 1) ze[gi].animation.setSpeed(bi, Mi);
          }
          function oi(bi, Mi) {
            var gi;
            for (gi = 0; gi < Yr; gi += 1)
              ze[gi].animation.setDirection(bi, Mi);
          }
          function ui(bi) {
            var Mi;
            for (Mi = 0; Mi < Yr; Mi += 1) ze[Mi].animation.play(bi);
          }
          function ai(bi) {
            var Mi = bi - Gr,
              gi;
            for (gi = 0; gi < Yr; gi += 1) ze[gi].animation.advanceTime(Mi);
            (Gr = bi), Kr && !Jr ? window.requestAnimationFrame(ai) : (Zr = !0);
          }
          function hi(bi) {
            (Gr = bi), window.requestAnimationFrame(ai);
          }
          function ci(bi) {
            var Mi;
            for (Mi = 0; Mi < Yr; Mi += 1) ze[Mi].animation.pause(bi);
          }
          function fi(bi, Mi, gi) {
            var xi;
            for (xi = 0; xi < Yr; xi += 1)
              ze[xi].animation.goToAndStop(bi, Mi, gi);
          }
          function di(bi) {
            var Mi;
            for (Mi = 0; Mi < Yr; Mi += 1) ze[Mi].animation.stop(bi);
          }
          function pi(bi) {
            var Mi;
            for (Mi = 0; Mi < Yr; Mi += 1) ze[Mi].animation.togglePause(bi);
          }
          function mi(bi) {
            var Mi;
            for (Mi = Yr - 1; Mi >= 0; Mi -= 1) ze[Mi].animation.destroy(bi);
          }
          function Si(bi, Mi, gi) {
            var xi = [].concat(
                [].slice.call(document.getElementsByClassName("lottie")),
                [].slice.call(document.getElementsByClassName("bodymovin"))
              ),
              Ti,
              vi = xi.length;
            for (Ti = 0; Ti < vi; Ti += 1)
              gi && xi[Ti].setAttribute("data-bm-type", gi), ei(xi[Ti], bi);
            if (Mi && vi === 0) {
              gi || (gi = "svg");
              var Ii = document.getElementsByTagName("body")[0];
              Ii.innerText = "";
              var Oi = createTag("div");
              (Oi.style.width = "100%"),
                (Oi.style.height = "100%"),
                Oi.setAttribute("data-bm-type", gi),
                Ii.appendChild(Oi),
                ei(Oi, bi);
            }
          }
          function yi() {
            var bi;
            for (bi = 0; bi < Yr; bi += 1) ze[bi].animation.resize();
          }
          function Ei() {
            !Jr && Kr && Zr && (window.requestAnimationFrame(hi), (Zr = !1));
          }
          function Pi() {
            Jr = !0;
          }
          function Ai() {
            (Jr = !1), Ei();
          }
          function Ri(bi, Mi) {
            var gi;
            for (gi = 0; gi < Yr; gi += 1) ze[gi].animation.setVolume(bi, Mi);
          }
          function wi(bi) {
            var Mi;
            for (Mi = 0; Mi < Yr; Mi += 1) ze[Mi].animation.mute(bi);
          }
          function Ci(bi) {
            var Mi;
            for (Mi = 0; Mi < Yr; Mi += 1) ze[Mi].animation.unmute(bi);
          }
          return (
            (Wr.registerAnimation = ei),
            (Wr.loadAnimation = si),
            (Wr.setSpeed = li),
            (Wr.setDirection = oi),
            (Wr.play = ui),
            (Wr.pause = ci),
            (Wr.stop = di),
            (Wr.togglePause = pi),
            (Wr.searchAnimations = Si),
            (Wr.resize = yi),
            (Wr.goToAndStop = fi),
            (Wr.destroy = mi),
            (Wr.freeze = Pi),
            (Wr.unfreeze = Ai),
            (Wr.setVolume = Ri),
            (Wr.mute = wi),
            (Wr.unmute = Ci),
            (Wr.getRegisteredAnimations = ti),
            Wr
          );
        })(),
        BezierFactory = (function () {
          var Wr = {};
          Wr.getBezierEasing = Gr;
          var ze = {};
          function Gr(hi, ci, fi, di, pi) {
            var mi =
              pi ||
              ("bez_" + hi + "_" + ci + "_" + fi + "_" + di).replace(
                /\./g,
                "p"
              );
            if (ze[mi]) return ze[mi];
            var Si = new ai([hi, ci, fi, di]);
            return (ze[mi] = Si), Si;
          }
          var Yr = 4,
            Kr = 0.001,
            Zr = 1e-7,
            Jr = 10,
            Qr = 11,
            ei = 1 / (Qr - 1),
            ti = typeof Float32Array == "function";
          function ri(hi, ci) {
            return 1 - 3 * ci + 3 * hi;
          }
          function ni(hi, ci) {
            return 3 * ci - 6 * hi;
          }
          function ii(hi) {
            return 3 * hi;
          }
          function si(hi, ci, fi) {
            return ((ri(ci, fi) * hi + ni(ci, fi)) * hi + ii(ci)) * hi;
          }
          function li(hi, ci, fi) {
            return 3 * ri(ci, fi) * hi * hi + 2 * ni(ci, fi) * hi + ii(ci);
          }
          function oi(hi, ci, fi, di, pi) {
            var mi,
              Si,
              yi = 0;
            do
              (Si = ci + (fi - ci) / 2),
                (mi = si(Si, di, pi) - hi),
                mi > 0 ? (fi = Si) : (ci = Si);
            while (Math.abs(mi) > Zr && ++yi < Jr);
            return Si;
          }
          function ui(hi, ci, fi, di) {
            for (var pi = 0; pi < Yr; ++pi) {
              var mi = li(ci, fi, di);
              if (mi === 0) return ci;
              var Si = si(ci, fi, di) - hi;
              ci -= Si / mi;
            }
            return ci;
          }
          function ai(hi) {
            (this._p = hi),
              (this._mSampleValues = ti ? new Float32Array(Qr) : new Array(Qr)),
              (this._precomputed = !1),
              (this.get = this.get.bind(this));
          }
          return (
            (ai.prototype = {
              get: function (ci) {
                var fi = this._p[0],
                  di = this._p[1],
                  pi = this._p[2],
                  mi = this._p[3];
                return (
                  this._precomputed || this._precompute(),
                  fi === di && pi === mi
                    ? ci
                    : ci === 0
                    ? 0
                    : ci === 1
                    ? 1
                    : si(this._getTForX(ci), di, mi)
                );
              },
              _precompute: function () {
                var ci = this._p[0],
                  fi = this._p[1],
                  di = this._p[2],
                  pi = this._p[3];
                (this._precomputed = !0),
                  (ci !== fi || di !== pi) && this._calcSampleValues();
              },
              _calcSampleValues: function () {
                for (
                  var ci = this._p[0], fi = this._p[2], di = 0;
                  di < Qr;
                  ++di
                )
                  this._mSampleValues[di] = si(di * ei, ci, fi);
              },
              _getTForX: function (ci) {
                for (
                  var fi = this._p[0],
                    di = this._p[2],
                    pi = this._mSampleValues,
                    mi = 0,
                    Si = 1,
                    yi = Qr - 1;
                  Si !== yi && pi[Si] <= ci;
                  ++Si
                )
                  mi += ei;
                --Si;
                var Ei = (ci - pi[Si]) / (pi[Si + 1] - pi[Si]),
                  Pi = mi + Ei * ei,
                  Ai = li(Pi, fi, di);
                return Ai >= Kr
                  ? ui(ci, Pi, fi, di)
                  : Ai === 0
                  ? Pi
                  : oi(ci, mi, mi + ei, fi, di);
              },
            }),
            Wr
          );
        })(),
        pooling = (function () {
          function Wr(ze) {
            return ze.concat(createSizedArray(ze.length));
          }
          return {
            double: Wr,
          };
        })(),
        poolFactory = (function () {
          return function (Wr, ze, Gr) {
            var Yr = 0,
              Kr = Wr,
              Zr = createSizedArray(Kr),
              Jr = {
                newElement: Qr,
                release: ei,
              };
            function Qr() {
              var ti;
              return Yr ? ((Yr -= 1), (ti = Zr[Yr])) : (ti = ze()), ti;
            }
            function ei(ti) {
              Yr === Kr && ((Zr = pooling.double(Zr)), (Kr *= 2)),
                Gr && Gr(ti),
                (Zr[Yr] = ti),
                (Yr += 1);
            }
            return Jr;
          };
        })(),
        bezierLengthPool = (function () {
          function Wr() {
            return {
              addedLength: 0,
              percents: createTypedArray("float32", getDefaultCurveSegments()),
              lengths: createTypedArray("float32", getDefaultCurveSegments()),
            };
          }
          return poolFactory(8, Wr);
        })(),
        segmentsLengthPool = (function () {
          function Wr() {
            return {
              lengths: [],
              totalLength: 0,
            };
          }
          function ze(Gr) {
            var Yr,
              Kr = Gr.lengths.length;
            for (Yr = 0; Yr < Kr; Yr += 1)
              bezierLengthPool.release(Gr.lengths[Yr]);
            Gr.lengths.length = 0;
          }
          return poolFactory(8, Wr, ze);
        })();
      function bezFunction() {
        var Wr = Math;
        function ze(ii, si, li, oi, ui, ai) {
          var hi = ii * oi + si * ui + li * ai - ui * oi - ai * ii - li * si;
          return hi > -0.001 && hi < 0.001;
        }
        function Gr(ii, si, li, oi, ui, ai, hi, ci, fi) {
          if (li === 0 && ai === 0 && fi === 0)
            return ze(ii, si, oi, ui, hi, ci);
          var di = Wr.sqrt(
              Wr.pow(oi - ii, 2) + Wr.pow(ui - si, 2) + Wr.pow(ai - li, 2)
            ),
            pi = Wr.sqrt(
              Wr.pow(hi - ii, 2) + Wr.pow(ci - si, 2) + Wr.pow(fi - li, 2)
            ),
            mi = Wr.sqrt(
              Wr.pow(hi - oi, 2) + Wr.pow(ci - ui, 2) + Wr.pow(fi - ai, 2)
            ),
            Si;
          return (
            di > pi
              ? di > mi
                ? (Si = di - pi - mi)
                : (Si = mi - pi - di)
              : mi > pi
              ? (Si = mi - pi - di)
              : (Si = pi - di - mi),
            Si > -1e-4 && Si < 1e-4
          );
        }
        var Yr = (function () {
          return function (ii, si, li, oi) {
            var ui = getDefaultCurveSegments(),
              ai,
              hi,
              ci,
              fi,
              di,
              pi = 0,
              mi,
              Si = [],
              yi = [],
              Ei = bezierLengthPool.newElement();
            for (ci = li.length, ai = 0; ai < ui; ai += 1) {
              for (di = ai / (ui - 1), mi = 0, hi = 0; hi < ci; hi += 1)
                (fi =
                  bmPow(1 - di, 3) * ii[hi] +
                  3 * bmPow(1 - di, 2) * di * li[hi] +
                  3 * (1 - di) * bmPow(di, 2) * oi[hi] +
                  bmPow(di, 3) * si[hi]),
                  (Si[hi] = fi),
                  yi[hi] !== null && (mi += bmPow(Si[hi] - yi[hi], 2)),
                  (yi[hi] = Si[hi]);
              mi && ((mi = bmSqrt(mi)), (pi += mi)),
                (Ei.percents[ai] = di),
                (Ei.lengths[ai] = pi);
            }
            return (Ei.addedLength = pi), Ei;
          };
        })();
        function Kr(ii) {
          var si = segmentsLengthPool.newElement(),
            li = ii.c,
            oi = ii.v,
            ui = ii.o,
            ai = ii.i,
            hi,
            ci = ii._length,
            fi = si.lengths,
            di = 0;
          for (hi = 0; hi < ci - 1; hi += 1)
            (fi[hi] = Yr(oi[hi], oi[hi + 1], ui[hi], ai[hi + 1])),
              (di += fi[hi].addedLength);
          return (
            li &&
              ci &&
              ((fi[hi] = Yr(oi[hi], oi[0], ui[hi], ai[0])),
              (di += fi[hi].addedLength)),
            (si.totalLength = di),
            si
          );
        }
        function Zr(ii) {
          (this.segmentLength = 0), (this.points = new Array(ii));
        }
        function Jr(ii, si) {
          (this.partialLength = ii), (this.point = si);
        }
        var Qr = (function () {
          var ii = {};
          return function (si, li, oi, ui) {
            var ai = (
              si[0] +
              "_" +
              si[1] +
              "_" +
              li[0] +
              "_" +
              li[1] +
              "_" +
              oi[0] +
              "_" +
              oi[1] +
              "_" +
              ui[0] +
              "_" +
              ui[1]
            ).replace(/\./g, "p");
            if (!ii[ai]) {
              var hi = getDefaultCurveSegments(),
                ci,
                fi,
                di,
                pi,
                mi,
                Si = 0,
                yi,
                Ei,
                Pi = null;
              si.length === 2 &&
                (si[0] !== li[0] || si[1] !== li[1]) &&
                ze(si[0], si[1], li[0], li[1], si[0] + oi[0], si[1] + oi[1]) &&
                ze(si[0], si[1], li[0], li[1], li[0] + ui[0], li[1] + ui[1]) &&
                (hi = 2);
              var Ai = new Zr(hi);
              for (di = oi.length, ci = 0; ci < hi; ci += 1) {
                for (
                  Ei = createSizedArray(di), mi = ci / (hi - 1), yi = 0, fi = 0;
                  fi < di;
                  fi += 1
                )
                  (pi =
                    bmPow(1 - mi, 3) * si[fi] +
                    3 * bmPow(1 - mi, 2) * mi * (si[fi] + oi[fi]) +
                    3 * (1 - mi) * bmPow(mi, 2) * (li[fi] + ui[fi]) +
                    bmPow(mi, 3) * li[fi]),
                    (Ei[fi] = pi),
                    Pi !== null && (yi += bmPow(Ei[fi] - Pi[fi], 2));
                (yi = bmSqrt(yi)),
                  (Si += yi),
                  (Ai.points[ci] = new Jr(yi, Ei)),
                  (Pi = Ei);
              }
              (Ai.segmentLength = Si), (ii[ai] = Ai);
            }
            return ii[ai];
          };
        })();
        function ei(ii, si) {
          var li = si.percents,
            oi = si.lengths,
            ui = li.length,
            ai = bmFloor((ui - 1) * ii),
            hi = ii * si.addedLength,
            ci = 0;
          if (ai === ui - 1 || ai === 0 || hi === oi[ai]) return li[ai];
          for (var fi = oi[ai] > hi ? -1 : 1, di = !0; di; )
            if (
              (oi[ai] <= hi && oi[ai + 1] > hi
                ? ((ci = (hi - oi[ai]) / (oi[ai + 1] - oi[ai])), (di = !1))
                : (ai += fi),
              ai < 0 || ai >= ui - 1)
            ) {
              if (ai === ui - 1) return li[ai];
              di = !1;
            }
          return li[ai] + (li[ai + 1] - li[ai]) * ci;
        }
        function ti(ii, si, li, oi, ui, ai) {
          var hi = ei(ui, ai),
            ci = 1 - hi,
            fi =
              Wr.round(
                (ci * ci * ci * ii[0] +
                  (hi * ci * ci + ci * hi * ci + ci * ci * hi) * li[0] +
                  (hi * hi * ci + ci * hi * hi + hi * ci * hi) * oi[0] +
                  hi * hi * hi * si[0]) *
                  1e3
              ) / 1e3,
            di =
              Wr.round(
                (ci * ci * ci * ii[1] +
                  (hi * ci * ci + ci * hi * ci + ci * ci * hi) * li[1] +
                  (hi * hi * ci + ci * hi * hi + hi * ci * hi) * oi[1] +
                  hi * hi * hi * si[1]) *
                  1e3
              ) / 1e3;
          return [fi, di];
        }
        var ri = createTypedArray("float32", 8);
        function ni(ii, si, li, oi, ui, ai, hi) {
          ui < 0 ? (ui = 0) : ui > 1 && (ui = 1);
          var ci = ei(ui, hi);
          ai = ai > 1 ? 1 : ai;
          var fi = ei(ai, hi),
            di,
            pi = ii.length,
            mi = 1 - ci,
            Si = 1 - fi,
            yi = mi * mi * mi,
            Ei = ci * mi * mi * 3,
            Pi = ci * ci * mi * 3,
            Ai = ci * ci * ci,
            Ri = mi * mi * Si,
            wi = ci * mi * Si + mi * ci * Si + mi * mi * fi,
            Ci = ci * ci * Si + mi * ci * fi + ci * mi * fi,
            bi = ci * ci * fi,
            Mi = mi * Si * Si,
            gi = ci * Si * Si + mi * fi * Si + mi * Si * fi,
            xi = ci * fi * Si + mi * fi * fi + ci * Si * fi,
            Ti = ci * fi * fi,
            vi = Si * Si * Si,
            Ii = fi * Si * Si + Si * fi * Si + Si * Si * fi,
            Oi = fi * fi * Si + Si * fi * fi + fi * Si * fi,
            ki = fi * fi * fi;
          for (di = 0; di < pi; di += 1)
            (ri[di * 4] =
              Wr.round(
                (yi * ii[di] + Ei * li[di] + Pi * oi[di] + Ai * si[di]) * 1e3
              ) / 1e3),
              (ri[di * 4 + 1] =
                Wr.round(
                  (Ri * ii[di] + wi * li[di] + Ci * oi[di] + bi * si[di]) * 1e3
                ) / 1e3),
              (ri[di * 4 + 2] =
                Wr.round(
                  (Mi * ii[di] + gi * li[di] + xi * oi[di] + Ti * si[di]) * 1e3
                ) / 1e3),
              (ri[di * 4 + 3] =
                Wr.round(
                  (vi * ii[di] + Ii * li[di] + Oi * oi[di] + ki * si[di]) * 1e3
                ) / 1e3);
          return ri;
        }
        return {
          getSegmentsLength: Kr,
          getNewSegment: ni,
          getPointInSegment: ti,
          buildBezierData: Qr,
          pointOnLine2D: ze,
          pointOnLine3D: Gr,
        };
      }
      var bez = bezFunction(),
        initFrame = initialDefaultFrame,
        mathAbs = Math.abs;
      function interpolateValue(Wr, ze) {
        var Gr = this.offsetTime,
          Yr;
        this.propType === "multidimensional" &&
          (Yr = createTypedArray("float32", this.pv.length));
        for (
          var Kr = ze.lastIndex,
            Zr = Kr,
            Jr = this.keyframes.length - 1,
            Qr = !0,
            ei,
            ti,
            ri;
          Qr;

        ) {
          if (
            ((ei = this.keyframes[Zr]),
            (ti = this.keyframes[Zr + 1]),
            Zr === Jr - 1 && Wr >= ti.t - Gr)
          ) {
            ei.h && (ei = ti), (Kr = 0);
            break;
          }
          if (ti.t - Gr > Wr) {
            Kr = Zr;
            break;
          }
          Zr < Jr - 1 ? (Zr += 1) : ((Kr = 0), (Qr = !1));
        }
        ri = this.keyframesMetadata[Zr] || {};
        var ni,
          ii,
          si,
          li,
          oi,
          ui,
          ai = ti.t - Gr,
          hi = ei.t - Gr,
          ci;
        if (ei.to) {
          ri.bezierData ||
            (ri.bezierData = bez.buildBezierData(
              ei.s,
              ti.s || ei.e,
              ei.to,
              ei.ti
            ));
          var fi = ri.bezierData;
          if (Wr >= ai || Wr < hi) {
            var di = Wr >= ai ? fi.points.length - 1 : 0;
            for (ii = fi.points[di].point.length, ni = 0; ni < ii; ni += 1)
              Yr[ni] = fi.points[di].point[ni];
          } else {
            ri.__fnct
              ? (ui = ri.__fnct)
              : ((ui = BezierFactory.getBezierEasing(
                  ei.o.x,
                  ei.o.y,
                  ei.i.x,
                  ei.i.y,
                  ei.n
                ).get),
                (ri.__fnct = ui)),
              (si = ui((Wr - hi) / (ai - hi)));
            var pi = fi.segmentLength * si,
              mi,
              Si =
                ze.lastFrame < Wr && ze._lastKeyframeIndex === Zr
                  ? ze._lastAddedLength
                  : 0;
            for (
              oi =
                ze.lastFrame < Wr && ze._lastKeyframeIndex === Zr
                  ? ze._lastPoint
                  : 0,
                Qr = !0,
                li = fi.points.length;
              Qr;

            ) {
              if (
                ((Si += fi.points[oi].partialLength),
                pi === 0 || si === 0 || oi === fi.points.length - 1)
              ) {
                for (ii = fi.points[oi].point.length, ni = 0; ni < ii; ni += 1)
                  Yr[ni] = fi.points[oi].point[ni];
                break;
              } else if (
                pi >= Si &&
                pi < Si + fi.points[oi + 1].partialLength
              ) {
                for (
                  mi = (pi - Si) / fi.points[oi + 1].partialLength,
                    ii = fi.points[oi].point.length,
                    ni = 0;
                  ni < ii;
                  ni += 1
                )
                  Yr[ni] =
                    fi.points[oi].point[ni] +
                    (fi.points[oi + 1].point[ni] - fi.points[oi].point[ni]) *
                      mi;
                break;
              }
              oi < li - 1 ? (oi += 1) : (Qr = !1);
            }
            (ze._lastPoint = oi),
              (ze._lastAddedLength = Si - fi.points[oi].partialLength),
              (ze._lastKeyframeIndex = Zr);
          }
        } else {
          var yi, Ei, Pi, Ai, Ri;
          if (((Jr = ei.s.length), (ci = ti.s || ei.e), this.sh && ei.h !== 1))
            if (Wr >= ai) (Yr[0] = ci[0]), (Yr[1] = ci[1]), (Yr[2] = ci[2]);
            else if (Wr <= hi)
              (Yr[0] = ei.s[0]), (Yr[1] = ei.s[1]), (Yr[2] = ei.s[2]);
            else {
              var wi = createQuaternion(ei.s),
                Ci = createQuaternion(ci),
                bi = (Wr - hi) / (ai - hi);
              quaternionToEuler(Yr, slerp(wi, Ci, bi));
            }
          else
            for (Zr = 0; Zr < Jr; Zr += 1)
              ei.h !== 1 &&
                (Wr >= ai
                  ? (si = 1)
                  : Wr < hi
                  ? (si = 0)
                  : (ei.o.x.constructor === Array
                      ? (ri.__fnct || (ri.__fnct = []),
                        ri.__fnct[Zr]
                          ? (ui = ri.__fnct[Zr])
                          : ((yi =
                              ei.o.x[Zr] === void 0 ? ei.o.x[0] : ei.o.x[Zr]),
                            (Ei =
                              ei.o.y[Zr] === void 0 ? ei.o.y[0] : ei.o.y[Zr]),
                            (Pi =
                              ei.i.x[Zr] === void 0 ? ei.i.x[0] : ei.i.x[Zr]),
                            (Ai =
                              ei.i.y[Zr] === void 0 ? ei.i.y[0] : ei.i.y[Zr]),
                            (ui = BezierFactory.getBezierEasing(
                              yi,
                              Ei,
                              Pi,
                              Ai
                            ).get),
                            (ri.__fnct[Zr] = ui)))
                      : ri.__fnct
                      ? (ui = ri.__fnct)
                      : ((yi = ei.o.x),
                        (Ei = ei.o.y),
                        (Pi = ei.i.x),
                        (Ai = ei.i.y),
                        (ui = BezierFactory.getBezierEasing(
                          yi,
                          Ei,
                          Pi,
                          Ai
                        ).get),
                        (ei.keyframeMetadata = ui)),
                    (si = ui((Wr - hi) / (ai - hi))))),
                (ci = ti.s || ei.e),
                (Ri =
                  ei.h === 1 ? ei.s[Zr] : ei.s[Zr] + (ci[Zr] - ei.s[Zr]) * si),
                this.propType === "multidimensional"
                  ? (Yr[Zr] = Ri)
                  : (Yr = Ri);
        }
        return (ze.lastIndex = Kr), Yr;
      }
      function slerp(Wr, ze, Gr) {
        var Yr = [],
          Kr = Wr[0],
          Zr = Wr[1],
          Jr = Wr[2],
          Qr = Wr[3],
          ei = ze[0],
          ti = ze[1],
          ri = ze[2],
          ni = ze[3],
          ii,
          si,
          li,
          oi,
          ui;
        return (
          (si = Kr * ei + Zr * ti + Jr * ri + Qr * ni),
          si < 0 &&
            ((si = -si), (ei = -ei), (ti = -ti), (ri = -ri), (ni = -ni)),
          1 - si > 1e-6
            ? ((ii = Math.acos(si)),
              (li = Math.sin(ii)),
              (oi = Math.sin((1 - Gr) * ii) / li),
              (ui = Math.sin(Gr * ii) / li))
            : ((oi = 1 - Gr), (ui = Gr)),
          (Yr[0] = oi * Kr + ui * ei),
          (Yr[1] = oi * Zr + ui * ti),
          (Yr[2] = oi * Jr + ui * ri),
          (Yr[3] = oi * Qr + ui * ni),
          Yr
        );
      }
      function quaternionToEuler(Wr, ze) {
        var Gr = ze[0],
          Yr = ze[1],
          Kr = ze[2],
          Zr = ze[3],
          Jr = Math.atan2(
            2 * Yr * Zr - 2 * Gr * Kr,
            1 - 2 * Yr * Yr - 2 * Kr * Kr
          ),
          Qr = Math.asin(2 * Gr * Yr + 2 * Kr * Zr),
          ei = Math.atan2(
            2 * Gr * Zr - 2 * Yr * Kr,
            1 - 2 * Gr * Gr - 2 * Kr * Kr
          );
        (Wr[0] = Jr / degToRads),
          (Wr[1] = Qr / degToRads),
          (Wr[2] = ei / degToRads);
      }
      function createQuaternion(Wr) {
        var ze = Wr[0] * degToRads,
          Gr = Wr[1] * degToRads,
          Yr = Wr[2] * degToRads,
          Kr = Math.cos(ze / 2),
          Zr = Math.cos(Gr / 2),
          Jr = Math.cos(Yr / 2),
          Qr = Math.sin(ze / 2),
          ei = Math.sin(Gr / 2),
          ti = Math.sin(Yr / 2),
          ri = Kr * Zr * Jr - Qr * ei * ti,
          ni = Qr * ei * Jr + Kr * Zr * ti,
          ii = Qr * Zr * Jr + Kr * ei * ti,
          si = Kr * ei * Jr - Qr * Zr * ti;
        return [ni, ii, si, ri];
      }
      function getValueAtCurrentTime() {
        var Wr = this.comp.renderedFrame - this.offsetTime,
          ze = this.keyframes[0].t - this.offsetTime,
          Gr = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (
          !(
            Wr === this._caching.lastFrame ||
            (this._caching.lastFrame !== initFrame &&
              ((this._caching.lastFrame >= Gr && Wr >= Gr) ||
                (this._caching.lastFrame < ze && Wr < ze)))
          )
        ) {
          this._caching.lastFrame >= Wr &&
            ((this._caching._lastKeyframeIndex = -1),
            (this._caching.lastIndex = 0));
          var Yr = this.interpolateValue(Wr, this._caching);
          this.pv = Yr;
        }
        return (this._caching.lastFrame = Wr), this.pv;
      }
      function setVValue(Wr) {
        var ze;
        if (this.propType === "unidimensional")
          (ze = Wr * this.mult),
            mathAbs(this.v - ze) > 1e-5 && ((this.v = ze), (this._mdf = !0));
        else
          for (var Gr = 0, Yr = this.v.length; Gr < Yr; )
            (ze = Wr[Gr] * this.mult),
              mathAbs(this.v[Gr] - ze) > 1e-5 &&
                ((this.v[Gr] = ze), (this._mdf = !0)),
              (Gr += 1);
      }
      function processEffectsSequence() {
        if (
          !(
            this.elem.globalData.frameId === this.frameId ||
            !this.effectsSequence.length
          )
        ) {
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          (this.lock = !0), (this._mdf = this._isFirstFrame);
          var Wr,
            ze = this.effectsSequence.length,
            Gr = this.kf ? this.pv : this.data.k;
          for (Wr = 0; Wr < ze; Wr += 1) Gr = this.effectsSequence[Wr](Gr);
          this.setVValue(Gr),
            (this._isFirstFrame = !1),
            (this.lock = !1),
            (this.frameId = this.elem.globalData.frameId);
        }
      }
      function addEffect(Wr) {
        this.effectsSequence.push(Wr), this.container.addDynamicProperty(this);
      }
      function ValueProperty(Wr, ze, Gr, Yr) {
        (this.propType = "unidimensional"),
          (this.mult = Gr || 1),
          (this.data = ze),
          (this.v = Gr ? ze.k * Gr : ze.k),
          (this.pv = ze.k),
          (this._mdf = !1),
          (this.elem = Wr),
          (this.container = Yr),
          (this.comp = Wr.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.vel = 0),
          (this.effectsSequence = []),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect);
      }
      function MultiDimensionalProperty(Wr, ze, Gr, Yr) {
        (this.propType = "multidimensional"),
          (this.mult = Gr || 1),
          (this.data = ze),
          (this._mdf = !1),
          (this.elem = Wr),
          (this.container = Yr),
          (this.comp = Wr.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.frameId = -1);
        var Kr,
          Zr = ze.k.length;
        for (
          this.v = createTypedArray("float32", Zr),
            this.pv = createTypedArray("float32", Zr),
            this.vel = createTypedArray("float32", Zr),
            Kr = 0;
          Kr < Zr;
          Kr += 1
        )
          (this.v[Kr] = ze.k[Kr] * this.mult), (this.pv[Kr] = ze.k[Kr]);
        (this._isFirstFrame = !0),
          (this.effectsSequence = []),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect);
      }
      function KeyframedValueProperty(Wr, ze, Gr, Yr) {
        (this.propType = "unidimensional"),
          (this.keyframes = ze.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = Wr.data.st),
          (this.frameId = -1),
          (this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: 0,
            _lastKeyframeIndex: -1,
          }),
          (this.k = !0),
          (this.kf = !0),
          (this.data = ze),
          (this.mult = Gr || 1),
          (this.elem = Wr),
          (this.container = Yr),
          (this.comp = Wr.comp),
          (this.v = initFrame),
          (this.pv = initFrame),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.addEffect = addEffect);
      }
      function KeyframedMultidimensionalProperty(Wr, ze, Gr, Yr) {
        this.propType = "multidimensional";
        var Kr,
          Zr = ze.k.length,
          Jr,
          Qr,
          ei,
          ti;
        for (Kr = 0; Kr < Zr - 1; Kr += 1)
          ze.k[Kr].to &&
            ze.k[Kr].s &&
            ze.k[Kr + 1] &&
            ze.k[Kr + 1].s &&
            ((Jr = ze.k[Kr].s),
            (Qr = ze.k[Kr + 1].s),
            (ei = ze.k[Kr].to),
            (ti = ze.k[Kr].ti),
            ((Jr.length === 2 &&
              !(Jr[0] === Qr[0] && Jr[1] === Qr[1]) &&
              bez.pointOnLine2D(
                Jr[0],
                Jr[1],
                Qr[0],
                Qr[1],
                Jr[0] + ei[0],
                Jr[1] + ei[1]
              ) &&
              bez.pointOnLine2D(
                Jr[0],
                Jr[1],
                Qr[0],
                Qr[1],
                Qr[0] + ti[0],
                Qr[1] + ti[1]
              )) ||
              (Jr.length === 3 &&
                !(Jr[0] === Qr[0] && Jr[1] === Qr[1] && Jr[2] === Qr[2]) &&
                bez.pointOnLine3D(
                  Jr[0],
                  Jr[1],
                  Jr[2],
                  Qr[0],
                  Qr[1],
                  Qr[2],
                  Jr[0] + ei[0],
                  Jr[1] + ei[1],
                  Jr[2] + ei[2]
                ) &&
                bez.pointOnLine3D(
                  Jr[0],
                  Jr[1],
                  Jr[2],
                  Qr[0],
                  Qr[1],
                  Qr[2],
                  Qr[0] + ti[0],
                  Qr[1] + ti[1],
                  Qr[2] + ti[2]
                ))) &&
              ((ze.k[Kr].to = null), (ze.k[Kr].ti = null)),
            Jr[0] === Qr[0] &&
              Jr[1] === Qr[1] &&
              ei[0] === 0 &&
              ei[1] === 0 &&
              ti[0] === 0 &&
              ti[1] === 0 &&
              (Jr.length === 2 ||
                (Jr[2] === Qr[2] && ei[2] === 0 && ti[2] === 0)) &&
              ((ze.k[Kr].to = null), (ze.k[Kr].ti = null)));
        (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.data = ze),
          (this.keyframes = ze.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = Wr.data.st),
          (this.k = !0),
          (this.kf = !0),
          (this._isFirstFrame = !0),
          (this.mult = Gr || 1),
          (this.elem = Wr),
          (this.container = Yr),
          (this.comp = Wr.comp),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.frameId = -1);
        var ri = ze.k[0].s.length;
        for (
          this.v = createTypedArray("float32", ri),
            this.pv = createTypedArray("float32", ri),
            Kr = 0;
          Kr < ri;
          Kr += 1
        )
          (this.v[Kr] = initFrame), (this.pv[Kr] = initFrame);
        (this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", ri),
        }),
          (this.addEffect = addEffect);
      }
      var PropertyFactory = (function () {
        function Wr(Gr, Yr, Kr, Zr, Jr) {
          Yr.sid && (Yr = Gr.globalData.slotManager.getProp(Yr));
          var Qr;
          if (!Yr.k.length) Qr = new ValueProperty(Gr, Yr, Zr, Jr);
          else if (typeof Yr.k[0] == "number")
            Qr = new MultiDimensionalProperty(Gr, Yr, Zr, Jr);
          else
            switch (Kr) {
              case 0:
                Qr = new KeyframedValueProperty(Gr, Yr, Zr, Jr);
                break;
              case 1:
                Qr = new KeyframedMultidimensionalProperty(Gr, Yr, Zr, Jr);
                break;
            }
          return Qr.effectsSequence.length && Jr.addDynamicProperty(Qr), Qr;
        }
        var ze = {
          getProp: Wr,
        };
        return ze;
      })();
      function DynamicPropertyContainer() {}
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function (ze) {
          this.dynamicProperties.indexOf(ze) === -1 &&
            (this.dynamicProperties.push(ze),
            this.container.addDynamicProperty(this),
            (this._isAnimated = !0));
        },
        iterateDynamicProperties: function () {
          this._mdf = !1;
          var ze,
            Gr = this.dynamicProperties.length;
          for (ze = 0; ze < Gr; ze += 1)
            this.dynamicProperties[ze].getValue(),
              this.dynamicProperties[ze]._mdf && (this._mdf = !0);
        },
        initDynamicPropertyContainer: function (ze) {
          (this.container = ze),
            (this.dynamicProperties = []),
            (this._mdf = !1),
            (this._isAnimated = !1);
        },
      };
      var pointPool = (function () {
        function Wr() {
          return createTypedArray("float32", 2);
        }
        return poolFactory(8, Wr);
      })();
      function ShapePath() {
        (this.c = !1),
          (this._length = 0),
          (this._maxLength = 8),
          (this.v = createSizedArray(this._maxLength)),
          (this.o = createSizedArray(this._maxLength)),
          (this.i = createSizedArray(this._maxLength));
      }
      (ShapePath.prototype.setPathData = function (Wr, ze) {
        (this.c = Wr), this.setLength(ze);
        for (var Gr = 0; Gr < ze; )
          (this.v[Gr] = pointPool.newElement()),
            (this.o[Gr] = pointPool.newElement()),
            (this.i[Gr] = pointPool.newElement()),
            (Gr += 1);
      }),
        (ShapePath.prototype.setLength = function (Wr) {
          for (; this._maxLength < Wr; ) this.doubleArrayLength();
          this._length = Wr;
        }),
        (ShapePath.prototype.doubleArrayLength = function () {
          (this.v = this.v.concat(createSizedArray(this._maxLength))),
            (this.i = this.i.concat(createSizedArray(this._maxLength))),
            (this.o = this.o.concat(createSizedArray(this._maxLength))),
            (this._maxLength *= 2);
        }),
        (ShapePath.prototype.setXYAt = function (Wr, ze, Gr, Yr, Kr) {
          var Zr;
          switch (
            ((this._length = Math.max(this._length, Yr + 1)),
            this._length >= this._maxLength && this.doubleArrayLength(),
            Gr)
          ) {
            case "v":
              Zr = this.v;
              break;
            case "i":
              Zr = this.i;
              break;
            case "o":
              Zr = this.o;
              break;
            default:
              Zr = [];
              break;
          }
          (!Zr[Yr] || (Zr[Yr] && !Kr)) && (Zr[Yr] = pointPool.newElement()),
            (Zr[Yr][0] = Wr),
            (Zr[Yr][1] = ze);
        }),
        (ShapePath.prototype.setTripleAt = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr,
          Zr,
          Jr,
          Qr
        ) {
          this.setXYAt(Wr, ze, "v", Jr, Qr),
            this.setXYAt(Gr, Yr, "o", Jr, Qr),
            this.setXYAt(Kr, Zr, "i", Jr, Qr);
        }),
        (ShapePath.prototype.reverse = function () {
          var Wr = new ShapePath();
          Wr.setPathData(this.c, this._length);
          var ze = this.v,
            Gr = this.o,
            Yr = this.i,
            Kr = 0;
          this.c &&
            (Wr.setTripleAt(
              ze[0][0],
              ze[0][1],
              Yr[0][0],
              Yr[0][1],
              Gr[0][0],
              Gr[0][1],
              0,
              !1
            ),
            (Kr = 1));
          var Zr = this._length - 1,
            Jr = this._length,
            Qr;
          for (Qr = Kr; Qr < Jr; Qr += 1)
            Wr.setTripleAt(
              ze[Zr][0],
              ze[Zr][1],
              Yr[Zr][0],
              Yr[Zr][1],
              Gr[Zr][0],
              Gr[Zr][1],
              Qr,
              !1
            ),
              (Zr -= 1);
          return Wr;
        }),
        (ShapePath.prototype.length = function () {
          return this._length;
        });
      var shapePool = (function () {
        function Wr() {
          return new ShapePath();
        }
        function ze(Kr) {
          var Zr = Kr._length,
            Jr;
          for (Jr = 0; Jr < Zr; Jr += 1)
            pointPool.release(Kr.v[Jr]),
              pointPool.release(Kr.i[Jr]),
              pointPool.release(Kr.o[Jr]),
              (Kr.v[Jr] = null),
              (Kr.i[Jr] = null),
              (Kr.o[Jr] = null);
          (Kr._length = 0), (Kr.c = !1);
        }
        function Gr(Kr) {
          var Zr = Yr.newElement(),
            Jr,
            Qr = Kr._length === void 0 ? Kr.v.length : Kr._length;
          for (Zr.setLength(Qr), Zr.c = Kr.c, Jr = 0; Jr < Qr; Jr += 1)
            Zr.setTripleAt(
              Kr.v[Jr][0],
              Kr.v[Jr][1],
              Kr.o[Jr][0],
              Kr.o[Jr][1],
              Kr.i[Jr][0],
              Kr.i[Jr][1],
              Jr
            );
          return Zr;
        }
        var Yr = poolFactory(4, Wr, ze);
        return (Yr.clone = Gr), Yr;
      })();
      function ShapeCollection() {
        (this._length = 0),
          (this._maxLength = 4),
          (this.shapes = createSizedArray(this._maxLength));
      }
      (ShapeCollection.prototype.addShape = function (Wr) {
        this._length === this._maxLength &&
          ((this.shapes = this.shapes.concat(
            createSizedArray(this._maxLength)
          )),
          (this._maxLength *= 2)),
          (this.shapes[this._length] = Wr),
          (this._length += 1);
      }),
        (ShapeCollection.prototype.releaseShapes = function () {
          var Wr;
          for (Wr = 0; Wr < this._length; Wr += 1)
            shapePool.release(this.shapes[Wr]);
          this._length = 0;
        });
      var shapeCollectionPool = (function () {
          var Wr = {
              newShapeCollection: Kr,
              release: Zr,
            },
            ze = 0,
            Gr = 4,
            Yr = createSizedArray(Gr);
          function Kr() {
            var Jr;
            return (
              ze ? ((ze -= 1), (Jr = Yr[ze])) : (Jr = new ShapeCollection()), Jr
            );
          }
          function Zr(Jr) {
            var Qr,
              ei = Jr._length;
            for (Qr = 0; Qr < ei; Qr += 1) shapePool.release(Jr.shapes[Qr]);
            (Jr._length = 0),
              ze === Gr && ((Yr = pooling.double(Yr)), (Gr *= 2)),
              (Yr[ze] = Jr),
              (ze += 1);
          }
          return Wr;
        })(),
        ShapePropertyFactory = (function () {
          var Wr = -999999;
          function ze(ai, hi, ci) {
            var fi = ci.lastIndex,
              di,
              pi,
              mi,
              Si,
              yi,
              Ei,
              Pi,
              Ai,
              Ri,
              wi = this.keyframes;
            if (ai < wi[0].t - this.offsetTime)
              (di = wi[0].s[0]), (mi = !0), (fi = 0);
            else if (ai >= wi[wi.length - 1].t - this.offsetTime)
              (di = wi[wi.length - 1].s
                ? wi[wi.length - 1].s[0]
                : wi[wi.length - 2].e[0]),
                (mi = !0);
            else {
              for (
                var Ci = fi, bi = wi.length - 1, Mi = !0, gi, xi, Ti;
                Mi &&
                ((gi = wi[Ci]),
                (xi = wi[Ci + 1]),
                !(xi.t - this.offsetTime > ai));

              )
                Ci < bi - 1 ? (Ci += 1) : (Mi = !1);
              if (
                ((Ti = this.keyframesMetadata[Ci] || {}),
                (mi = gi.h === 1),
                (fi = Ci),
                !mi)
              ) {
                if (ai >= xi.t - this.offsetTime) Ai = 1;
                else if (ai < gi.t - this.offsetTime) Ai = 0;
                else {
                  var vi;
                  Ti.__fnct
                    ? (vi = Ti.__fnct)
                    : ((vi = BezierFactory.getBezierEasing(
                        gi.o.x,
                        gi.o.y,
                        gi.i.x,
                        gi.i.y
                      ).get),
                      (Ti.__fnct = vi)),
                    (Ai = vi(
                      (ai - (gi.t - this.offsetTime)) /
                        (xi.t - this.offsetTime - (gi.t - this.offsetTime))
                    ));
                }
                pi = xi.s ? xi.s[0] : gi.e[0];
              }
              di = gi.s[0];
            }
            for (
              Ei = hi._length, Pi = di.i[0].length, ci.lastIndex = fi, Si = 0;
              Si < Ei;
              Si += 1
            )
              for (yi = 0; yi < Pi; yi += 1)
                (Ri = mi
                  ? di.i[Si][yi]
                  : di.i[Si][yi] + (pi.i[Si][yi] - di.i[Si][yi]) * Ai),
                  (hi.i[Si][yi] = Ri),
                  (Ri = mi
                    ? di.o[Si][yi]
                    : di.o[Si][yi] + (pi.o[Si][yi] - di.o[Si][yi]) * Ai),
                  (hi.o[Si][yi] = Ri),
                  (Ri = mi
                    ? di.v[Si][yi]
                    : di.v[Si][yi] + (pi.v[Si][yi] - di.v[Si][yi]) * Ai),
                  (hi.v[Si][yi] = Ri);
          }
          function Gr() {
            var ai = this.comp.renderedFrame - this.offsetTime,
              hi = this.keyframes[0].t - this.offsetTime,
              ci =
                this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
              fi = this._caching.lastFrame;
            return (
              (fi !== Wr && ((fi < hi && ai < hi) || (fi > ci && ai > ci))) ||
                ((this._caching.lastIndex =
                  fi < ai ? this._caching.lastIndex : 0),
                this.interpolateShape(ai, this.pv, this._caching)),
              (this._caching.lastFrame = ai),
              this.pv
            );
          }
          function Yr() {
            this.paths = this.localShapeCollection;
          }
          function Kr(ai, hi) {
            if (ai._length !== hi._length || ai.c !== hi.c) return !1;
            var ci,
              fi = ai._length;
            for (ci = 0; ci < fi; ci += 1)
              if (
                ai.v[ci][0] !== hi.v[ci][0] ||
                ai.v[ci][1] !== hi.v[ci][1] ||
                ai.o[ci][0] !== hi.o[ci][0] ||
                ai.o[ci][1] !== hi.o[ci][1] ||
                ai.i[ci][0] !== hi.i[ci][0] ||
                ai.i[ci][1] !== hi.i[ci][1]
              )
                return !1;
            return !0;
          }
          function Zr(ai) {
            Kr(this.v, ai) ||
              ((this.v = shapePool.clone(ai)),
              this.localShapeCollection.releaseShapes(),
              this.localShapeCollection.addShape(this.v),
              (this._mdf = !0),
              (this.paths = this.localShapeCollection));
          }
          function Jr() {
            if (this.elem.globalData.frameId !== this.frameId) {
              if (!this.effectsSequence.length) {
                this._mdf = !1;
                return;
              }
              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }
              (this.lock = !0), (this._mdf = !1);
              var ai;
              this.kf
                ? (ai = this.pv)
                : this.data.ks
                ? (ai = this.data.ks.k)
                : (ai = this.data.pt.k);
              var hi,
                ci = this.effectsSequence.length;
              for (hi = 0; hi < ci; hi += 1) ai = this.effectsSequence[hi](ai);
              this.setVValue(ai),
                (this.lock = !1),
                (this.frameId = this.elem.globalData.frameId);
            }
          }
          function Qr(ai, hi, ci) {
            (this.propType = "shape"),
              (this.comp = ai.comp),
              (this.container = ai),
              (this.elem = ai),
              (this.data = hi),
              (this.k = !1),
              (this.kf = !1),
              (this._mdf = !1);
            var fi = ci === 3 ? hi.pt.k : hi.ks.k;
            (this.v = shapePool.clone(fi)),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.reset = Yr),
              (this.effectsSequence = []);
          }
          function ei(ai) {
            this.effectsSequence.push(ai),
              this.container.addDynamicProperty(this);
          }
          (Qr.prototype.interpolateShape = ze),
            (Qr.prototype.getValue = Jr),
            (Qr.prototype.setVValue = Zr),
            (Qr.prototype.addEffect = ei);
          function ti(ai, hi, ci) {
            (this.propType = "shape"),
              (this.comp = ai.comp),
              (this.elem = ai),
              (this.container = ai),
              (this.offsetTime = ai.data.st),
              (this.keyframes = ci === 3 ? hi.pt.k : hi.ks.k),
              (this.keyframesMetadata = []),
              (this.k = !0),
              (this.kf = !0);
            var fi = this.keyframes[0].s[0].i.length;
            (this.v = shapePool.newElement()),
              this.v.setPathData(this.keyframes[0].s[0].c, fi),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.lastFrame = Wr),
              (this.reset = Yr),
              (this._caching = {
                lastFrame: Wr,
                lastIndex: 0,
              }),
              (this.effectsSequence = [Gr.bind(this)]);
          }
          (ti.prototype.getValue = Jr),
            (ti.prototype.interpolateShape = ze),
            (ti.prototype.setVValue = Zr),
            (ti.prototype.addEffect = ei);
          var ri = (function () {
              var ai = roundCorner;
              function hi(ci, fi) {
                (this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 4),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  (this.paths = this.localShapeCollection),
                  this.localShapeCollection.addShape(this.v),
                  (this.d = fi.d),
                  (this.elem = ci),
                  (this.comp = ci.comp),
                  (this.frameId = -1),
                  this.initDynamicPropertyContainer(ci),
                  (this.p = PropertyFactory.getProp(ci, fi.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(ci, fi.s, 1, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertEllToPath());
              }
              return (
                (hi.prototype = {
                  reset: Yr,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertEllToPath());
                  },
                  convertEllToPath: function () {
                    var fi = this.p.v[0],
                      di = this.p.v[1],
                      pi = this.s.v[0] / 2,
                      mi = this.s.v[1] / 2,
                      Si = this.d !== 3,
                      yi = this.v;
                    (yi.v[0][0] = fi),
                      (yi.v[0][1] = di - mi),
                      (yi.v[1][0] = Si ? fi + pi : fi - pi),
                      (yi.v[1][1] = di),
                      (yi.v[2][0] = fi),
                      (yi.v[2][1] = di + mi),
                      (yi.v[3][0] = Si ? fi - pi : fi + pi),
                      (yi.v[3][1] = di),
                      (yi.i[0][0] = Si ? fi - pi * ai : fi + pi * ai),
                      (yi.i[0][1] = di - mi),
                      (yi.i[1][0] = Si ? fi + pi : fi - pi),
                      (yi.i[1][1] = di - mi * ai),
                      (yi.i[2][0] = Si ? fi + pi * ai : fi - pi * ai),
                      (yi.i[2][1] = di + mi),
                      (yi.i[3][0] = Si ? fi - pi : fi + pi),
                      (yi.i[3][1] = di + mi * ai),
                      (yi.o[0][0] = Si ? fi + pi * ai : fi - pi * ai),
                      (yi.o[0][1] = di - mi),
                      (yi.o[1][0] = Si ? fi + pi : fi - pi),
                      (yi.o[1][1] = di + mi * ai),
                      (yi.o[2][0] = Si ? fi - pi * ai : fi + pi * ai),
                      (yi.o[2][1] = di + mi),
                      (yi.o[3][0] = Si ? fi - pi : fi + pi),
                      (yi.o[3][1] = di - mi * ai);
                  },
                }),
                extendPrototype([DynamicPropertyContainer], hi),
                hi
              );
            })(),
            ni = (function () {
              function ai(hi, ci) {
                (this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 0),
                  (this.elem = hi),
                  (this.comp = hi.comp),
                  (this.data = ci),
                  (this.frameId = -1),
                  (this.d = ci.d),
                  this.initDynamicPropertyContainer(hi),
                  ci.sy === 1
                    ? ((this.ir = PropertyFactory.getProp(
                        hi,
                        ci.ir,
                        0,
                        0,
                        this
                      )),
                      (this.is = PropertyFactory.getProp(
                        hi,
                        ci.is,
                        0,
                        0.01,
                        this
                      )),
                      (this.convertToPath = this.convertStarToPath))
                    : (this.convertToPath = this.convertPolygonToPath),
                  (this.pt = PropertyFactory.getProp(hi, ci.pt, 0, 0, this)),
                  (this.p = PropertyFactory.getProp(hi, ci.p, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(
                    hi,
                    ci.r,
                    0,
                    degToRads,
                    this
                  )),
                  (this.or = PropertyFactory.getProp(hi, ci.or, 0, 0, this)),
                  (this.os = PropertyFactory.getProp(hi, ci.os, 0, 0.01, this)),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertToPath());
              }
              return (
                (ai.prototype = {
                  reset: Yr,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertToPath());
                  },
                  convertStarToPath: function () {
                    var ci = Math.floor(this.pt.v) * 2,
                      fi = (Math.PI * 2) / ci,
                      di = !0,
                      pi = this.or.v,
                      mi = this.ir.v,
                      Si = this.os.v,
                      yi = this.is.v,
                      Ei = (2 * Math.PI * pi) / (ci * 2),
                      Pi = (2 * Math.PI * mi) / (ci * 2),
                      Ai,
                      Ri,
                      wi,
                      Ci,
                      bi = -Math.PI / 2;
                    bi += this.r.v;
                    var Mi = this.data.d === 3 ? -1 : 1;
                    for (this.v._length = 0, Ai = 0; Ai < ci; Ai += 1) {
                      (Ri = di ? pi : mi),
                        (wi = di ? Si : yi),
                        (Ci = di ? Ei : Pi);
                      var gi = Ri * Math.cos(bi),
                        xi = Ri * Math.sin(bi),
                        Ti =
                          gi === 0 && xi === 0
                            ? 0
                            : xi / Math.sqrt(gi * gi + xi * xi),
                        vi =
                          gi === 0 && xi === 0
                            ? 0
                            : -gi / Math.sqrt(gi * gi + xi * xi);
                      (gi += +this.p.v[0]),
                        (xi += +this.p.v[1]),
                        this.v.setTripleAt(
                          gi,
                          xi,
                          gi - Ti * Ci * wi * Mi,
                          xi - vi * Ci * wi * Mi,
                          gi + Ti * Ci * wi * Mi,
                          xi + vi * Ci * wi * Mi,
                          Ai,
                          !0
                        ),
                        (di = !di),
                        (bi += fi * Mi);
                    }
                  },
                  convertPolygonToPath: function () {
                    var ci = Math.floor(this.pt.v),
                      fi = (Math.PI * 2) / ci,
                      di = this.or.v,
                      pi = this.os.v,
                      mi = (2 * Math.PI * di) / (ci * 4),
                      Si,
                      yi = -Math.PI * 0.5,
                      Ei = this.data.d === 3 ? -1 : 1;
                    for (
                      yi += this.r.v, this.v._length = 0, Si = 0;
                      Si < ci;
                      Si += 1
                    ) {
                      var Pi = di * Math.cos(yi),
                        Ai = di * Math.sin(yi),
                        Ri =
                          Pi === 0 && Ai === 0
                            ? 0
                            : Ai / Math.sqrt(Pi * Pi + Ai * Ai),
                        wi =
                          Pi === 0 && Ai === 0
                            ? 0
                            : -Pi / Math.sqrt(Pi * Pi + Ai * Ai);
                      (Pi += +this.p.v[0]),
                        (Ai += +this.p.v[1]),
                        this.v.setTripleAt(
                          Pi,
                          Ai,
                          Pi - Ri * mi * pi * Ei,
                          Ai - wi * mi * pi * Ei,
                          Pi + Ri * mi * pi * Ei,
                          Ai + wi * mi * pi * Ei,
                          Si,
                          !0
                        ),
                        (yi += fi * Ei);
                    }
                    (this.paths.length = 0), (this.paths[0] = this.v);
                  },
                }),
                extendPrototype([DynamicPropertyContainer], ai),
                ai
              );
            })(),
            ii = (function () {
              function ai(hi, ci) {
                (this.v = shapePool.newElement()),
                  (this.v.c = !0),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  (this.elem = hi),
                  (this.comp = hi.comp),
                  (this.frameId = -1),
                  (this.d = ci.d),
                  this.initDynamicPropertyContainer(hi),
                  (this.p = PropertyFactory.getProp(hi, ci.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(hi, ci.s, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(hi, ci.r, 0, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertRectToPath());
              }
              return (
                (ai.prototype = {
                  convertRectToPath: function () {
                    var ci = this.p.v[0],
                      fi = this.p.v[1],
                      di = this.s.v[0] / 2,
                      pi = this.s.v[1] / 2,
                      mi = bmMin(di, pi, this.r.v),
                      Si = mi * (1 - roundCorner);
                    (this.v._length = 0),
                      this.d === 2 || this.d === 1
                        ? (this.v.setTripleAt(
                            ci + di,
                            fi - pi + mi,
                            ci + di,
                            fi - pi + mi,
                            ci + di,
                            fi - pi + Si,
                            0,
                            !0
                          ),
                          this.v.setTripleAt(
                            ci + di,
                            fi + pi - mi,
                            ci + di,
                            fi + pi - Si,
                            ci + di,
                            fi + pi - mi,
                            1,
                            !0
                          ),
                          mi !== 0
                            ? (this.v.setTripleAt(
                                ci + di - mi,
                                fi + pi,
                                ci + di - mi,
                                fi + pi,
                                ci + di - Si,
                                fi + pi,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di + mi,
                                fi + pi,
                                ci - di + Si,
                                fi + pi,
                                ci - di + mi,
                                fi + pi,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di,
                                fi + pi - mi,
                                ci - di,
                                fi + pi - mi,
                                ci - di,
                                fi + pi - Si,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di,
                                fi - pi + mi,
                                ci - di,
                                fi - pi + Si,
                                ci - di,
                                fi - pi + mi,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di + mi,
                                fi - pi,
                                ci - di + mi,
                                fi - pi,
                                ci - di + Si,
                                fi - pi,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci + di - mi,
                                fi - pi,
                                ci + di - Si,
                                fi - pi,
                                ci + di - mi,
                                fi - pi,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                ci - di,
                                fi + pi,
                                ci - di + Si,
                                fi + pi,
                                ci - di,
                                fi + pi,
                                2
                              ),
                              this.v.setTripleAt(
                                ci - di,
                                fi - pi,
                                ci - di,
                                fi - pi + Si,
                                ci - di,
                                fi - pi,
                                3
                              )))
                        : (this.v.setTripleAt(
                            ci + di,
                            fi - pi + mi,
                            ci + di,
                            fi - pi + Si,
                            ci + di,
                            fi - pi + mi,
                            0,
                            !0
                          ),
                          mi !== 0
                            ? (this.v.setTripleAt(
                                ci + di - mi,
                                fi - pi,
                                ci + di - mi,
                                fi - pi,
                                ci + di - Si,
                                fi - pi,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di + mi,
                                fi - pi,
                                ci - di + Si,
                                fi - pi,
                                ci - di + mi,
                                fi - pi,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di,
                                fi - pi + mi,
                                ci - di,
                                fi - pi + mi,
                                ci - di,
                                fi - pi + Si,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di,
                                fi + pi - mi,
                                ci - di,
                                fi + pi - Si,
                                ci - di,
                                fi + pi - mi,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di + mi,
                                fi + pi,
                                ci - di + mi,
                                fi + pi,
                                ci - di + Si,
                                fi + pi,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci + di - mi,
                                fi + pi,
                                ci + di - Si,
                                fi + pi,
                                ci + di - mi,
                                fi + pi,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci + di,
                                fi + pi - mi,
                                ci + di,
                                fi + pi - mi,
                                ci + di,
                                fi + pi - Si,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                ci - di,
                                fi - pi,
                                ci - di + Si,
                                fi - pi,
                                ci - di,
                                fi - pi,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci - di,
                                fi + pi,
                                ci - di,
                                fi + pi - Si,
                                ci - di,
                                fi + pi,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                ci + di,
                                fi + pi,
                                ci + di - Si,
                                fi + pi,
                                ci + di,
                                fi + pi,
                                3,
                                !0
                              )));
                  },
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertRectToPath());
                  },
                  reset: Yr,
                }),
                extendPrototype([DynamicPropertyContainer], ai),
                ai
              );
            })();
          function si(ai, hi, ci) {
            var fi;
            if (ci === 3 || ci === 4) {
              var di = ci === 3 ? hi.pt : hi.ks,
                pi = di.k;
              pi.length ? (fi = new ti(ai, hi, ci)) : (fi = new Qr(ai, hi, ci));
            } else
              ci === 5
                ? (fi = new ii(ai, hi))
                : ci === 6
                ? (fi = new ri(ai, hi))
                : ci === 7 && (fi = new ni(ai, hi));
            return fi.k && ai.addDynamicProperty(fi), fi;
          }
          function li() {
            return Qr;
          }
          function oi() {
            return ti;
          }
          var ui = {};
          return (
            (ui.getShapeProp = si),
            (ui.getConstructorFunction = li),
            (ui.getKeyframedConstructorFunction = oi),
            ui
          );
        })();
      /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */
      var Matrix = (function () {
        var Wr = Math.cos,
          ze = Math.sin,
          Gr = Math.tan,
          Yr = Math.round;
        function Kr() {
          return (
            (this.props[0] = 1),
            (this.props[1] = 0),
            (this.props[2] = 0),
            (this.props[3] = 0),
            (this.props[4] = 0),
            (this.props[5] = 1),
            (this.props[6] = 0),
            (this.props[7] = 0),
            (this.props[8] = 0),
            (this.props[9] = 0),
            (this.props[10] = 1),
            (this.props[11] = 0),
            (this.props[12] = 0),
            (this.props[13] = 0),
            (this.props[14] = 0),
            (this.props[15] = 1),
            this
          );
        }
        function Zr(gi) {
          if (gi === 0) return this;
          var xi = Wr(gi),
            Ti = ze(gi);
          return this._t(xi, -Ti, 0, 0, Ti, xi, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function Jr(gi) {
          if (gi === 0) return this;
          var xi = Wr(gi),
            Ti = ze(gi);
          return this._t(1, 0, 0, 0, 0, xi, -Ti, 0, 0, Ti, xi, 0, 0, 0, 0, 1);
        }
        function Qr(gi) {
          if (gi === 0) return this;
          var xi = Wr(gi),
            Ti = ze(gi);
          return this._t(xi, 0, Ti, 0, 0, 1, 0, 0, -Ti, 0, xi, 0, 0, 0, 0, 1);
        }
        function ei(gi) {
          if (gi === 0) return this;
          var xi = Wr(gi),
            Ti = ze(gi);
          return this._t(xi, -Ti, 0, 0, Ti, xi, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function ti(gi, xi) {
          return this._t(1, xi, gi, 1, 0, 0);
        }
        function ri(gi, xi) {
          return this.shear(Gr(gi), Gr(xi));
        }
        function ni(gi, xi) {
          var Ti = Wr(xi),
            vi = ze(xi);
          return this._t(Ti, vi, 0, 0, -vi, Ti, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(1, 0, 0, 0, Gr(gi), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(Ti, -vi, 0, 0, vi, Ti, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function ii(gi, xi, Ti) {
          return (
            !Ti && Ti !== 0 && (Ti = 1),
            gi === 1 && xi === 1 && Ti === 1
              ? this
              : this._t(gi, 0, 0, 0, 0, xi, 0, 0, 0, 0, Ti, 0, 0, 0, 0, 1)
          );
        }
        function si(
          gi,
          xi,
          Ti,
          vi,
          Ii,
          Oi,
          ki,
          Bi,
          Xi,
          an,
          Qi,
          ln,
          yn,
          un,
          Vi,
          rn
        ) {
          return (
            (this.props[0] = gi),
            (this.props[1] = xi),
            (this.props[2] = Ti),
            (this.props[3] = vi),
            (this.props[4] = Ii),
            (this.props[5] = Oi),
            (this.props[6] = ki),
            (this.props[7] = Bi),
            (this.props[8] = Xi),
            (this.props[9] = an),
            (this.props[10] = Qi),
            (this.props[11] = ln),
            (this.props[12] = yn),
            (this.props[13] = un),
            (this.props[14] = Vi),
            (this.props[15] = rn),
            this
          );
        }
        function li(gi, xi, Ti) {
          return (
            (Ti = Ti || 0),
            gi !== 0 || xi !== 0 || Ti !== 0
              ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, gi, xi, Ti, 1)
              : this
          );
        }
        function oi(
          gi,
          xi,
          Ti,
          vi,
          Ii,
          Oi,
          ki,
          Bi,
          Xi,
          an,
          Qi,
          ln,
          yn,
          un,
          Vi,
          rn
        ) {
          var qi = this.props;
          if (
            gi === 1 &&
            xi === 0 &&
            Ti === 0 &&
            vi === 0 &&
            Ii === 0 &&
            Oi === 1 &&
            ki === 0 &&
            Bi === 0 &&
            Xi === 0 &&
            an === 0 &&
            Qi === 1 &&
            ln === 0
          )
            return (
              (qi[12] = qi[12] * gi + qi[15] * yn),
              (qi[13] = qi[13] * Oi + qi[15] * un),
              (qi[14] = qi[14] * Qi + qi[15] * Vi),
              (qi[15] *= rn),
              (this._identityCalculated = !1),
              this
            );
          var pn = qi[0],
            vn = qi[1],
            zi = qi[2],
            mn = qi[3],
            Sn = qi[4],
            Dn = qi[5],
            Cn = qi[6],
            $n = qi[7],
            Di = qi[8],
            Li = qi[9],
            Gi = qi[10],
            Yi = qi[11],
            Ki = qi[12],
            Zi = qi[13],
            _n = qi[14],
            tn = qi[15];
          return (
            (qi[0] = pn * gi + vn * Ii + zi * Xi + mn * yn),
            (qi[1] = pn * xi + vn * Oi + zi * an + mn * un),
            (qi[2] = pn * Ti + vn * ki + zi * Qi + mn * Vi),
            (qi[3] = pn * vi + vn * Bi + zi * ln + mn * rn),
            (qi[4] = Sn * gi + Dn * Ii + Cn * Xi + $n * yn),
            (qi[5] = Sn * xi + Dn * Oi + Cn * an + $n * un),
            (qi[6] = Sn * Ti + Dn * ki + Cn * Qi + $n * Vi),
            (qi[7] = Sn * vi + Dn * Bi + Cn * ln + $n * rn),
            (qi[8] = Di * gi + Li * Ii + Gi * Xi + Yi * yn),
            (qi[9] = Di * xi + Li * Oi + Gi * an + Yi * un),
            (qi[10] = Di * Ti + Li * ki + Gi * Qi + Yi * Vi),
            (qi[11] = Di * vi + Li * Bi + Gi * ln + Yi * rn),
            (qi[12] = Ki * gi + Zi * Ii + _n * Xi + tn * yn),
            (qi[13] = Ki * xi + Zi * Oi + _n * an + tn * un),
            (qi[14] = Ki * Ti + Zi * ki + _n * Qi + tn * Vi),
            (qi[15] = Ki * vi + Zi * Bi + _n * ln + tn * rn),
            (this._identityCalculated = !1),
            this
          );
        }
        function ui(gi) {
          var xi = gi.props;
          return this.transform(
            xi[0],
            xi[1],
            xi[2],
            xi[3],
            xi[4],
            xi[5],
            xi[6],
            xi[7],
            xi[8],
            xi[9],
            xi[10],
            xi[11],
            xi[12],
            xi[13],
            xi[14],
            xi[15]
          );
        }
        function ai() {
          return (
            this._identityCalculated ||
              ((this._identity = !(
                this.props[0] !== 1 ||
                this.props[1] !== 0 ||
                this.props[2] !== 0 ||
                this.props[3] !== 0 ||
                this.props[4] !== 0 ||
                this.props[5] !== 1 ||
                this.props[6] !== 0 ||
                this.props[7] !== 0 ||
                this.props[8] !== 0 ||
                this.props[9] !== 0 ||
                this.props[10] !== 1 ||
                this.props[11] !== 0 ||
                this.props[12] !== 0 ||
                this.props[13] !== 0 ||
                this.props[14] !== 0 ||
                this.props[15] !== 1
              )),
              (this._identityCalculated = !0)),
            this._identity
          );
        }
        function hi(gi) {
          for (var xi = 0; xi < 16; ) {
            if (gi.props[xi] !== this.props[xi]) return !1;
            xi += 1;
          }
          return !0;
        }
        function ci(gi) {
          var xi;
          for (xi = 0; xi < 16; xi += 1) gi.props[xi] = this.props[xi];
          return gi;
        }
        function fi(gi) {
          var xi;
          for (xi = 0; xi < 16; xi += 1) this.props[xi] = gi[xi];
        }
        function di(gi, xi, Ti) {
          return {
            x:
              gi * this.props[0] +
              xi * this.props[4] +
              Ti * this.props[8] +
              this.props[12],
            y:
              gi * this.props[1] +
              xi * this.props[5] +
              Ti * this.props[9] +
              this.props[13],
            z:
              gi * this.props[2] +
              xi * this.props[6] +
              Ti * this.props[10] +
              this.props[14],
          };
        }
        function pi(gi, xi, Ti) {
          return (
            gi * this.props[0] +
            xi * this.props[4] +
            Ti * this.props[8] +
            this.props[12]
          );
        }
        function mi(gi, xi, Ti) {
          return (
            gi * this.props[1] +
            xi * this.props[5] +
            Ti * this.props[9] +
            this.props[13]
          );
        }
        function Si(gi, xi, Ti) {
          return (
            gi * this.props[2] +
            xi * this.props[6] +
            Ti * this.props[10] +
            this.props[14]
          );
        }
        function yi() {
          var gi =
              this.props[0] * this.props[5] - this.props[1] * this.props[4],
            xi = this.props[5] / gi,
            Ti = -this.props[1] / gi,
            vi = -this.props[4] / gi,
            Ii = this.props[0] / gi,
            Oi =
              (this.props[4] * this.props[13] -
                this.props[5] * this.props[12]) /
              gi,
            ki =
              -(
                this.props[0] * this.props[13] -
                this.props[1] * this.props[12]
              ) / gi,
            Bi = new Matrix();
          return (
            (Bi.props[0] = xi),
            (Bi.props[1] = Ti),
            (Bi.props[4] = vi),
            (Bi.props[5] = Ii),
            (Bi.props[12] = Oi),
            (Bi.props[13] = ki),
            Bi
          );
        }
        function Ei(gi) {
          var xi = this.getInverseMatrix();
          return xi.applyToPointArray(gi[0], gi[1], gi[2] || 0);
        }
        function Pi(gi) {
          var xi,
            Ti = gi.length,
            vi = [];
          for (xi = 0; xi < Ti; xi += 1) vi[xi] = Ei(gi[xi]);
          return vi;
        }
        function Ai(gi, xi, Ti) {
          var vi = createTypedArray("float32", 6);
          if (this.isIdentity())
            (vi[0] = gi[0]),
              (vi[1] = gi[1]),
              (vi[2] = xi[0]),
              (vi[3] = xi[1]),
              (vi[4] = Ti[0]),
              (vi[5] = Ti[1]);
          else {
            var Ii = this.props[0],
              Oi = this.props[1],
              ki = this.props[4],
              Bi = this.props[5],
              Xi = this.props[12],
              an = this.props[13];
            (vi[0] = gi[0] * Ii + gi[1] * ki + Xi),
              (vi[1] = gi[0] * Oi + gi[1] * Bi + an),
              (vi[2] = xi[0] * Ii + xi[1] * ki + Xi),
              (vi[3] = xi[0] * Oi + xi[1] * Bi + an),
              (vi[4] = Ti[0] * Ii + Ti[1] * ki + Xi),
              (vi[5] = Ti[0] * Oi + Ti[1] * Bi + an);
          }
          return vi;
        }
        function Ri(gi, xi, Ti) {
          var vi;
          return (
            this.isIdentity()
              ? (vi = [gi, xi, Ti])
              : (vi = [
                  gi * this.props[0] +
                    xi * this.props[4] +
                    Ti * this.props[8] +
                    this.props[12],
                  gi * this.props[1] +
                    xi * this.props[5] +
                    Ti * this.props[9] +
                    this.props[13],
                  gi * this.props[2] +
                    xi * this.props[6] +
                    Ti * this.props[10] +
                    this.props[14],
                ]),
            vi
          );
        }
        function wi(gi, xi) {
          if (this.isIdentity()) return gi + "," + xi;
          var Ti = this.props;
          return (
            Math.round((gi * Ti[0] + xi * Ti[4] + Ti[12]) * 100) / 100 +
            "," +
            Math.round((gi * Ti[1] + xi * Ti[5] + Ti[13]) * 100) / 100
          );
        }
        function Ci() {
          for (
            var gi = 0, xi = this.props, Ti = "matrix3d(", vi = 1e4;
            gi < 16;

          )
            (Ti += Yr(xi[gi] * vi) / vi),
              (Ti += gi === 15 ? ")" : ","),
              (gi += 1);
          return Ti;
        }
        function bi(gi) {
          var xi = 1e4;
          return (gi < 1e-6 && gi > 0) || (gi > -1e-6 && gi < 0)
            ? Yr(gi * xi) / xi
            : gi;
        }
        function Mi() {
          var gi = this.props,
            xi = bi(gi[0]),
            Ti = bi(gi[1]),
            vi = bi(gi[4]),
            Ii = bi(gi[5]),
            Oi = bi(gi[12]),
            ki = bi(gi[13]);
          return (
            "matrix(" +
            xi +
            "," +
            Ti +
            "," +
            vi +
            "," +
            Ii +
            "," +
            Oi +
            "," +
            ki +
            ")"
          );
        }
        return function () {
          (this.reset = Kr),
            (this.rotate = Zr),
            (this.rotateX = Jr),
            (this.rotateY = Qr),
            (this.rotateZ = ei),
            (this.skew = ri),
            (this.skewFromAxis = ni),
            (this.shear = ti),
            (this.scale = ii),
            (this.setTransform = si),
            (this.translate = li),
            (this.transform = oi),
            (this.multiply = ui),
            (this.applyToPoint = di),
            (this.applyToX = pi),
            (this.applyToY = mi),
            (this.applyToZ = Si),
            (this.applyToPointArray = Ri),
            (this.applyToTriplePoints = Ai),
            (this.applyToPointStringified = wi),
            (this.toCSS = Ci),
            (this.to2dCSS = Mi),
            (this.clone = ci),
            (this.cloneFromProps = fi),
            (this.equals = hi),
            (this.inversePoints = Pi),
            (this.inversePoint = Ei),
            (this.getInverseMatrix = yi),
            (this._t = this.transform),
            (this.isIdentity = ai),
            (this._identity = !0),
            (this._identityCalculated = !1),
            (this.props = createTypedArray("float32", 16)),
            this.reset();
        };
      })();
      function _typeof$3(Wr) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$3 = function (Gr) {
                return typeof Gr;
              })
            : (_typeof$3 = function (Gr) {
                return Gr &&
                  typeof Symbol == "function" &&
                  Gr.constructor === Symbol &&
                  Gr !== Symbol.prototype
                  ? "symbol"
                  : typeof Gr;
              }),
          _typeof$3(Wr)
        );
      }
      var lottie = {};
      function setLocation(Wr) {
        setLocationHref(Wr);
      }
      function searchAnimations() {
        animationManager.searchAnimations();
      }
      function setSubframeRendering(Wr) {
        setSubframeEnabled(Wr);
      }
      function setPrefix(Wr) {
        setIdPrefix(Wr);
      }
      function loadAnimation(Wr) {
        return animationManager.loadAnimation(Wr);
      }
      function setQuality(Wr) {
        if (typeof Wr == "string")
          switch (Wr) {
            case "high":
              setDefaultCurveSegments(200);
              break;
            default:
            case "medium":
              setDefaultCurveSegments(50);
              break;
            case "low":
              setDefaultCurveSegments(10);
              break;
          }
        else !isNaN(Wr) && Wr > 1 && setDefaultCurveSegments(Wr);
      }
      function inBrowser() {
        return typeof navigator < "u";
      }
      function installPlugin(Wr, ze) {
        Wr === "expressions" && setExpressionsPlugin(ze);
      }
      function getFactory(Wr) {
        switch (Wr) {
          case "propertyFactory":
            return PropertyFactory;
          case "shapePropertyFactory":
            return ShapePropertyFactory;
          case "matrix":
            return Matrix;
          default:
            return null;
        }
      }
      (lottie.play = animationManager.play),
        (lottie.pause = animationManager.pause),
        (lottie.setLocationHref = setLocation),
        (lottie.togglePause = animationManager.togglePause),
        (lottie.setSpeed = animationManager.setSpeed),
        (lottie.setDirection = animationManager.setDirection),
        (lottie.stop = animationManager.stop),
        (lottie.searchAnimations = searchAnimations),
        (lottie.registerAnimation = animationManager.registerAnimation),
        (lottie.loadAnimation = loadAnimation),
        (lottie.setSubframeRendering = setSubframeRendering),
        (lottie.resize = animationManager.resize),
        (lottie.goToAndStop = animationManager.goToAndStop),
        (lottie.destroy = animationManager.destroy),
        (lottie.setQuality = setQuality),
        (lottie.inBrowser = inBrowser),
        (lottie.installPlugin = installPlugin),
        (lottie.freeze = animationManager.freeze),
        (lottie.unfreeze = animationManager.unfreeze),
        (lottie.setVolume = animationManager.setVolume),
        (lottie.mute = animationManager.mute),
        (lottie.unmute = animationManager.unmute),
        (lottie.getRegisteredAnimations =
          animationManager.getRegisteredAnimations),
        (lottie.useWebWorker = setWebWorker),
        (lottie.setIDPrefix = setPrefix),
        (lottie.__getFactory = getFactory),
        (lottie.version = "5.12.2");
      function checkReady() {
        document.readyState === "complete" &&
          (clearInterval(readyStateCheckInterval), searchAnimations());
      }
      function getQueryVariable(Wr) {
        for (var ze = queryString.split("&"), Gr = 0; Gr < ze.length; Gr += 1) {
          var Yr = ze[Gr].split("=");
          if (decodeURIComponent(Yr[0]) == Wr) return decodeURIComponent(Yr[1]);
        }
        return null;
      }
      var queryString = "";
      {
        var scripts = document.getElementsByTagName("script"),
          index = scripts.length - 1,
          myScript = scripts[index] || {
            src: "",
          };
        (queryString = myScript.src
          ? myScript.src.replace(/^[^\?]+\??/, "")
          : ""),
          getQueryVariable("renderer");
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
        _typeof$3(exports) !== "object" && (window.bodymovin = lottie);
      } catch (Wr) {}
      var ShapeModifiers = (function () {
        var Wr = {},
          ze = {};
        (Wr.registerModifier = Gr), (Wr.getModifier = Yr);
        function Gr(Kr, Zr) {
          ze[Kr] || (ze[Kr] = Zr);
        }
        function Yr(Kr, Zr, Jr) {
          return new ze[Kr](Zr, Jr);
        }
        return Wr;
      })();
      function ShapeModifier() {}
      (ShapeModifier.prototype.initModifierProperties = function () {}),
        (ShapeModifier.prototype.addShapeToModifier = function () {}),
        (ShapeModifier.prototype.addShape = function (Wr) {
          if (!this.closed) {
            Wr.sh.container.addDynamicProperty(Wr.sh);
            var ze = {
              shape: Wr.sh,
              data: Wr,
              localShapeCollection: shapeCollectionPool.newShapeCollection(),
            };
            this.shapes.push(ze),
              this.addShapeToModifier(ze),
              this._isAnimated && Wr.setAsAnimated();
          }
        }),
        (ShapeModifier.prototype.init = function (Wr, ze) {
          (this.shapes = []),
            (this.elem = Wr),
            this.initDynamicPropertyContainer(Wr),
            this.initModifierProperties(Wr, ze),
            (this.frameId = initialDefaultFrame),
            (this.closed = !1),
            (this.k = !1),
            this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0);
        }),
        (ShapeModifier.prototype.processKeys = function () {
          this.elem.globalData.frameId !== this.frameId &&
            ((this.frameId = this.elem.globalData.frameId),
            this.iterateDynamicProperties());
        }),
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {}
      extendPrototype([ShapeModifier], TrimModifier),
        (TrimModifier.prototype.initModifierProperties = function (Wr, ze) {
          (this.s = PropertyFactory.getProp(Wr, ze.s, 0, 0.01, this)),
            (this.e = PropertyFactory.getProp(Wr, ze.e, 0, 0.01, this)),
            (this.o = PropertyFactory.getProp(Wr, ze.o, 0, 0, this)),
            (this.sValue = 0),
            (this.eValue = 0),
            (this.getValue = this.processKeys),
            (this.m = ze.m),
            (this._isAnimated =
              !!this.s.effectsSequence.length ||
              !!this.e.effectsSequence.length ||
              !!this.o.effectsSequence.length);
        }),
        (TrimModifier.prototype.addShapeToModifier = function (Wr) {
          Wr.pathsData = [];
        }),
        (TrimModifier.prototype.calculateShapeEdges = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr
        ) {
          var Zr = [];
          ze <= 1
            ? Zr.push({
                s: Wr,
                e: ze,
              })
            : Wr >= 1
            ? Zr.push({
                s: Wr - 1,
                e: ze - 1,
              })
            : (Zr.push({
                s: Wr,
                e: 1,
              }),
              Zr.push({
                s: 0,
                e: ze - 1,
              }));
          var Jr = [],
            Qr,
            ei = Zr.length,
            ti;
          for (Qr = 0; Qr < ei; Qr += 1)
            if (((ti = Zr[Qr]), !(ti.e * Kr < Yr || ti.s * Kr > Yr + Gr))) {
              var ri, ni;
              ti.s * Kr <= Yr ? (ri = 0) : (ri = (ti.s * Kr - Yr) / Gr),
                ti.e * Kr >= Yr + Gr ? (ni = 1) : (ni = (ti.e * Kr - Yr) / Gr),
                Jr.push([ri, ni]);
            }
          return Jr.length || Jr.push([0, 0]), Jr;
        }),
        (TrimModifier.prototype.releasePathsData = function (Wr) {
          var ze,
            Gr = Wr.length;
          for (ze = 0; ze < Gr; ze += 1) segmentsLengthPool.release(Wr[ze]);
          return (Wr.length = 0), Wr;
        }),
        (TrimModifier.prototype.processShapes = function (Wr) {
          var ze, Gr;
          if (this._mdf || Wr) {
            var Yr = (this.o.v % 360) / 360;
            if (
              (Yr < 0 && (Yr += 1),
              this.s.v > 1
                ? (ze = 1 + Yr)
                : this.s.v < 0
                ? (ze = 0 + Yr)
                : (ze = this.s.v + Yr),
              this.e.v > 1
                ? (Gr = 1 + Yr)
                : this.e.v < 0
                ? (Gr = 0 + Yr)
                : (Gr = this.e.v + Yr),
              ze > Gr)
            ) {
              var Kr = ze;
              (ze = Gr), (Gr = Kr);
            }
            (ze = Math.round(ze * 1e4) * 1e-4),
              (Gr = Math.round(Gr * 1e4) * 1e-4),
              (this.sValue = ze),
              (this.eValue = Gr);
          } else (ze = this.sValue), (Gr = this.eValue);
          var Zr,
            Jr,
            Qr = this.shapes.length,
            ei,
            ti,
            ri,
            ni,
            ii,
            si = 0;
          if (Gr === ze)
            for (Jr = 0; Jr < Qr; Jr += 1)
              this.shapes[Jr].localShapeCollection.releaseShapes(),
                (this.shapes[Jr].shape._mdf = !0),
                (this.shapes[Jr].shape.paths =
                  this.shapes[Jr].localShapeCollection),
                this._mdf && (this.shapes[Jr].pathsData.length = 0);
          else if ((Gr === 1 && ze === 0) || (Gr === 0 && ze === 1)) {
            if (this._mdf)
              for (Jr = 0; Jr < Qr; Jr += 1)
                (this.shapes[Jr].pathsData.length = 0),
                  (this.shapes[Jr].shape._mdf = !0);
          } else {
            var li = [],
              oi,
              ui;
            for (Jr = 0; Jr < Qr; Jr += 1)
              if (
                ((oi = this.shapes[Jr]),
                !oi.shape._mdf && !this._mdf && !Wr && this.m !== 2)
              )
                oi.shape.paths = oi.localShapeCollection;
              else {
                if (
                  ((Zr = oi.shape.paths),
                  (ti = Zr._length),
                  (ii = 0),
                  !oi.shape._mdf && oi.pathsData.length)
                )
                  ii = oi.totalShapeLength;
                else {
                  for (
                    ri = this.releasePathsData(oi.pathsData), ei = 0;
                    ei < ti;
                    ei += 1
                  )
                    (ni = bez.getSegmentsLength(Zr.shapes[ei])),
                      ri.push(ni),
                      (ii += ni.totalLength);
                  (oi.totalShapeLength = ii), (oi.pathsData = ri);
                }
                (si += ii), (oi.shape._mdf = !0);
              }
            var ai = ze,
              hi = Gr,
              ci = 0,
              fi;
            for (Jr = Qr - 1; Jr >= 0; Jr -= 1)
              if (((oi = this.shapes[Jr]), oi.shape._mdf)) {
                for (
                  ui = oi.localShapeCollection,
                    ui.releaseShapes(),
                    this.m === 2 && Qr > 1
                      ? ((fi = this.calculateShapeEdges(
                          ze,
                          Gr,
                          oi.totalShapeLength,
                          ci,
                          si
                        )),
                        (ci += oi.totalShapeLength))
                      : (fi = [[ai, hi]]),
                    ti = fi.length,
                    ei = 0;
                  ei < ti;
                  ei += 1
                ) {
                  (ai = fi[ei][0]),
                    (hi = fi[ei][1]),
                    (li.length = 0),
                    hi <= 1
                      ? li.push({
                          s: oi.totalShapeLength * ai,
                          e: oi.totalShapeLength * hi,
                        })
                      : ai >= 1
                      ? li.push({
                          s: oi.totalShapeLength * (ai - 1),
                          e: oi.totalShapeLength * (hi - 1),
                        })
                      : (li.push({
                          s: oi.totalShapeLength * ai,
                          e: oi.totalShapeLength,
                        }),
                        li.push({
                          s: 0,
                          e: oi.totalShapeLength * (hi - 1),
                        }));
                  var di = this.addShapes(oi, li[0]);
                  if (li[0].s !== li[0].e) {
                    if (li.length > 1) {
                      var pi =
                        oi.shape.paths.shapes[oi.shape.paths._length - 1];
                      if (pi.c) {
                        var mi = di.pop();
                        this.addPaths(di, ui),
                          (di = this.addShapes(oi, li[1], mi));
                      } else
                        this.addPaths(di, ui), (di = this.addShapes(oi, li[1]));
                    }
                    this.addPaths(di, ui);
                  }
                }
                oi.shape.paths = ui;
              }
          }
        }),
        (TrimModifier.prototype.addPaths = function (Wr, ze) {
          var Gr,
            Yr = Wr.length;
          for (Gr = 0; Gr < Yr; Gr += 1) ze.addShape(Wr[Gr]);
        }),
        (TrimModifier.prototype.addSegment = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr,
          Zr,
          Jr
        ) {
          Kr.setXYAt(ze[0], ze[1], "o", Zr),
            Kr.setXYAt(Gr[0], Gr[1], "i", Zr + 1),
            Jr && Kr.setXYAt(Wr[0], Wr[1], "v", Zr),
            Kr.setXYAt(Yr[0], Yr[1], "v", Zr + 1);
        }),
        (TrimModifier.prototype.addSegmentFromArray = function (
          Wr,
          ze,
          Gr,
          Yr
        ) {
          ze.setXYAt(Wr[1], Wr[5], "o", Gr),
            ze.setXYAt(Wr[2], Wr[6], "i", Gr + 1),
            Yr && ze.setXYAt(Wr[0], Wr[4], "v", Gr),
            ze.setXYAt(Wr[3], Wr[7], "v", Gr + 1);
        }),
        (TrimModifier.prototype.addShapes = function (Wr, ze, Gr) {
          var Yr = Wr.pathsData,
            Kr = Wr.shape.paths.shapes,
            Zr,
            Jr = Wr.shape.paths._length,
            Qr,
            ei,
            ti = 0,
            ri,
            ni,
            ii,
            si,
            li = [],
            oi,
            ui = !0;
          for (
            Gr
              ? ((ni = Gr._length), (oi = Gr._length))
              : ((Gr = shapePool.newElement()), (ni = 0), (oi = 0)),
              li.push(Gr),
              Zr = 0;
            Zr < Jr;
            Zr += 1
          ) {
            for (
              ii = Yr[Zr].lengths,
                Gr.c = Kr[Zr].c,
                ei = Kr[Zr].c ? ii.length : ii.length + 1,
                Qr = 1;
              Qr < ei;
              Qr += 1
            )
              if (((ri = ii[Qr - 1]), ti + ri.addedLength < ze.s))
                (ti += ri.addedLength), (Gr.c = !1);
              else if (ti > ze.e) {
                Gr.c = !1;
                break;
              } else
                ze.s <= ti && ze.e >= ti + ri.addedLength
                  ? (this.addSegment(
                      Kr[Zr].v[Qr - 1],
                      Kr[Zr].o[Qr - 1],
                      Kr[Zr].i[Qr],
                      Kr[Zr].v[Qr],
                      Gr,
                      ni,
                      ui
                    ),
                    (ui = !1))
                  : ((si = bez.getNewSegment(
                      Kr[Zr].v[Qr - 1],
                      Kr[Zr].v[Qr],
                      Kr[Zr].o[Qr - 1],
                      Kr[Zr].i[Qr],
                      (ze.s - ti) / ri.addedLength,
                      (ze.e - ti) / ri.addedLength,
                      ii[Qr - 1]
                    )),
                    this.addSegmentFromArray(si, Gr, ni, ui),
                    (ui = !1),
                    (Gr.c = !1)),
                  (ti += ri.addedLength),
                  (ni += 1);
            if (Kr[Zr].c && ii.length) {
              if (((ri = ii[Qr - 1]), ti <= ze.e)) {
                var ai = ii[Qr - 1].addedLength;
                ze.s <= ti && ze.e >= ti + ai
                  ? (this.addSegment(
                      Kr[Zr].v[Qr - 1],
                      Kr[Zr].o[Qr - 1],
                      Kr[Zr].i[0],
                      Kr[Zr].v[0],
                      Gr,
                      ni,
                      ui
                    ),
                    (ui = !1))
                  : ((si = bez.getNewSegment(
                      Kr[Zr].v[Qr - 1],
                      Kr[Zr].v[0],
                      Kr[Zr].o[Qr - 1],
                      Kr[Zr].i[0],
                      (ze.s - ti) / ai,
                      (ze.e - ti) / ai,
                      ii[Qr - 1]
                    )),
                    this.addSegmentFromArray(si, Gr, ni, ui),
                    (ui = !1),
                    (Gr.c = !1));
              } else Gr.c = !1;
              (ti += ri.addedLength), (ni += 1);
            }
            if (
              (Gr._length &&
                (Gr.setXYAt(Gr.v[oi][0], Gr.v[oi][1], "i", oi),
                Gr.setXYAt(
                  Gr.v[Gr._length - 1][0],
                  Gr.v[Gr._length - 1][1],
                  "o",
                  Gr._length - 1
                )),
              ti > ze.e)
            )
              break;
            Zr < Jr - 1 &&
              ((Gr = shapePool.newElement()), (ui = !0), li.push(Gr), (ni = 0));
          }
          return li;
        });
      function PuckerAndBloatModifier() {}
      extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        (PuckerAndBloatModifier.prototype.initModifierProperties = function (
          Wr,
          ze
        ) {
          (this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(Wr, ze.a, 0, null, this)),
            (this._isAnimated = !!this.amount.effectsSequence.length);
        }),
        (PuckerAndBloatModifier.prototype.processPath = function (Wr, ze) {
          var Gr = ze / 100,
            Yr = [0, 0],
            Kr = Wr._length,
            Zr = 0;
          for (Zr = 0; Zr < Kr; Zr += 1)
            (Yr[0] += Wr.v[Zr][0]), (Yr[1] += Wr.v[Zr][1]);
          (Yr[0] /= Kr), (Yr[1] /= Kr);
          var Jr = shapePool.newElement();
          Jr.c = Wr.c;
          var Qr, ei, ti, ri, ni, ii;
          for (Zr = 0; Zr < Kr; Zr += 1)
            (Qr = Wr.v[Zr][0] + (Yr[0] - Wr.v[Zr][0]) * Gr),
              (ei = Wr.v[Zr][1] + (Yr[1] - Wr.v[Zr][1]) * Gr),
              (ti = Wr.o[Zr][0] + (Yr[0] - Wr.o[Zr][0]) * -Gr),
              (ri = Wr.o[Zr][1] + (Yr[1] - Wr.o[Zr][1]) * -Gr),
              (ni = Wr.i[Zr][0] + (Yr[0] - Wr.i[Zr][0]) * -Gr),
              (ii = Wr.i[Zr][1] + (Yr[1] - Wr.i[Zr][1]) * -Gr),
              Jr.setTripleAt(Qr, ei, ti, ri, ni, ii, Zr);
          return Jr;
        }),
        (PuckerAndBloatModifier.prototype.processShapes = function (Wr) {
          var ze,
            Gr,
            Yr = this.shapes.length,
            Kr,
            Zr,
            Jr = this.amount.v;
          if (Jr !== 0) {
            var Qr, ei;
            for (Gr = 0; Gr < Yr; Gr += 1) {
              if (
                ((Qr = this.shapes[Gr]),
                (ei = Qr.localShapeCollection),
                !(!Qr.shape._mdf && !this._mdf && !Wr))
              )
                for (
                  ei.releaseShapes(),
                    Qr.shape._mdf = !0,
                    ze = Qr.shape.paths.shapes,
                    Zr = Qr.shape.paths._length,
                    Kr = 0;
                  Kr < Zr;
                  Kr += 1
                )
                  ei.addShape(this.processPath(ze[Kr], Jr));
              Qr.shape.paths = Qr.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      var TransformPropertyFactory = (function () {
        var Wr = [0, 0];
        function ze(ei) {
          var ti = this._mdf;
          this.iterateDynamicProperties(),
            (this._mdf = this._mdf || ti),
            this.a && ei.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
            this.s && ei.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
            this.sk && ei.skewFromAxis(-this.sk.v, this.sa.v),
            this.r
              ? ei.rotate(-this.r.v)
              : ei
                  .rotateZ(-this.rz.v)
                  .rotateY(this.ry.v)
                  .rotateX(this.rx.v)
                  .rotateZ(-this.or.v[2])
                  .rotateY(this.or.v[1])
                  .rotateX(this.or.v[0]),
            this.data.p.s
              ? this.data.p.z
                ? ei.translate(this.px.v, this.py.v, -this.pz.v)
                : ei.translate(this.px.v, this.py.v, 0)
              : ei.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
        function Gr(ei) {
          if (this.elem.globalData.frameId !== this.frameId) {
            if (
              (this._isDirty &&
                (this.precalculateMatrix(), (this._isDirty = !1)),
              this.iterateDynamicProperties(),
              this._mdf || ei)
            ) {
              var ti;
              if (
                (this.v.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1 &&
                  this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.appliedTransformations < 2 &&
                  this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk &&
                  this.appliedTransformations < 3 &&
                  this.v.skewFromAxis(-this.sk.v, this.sa.v),
                this.r && this.appliedTransformations < 4
                  ? this.v.rotate(-this.r.v)
                  : !this.r &&
                    this.appliedTransformations < 4 &&
                    this.v
                      .rotateZ(-this.rz.v)
                      .rotateY(this.ry.v)
                      .rotateX(this.rx.v)
                      .rotateZ(-this.or.v[2])
                      .rotateY(this.or.v[1])
                      .rotateX(this.or.v[0]),
                this.autoOriented)
              ) {
                var ri, ni;
                if (
                  ((ti = this.elem.globalData.frameRate),
                  this.p && this.p.keyframes && this.p.getValueAtTime)
                )
                  this.p._caching.lastFrame + this.p.offsetTime <=
                  this.p.keyframes[0].t
                    ? ((ri = this.p.getValueAtTime(
                        (this.p.keyframes[0].t + 0.01) / ti,
                        0
                      )),
                      (ni = this.p.getValueAtTime(
                        this.p.keyframes[0].t / ti,
                        0
                      )))
                    : this.p._caching.lastFrame + this.p.offsetTime >=
                      this.p.keyframes[this.p.keyframes.length - 1].t
                    ? ((ri = this.p.getValueAtTime(
                        this.p.keyframes[this.p.keyframes.length - 1].t / ti,
                        0
                      )),
                      (ni = this.p.getValueAtTime(
                        (this.p.keyframes[this.p.keyframes.length - 1].t -
                          0.05) /
                          ti,
                        0
                      )))
                    : ((ri = this.p.pv),
                      (ni = this.p.getValueAtTime(
                        (this.p._caching.lastFrame + this.p.offsetTime - 0.01) /
                          ti,
                        this.p.offsetTime
                      )));
                else if (
                  this.px &&
                  this.px.keyframes &&
                  this.py.keyframes &&
                  this.px.getValueAtTime &&
                  this.py.getValueAtTime
                ) {
                  (ri = []), (ni = []);
                  var ii = this.px,
                    si = this.py;
                  ii._caching.lastFrame + ii.offsetTime <= ii.keyframes[0].t
                    ? ((ri[0] = ii.getValueAtTime(
                        (ii.keyframes[0].t + 0.01) / ti,
                        0
                      )),
                      (ri[1] = si.getValueAtTime(
                        (si.keyframes[0].t + 0.01) / ti,
                        0
                      )),
                      (ni[0] = ii.getValueAtTime(ii.keyframes[0].t / ti, 0)),
                      (ni[1] = si.getValueAtTime(si.keyframes[0].t / ti, 0)))
                    : ii._caching.lastFrame + ii.offsetTime >=
                      ii.keyframes[ii.keyframes.length - 1].t
                    ? ((ri[0] = ii.getValueAtTime(
                        ii.keyframes[ii.keyframes.length - 1].t / ti,
                        0
                      )),
                      (ri[1] = si.getValueAtTime(
                        si.keyframes[si.keyframes.length - 1].t / ti,
                        0
                      )),
                      (ni[0] = ii.getValueAtTime(
                        (ii.keyframes[ii.keyframes.length - 1].t - 0.01) / ti,
                        0
                      )),
                      (ni[1] = si.getValueAtTime(
                        (si.keyframes[si.keyframes.length - 1].t - 0.01) / ti,
                        0
                      )))
                    : ((ri = [ii.pv, si.pv]),
                      (ni[0] = ii.getValueAtTime(
                        (ii._caching.lastFrame + ii.offsetTime - 0.01) / ti,
                        ii.offsetTime
                      )),
                      (ni[1] = si.getValueAtTime(
                        (si._caching.lastFrame + si.offsetTime - 0.01) / ti,
                        si.offsetTime
                      )));
                } else (ni = Wr), (ri = ni);
                this.v.rotate(-Math.atan2(ri[1] - ni[1], ri[0] - ni[0]));
              }
              this.data.p && this.data.p.s
                ? this.data.p.z
                  ? this.v.translate(this.px.v, this.py.v, -this.pz.v)
                  : this.v.translate(this.px.v, this.py.v, 0)
                : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
            this.frameId = this.elem.globalData.frameId;
          }
        }
        function Yr() {
          if (
            ((this.appliedTransformations = 0),
            this.pre.reset(),
            !this.a.effectsSequence.length)
          )
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
              (this.appliedTransformations = 1);
          else return;
          if (!this.s.effectsSequence.length)
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
              (this.appliedTransformations = 2);
          else return;
          if (this.sk)
            if (
              !this.sk.effectsSequence.length &&
              !this.sa.effectsSequence.length
            )
              this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                (this.appliedTransformations = 3);
            else return;
          this.r
            ? this.r.effectsSequence.length ||
              (this.pre.rotate(-this.r.v), (this.appliedTransformations = 4))
            : !this.rz.effectsSequence.length &&
              !this.ry.effectsSequence.length &&
              !this.rx.effectsSequence.length &&
              !this.or.effectsSequence.length &&
              (this.pre
                .rotateZ(-this.rz.v)
                .rotateY(this.ry.v)
                .rotateX(this.rx.v)
                .rotateZ(-this.or.v[2])
                .rotateY(this.or.v[1])
                .rotateX(this.or.v[0]),
              (this.appliedTransformations = 4));
        }
        function Kr() {}
        function Zr(ei) {
          this._addDynamicProperty(ei),
            this.elem.addDynamicProperty(ei),
            (this._isDirty = !0);
        }
        function Jr(ei, ti, ri) {
          if (
            ((this.elem = ei),
            (this.frameId = -1),
            (this.propType = "transform"),
            (this.data = ti),
            (this.v = new Matrix()),
            (this.pre = new Matrix()),
            (this.appliedTransformations = 0),
            this.initDynamicPropertyContainer(ri || ei),
            ti.p && ti.p.s
              ? ((this.px = PropertyFactory.getProp(ei, ti.p.x, 0, 0, this)),
                (this.py = PropertyFactory.getProp(ei, ti.p.y, 0, 0, this)),
                ti.p.z &&
                  (this.pz = PropertyFactory.getProp(ei, ti.p.z, 0, 0, this)))
              : (this.p = PropertyFactory.getProp(
                  ei,
                  ti.p || {
                    k: [0, 0, 0],
                  },
                  1,
                  0,
                  this
                )),
            ti.rx)
          ) {
            if (
              ((this.rx = PropertyFactory.getProp(
                ei,
                ti.rx,
                0,
                degToRads,
                this
              )),
              (this.ry = PropertyFactory.getProp(
                ei,
                ti.ry,
                0,
                degToRads,
                this
              )),
              (this.rz = PropertyFactory.getProp(
                ei,
                ti.rz,
                0,
                degToRads,
                this
              )),
              ti.or.k[0].ti)
            ) {
              var ni,
                ii = ti.or.k.length;
              for (ni = 0; ni < ii; ni += 1)
                (ti.or.k[ni].to = null), (ti.or.k[ni].ti = null);
            }
            (this.or = PropertyFactory.getProp(ei, ti.or, 1, degToRads, this)),
              (this.or.sh = !0);
          } else
            this.r = PropertyFactory.getProp(
              ei,
              ti.r || {
                k: 0,
              },
              0,
              degToRads,
              this
            );
          ti.sk &&
            ((this.sk = PropertyFactory.getProp(ei, ti.sk, 0, degToRads, this)),
            (this.sa = PropertyFactory.getProp(ei, ti.sa, 0, degToRads, this))),
            (this.a = PropertyFactory.getProp(
              ei,
              ti.a || {
                k: [0, 0, 0],
              },
              1,
              0,
              this
            )),
            (this.s = PropertyFactory.getProp(
              ei,
              ti.s || {
                k: [100, 100, 100],
              },
              1,
              0.01,
              this
            )),
            ti.o
              ? (this.o = PropertyFactory.getProp(ei, ti.o, 0, 0.01, ei))
              : (this.o = {
                  _mdf: !1,
                  v: 1,
                }),
            (this._isDirty = !0),
            this.dynamicProperties.length || this.getValue(!0);
        }
        (Jr.prototype = {
          applyToMatrix: ze,
          getValue: Gr,
          precalculateMatrix: Yr,
          autoOrient: Kr,
        }),
          extendPrototype([DynamicPropertyContainer], Jr),
          (Jr.prototype.addDynamicProperty = Zr),
          (Jr.prototype._addDynamicProperty =
            DynamicPropertyContainer.prototype.addDynamicProperty);
        function Qr(ei, ti, ri) {
          return new Jr(ei, ti, ri);
        }
        return {
          getTransformProperty: Qr,
        };
      })();
      function RepeaterModifier() {}
      extendPrototype([ShapeModifier], RepeaterModifier),
        (RepeaterModifier.prototype.initModifierProperties = function (Wr, ze) {
          (this.getValue = this.processKeys),
            (this.c = PropertyFactory.getProp(Wr, ze.c, 0, null, this)),
            (this.o = PropertyFactory.getProp(Wr, ze.o, 0, null, this)),
            (this.tr = TransformPropertyFactory.getTransformProperty(
              Wr,
              ze.tr,
              this
            )),
            (this.so = PropertyFactory.getProp(Wr, ze.tr.so, 0, 0.01, this)),
            (this.eo = PropertyFactory.getProp(Wr, ze.tr.eo, 0, 0.01, this)),
            (this.data = ze),
            this.dynamicProperties.length || this.getValue(!0),
            (this._isAnimated = !!this.dynamicProperties.length),
            (this.pMatrix = new Matrix()),
            (this.rMatrix = new Matrix()),
            (this.sMatrix = new Matrix()),
            (this.tMatrix = new Matrix()),
            (this.matrix = new Matrix());
        }),
        (RepeaterModifier.prototype.applyTransforms = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr,
          Zr
        ) {
          var Jr = Zr ? -1 : 1,
            Qr = Yr.s.v[0] + (1 - Yr.s.v[0]) * (1 - Kr),
            ei = Yr.s.v[1] + (1 - Yr.s.v[1]) * (1 - Kr);
          Wr.translate(Yr.p.v[0] * Jr * Kr, Yr.p.v[1] * Jr * Kr, Yr.p.v[2]),
            ze.translate(-Yr.a.v[0], -Yr.a.v[1], Yr.a.v[2]),
            ze.rotate(-Yr.r.v * Jr * Kr),
            ze.translate(Yr.a.v[0], Yr.a.v[1], Yr.a.v[2]),
            Gr.translate(-Yr.a.v[0], -Yr.a.v[1], Yr.a.v[2]),
            Gr.scale(Zr ? 1 / Qr : Qr, Zr ? 1 / ei : ei),
            Gr.translate(Yr.a.v[0], Yr.a.v[1], Yr.a.v[2]);
        }),
        (RepeaterModifier.prototype.init = function (Wr, ze, Gr, Yr) {
          for (
            this.elem = Wr,
              this.arr = ze,
              this.pos = Gr,
              this.elemsData = Yr,
              this._currentCopies = 0,
              this._elements = [],
              this._groups = [],
              this.frameId = -1,
              this.initDynamicPropertyContainer(Wr),
              this.initModifierProperties(Wr, ze[Gr]);
            Gr > 0;

          )
            (Gr -= 1), this._elements.unshift(ze[Gr]);
          this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0);
        }),
        (RepeaterModifier.prototype.resetElements = function (Wr) {
          var ze,
            Gr = Wr.length;
          for (ze = 0; ze < Gr; ze += 1)
            (Wr[ze]._processed = !1),
              Wr[ze].ty === "gr" && this.resetElements(Wr[ze].it);
        }),
        (RepeaterModifier.prototype.cloneElements = function (Wr) {
          var ze = JSON.parse(JSON.stringify(Wr));
          return this.resetElements(ze), ze;
        }),
        (RepeaterModifier.prototype.changeGroupRender = function (Wr, ze) {
          var Gr,
            Yr = Wr.length;
          for (Gr = 0; Gr < Yr; Gr += 1)
            (Wr[Gr]._render = ze),
              Wr[Gr].ty === "gr" && this.changeGroupRender(Wr[Gr].it, ze);
        }),
        (RepeaterModifier.prototype.processShapes = function (Wr) {
          var ze,
            Gr,
            Yr,
            Kr,
            Zr,
            Jr = !1;
          if (this._mdf || Wr) {
            var Qr = Math.ceil(this.c.v);
            if (this._groups.length < Qr) {
              for (; this._groups.length < Qr; ) {
                var ei = {
                  it: this.cloneElements(this._elements),
                  ty: "gr",
                };
                ei.it.push({
                  a: {
                    a: 0,
                    ix: 1,
                    k: [0, 0],
                  },
                  nm: "Transform",
                  o: {
                    a: 0,
                    ix: 7,
                    k: 100,
                  },
                  p: {
                    a: 0,
                    ix: 2,
                    k: [0, 0],
                  },
                  r: {
                    a: 1,
                    ix: 6,
                    k: [
                      {
                        s: 0,
                        e: 0,
                        t: 0,
                      },
                      {
                        s: 0,
                        e: 0,
                        t: 1,
                      },
                    ],
                  },
                  s: {
                    a: 0,
                    ix: 3,
                    k: [100, 100],
                  },
                  sa: {
                    a: 0,
                    ix: 5,
                    k: 0,
                  },
                  sk: {
                    a: 0,
                    ix: 4,
                    k: 0,
                  },
                  ty: "tr",
                }),
                  this.arr.splice(0, 0, ei),
                  this._groups.splice(0, 0, ei),
                  (this._currentCopies += 1);
              }
              this.elem.reloadShapes(), (Jr = !0);
            }
            Zr = 0;
            var ti;
            for (Yr = 0; Yr <= this._groups.length - 1; Yr += 1) {
              if (
                ((ti = Zr < Qr),
                (this._groups[Yr]._render = ti),
                this.changeGroupRender(this._groups[Yr].it, ti),
                !ti)
              ) {
                var ri = this.elemsData[Yr].it,
                  ni = ri[ri.length - 1];
                ni.transform.op.v !== 0
                  ? ((ni.transform.op._mdf = !0), (ni.transform.op.v = 0))
                  : (ni.transform.op._mdf = !1);
              }
              Zr += 1;
            }
            this._currentCopies = Qr;
            var ii = this.o.v,
              si = ii % 1,
              li = ii > 0 ? Math.floor(ii) : Math.ceil(ii),
              oi = this.pMatrix.props,
              ui = this.rMatrix.props,
              ai = this.sMatrix.props;
            this.pMatrix.reset(),
              this.rMatrix.reset(),
              this.sMatrix.reset(),
              this.tMatrix.reset(),
              this.matrix.reset();
            var hi = 0;
            if (ii > 0) {
              for (; hi < li; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !1
                ),
                  (hi += 1);
              si &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  si,
                  !1
                ),
                (hi += si));
            } else if (ii < 0) {
              for (; hi > li; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !0
                ),
                  (hi -= 1);
              si &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  -si,
                  !0
                ),
                (hi -= si));
            }
            (Yr = this.data.m === 1 ? 0 : this._currentCopies - 1),
              (Kr = this.data.m === 1 ? 1 : -1),
              (Zr = this._currentCopies);
            for (var ci, fi; Zr; ) {
              if (
                ((ze = this.elemsData[Yr].it),
                (Gr = ze[ze.length - 1].transform.mProps.v.props),
                (fi = Gr.length),
                (ze[ze.length - 1].transform.mProps._mdf = !0),
                (ze[ze.length - 1].transform.op._mdf = !0),
                (ze[ze.length - 1].transform.op.v =
                  this._currentCopies === 1
                    ? this.so.v
                    : this.so.v +
                      (this.eo.v - this.so.v) *
                        (Yr / (this._currentCopies - 1))),
                hi !== 0)
              ) {
                for (
                  ((Yr !== 0 && Kr === 1) ||
                    (Yr !== this._currentCopies - 1 && Kr === -1)) &&
                    this.applyTransforms(
                      this.pMatrix,
                      this.rMatrix,
                      this.sMatrix,
                      this.tr,
                      1,
                      !1
                    ),
                    this.matrix.transform(
                      ui[0],
                      ui[1],
                      ui[2],
                      ui[3],
                      ui[4],
                      ui[5],
                      ui[6],
                      ui[7],
                      ui[8],
                      ui[9],
                      ui[10],
                      ui[11],
                      ui[12],
                      ui[13],
                      ui[14],
                      ui[15]
                    ),
                    this.matrix.transform(
                      ai[0],
                      ai[1],
                      ai[2],
                      ai[3],
                      ai[4],
                      ai[5],
                      ai[6],
                      ai[7],
                      ai[8],
                      ai[9],
                      ai[10],
                      ai[11],
                      ai[12],
                      ai[13],
                      ai[14],
                      ai[15]
                    ),
                    this.matrix.transform(
                      oi[0],
                      oi[1],
                      oi[2],
                      oi[3],
                      oi[4],
                      oi[5],
                      oi[6],
                      oi[7],
                      oi[8],
                      oi[9],
                      oi[10],
                      oi[11],
                      oi[12],
                      oi[13],
                      oi[14],
                      oi[15]
                    ),
                    ci = 0;
                  ci < fi;
                  ci += 1
                )
                  Gr[ci] = this.matrix.props[ci];
                this.matrix.reset();
              } else
                for (this.matrix.reset(), ci = 0; ci < fi; ci += 1)
                  Gr[ci] = this.matrix.props[ci];
              (hi += 1), (Zr -= 1), (Yr += Kr);
            }
          } else
            for (Zr = this._currentCopies, Yr = 0, Kr = 1; Zr; )
              (ze = this.elemsData[Yr].it),
                (Gr = ze[ze.length - 1].transform.mProps.v.props),
                (ze[ze.length - 1].transform.mProps._mdf = !1),
                (ze[ze.length - 1].transform.op._mdf = !1),
                (Zr -= 1),
                (Yr += Kr);
          return Jr;
        }),
        (RepeaterModifier.prototype.addShape = function () {});
      function RoundCornersModifier() {}
      extendPrototype([ShapeModifier], RoundCornersModifier),
        (RoundCornersModifier.prototype.initModifierProperties = function (
          Wr,
          ze
        ) {
          (this.getValue = this.processKeys),
            (this.rd = PropertyFactory.getProp(Wr, ze.r, 0, null, this)),
            (this._isAnimated = !!this.rd.effectsSequence.length);
        }),
        (RoundCornersModifier.prototype.processPath = function (Wr, ze) {
          var Gr = shapePool.newElement();
          Gr.c = Wr.c;
          var Yr,
            Kr = Wr._length,
            Zr,
            Jr,
            Qr,
            ei,
            ti,
            ri,
            ni = 0,
            ii,
            si,
            li,
            oi,
            ui,
            ai;
          for (Yr = 0; Yr < Kr; Yr += 1)
            (Zr = Wr.v[Yr]),
              (Qr = Wr.o[Yr]),
              (Jr = Wr.i[Yr]),
              Zr[0] === Qr[0] &&
              Zr[1] === Qr[1] &&
              Zr[0] === Jr[0] &&
              Zr[1] === Jr[1]
                ? (Yr === 0 || Yr === Kr - 1) && !Wr.c
                  ? (Gr.setTripleAt(
                      Zr[0],
                      Zr[1],
                      Qr[0],
                      Qr[1],
                      Jr[0],
                      Jr[1],
                      ni
                    ),
                    (ni += 1))
                  : (Yr === 0 ? (ei = Wr.v[Kr - 1]) : (ei = Wr.v[Yr - 1]),
                    (ti = Math.sqrt(
                      Math.pow(Zr[0] - ei[0], 2) + Math.pow(Zr[1] - ei[1], 2)
                    )),
                    (ri = ti ? Math.min(ti / 2, ze) / ti : 0),
                    (ui = Zr[0] + (ei[0] - Zr[0]) * ri),
                    (ii = ui),
                    (ai = Zr[1] - (Zr[1] - ei[1]) * ri),
                    (si = ai),
                    (li = ii - (ii - Zr[0]) * roundCorner),
                    (oi = si - (si - Zr[1]) * roundCorner),
                    Gr.setTripleAt(ii, si, li, oi, ui, ai, ni),
                    (ni += 1),
                    Yr === Kr - 1 ? (ei = Wr.v[0]) : (ei = Wr.v[Yr + 1]),
                    (ti = Math.sqrt(
                      Math.pow(Zr[0] - ei[0], 2) + Math.pow(Zr[1] - ei[1], 2)
                    )),
                    (ri = ti ? Math.min(ti / 2, ze) / ti : 0),
                    (li = Zr[0] + (ei[0] - Zr[0]) * ri),
                    (ii = li),
                    (oi = Zr[1] + (ei[1] - Zr[1]) * ri),
                    (si = oi),
                    (ui = ii - (ii - Zr[0]) * roundCorner),
                    (ai = si - (si - Zr[1]) * roundCorner),
                    Gr.setTripleAt(ii, si, li, oi, ui, ai, ni),
                    (ni += 1))
                : (Gr.setTripleAt(
                    Wr.v[Yr][0],
                    Wr.v[Yr][1],
                    Wr.o[Yr][0],
                    Wr.o[Yr][1],
                    Wr.i[Yr][0],
                    Wr.i[Yr][1],
                    ni
                  ),
                  (ni += 1));
          return Gr;
        }),
        (RoundCornersModifier.prototype.processShapes = function (Wr) {
          var ze,
            Gr,
            Yr = this.shapes.length,
            Kr,
            Zr,
            Jr = this.rd.v;
          if (Jr !== 0) {
            var Qr, ei;
            for (Gr = 0; Gr < Yr; Gr += 1) {
              if (
                ((Qr = this.shapes[Gr]),
                (ei = Qr.localShapeCollection),
                !(!Qr.shape._mdf && !this._mdf && !Wr))
              )
                for (
                  ei.releaseShapes(),
                    Qr.shape._mdf = !0,
                    ze = Qr.shape.paths.shapes,
                    Zr = Qr.shape.paths._length,
                    Kr = 0;
                  Kr < Zr;
                  Kr += 1
                )
                  ei.addShape(this.processPath(ze[Kr], Jr));
              Qr.shape.paths = Qr.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function floatEqual(Wr, ze) {
        return Math.abs(Wr - ze) * 1e5 <= Math.min(Math.abs(Wr), Math.abs(ze));
      }
      function floatZero(Wr) {
        return Math.abs(Wr) <= 1e-5;
      }
      function lerp(Wr, ze, Gr) {
        return Wr * (1 - Gr) + ze * Gr;
      }
      function lerpPoint(Wr, ze, Gr) {
        return [lerp(Wr[0], ze[0], Gr), lerp(Wr[1], ze[1], Gr)];
      }
      function quadRoots(Wr, ze, Gr) {
        if (Wr === 0) return [];
        var Yr = ze * ze - 4 * Wr * Gr;
        if (Yr < 0) return [];
        var Kr = -ze / (2 * Wr);
        if (Yr === 0) return [Kr];
        var Zr = Math.sqrt(Yr) / (2 * Wr);
        return [Kr - Zr, Kr + Zr];
      }
      function polynomialCoefficients(Wr, ze, Gr, Yr) {
        return [
          -Wr + 3 * ze - 3 * Gr + Yr,
          3 * Wr - 6 * ze + 3 * Gr,
          -3 * Wr + 3 * ze,
          Wr,
        ];
      }
      function singlePoint(Wr) {
        return new PolynomialBezier(Wr, Wr, Wr, Wr, !1);
      }
      function PolynomialBezier(Wr, ze, Gr, Yr, Kr) {
        Kr && pointEqual(Wr, ze) && (ze = lerpPoint(Wr, Yr, 1 / 3)),
          Kr && pointEqual(Gr, Yr) && (Gr = lerpPoint(Wr, Yr, 2 / 3));
        var Zr = polynomialCoefficients(Wr[0], ze[0], Gr[0], Yr[0]),
          Jr = polynomialCoefficients(Wr[1], ze[1], Gr[1], Yr[1]);
        (this.a = [Zr[0], Jr[0]]),
          (this.b = [Zr[1], Jr[1]]),
          (this.c = [Zr[2], Jr[2]]),
          (this.d = [Zr[3], Jr[3]]),
          (this.points = [Wr, ze, Gr, Yr]);
      }
      (PolynomialBezier.prototype.point = function (Wr) {
        return [
          ((this.a[0] * Wr + this.b[0]) * Wr + this.c[0]) * Wr + this.d[0],
          ((this.a[1] * Wr + this.b[1]) * Wr + this.c[1]) * Wr + this.d[1],
        ];
      }),
        (PolynomialBezier.prototype.derivative = function (Wr) {
          return [
            (3 * Wr * this.a[0] + 2 * this.b[0]) * Wr + this.c[0],
            (3 * Wr * this.a[1] + 2 * this.b[1]) * Wr + this.c[1],
          ];
        }),
        (PolynomialBezier.prototype.tangentAngle = function (Wr) {
          var ze = this.derivative(Wr);
          return Math.atan2(ze[1], ze[0]);
        }),
        (PolynomialBezier.prototype.normalAngle = function (Wr) {
          var ze = this.derivative(Wr);
          return Math.atan2(ze[0], ze[1]);
        }),
        (PolynomialBezier.prototype.inflectionPoints = function () {
          var Wr = this.a[1] * this.b[0] - this.a[0] * this.b[1];
          if (floatZero(Wr)) return [];
          var ze =
              (-0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1])) / Wr,
            Gr =
              ze * ze -
              ((1 / 3) * (this.b[1] * this.c[0] - this.b[0] * this.c[1])) / Wr;
          if (Gr < 0) return [];
          var Yr = Math.sqrt(Gr);
          return floatZero(Yr)
            ? Yr > 0 && Yr < 1
              ? [ze]
              : []
            : [ze - Yr, ze + Yr].filter(function (Kr) {
                return Kr > 0 && Kr < 1;
              });
        }),
        (PolynomialBezier.prototype.split = function (Wr) {
          if (Wr <= 0) return [singlePoint(this.points[0]), this];
          if (Wr >= 1)
            return [this, singlePoint(this.points[this.points.length - 1])];
          var ze = lerpPoint(this.points[0], this.points[1], Wr),
            Gr = lerpPoint(this.points[1], this.points[2], Wr),
            Yr = lerpPoint(this.points[2], this.points[3], Wr),
            Kr = lerpPoint(ze, Gr, Wr),
            Zr = lerpPoint(Gr, Yr, Wr),
            Jr = lerpPoint(Kr, Zr, Wr);
          return [
            new PolynomialBezier(this.points[0], ze, Kr, Jr, !0),
            new PolynomialBezier(Jr, Zr, Yr, this.points[3], !0),
          ];
        });
      function extrema(Wr, ze) {
        var Gr = Wr.points[0][ze],
          Yr = Wr.points[Wr.points.length - 1][ze];
        if (Gr > Yr) {
          var Kr = Yr;
          (Yr = Gr), (Gr = Kr);
        }
        for (
          var Zr = quadRoots(3 * Wr.a[ze], 2 * Wr.b[ze], Wr.c[ze]), Jr = 0;
          Jr < Zr.length;
          Jr += 1
        )
          if (Zr[Jr] > 0 && Zr[Jr] < 1) {
            var Qr = Wr.point(Zr[Jr])[ze];
            Qr < Gr ? (Gr = Qr) : Qr > Yr && (Yr = Qr);
          }
        return {
          min: Gr,
          max: Yr,
        };
      }
      (PolynomialBezier.prototype.bounds = function () {
        return {
          x: extrema(this, 0),
          y: extrema(this, 1),
        };
      }),
        (PolynomialBezier.prototype.boundingBox = function () {
          var Wr = this.bounds();
          return {
            left: Wr.x.min,
            right: Wr.x.max,
            top: Wr.y.min,
            bottom: Wr.y.max,
            width: Wr.x.max - Wr.x.min,
            height: Wr.y.max - Wr.y.min,
            cx: (Wr.x.max + Wr.x.min) / 2,
            cy: (Wr.y.max + Wr.y.min) / 2,
          };
        });
      function intersectData(Wr, ze, Gr) {
        var Yr = Wr.boundingBox();
        return {
          cx: Yr.cx,
          cy: Yr.cy,
          width: Yr.width,
          height: Yr.height,
          bez: Wr,
          t: (ze + Gr) / 2,
          t1: ze,
          t2: Gr,
        };
      }
      function splitData(Wr) {
        var ze = Wr.bez.split(0.5);
        return [
          intersectData(ze[0], Wr.t1, Wr.t),
          intersectData(ze[1], Wr.t, Wr.t2),
        ];
      }
      function boxIntersect(Wr, ze) {
        return (
          Math.abs(Wr.cx - ze.cx) * 2 < Wr.width + ze.width &&
          Math.abs(Wr.cy - ze.cy) * 2 < Wr.height + ze.height
        );
      }
      function intersectsImpl(Wr, ze, Gr, Yr, Kr, Zr) {
        if (boxIntersect(Wr, ze)) {
          if (
            Gr >= Zr ||
            (Wr.width <= Yr &&
              Wr.height <= Yr &&
              ze.width <= Yr &&
              ze.height <= Yr)
          ) {
            Kr.push([Wr.t, ze.t]);
            return;
          }
          var Jr = splitData(Wr),
            Qr = splitData(ze);
          intersectsImpl(Jr[0], Qr[0], Gr + 1, Yr, Kr, Zr),
            intersectsImpl(Jr[0], Qr[1], Gr + 1, Yr, Kr, Zr),
            intersectsImpl(Jr[1], Qr[0], Gr + 1, Yr, Kr, Zr),
            intersectsImpl(Jr[1], Qr[1], Gr + 1, Yr, Kr, Zr);
        }
      }
      (PolynomialBezier.prototype.intersections = function (Wr, ze, Gr) {
        ze === void 0 && (ze = 2), Gr === void 0 && (Gr = 7);
        var Yr = [];
        return (
          intersectsImpl(
            intersectData(this, 0, 1),
            intersectData(Wr, 0, 1),
            0,
            ze,
            Yr,
            Gr
          ),
          Yr
        );
      }),
        (PolynomialBezier.shapeSegment = function (Wr, ze) {
          var Gr = (ze + 1) % Wr.length();
          return new PolynomialBezier(
            Wr.v[ze],
            Wr.o[ze],
            Wr.i[Gr],
            Wr.v[Gr],
            !0
          );
        }),
        (PolynomialBezier.shapeSegmentInverted = function (Wr, ze) {
          var Gr = (ze + 1) % Wr.length();
          return new PolynomialBezier(
            Wr.v[Gr],
            Wr.i[Gr],
            Wr.o[ze],
            Wr.v[ze],
            !0
          );
        });
      function crossProduct(Wr, ze) {
        return [
          Wr[1] * ze[2] - Wr[2] * ze[1],
          Wr[2] * ze[0] - Wr[0] * ze[2],
          Wr[0] * ze[1] - Wr[1] * ze[0],
        ];
      }
      function lineIntersection(Wr, ze, Gr, Yr) {
        var Kr = [Wr[0], Wr[1], 1],
          Zr = [ze[0], ze[1], 1],
          Jr = [Gr[0], Gr[1], 1],
          Qr = [Yr[0], Yr[1], 1],
          ei = crossProduct(crossProduct(Kr, Zr), crossProduct(Jr, Qr));
        return floatZero(ei[2]) ? null : [ei[0] / ei[2], ei[1] / ei[2]];
      }
      function polarOffset(Wr, ze, Gr) {
        return [Wr[0] + Math.cos(ze) * Gr, Wr[1] - Math.sin(ze) * Gr];
      }
      function pointDistance(Wr, ze) {
        return Math.hypot(Wr[0] - ze[0], Wr[1] - ze[1]);
      }
      function pointEqual(Wr, ze) {
        return floatEqual(Wr[0], ze[0]) && floatEqual(Wr[1], ze[1]);
      }
      function ZigZagModifier() {}
      extendPrototype([ShapeModifier], ZigZagModifier),
        (ZigZagModifier.prototype.initModifierProperties = function (Wr, ze) {
          (this.getValue = this.processKeys),
            (this.amplitude = PropertyFactory.getProp(Wr, ze.s, 0, null, this)),
            (this.frequency = PropertyFactory.getProp(Wr, ze.r, 0, null, this)),
            (this.pointsType = PropertyFactory.getProp(
              Wr,
              ze.pt,
              0,
              null,
              this
            )),
            (this._isAnimated =
              this.amplitude.effectsSequence.length !== 0 ||
              this.frequency.effectsSequence.length !== 0 ||
              this.pointsType.effectsSequence.length !== 0);
        });
      function setPoint(Wr, ze, Gr, Yr, Kr, Zr, Jr) {
        var Qr = Gr - Math.PI / 2,
          ei = Gr + Math.PI / 2,
          ti = ze[0] + Math.cos(Gr) * Yr * Kr,
          ri = ze[1] - Math.sin(Gr) * Yr * Kr;
        Wr.setTripleAt(
          ti,
          ri,
          ti + Math.cos(Qr) * Zr,
          ri - Math.sin(Qr) * Zr,
          ti + Math.cos(ei) * Jr,
          ri - Math.sin(ei) * Jr,
          Wr.length()
        );
      }
      function getPerpendicularVector(Wr, ze) {
        var Gr = [ze[0] - Wr[0], ze[1] - Wr[1]],
          Yr = -Math.PI * 0.5,
          Kr = [
            Math.cos(Yr) * Gr[0] - Math.sin(Yr) * Gr[1],
            Math.sin(Yr) * Gr[0] + Math.cos(Yr) * Gr[1],
          ];
        return Kr;
      }
      function getProjectingAngle(Wr, ze) {
        var Gr = ze === 0 ? Wr.length() - 1 : ze - 1,
          Yr = (ze + 1) % Wr.length(),
          Kr = Wr.v[Gr],
          Zr = Wr.v[Yr],
          Jr = getPerpendicularVector(Kr, Zr);
        return Math.atan2(0, 1) - Math.atan2(Jr[1], Jr[0]);
      }
      function zigZagCorner(Wr, ze, Gr, Yr, Kr, Zr, Jr) {
        var Qr = getProjectingAngle(ze, Gr),
          ei = ze.v[Gr % ze._length],
          ti = ze.v[Gr === 0 ? ze._length - 1 : Gr - 1],
          ri = ze.v[(Gr + 1) % ze._length],
          ni =
            Zr === 2
              ? Math.sqrt(
                  Math.pow(ei[0] - ti[0], 2) + Math.pow(ei[1] - ti[1], 2)
                )
              : 0,
          ii =
            Zr === 2
              ? Math.sqrt(
                  Math.pow(ei[0] - ri[0], 2) + Math.pow(ei[1] - ri[1], 2)
                )
              : 0;
        setPoint(
          Wr,
          ze.v[Gr % ze._length],
          Qr,
          Jr,
          Yr,
          ii / ((Kr + 1) * 2),
          ni / ((Kr + 1) * 2)
        );
      }
      function zigZagSegment(Wr, ze, Gr, Yr, Kr, Zr) {
        for (var Jr = 0; Jr < Yr; Jr += 1) {
          var Qr = (Jr + 1) / (Yr + 1),
            ei =
              Kr === 2
                ? Math.sqrt(
                    Math.pow(ze.points[3][0] - ze.points[0][0], 2) +
                      Math.pow(ze.points[3][1] - ze.points[0][1], 2)
                  )
                : 0,
            ti = ze.normalAngle(Qr),
            ri = ze.point(Qr);
          setPoint(
            Wr,
            ri,
            ti,
            Zr,
            Gr,
            ei / ((Yr + 1) * 2),
            ei / ((Yr + 1) * 2)
          ),
            (Zr = -Zr);
        }
        return Zr;
      }
      (ZigZagModifier.prototype.processPath = function (Wr, ze, Gr, Yr) {
        var Kr = Wr._length,
          Zr = shapePool.newElement();
        if (((Zr.c = Wr.c), Wr.c || (Kr -= 1), Kr === 0)) return Zr;
        var Jr = -1,
          Qr = PolynomialBezier.shapeSegment(Wr, 0);
        zigZagCorner(Zr, Wr, 0, ze, Gr, Yr, Jr);
        for (var ei = 0; ei < Kr; ei += 1)
          (Jr = zigZagSegment(Zr, Qr, ze, Gr, Yr, -Jr)),
            ei === Kr - 1 && !Wr.c
              ? (Qr = null)
              : (Qr = PolynomialBezier.shapeSegment(Wr, (ei + 1) % Kr)),
            zigZagCorner(Zr, Wr, ei + 1, ze, Gr, Yr, Jr);
        return Zr;
      }),
        (ZigZagModifier.prototype.processShapes = function (Wr) {
          var ze,
            Gr,
            Yr = this.shapes.length,
            Kr,
            Zr,
            Jr = this.amplitude.v,
            Qr = Math.max(0, Math.round(this.frequency.v)),
            ei = this.pointsType.v;
          if (Jr !== 0) {
            var ti, ri;
            for (Gr = 0; Gr < Yr; Gr += 1) {
              if (
                ((ti = this.shapes[Gr]),
                (ri = ti.localShapeCollection),
                !(!ti.shape._mdf && !this._mdf && !Wr))
              )
                for (
                  ri.releaseShapes(),
                    ti.shape._mdf = !0,
                    ze = ti.shape.paths.shapes,
                    Zr = ti.shape.paths._length,
                    Kr = 0;
                  Kr < Zr;
                  Kr += 1
                )
                  ri.addShape(this.processPath(ze[Kr], Jr, Qr, ei));
              ti.shape.paths = ti.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function linearOffset(Wr, ze, Gr) {
        var Yr = Math.atan2(ze[0] - Wr[0], ze[1] - Wr[1]);
        return [polarOffset(Wr, Yr, Gr), polarOffset(ze, Yr, Gr)];
      }
      function offsetSegment(Wr, ze) {
        var Gr, Yr, Kr, Zr, Jr, Qr, ei;
        (ei = linearOffset(Wr.points[0], Wr.points[1], ze)),
          (Gr = ei[0]),
          (Yr = ei[1]),
          (ei = linearOffset(Wr.points[1], Wr.points[2], ze)),
          (Kr = ei[0]),
          (Zr = ei[1]),
          (ei = linearOffset(Wr.points[2], Wr.points[3], ze)),
          (Jr = ei[0]),
          (Qr = ei[1]);
        var ti = lineIntersection(Gr, Yr, Kr, Zr);
        ti === null && (ti = Yr);
        var ri = lineIntersection(Jr, Qr, Kr, Zr);
        return ri === null && (ri = Jr), new PolynomialBezier(Gr, ti, ri, Qr);
      }
      function joinLines(Wr, ze, Gr, Yr, Kr) {
        var Zr = ze.points[3],
          Jr = Gr.points[0];
        if (Yr === 3 || pointEqual(Zr, Jr)) return Zr;
        if (Yr === 2) {
          var Qr = -ze.tangentAngle(1),
            ei = -Gr.tangentAngle(0) + Math.PI,
            ti = lineIntersection(
              Zr,
              polarOffset(Zr, Qr + Math.PI / 2, 100),
              Jr,
              polarOffset(Jr, Qr + Math.PI / 2, 100)
            ),
            ri = ti ? pointDistance(ti, Zr) : pointDistance(Zr, Jr) / 2,
            ni = polarOffset(Zr, Qr, 2 * ri * roundCorner);
          return (
            Wr.setXYAt(ni[0], ni[1], "o", Wr.length() - 1),
            (ni = polarOffset(Jr, ei, 2 * ri * roundCorner)),
            Wr.setTripleAt(
              Jr[0],
              Jr[1],
              Jr[0],
              Jr[1],
              ni[0],
              ni[1],
              Wr.length()
            ),
            Jr
          );
        }
        var ii = pointEqual(Zr, ze.points[2]) ? ze.points[0] : ze.points[2],
          si = pointEqual(Jr, Gr.points[1]) ? Gr.points[3] : Gr.points[1],
          li = lineIntersection(ii, Zr, Jr, si);
        return li && pointDistance(li, Zr) < Kr
          ? (Wr.setTripleAt(
              li[0],
              li[1],
              li[0],
              li[1],
              li[0],
              li[1],
              Wr.length()
            ),
            li)
          : Zr;
      }
      function getIntersection(Wr, ze) {
        var Gr = Wr.intersections(ze);
        return (
          Gr.length && floatEqual(Gr[0][0], 1) && Gr.shift(),
          Gr.length ? Gr[0] : null
        );
      }
      function pruneSegmentIntersection(Wr, ze) {
        var Gr = Wr.slice(),
          Yr = ze.slice(),
          Kr = getIntersection(Wr[Wr.length - 1], ze[0]);
        return (
          Kr &&
            ((Gr[Wr.length - 1] = Wr[Wr.length - 1].split(Kr[0])[0]),
            (Yr[0] = ze[0].split(Kr[1])[1])),
          Wr.length > 1 &&
          ze.length > 1 &&
          ((Kr = getIntersection(Wr[0], ze[ze.length - 1])), Kr)
            ? [[Wr[0].split(Kr[0])[0]], [ze[ze.length - 1].split(Kr[1])[1]]]
            : [Gr, Yr]
        );
      }
      function pruneIntersections(Wr) {
        for (var ze, Gr = 1; Gr < Wr.length; Gr += 1)
          (ze = pruneSegmentIntersection(Wr[Gr - 1], Wr[Gr])),
            (Wr[Gr - 1] = ze[0]),
            (Wr[Gr] = ze[1]);
        return (
          Wr.length > 1 &&
            ((ze = pruneSegmentIntersection(Wr[Wr.length - 1], Wr[0])),
            (Wr[Wr.length - 1] = ze[0]),
            (Wr[0] = ze[1])),
          Wr
        );
      }
      function offsetSegmentSplit(Wr, ze) {
        var Gr = Wr.inflectionPoints(),
          Yr,
          Kr,
          Zr,
          Jr;
        if (Gr.length === 0) return [offsetSegment(Wr, ze)];
        if (Gr.length === 1 || floatEqual(Gr[1], 1))
          return (
            (Zr = Wr.split(Gr[0])),
            (Yr = Zr[0]),
            (Kr = Zr[1]),
            [offsetSegment(Yr, ze), offsetSegment(Kr, ze)]
          );
        (Zr = Wr.split(Gr[0])), (Yr = Zr[0]);
        var Qr = (Gr[1] - Gr[0]) / (1 - Gr[0]);
        return (
          (Zr = Zr[1].split(Qr)),
          (Jr = Zr[0]),
          (Kr = Zr[1]),
          [offsetSegment(Yr, ze), offsetSegment(Jr, ze), offsetSegment(Kr, ze)]
        );
      }
      function OffsetPathModifier() {}
      extendPrototype([ShapeModifier], OffsetPathModifier),
        (OffsetPathModifier.prototype.initModifierProperties = function (
          Wr,
          ze
        ) {
          (this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(Wr, ze.a, 0, null, this)),
            (this.miterLimit = PropertyFactory.getProp(
              Wr,
              ze.ml,
              0,
              null,
              this
            )),
            (this.lineJoin = ze.lj),
            (this._isAnimated = this.amount.effectsSequence.length !== 0);
        }),
        (OffsetPathModifier.prototype.processPath = function (Wr, ze, Gr, Yr) {
          var Kr = shapePool.newElement();
          Kr.c = Wr.c;
          var Zr = Wr.length();
          Wr.c || (Zr -= 1);
          var Jr,
            Qr,
            ei,
            ti = [];
          for (Jr = 0; Jr < Zr; Jr += 1)
            (ei = PolynomialBezier.shapeSegment(Wr, Jr)),
              ti.push(offsetSegmentSplit(ei, ze));
          if (!Wr.c)
            for (Jr = Zr - 1; Jr >= 0; Jr -= 1)
              (ei = PolynomialBezier.shapeSegmentInverted(Wr, Jr)),
                ti.push(offsetSegmentSplit(ei, ze));
          ti = pruneIntersections(ti);
          var ri = null,
            ni = null;
          for (Jr = 0; Jr < ti.length; Jr += 1) {
            var ii = ti[Jr];
            for (
              ni && (ri = joinLines(Kr, ni, ii[0], Gr, Yr)),
                ni = ii[ii.length - 1],
                Qr = 0;
              Qr < ii.length;
              Qr += 1
            )
              (ei = ii[Qr]),
                ri && pointEqual(ei.points[0], ri)
                  ? Kr.setXYAt(
                      ei.points[1][0],
                      ei.points[1][1],
                      "o",
                      Kr.length() - 1
                    )
                  : Kr.setTripleAt(
                      ei.points[0][0],
                      ei.points[0][1],
                      ei.points[1][0],
                      ei.points[1][1],
                      ei.points[0][0],
                      ei.points[0][1],
                      Kr.length()
                    ),
                Kr.setTripleAt(
                  ei.points[3][0],
                  ei.points[3][1],
                  ei.points[3][0],
                  ei.points[3][1],
                  ei.points[2][0],
                  ei.points[2][1],
                  Kr.length()
                ),
                (ri = ei.points[3]);
          }
          return ti.length && joinLines(Kr, ni, ti[0][0], Gr, Yr), Kr;
        }),
        (OffsetPathModifier.prototype.processShapes = function (Wr) {
          var ze,
            Gr,
            Yr = this.shapes.length,
            Kr,
            Zr,
            Jr = this.amount.v,
            Qr = this.miterLimit.v,
            ei = this.lineJoin;
          if (Jr !== 0) {
            var ti, ri;
            for (Gr = 0; Gr < Yr; Gr += 1) {
              if (
                ((ti = this.shapes[Gr]),
                (ri = ti.localShapeCollection),
                !(!ti.shape._mdf && !this._mdf && !Wr))
              )
                for (
                  ri.releaseShapes(),
                    ti.shape._mdf = !0,
                    ze = ti.shape.paths.shapes,
                    Zr = ti.shape.paths._length,
                    Kr = 0;
                  Kr < Zr;
                  Kr += 1
                )
                  ri.addShape(this.processPath(ze[Kr], Jr, ei, Qr));
              ti.shape.paths = ti.localShapeCollection;
            }
          }
          this.dynamicProperties.length || (this._mdf = !1);
        });
      function getFontProperties(Wr) {
        for (
          var ze = Wr.fStyle ? Wr.fStyle.split(" ") : [],
            Gr = "normal",
            Yr = "normal",
            Kr = ze.length,
            Zr,
            Jr = 0;
          Jr < Kr;
          Jr += 1
        )
          switch (((Zr = ze[Jr].toLowerCase()), Zr)) {
            case "italic":
              Yr = "italic";
              break;
            case "bold":
              Gr = "700";
              break;
            case "black":
              Gr = "900";
              break;
            case "medium":
              Gr = "500";
              break;
            case "regular":
            case "normal":
              Gr = "400";
              break;
            case "light":
            case "thin":
              Gr = "200";
              break;
          }
        return {
          style: Yr,
          weight: Wr.fWeight || Gr,
        };
      }
      var FontManager = (function () {
        var Wr = 5e3,
          ze = {
            w: 0,
            size: 0,
            shapes: [],
            data: {
              shapes: [],
            },
          },
          Gr = [];
        Gr = Gr.concat([
          2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368,
          2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
          2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403,
        ]);
        var Yr = 127988,
          Kr = 917631,
          Zr = 917601,
          Jr = 917626,
          Qr = 65039,
          ei = 8205,
          ti = 127462,
          ri = 127487,
          ni = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
        function ii(bi) {
          var Mi = bi.split(","),
            gi,
            xi = Mi.length,
            Ti = [];
          for (gi = 0; gi < xi; gi += 1)
            Mi[gi] !== "sans-serif" &&
              Mi[gi] !== "monospace" &&
              Ti.push(Mi[gi]);
          return Ti.join(",");
        }
        function si(bi, Mi) {
          var gi = createTag("span");
          gi.setAttribute("aria-hidden", !0), (gi.style.fontFamily = Mi);
          var xi = createTag("span");
          (xi.innerText = "giItT1WQy@!-/#"),
            (gi.style.position = "absolute"),
            (gi.style.left = "-10000px"),
            (gi.style.top = "-10000px"),
            (gi.style.fontSize = "300px"),
            (gi.style.fontVariant = "normal"),
            (gi.style.fontStyle = "normal"),
            (gi.style.fontWeight = "normal"),
            (gi.style.letterSpacing = "0"),
            gi.appendChild(xi),
            document.body.appendChild(gi);
          var Ti = xi.offsetWidth;
          return (
            (xi.style.fontFamily = ii(bi) + ", " + Mi),
            {
              node: xi,
              w: Ti,
              parent: gi,
            }
          );
        }
        function li() {
          var bi,
            Mi = this.fonts.length,
            gi,
            xi,
            Ti = Mi;
          for (bi = 0; bi < Mi; bi += 1)
            this.fonts[bi].loaded
              ? (Ti -= 1)
              : this.fonts[bi].fOrigin === "n" || this.fonts[bi].origin === 0
              ? (this.fonts[bi].loaded = !0)
              : ((gi = this.fonts[bi].monoCase.node),
                (xi = this.fonts[bi].monoCase.w),
                gi.offsetWidth !== xi
                  ? ((Ti -= 1), (this.fonts[bi].loaded = !0))
                  : ((gi = this.fonts[bi].sansCase.node),
                    (xi = this.fonts[bi].sansCase.w),
                    gi.offsetWidth !== xi &&
                      ((Ti -= 1), (this.fonts[bi].loaded = !0))),
                this.fonts[bi].loaded &&
                  (this.fonts[bi].sansCase.parent.parentNode.removeChild(
                    this.fonts[bi].sansCase.parent
                  ),
                  this.fonts[bi].monoCase.parent.parentNode.removeChild(
                    this.fonts[bi].monoCase.parent
                  )));
          Ti !== 0 && Date.now() - this.initTime < Wr
            ? setTimeout(this.checkLoadedFontsBinded, 20)
            : setTimeout(this.setIsLoadedBinded, 10);
        }
        function oi(bi, Mi) {
          var gi = document.body && Mi ? "svg" : "canvas",
            xi,
            Ti = getFontProperties(bi);
          if (gi === "svg") {
            var vi = createNS("text");
            (vi.style.fontSize = "100px"),
              vi.setAttribute("font-family", bi.fFamily),
              vi.setAttribute("font-style", Ti.style),
              vi.setAttribute("font-weight", Ti.weight),
              (vi.textContent = "1"),
              bi.fClass
                ? ((vi.style.fontFamily = "inherit"),
                  vi.setAttribute("class", bi.fClass))
                : (vi.style.fontFamily = bi.fFamily),
              Mi.appendChild(vi),
              (xi = vi);
          } else {
            var Ii = new OffscreenCanvas(500, 500).getContext("2d");
            (Ii.font = Ti.style + " " + Ti.weight + " 100px " + bi.fFamily),
              (xi = Ii);
          }
          function Oi(ki) {
            return gi === "svg"
              ? ((xi.textContent = ki), xi.getComputedTextLength())
              : xi.measureText(ki).width;
          }
          return {
            measureText: Oi,
          };
        }
        function ui(bi, Mi) {
          if (!bi) {
            this.isLoaded = !0;
            return;
          }
          if (this.chars) {
            (this.isLoaded = !0), (this.fonts = bi.list);
            return;
          }
          if (!document.body) {
            (this.isLoaded = !0),
              bi.list.forEach(function (Qi) {
                (Qi.helper = oi(Qi)), (Qi.cache = {});
              }),
              (this.fonts = bi.list);
            return;
          }
          var gi = bi.list,
            xi,
            Ti = gi.length,
            vi = Ti;
          for (xi = 0; xi < Ti; xi += 1) {
            var Ii = !0,
              Oi,
              ki;
            if (
              ((gi[xi].loaded = !1),
              (gi[xi].monoCase = si(gi[xi].fFamily, "monospace")),
              (gi[xi].sansCase = si(gi[xi].fFamily, "sans-serif")),
              !gi[xi].fPath)
            )
              (gi[xi].loaded = !0), (vi -= 1);
            else if (gi[xi].fOrigin === "p" || gi[xi].origin === 3) {
              if (
                ((Oi = document.querySelectorAll(
                  'style[f-forigin="p"][f-family="' +
                    gi[xi].fFamily +
                    '"], style[f-origin="3"][f-family="' +
                    gi[xi].fFamily +
                    '"]'
                )),
                Oi.length > 0 && (Ii = !1),
                Ii)
              ) {
                var Bi = createTag("style");
                Bi.setAttribute("f-forigin", gi[xi].fOrigin),
                  Bi.setAttribute("f-origin", gi[xi].origin),
                  Bi.setAttribute("f-family", gi[xi].fFamily),
                  (Bi.type = "text/css"),
                  (Bi.innerText =
                    "@font-face {font-family: " +
                    gi[xi].fFamily +
                    "; font-style: normal; src: url('" +
                    gi[xi].fPath +
                    "');}"),
                  Mi.appendChild(Bi);
              }
            } else if (gi[xi].fOrigin === "g" || gi[xi].origin === 1) {
              for (
                Oi = document.querySelectorAll(
                  'link[f-forigin="g"], link[f-origin="1"]'
                ),
                  ki = 0;
                ki < Oi.length;
                ki += 1
              )
                Oi[ki].href.indexOf(gi[xi].fPath) !== -1 && (Ii = !1);
              if (Ii) {
                var Xi = createTag("link");
                Xi.setAttribute("f-forigin", gi[xi].fOrigin),
                  Xi.setAttribute("f-origin", gi[xi].origin),
                  (Xi.type = "text/css"),
                  (Xi.rel = "stylesheet"),
                  (Xi.href = gi[xi].fPath),
                  document.body.appendChild(Xi);
              }
            } else if (gi[xi].fOrigin === "t" || gi[xi].origin === 2) {
              for (
                Oi = document.querySelectorAll(
                  'script[f-forigin="t"], script[f-origin="2"]'
                ),
                  ki = 0;
                ki < Oi.length;
                ki += 1
              )
                gi[xi].fPath === Oi[ki].src && (Ii = !1);
              if (Ii) {
                var an = createTag("link");
                an.setAttribute("f-forigin", gi[xi].fOrigin),
                  an.setAttribute("f-origin", gi[xi].origin),
                  an.setAttribute("rel", "stylesheet"),
                  an.setAttribute("href", gi[xi].fPath),
                  Mi.appendChild(an);
              }
            }
            (gi[xi].helper = oi(gi[xi], Mi)),
              (gi[xi].cache = {}),
              this.fonts.push(gi[xi]);
          }
          vi === 0
            ? (this.isLoaded = !0)
            : setTimeout(this.checkLoadedFonts.bind(this), 100);
        }
        function ai(bi) {
          if (bi) {
            this.chars || (this.chars = []);
            var Mi,
              gi = bi.length,
              xi,
              Ti = this.chars.length,
              vi;
            for (Mi = 0; Mi < gi; Mi += 1) {
              for (xi = 0, vi = !1; xi < Ti; )
                this.chars[xi].style === bi[Mi].style &&
                  this.chars[xi].fFamily === bi[Mi].fFamily &&
                  this.chars[xi].ch === bi[Mi].ch &&
                  (vi = !0),
                  (xi += 1);
              vi || (this.chars.push(bi[Mi]), (Ti += 1));
            }
          }
        }
        function hi(bi, Mi, gi) {
          for (var xi = 0, Ti = this.chars.length; xi < Ti; ) {
            if (
              this.chars[xi].ch === bi &&
              this.chars[xi].style === Mi &&
              this.chars[xi].fFamily === gi
            )
              return this.chars[xi];
            xi += 1;
          }
          return (
            ((typeof bi == "string" && bi.charCodeAt(0) !== 13) || !bi) &&
              console &&
              console.warn &&
              !this._warned &&
              ((this._warned = !0),
              console.warn(
                "Missing character from exported characters list: ",
                bi,
                Mi,
                gi
              )),
            ze
          );
        }
        function ci(bi, Mi, gi) {
          var xi = this.getFontByName(Mi),
            Ti = bi;
          if (!xi.cache[Ti]) {
            var vi = xi.helper;
            if (bi === " ") {
              var Ii = vi.measureText("|" + bi + "|"),
                Oi = vi.measureText("||");
              xi.cache[Ti] = (Ii - Oi) / 100;
            } else xi.cache[Ti] = vi.measureText(bi) / 100;
          }
          return xi.cache[Ti] * gi;
        }
        function fi(bi) {
          for (var Mi = 0, gi = this.fonts.length; Mi < gi; ) {
            if (this.fonts[Mi].fName === bi) return this.fonts[Mi];
            Mi += 1;
          }
          return this.fonts[0];
        }
        function di(bi) {
          var Mi = 0,
            gi = bi.charCodeAt(0);
          if (gi >= 55296 && gi <= 56319) {
            var xi = bi.charCodeAt(1);
            xi >= 56320 &&
              xi <= 57343 &&
              (Mi = (gi - 55296) * 1024 + xi - 56320 + 65536);
          }
          return Mi;
        }
        function pi(bi, Mi) {
          var gi = bi.toString(16) + Mi.toString(16);
          return ni.indexOf(gi) !== -1;
        }
        function mi(bi) {
          return bi === ei;
        }
        function Si(bi) {
          return bi === Qr;
        }
        function yi(bi) {
          var Mi = di(bi);
          return Mi >= ti && Mi <= ri;
        }
        function Ei(bi) {
          return yi(bi.substr(0, 2)) && yi(bi.substr(2, 2));
        }
        function Pi(bi) {
          return Gr.indexOf(bi) !== -1;
        }
        function Ai(bi, Mi) {
          var gi = di(bi.substr(Mi, 2));
          if (gi !== Yr) return !1;
          var xi = 0;
          for (Mi += 2; xi < 5; ) {
            if (((gi = di(bi.substr(Mi, 2))), gi < Zr || gi > Jr)) return !1;
            (xi += 1), (Mi += 2);
          }
          return di(bi.substr(Mi, 2)) === Kr;
        }
        function Ri() {
          this.isLoaded = !0;
        }
        var wi = function () {
          (this.fonts = []),
            (this.chars = null),
            (this.typekitLoaded = 0),
            (this.isLoaded = !1),
            (this._warned = !1),
            (this.initTime = Date.now()),
            (this.setIsLoadedBinded = this.setIsLoaded.bind(this)),
            (this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this));
        };
        (wi.isModifier = pi),
          (wi.isZeroWidthJoiner = mi),
          (wi.isFlagEmoji = Ei),
          (wi.isRegionalCode = yi),
          (wi.isCombinedCharacter = Pi),
          (wi.isRegionalFlag = Ai),
          (wi.isVariationSelector = Si),
          (wi.BLACK_FLAG_CODE_POINT = Yr);
        var Ci = {
          addChars: ai,
          addFonts: ui,
          getCharData: hi,
          getFontByName: fi,
          measureText: ci,
          checkLoadedFonts: li,
          setIsLoaded: Ri,
        };
        return (wi.prototype = Ci), wi;
      })();
      function SlotManager(Wr) {
        this.animationData = Wr;
      }
      SlotManager.prototype.getProp = function (Wr) {
        return this.animationData.slots && this.animationData.slots[Wr.sid]
          ? Object.assign(Wr, this.animationData.slots[Wr.sid].p)
          : Wr;
      };
      function slotFactory(Wr) {
        return new SlotManager(Wr);
      }
      function RenderableElement() {}
      RenderableElement.prototype = {
        initRenderable: function () {
          (this.isInRange = !1),
            (this.hidden = !1),
            (this.isTransparent = !1),
            (this.renderableComponents = []);
        },
        addRenderableComponent: function (ze) {
          this.renderableComponents.indexOf(ze) === -1 &&
            this.renderableComponents.push(ze);
        },
        removeRenderableComponent: function (ze) {
          this.renderableComponents.indexOf(ze) !== -1 &&
            this.renderableComponents.splice(
              this.renderableComponents.indexOf(ze),
              1
            );
        },
        prepareRenderableFrame: function (ze) {
          this.checkLayerLimits(ze);
        },
        checkTransparency: function () {
          this.finalTransform.mProp.o.v <= 0
            ? !this.isTransparent &&
              this.globalData.renderConfig.hideOnTransparent &&
              ((this.isTransparent = !0), this.hide())
            : this.isTransparent && ((this.isTransparent = !1), this.show());
        },
        checkLayerLimits: function (ze) {
          this.data.ip - this.data.st <= ze && this.data.op - this.data.st > ze
            ? this.isInRange !== !0 &&
              ((this.globalData._mdf = !0),
              (this._mdf = !0),
              (this.isInRange = !0),
              this.show())
            : this.isInRange !== !1 &&
              ((this.globalData._mdf = !0), (this.isInRange = !1), this.hide());
        },
        renderRenderable: function () {
          var ze,
            Gr = this.renderableComponents.length;
          for (ze = 0; ze < Gr; ze += 1)
            this.renderableComponents[ze].renderFrame(this._isFirstFrame);
        },
        sourceRectAtTime: function () {
          return {
            top: 0,
            left: 0,
            width: 100,
            height: 100,
          };
        },
        getLayerSize: function () {
          return this.data.ty === 5
            ? {
                w: this.data.textData.width,
                h: this.data.textData.height,
              }
            : {
                w: this.data.width,
                h: this.data.height,
              };
        },
      };
      var getBlendMode = (function () {
        var Wr = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity",
        };
        return function (ze) {
          return Wr[ze] || "";
        };
      })();
      function SliderEffect(Wr, ze, Gr) {
        this.p = PropertyFactory.getProp(ze, Wr.v, 0, 0, Gr);
      }
      function AngleEffect(Wr, ze, Gr) {
        this.p = PropertyFactory.getProp(ze, Wr.v, 0, 0, Gr);
      }
      function ColorEffect(Wr, ze, Gr) {
        this.p = PropertyFactory.getProp(ze, Wr.v, 1, 0, Gr);
      }
      function PointEffect(Wr, ze, Gr) {
        this.p = PropertyFactory.getProp(ze, Wr.v, 1, 0, Gr);
      }
      function LayerIndexEffect(Wr, ze, Gr) {
        this.p = PropertyFactory.getProp(ze, Wr.v, 0, 0, Gr);
      }
      function MaskIndexEffect(Wr, ze, Gr) {
        this.p = PropertyFactory.getProp(ze, Wr.v, 0, 0, Gr);
      }
      function CheckboxEffect(Wr, ze, Gr) {
        this.p = PropertyFactory.getProp(ze, Wr.v, 0, 0, Gr);
      }
      function NoValueEffect() {
        this.p = {};
      }
      function EffectsManager(Wr, ze) {
        var Gr = Wr.ef || [];
        this.effectElements = [];
        var Yr,
          Kr = Gr.length,
          Zr;
        for (Yr = 0; Yr < Kr; Yr += 1)
          (Zr = new GroupEffect(Gr[Yr], ze)), this.effectElements.push(Zr);
      }
      function GroupEffect(Wr, ze) {
        this.init(Wr, ze);
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect),
        (GroupEffect.prototype.getValue =
          GroupEffect.prototype.iterateDynamicProperties),
        (GroupEffect.prototype.init = function (Wr, ze) {
          (this.data = Wr),
            (this.effectElements = []),
            this.initDynamicPropertyContainer(ze);
          var Gr,
            Yr = this.data.ef.length,
            Kr,
            Zr = this.data.ef;
          for (Gr = 0; Gr < Yr; Gr += 1) {
            switch (((Kr = null), Zr[Gr].ty)) {
              case 0:
                Kr = new SliderEffect(Zr[Gr], ze, this);
                break;
              case 1:
                Kr = new AngleEffect(Zr[Gr], ze, this);
                break;
              case 2:
                Kr = new ColorEffect(Zr[Gr], ze, this);
                break;
              case 3:
                Kr = new PointEffect(Zr[Gr], ze, this);
                break;
              case 4:
              case 7:
                Kr = new CheckboxEffect(Zr[Gr], ze, this);
                break;
              case 10:
                Kr = new LayerIndexEffect(Zr[Gr], ze, this);
                break;
              case 11:
                Kr = new MaskIndexEffect(Zr[Gr], ze, this);
                break;
              case 5:
                Kr = new EffectsManager(Zr[Gr], ze);
                break;
              default:
                Kr = new NoValueEffect(Zr[Gr]);
                break;
            }
            Kr && this.effectElements.push(Kr);
          }
        });
      function BaseElement() {}
      BaseElement.prototype = {
        checkMasks: function () {
          if (!this.data.hasMask) return !1;
          for (var ze = 0, Gr = this.data.masksProperties.length; ze < Gr; ) {
            if (
              this.data.masksProperties[ze].mode !== "n" &&
              this.data.masksProperties[ze].cl !== !1
            )
              return !0;
            ze += 1;
          }
          return !1;
        },
        initExpressions: function () {
          var ze = getExpressionInterfaces();
          if (ze) {
            var Gr = ze("layer"),
              Yr = ze("effects"),
              Kr = ze("shape"),
              Zr = ze("text"),
              Jr = ze("comp");
            (this.layerInterface = Gr(this)),
              this.data.hasMask &&
                this.maskManager &&
                this.layerInterface.registerMaskInterface(this.maskManager);
            var Qr = Yr.createEffectsInterface(this, this.layerInterface);
            this.layerInterface.registerEffectsInterface(Qr),
              this.data.ty === 0 || this.data.xt
                ? (this.compInterface = Jr(this))
                : this.data.ty === 4
                ? ((this.layerInterface.shapeInterface = Kr(
                    this.shapesData,
                    this.itemsData,
                    this.layerInterface
                  )),
                  (this.layerInterface.content =
                    this.layerInterface.shapeInterface))
                : this.data.ty === 5 &&
                  ((this.layerInterface.textInterface = Zr(this)),
                  (this.layerInterface.text =
                    this.layerInterface.textInterface));
          }
        },
        setBlendMode: function () {
          var ze = getBlendMode(this.data.bm),
            Gr = this.baseElement || this.layerElement;
          Gr.style["mix-blend-mode"] = ze;
        },
        initBaseData: function (ze, Gr, Yr) {
          (this.globalData = Gr),
            (this.comp = Yr),
            (this.data = ze),
            (this.layerId = createElementID()),
            this.data.sr || (this.data.sr = 1),
            (this.effectsManager = new EffectsManager(
              this.data,
              this,
              this.dynamicProperties
            ));
        },
        getType: function () {
          return this.type;
        },
        sourceRectAtTime: function () {},
      };
      function FrameElement() {}
      FrameElement.prototype = {
        initFrame: function () {
          (this._isFirstFrame = !1),
            (this.dynamicProperties = []),
            (this._mdf = !1);
        },
        prepareProperties: function (ze, Gr) {
          var Yr,
            Kr = this.dynamicProperties.length;
          for (Yr = 0; Yr < Kr; Yr += 1)
            (Gr ||
              (this._isParent &&
                this.dynamicProperties[Yr].propType === "transform")) &&
              (this.dynamicProperties[Yr].getValue(),
              this.dynamicProperties[Yr]._mdf &&
                ((this.globalData._mdf = !0), (this._mdf = !0)));
        },
        addDynamicProperty: function (ze) {
          this.dynamicProperties.indexOf(ze) === -1 &&
            this.dynamicProperties.push(ze);
        },
      };
      function FootageElement(Wr, ze, Gr) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = ze.getAssetData(Wr.refId)),
          (this.footageData = ze.imageLoader.getAsset(this.assetData)),
          this.initBaseData(Wr, ze, Gr);
      }
      (FootageElement.prototype.prepareFrame = function () {}),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          FootageElement
        ),
        (FootageElement.prototype.getBaseElement = function () {
          return null;
        }),
        (FootageElement.prototype.renderFrame = function () {}),
        (FootageElement.prototype.destroy = function () {}),
        (FootageElement.prototype.initExpressions = function () {
          var Wr = getExpressionInterfaces();
          if (Wr) {
            var ze = Wr("footage");
            this.layerInterface = ze(this);
          }
        }),
        (FootageElement.prototype.getFootageData = function () {
          return this.footageData;
        });
      function AudioElement(Wr, ze, Gr) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = ze.getAssetData(Wr.refId)),
          this.initBaseData(Wr, ze, Gr),
          (this._isPlaying = !1),
          (this._canPlay = !1);
        var Yr = this.globalData.getAssetsPath(this.assetData);
        (this.audio = this.globalData.audioController.createAudio(Yr)),
          (this._currentTime = 0),
          this.globalData.audioController.addAudio(this),
          (this._volumeMultiplier = 1),
          (this._volume = 1),
          (this._previousVolume = null),
          (this.tm = Wr.tm
            ? PropertyFactory.getProp(this, Wr.tm, 0, ze.frameRate, this)
            : {
                _placeholder: !0,
              }),
          (this.lv = PropertyFactory.getProp(
            this,
            Wr.au && Wr.au.lv
              ? Wr.au.lv
              : {
                  k: [100],
                },
            1,
            0.01,
            this
          ));
      }
      (AudioElement.prototype.prepareFrame = function (Wr) {
        if (
          (this.prepareRenderableFrame(Wr, !0),
          this.prepareProperties(Wr, !0),
          this.tm._placeholder)
        )
          this._currentTime = Wr / this.data.sr;
        else {
          var ze = this.tm.v;
          this._currentTime = ze;
        }
        this._volume = this.lv.v[0];
        var Gr = this._volume * this._volumeMultiplier;
        this._previousVolume !== Gr &&
          ((this._previousVolume = Gr), this.audio.volume(Gr));
      }),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          AudioElement
        ),
        (AudioElement.prototype.renderFrame = function () {
          this.isInRange &&
            this._canPlay &&
            (this._isPlaying
              ? (!this.audio.playing() ||
                  Math.abs(
                    this._currentTime / this.globalData.frameRate -
                      this.audio.seek()
                  ) > 0.1) &&
                this.audio.seek(this._currentTime / this.globalData.frameRate)
              : (this.audio.play(),
                this.audio.seek(this._currentTime / this.globalData.frameRate),
                (this._isPlaying = !0)));
        }),
        (AudioElement.prototype.show = function () {}),
        (AudioElement.prototype.hide = function () {
          this.audio.pause(), (this._isPlaying = !1);
        }),
        (AudioElement.prototype.pause = function () {
          this.audio.pause(), (this._isPlaying = !1), (this._canPlay = !1);
        }),
        (AudioElement.prototype.resume = function () {
          this._canPlay = !0;
        }),
        (AudioElement.prototype.setRate = function (Wr) {
          this.audio.rate(Wr);
        }),
        (AudioElement.prototype.volume = function (Wr) {
          (this._volumeMultiplier = Wr),
            (this._previousVolume = Wr * this._volume),
            this.audio.volume(this._previousVolume);
        }),
        (AudioElement.prototype.getBaseElement = function () {
          return null;
        }),
        (AudioElement.prototype.destroy = function () {}),
        (AudioElement.prototype.sourceRectAtTime = function () {}),
        (AudioElement.prototype.initExpressions = function () {});
      function BaseRenderer() {}
      (BaseRenderer.prototype.checkLayers = function (Wr) {
        var ze,
          Gr = this.layers.length,
          Yr;
        for (this.completeLayers = !0, ze = Gr - 1; ze >= 0; ze -= 1)
          this.elements[ze] ||
            ((Yr = this.layers[ze]),
            Yr.ip - Yr.st <= Wr - this.layers[ze].st &&
              Yr.op - Yr.st > Wr - this.layers[ze].st &&
              this.buildItem(ze)),
            (this.completeLayers = this.elements[ze]
              ? this.completeLayers
              : !1);
        this.checkPendingElements();
      }),
        (BaseRenderer.prototype.createItem = function (Wr) {
          switch (Wr.ty) {
            case 2:
              return this.createImage(Wr);
            case 0:
              return this.createComp(Wr);
            case 1:
              return this.createSolid(Wr);
            case 3:
              return this.createNull(Wr);
            case 4:
              return this.createShape(Wr);
            case 5:
              return this.createText(Wr);
            case 6:
              return this.createAudio(Wr);
            case 13:
              return this.createCamera(Wr);
            case 15:
              return this.createFootage(Wr);
            default:
              return this.createNull(Wr);
          }
        }),
        (BaseRenderer.prototype.createCamera = function () {
          throw new Error("You're using a 3d camera. Try the html renderer.");
        }),
        (BaseRenderer.prototype.createAudio = function (Wr) {
          return new AudioElement(Wr, this.globalData, this);
        }),
        (BaseRenderer.prototype.createFootage = function (Wr) {
          return new FootageElement(Wr, this.globalData, this);
        }),
        (BaseRenderer.prototype.buildAllItems = function () {
          var Wr,
            ze = this.layers.length;
          for (Wr = 0; Wr < ze; Wr += 1) this.buildItem(Wr);
          this.checkPendingElements();
        }),
        (BaseRenderer.prototype.includeLayers = function (Wr) {
          this.completeLayers = !1;
          var ze,
            Gr = Wr.length,
            Yr,
            Kr = this.layers.length;
          for (ze = 0; ze < Gr; ze += 1)
            for (Yr = 0; Yr < Kr; ) {
              if (this.layers[Yr].id === Wr[ze].id) {
                this.layers[Yr] = Wr[ze];
                break;
              }
              Yr += 1;
            }
        }),
        (BaseRenderer.prototype.setProjectInterface = function (Wr) {
          this.globalData.projectInterface = Wr;
        }),
        (BaseRenderer.prototype.initItems = function () {
          this.globalData.progressiveLoad || this.buildAllItems();
        }),
        (BaseRenderer.prototype.buildElementParenting = function (Wr, ze, Gr) {
          for (
            var Yr = this.elements, Kr = this.layers, Zr = 0, Jr = Kr.length;
            Zr < Jr;

          )
            Kr[Zr].ind == ze &&
              (!Yr[Zr] || Yr[Zr] === !0
                ? (this.buildItem(Zr), this.addPendingElement(Wr))
                : (Gr.push(Yr[Zr]),
                  Yr[Zr].setAsParent(),
                  Kr[Zr].parent !== void 0
                    ? this.buildElementParenting(Wr, Kr[Zr].parent, Gr)
                    : Wr.setHierarchy(Gr))),
              (Zr += 1);
        }),
        (BaseRenderer.prototype.addPendingElement = function (Wr) {
          this.pendingElements.push(Wr);
        }),
        (BaseRenderer.prototype.searchExtraCompositions = function (Wr) {
          var ze,
            Gr = Wr.length;
          for (ze = 0; ze < Gr; ze += 1)
            if (Wr[ze].xt) {
              var Yr = this.createComp(Wr[ze]);
              Yr.initExpressions(),
                this.globalData.projectInterface.registerComposition(Yr);
            }
        }),
        (BaseRenderer.prototype.getElementById = function (Wr) {
          var ze,
            Gr = this.elements.length;
          for (ze = 0; ze < Gr; ze += 1)
            if (this.elements[ze].data.ind === Wr) return this.elements[ze];
          return null;
        }),
        (BaseRenderer.prototype.getElementByPath = function (Wr) {
          var ze = Wr.shift(),
            Gr;
          if (typeof ze == "number") Gr = this.elements[ze];
          else {
            var Yr,
              Kr = this.elements.length;
            for (Yr = 0; Yr < Kr; Yr += 1)
              if (this.elements[Yr].data.nm === ze) {
                Gr = this.elements[Yr];
                break;
              }
          }
          return Wr.length === 0 ? Gr : Gr.getElementByPath(Wr);
        }),
        (BaseRenderer.prototype.setupGlobalData = function (Wr, ze) {
          (this.globalData.fontManager = new FontManager()),
            (this.globalData.slotManager = slotFactory(Wr)),
            this.globalData.fontManager.addChars(Wr.chars),
            this.globalData.fontManager.addFonts(Wr.fonts, ze),
            (this.globalData.getAssetData =
              this.animationItem.getAssetData.bind(this.animationItem)),
            (this.globalData.getAssetsPath =
              this.animationItem.getAssetsPath.bind(this.animationItem)),
            (this.globalData.imageLoader = this.animationItem.imagePreloader),
            (this.globalData.audioController =
              this.animationItem.audioController),
            (this.globalData.frameId = 0),
            (this.globalData.frameRate = Wr.fr),
            (this.globalData.nm = Wr.nm),
            (this.globalData.compSize = {
              w: Wr.w,
              h: Wr.h,
            });
        });
      var effectTypes = {
        TRANSFORM_EFFECT: "transformEFfect",
      };
      function TransformElement() {}
      TransformElement.prototype = {
        initTransform: function () {
          var ze = new Matrix();
          (this.finalTransform = {
            mProp: this.data.ks
              ? TransformPropertyFactory.getTransformProperty(
                  this,
                  this.data.ks,
                  this
                )
              : {
                  o: 0,
                },
            _matMdf: !1,
            _localMatMdf: !1,
            _opMdf: !1,
            mat: ze,
            localMat: ze,
            localOpacity: 1,
          }),
            this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
            this.data.ty;
        },
        renderTransform: function () {
          if (
            ((this.finalTransform._opMdf =
              this.finalTransform.mProp.o._mdf || this._isFirstFrame),
            (this.finalTransform._matMdf =
              this.finalTransform.mProp._mdf || this._isFirstFrame),
            this.hierarchy)
          ) {
            var ze,
              Gr = this.finalTransform.mat,
              Yr = 0,
              Kr = this.hierarchy.length;
            if (!this.finalTransform._matMdf)
              for (; Yr < Kr; ) {
                if (this.hierarchy[Yr].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = !0;
                  break;
                }
                Yr += 1;
              }
            if (this.finalTransform._matMdf)
              for (
                ze = this.finalTransform.mProp.v.props,
                  Gr.cloneFromProps(ze),
                  Yr = 0;
                Yr < Kr;
                Yr += 1
              )
                Gr.multiply(this.hierarchy[Yr].finalTransform.mProp.v);
          }
          this.finalTransform._matMdf &&
            (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
            this.finalTransform._opMdf &&
              (this.finalTransform.localOpacity =
                this.finalTransform.mProp.o.v);
        },
        renderLocalTransform: function () {
          if (this.localTransforms) {
            var ze = 0,
              Gr = this.localTransforms.length;
            if (
              ((this.finalTransform._localMatMdf = this.finalTransform._matMdf),
              !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
            )
              for (; ze < Gr; )
                this.localTransforms[ze]._mdf &&
                  (this.finalTransform._localMatMdf = !0),
                  this.localTransforms[ze]._opMdf &&
                    !this.finalTransform._opMdf &&
                    ((this.finalTransform.localOpacity =
                      this.finalTransform.mProp.o.v),
                    (this.finalTransform._opMdf = !0)),
                  (ze += 1);
            if (this.finalTransform._localMatMdf) {
              var Yr = this.finalTransform.localMat;
              for (
                this.localTransforms[0].matrix.clone(Yr), ze = 1;
                ze < Gr;
                ze += 1
              ) {
                var Kr = this.localTransforms[ze].matrix;
                Yr.multiply(Kr);
              }
              Yr.multiply(this.finalTransform.mat);
            }
            if (this.finalTransform._opMdf) {
              var Zr = this.finalTransform.localOpacity;
              for (ze = 0; ze < Gr; ze += 1)
                Zr *= this.localTransforms[ze].opacity * 0.01;
              this.finalTransform.localOpacity = Zr;
            }
          }
        },
        searchEffectTransforms: function () {
          if (this.renderableEffectsManager) {
            var ze = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            );
            if (ze.length) {
              (this.localTransforms = []),
                (this.finalTransform.localMat = new Matrix());
              var Gr = 0,
                Yr = ze.length;
              for (Gr = 0; Gr < Yr; Gr += 1) this.localTransforms.push(ze[Gr]);
            }
          }
        },
        globalToLocal: function (ze) {
          var Gr = [];
          Gr.push(this.finalTransform);
          for (var Yr = !0, Kr = this.comp; Yr; )
            Kr.finalTransform
              ? (Kr.data.hasMask && Gr.splice(0, 0, Kr.finalTransform),
                (Kr = Kr.comp))
              : (Yr = !1);
          var Zr,
            Jr = Gr.length,
            Qr;
          for (Zr = 0; Zr < Jr; Zr += 1)
            (Qr = Gr[Zr].mat.applyToPointArray(0, 0, 0)),
              (ze = [ze[0] - Qr[0], ze[1] - Qr[1], 0]);
          return ze;
        },
        mHelper: new Matrix(),
      };
      function MaskElement(Wr, ze, Gr) {
        (this.data = Wr),
          (this.element = ze),
          (this.globalData = Gr),
          (this.storedData = []),
          (this.masksProperties = this.data.masksProperties || []),
          (this.maskElement = null);
        var Yr = this.globalData.defs,
          Kr,
          Zr = this.masksProperties ? this.masksProperties.length : 0;
        (this.viewData = createSizedArray(Zr)), (this.solidPath = "");
        var Jr,
          Qr = this.masksProperties,
          ei = 0,
          ti = [],
          ri,
          ni,
          ii = createElementID(),
          si,
          li,
          oi,
          ui,
          ai = "clipPath",
          hi = "clip-path";
        for (Kr = 0; Kr < Zr; Kr += 1)
          if (
            (((Qr[Kr].mode !== "a" && Qr[Kr].mode !== "n") ||
              Qr[Kr].inv ||
              Qr[Kr].o.k !== 100 ||
              Qr[Kr].o.x) &&
              ((ai = "mask"), (hi = "mask")),
            (Qr[Kr].mode === "s" || Qr[Kr].mode === "i") && ei === 0
              ? ((si = createNS("rect")),
                si.setAttribute("fill", "#ffffff"),
                si.setAttribute("width", this.element.comp.data.w || 0),
                si.setAttribute("height", this.element.comp.data.h || 0),
                ti.push(si))
              : (si = null),
            (Jr = createNS("path")),
            Qr[Kr].mode === "n")
          )
            (this.viewData[Kr] = {
              op: PropertyFactory.getProp(
                this.element,
                Qr[Kr].o,
                0,
                0.01,
                this.element
              ),
              prop: ShapePropertyFactory.getShapeProp(this.element, Qr[Kr], 3),
              elem: Jr,
              lastPath: "",
            }),
              Yr.appendChild(Jr);
          else {
            (ei += 1),
              Jr.setAttribute(
                "fill",
                Qr[Kr].mode === "s" ? "#000000" : "#ffffff"
              ),
              Jr.setAttribute("clip-rule", "nonzero");
            var ci;
            if (
              (Qr[Kr].x.k !== 0
                ? ((ai = "mask"),
                  (hi = "mask"),
                  (ui = PropertyFactory.getProp(
                    this.element,
                    Qr[Kr].x,
                    0,
                    null,
                    this.element
                  )),
                  (ci = createElementID()),
                  (li = createNS("filter")),
                  li.setAttribute("id", ci),
                  (oi = createNS("feMorphology")),
                  oi.setAttribute("operator", "erode"),
                  oi.setAttribute("in", "SourceGraphic"),
                  oi.setAttribute("radius", "0"),
                  li.appendChild(oi),
                  Yr.appendChild(li),
                  Jr.setAttribute(
                    "stroke",
                    Qr[Kr].mode === "s" ? "#000000" : "#ffffff"
                  ))
                : ((oi = null), (ui = null)),
              (this.storedData[Kr] = {
                elem: Jr,
                x: ui,
                expan: oi,
                lastPath: "",
                lastOperator: "",
                filterId: ci,
                lastRadius: 0,
              }),
              Qr[Kr].mode === "i")
            ) {
              ni = ti.length;
              var fi = createNS("g");
              for (ri = 0; ri < ni; ri += 1) fi.appendChild(ti[ri]);
              var di = createNS("mask");
              di.setAttribute("mask-type", "alpha"),
                di.setAttribute("id", ii + "_" + ei),
                di.appendChild(Jr),
                Yr.appendChild(di),
                fi.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + ii + "_" + ei + ")"
                ),
                (ti.length = 0),
                ti.push(fi);
            } else ti.push(Jr);
            Qr[Kr].inv &&
              !this.solidPath &&
              (this.solidPath = this.createLayerSolidPath()),
              (this.viewData[Kr] = {
                elem: Jr,
                lastPath: "",
                op: PropertyFactory.getProp(
                  this.element,
                  Qr[Kr].o,
                  0,
                  0.01,
                  this.element
                ),
                prop: ShapePropertyFactory.getShapeProp(
                  this.element,
                  Qr[Kr],
                  3
                ),
                invRect: si,
              }),
              this.viewData[Kr].prop.k ||
                this.drawPath(
                  Qr[Kr],
                  this.viewData[Kr].prop.v,
                  this.viewData[Kr]
                );
          }
        for (
          this.maskElement = createNS(ai), Zr = ti.length, Kr = 0;
          Kr < Zr;
          Kr += 1
        )
          this.maskElement.appendChild(ti[Kr]);
        ei > 0 &&
          (this.maskElement.setAttribute("id", ii),
          this.element.maskedElement.setAttribute(
            hi,
            "url(" + getLocationHref() + "#" + ii + ")"
          ),
          Yr.appendChild(this.maskElement)),
          this.viewData.length && this.element.addRenderableComponent(this);
      }
      (MaskElement.prototype.getMaskProperty = function (Wr) {
        return this.viewData[Wr].prop;
      }),
        (MaskElement.prototype.renderFrame = function (Wr) {
          var ze = this.element.finalTransform.mat,
            Gr,
            Yr = this.masksProperties.length;
          for (Gr = 0; Gr < Yr; Gr += 1)
            if (
              ((this.viewData[Gr].prop._mdf || Wr) &&
                this.drawPath(
                  this.masksProperties[Gr],
                  this.viewData[Gr].prop.v,
                  this.viewData[Gr]
                ),
              (this.viewData[Gr].op._mdf || Wr) &&
                this.viewData[Gr].elem.setAttribute(
                  "fill-opacity",
                  this.viewData[Gr].op.v
                ),
              this.masksProperties[Gr].mode !== "n" &&
                (this.viewData[Gr].invRect &&
                  (this.element.finalTransform.mProp._mdf || Wr) &&
                  this.viewData[Gr].invRect.setAttribute(
                    "transform",
                    ze.getInverseMatrix().to2dCSS()
                  ),
                this.storedData[Gr].x && (this.storedData[Gr].x._mdf || Wr)))
            ) {
              var Kr = this.storedData[Gr].expan;
              this.storedData[Gr].x.v < 0
                ? (this.storedData[Gr].lastOperator !== "erode" &&
                    ((this.storedData[Gr].lastOperator = "erode"),
                    this.storedData[Gr].elem.setAttribute(
                      "filter",
                      "url(" +
                        getLocationHref() +
                        "#" +
                        this.storedData[Gr].filterId +
                        ")"
                    )),
                  Kr.setAttribute("radius", -this.storedData[Gr].x.v))
                : (this.storedData[Gr].lastOperator !== "dilate" &&
                    ((this.storedData[Gr].lastOperator = "dilate"),
                    this.storedData[Gr].elem.setAttribute("filter", null)),
                  this.storedData[Gr].elem.setAttribute(
                    "stroke-width",
                    this.storedData[Gr].x.v * 2
                  ));
            }
        }),
        (MaskElement.prototype.getMaskelement = function () {
          return this.maskElement;
        }),
        (MaskElement.prototype.createLayerSolidPath = function () {
          var Wr = "M0,0 ";
          return (
            (Wr += " h" + this.globalData.compSize.w),
            (Wr += " v" + this.globalData.compSize.h),
            (Wr += " h-" + this.globalData.compSize.w),
            (Wr += " v-" + this.globalData.compSize.h + " "),
            Wr
          );
        }),
        (MaskElement.prototype.drawPath = function (Wr, ze, Gr) {
          var Yr = " M" + ze.v[0][0] + "," + ze.v[0][1],
            Kr,
            Zr;
          for (Zr = ze._length, Kr = 1; Kr < Zr; Kr += 1)
            Yr +=
              " C" +
              ze.o[Kr - 1][0] +
              "," +
              ze.o[Kr - 1][1] +
              " " +
              ze.i[Kr][0] +
              "," +
              ze.i[Kr][1] +
              " " +
              ze.v[Kr][0] +
              "," +
              ze.v[Kr][1];
          if (
            (ze.c &&
              Zr > 1 &&
              (Yr +=
                " C" +
                ze.o[Kr - 1][0] +
                "," +
                ze.o[Kr - 1][1] +
                " " +
                ze.i[0][0] +
                "," +
                ze.i[0][1] +
                " " +
                ze.v[0][0] +
                "," +
                ze.v[0][1]),
            Gr.lastPath !== Yr)
          ) {
            var Jr = "";
            Gr.elem &&
              (ze.c && (Jr = Wr.inv ? this.solidPath + Yr : Yr),
              Gr.elem.setAttribute("d", Jr)),
              (Gr.lastPath = Yr);
          }
        }),
        (MaskElement.prototype.destroy = function () {
          (this.element = null),
            (this.globalData = null),
            (this.maskElement = null),
            (this.data = null),
            (this.masksProperties = null);
        });
      var filtersFactory = (function () {
          var Wr = {};
          (Wr.createFilter = ze), (Wr.createAlphaToLuminanceFilter = Gr);
          function ze(Yr, Kr) {
            var Zr = createNS("filter");
            return (
              Zr.setAttribute("id", Yr),
              Kr !== !0 &&
                (Zr.setAttribute("filterUnits", "objectBoundingBox"),
                Zr.setAttribute("x", "0%"),
                Zr.setAttribute("y", "0%"),
                Zr.setAttribute("width", "100%"),
                Zr.setAttribute("height", "100%")),
              Zr
            );
          }
          function Gr() {
            var Yr = createNS("feColorMatrix");
            return (
              Yr.setAttribute("type", "matrix"),
              Yr.setAttribute("color-interpolation-filters", "sRGB"),
              Yr.setAttribute(
                "values",
                "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"
              ),
              Yr
            );
          }
          return Wr;
        })(),
        featureSupport = (function () {
          var Wr = {
            maskType: !0,
            svgLumaHidden: !0,
            offscreenCanvas: typeof OffscreenCanvas < "u",
          };
          return (
            (/MSIE 10/i.test(navigator.userAgent) ||
              /MSIE 9/i.test(navigator.userAgent) ||
              /rv:11.0/i.test(navigator.userAgent) ||
              /Edge\/\d./i.test(navigator.userAgent)) &&
              (Wr.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (Wr.svgLumaHidden = !1),
            Wr
          );
        })(),
        registeredEffects$1 = {},
        idPrefix = "filter_result_";
      function SVGEffects(Wr) {
        var ze,
          Gr = "SourceGraphic",
          Yr = Wr.data.ef ? Wr.data.ef.length : 0,
          Kr = createElementID(),
          Zr = filtersFactory.createFilter(Kr, !0),
          Jr = 0;
        this.filters = [];
        var Qr;
        for (ze = 0; ze < Yr; ze += 1) {
          Qr = null;
          var ei = Wr.data.ef[ze].ty;
          if (registeredEffects$1[ei]) {
            var ti = registeredEffects$1[ei].effect;
            (Qr = new ti(
              Zr,
              Wr.effectsManager.effectElements[ze],
              Wr,
              idPrefix + Jr,
              Gr
            )),
              (Gr = idPrefix + Jr),
              registeredEffects$1[ei].countsAsEffect && (Jr += 1);
          }
          Qr && this.filters.push(Qr);
        }
        Jr &&
          (Wr.globalData.defs.appendChild(Zr),
          Wr.layerElement.setAttribute(
            "filter",
            "url(" + getLocationHref() + "#" + Kr + ")"
          )),
          this.filters.length && Wr.addRenderableComponent(this);
      }
      (SVGEffects.prototype.renderFrame = function (Wr) {
        var ze,
          Gr = this.filters.length;
        for (ze = 0; ze < Gr; ze += 1) this.filters[ze].renderFrame(Wr);
      }),
        (SVGEffects.prototype.getEffects = function (Wr) {
          var ze,
            Gr = this.filters.length,
            Yr = [];
          for (ze = 0; ze < Gr; ze += 1)
            this.filters[ze].type === Wr && Yr.push(this.filters[ze]);
          return Yr;
        });
      function registerEffect$1(Wr, ze, Gr) {
        registeredEffects$1[Wr] = {
          effect: ze,
          countsAsEffect: Gr,
        };
      }
      function SVGBaseElement() {}
      SVGBaseElement.prototype = {
        initRendererElement: function () {
          this.layerElement = createNS("g");
        },
        createContainerElements: function () {
          (this.matteElement = createNS("g")),
            (this.transformedElement = this.layerElement),
            (this.maskedElement = this.layerElement),
            (this._sizeChanged = !1);
          var ze = null;
          if (this.data.td) {
            this.matteMasks = {};
            var Gr = createNS("g");
            Gr.setAttribute("id", this.layerId),
              Gr.appendChild(this.layerElement),
              (ze = Gr),
              this.globalData.defs.appendChild(Gr);
          } else
            this.data.tt
              ? (this.matteElement.appendChild(this.layerElement),
                (ze = this.matteElement),
                (this.baseElement = this.matteElement))
              : (this.baseElement = this.layerElement);
          if (
            (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.ty === 0 && !this.data.hd)
          ) {
            var Yr = createNS("clipPath"),
              Kr = createNS("path");
            Kr.setAttribute(
              "d",
              "M0,0 L" +
                this.data.w +
                ",0 L" +
                this.data.w +
                "," +
                this.data.h +
                " L0," +
                this.data.h +
                "z"
            );
            var Zr = createElementID();
            if (
              (Yr.setAttribute("id", Zr),
              Yr.appendChild(Kr),
              this.globalData.defs.appendChild(Yr),
              this.checkMasks())
            ) {
              var Jr = createNS("g");
              Jr.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + Zr + ")"
              ),
                Jr.appendChild(this.layerElement),
                (this.transformedElement = Jr),
                ze
                  ? ze.appendChild(this.transformedElement)
                  : (this.baseElement = this.transformedElement);
            } else
              this.layerElement.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + Zr + ")"
              );
          }
          this.data.bm !== 0 && this.setBlendMode();
        },
        renderElement: function () {
          this.finalTransform._localMatMdf &&
            this.transformedElement.setAttribute(
              "transform",
              this.finalTransform.localMat.to2dCSS()
            ),
            this.finalTransform._opMdf &&
              this.transformedElement.setAttribute(
                "opacity",
                this.finalTransform.localOpacity
              );
        },
        destroyBaseElement: function () {
          (this.layerElement = null),
            (this.matteElement = null),
            this.maskManager.destroy();
        },
        getBaseElement: function () {
          return this.data.hd ? null : this.baseElement;
        },
        createRenderableComponents: function () {
          (this.maskManager = new MaskElement(
            this.data,
            this,
            this.globalData
          )),
            (this.renderableEffectsManager = new SVGEffects(this)),
            this.searchEffectTransforms();
        },
        getMatte: function (ze) {
          if (
            (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[ze])
          ) {
            var Gr = this.layerId + "_" + ze,
              Yr,
              Kr,
              Zr,
              Jr;
            if (ze === 1 || ze === 3) {
              var Qr = createNS("mask");
              Qr.setAttribute("id", Gr),
                Qr.setAttribute("mask-type", ze === 3 ? "luminance" : "alpha"),
                (Zr = createNS("use")),
                Zr.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                Qr.appendChild(Zr),
                this.globalData.defs.appendChild(Qr),
                !featureSupport.maskType &&
                  ze === 1 &&
                  (Qr.setAttribute("mask-type", "luminance"),
                  (Yr = createElementID()),
                  (Kr = filtersFactory.createFilter(Yr)),
                  this.globalData.defs.appendChild(Kr),
                  Kr.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (Jr = createNS("g")),
                  Jr.appendChild(Zr),
                  Qr.appendChild(Jr),
                  Jr.setAttribute(
                    "filter",
                    "url(" + getLocationHref() + "#" + Yr + ")"
                  ));
            } else if (ze === 2) {
              var ei = createNS("mask");
              ei.setAttribute("id", Gr), ei.setAttribute("mask-type", "alpha");
              var ti = createNS("g");
              ei.appendChild(ti),
                (Yr = createElementID()),
                (Kr = filtersFactory.createFilter(Yr));
              var ri = createNS("feComponentTransfer");
              ri.setAttribute("in", "SourceGraphic"), Kr.appendChild(ri);
              var ni = createNS("feFuncA");
              ni.setAttribute("type", "table"),
                ni.setAttribute("tableValues", "1.0 0.0"),
                ri.appendChild(ni),
                this.globalData.defs.appendChild(Kr);
              var ii = createNS("rect");
              ii.setAttribute("width", this.comp.data.w),
                ii.setAttribute("height", this.comp.data.h),
                ii.setAttribute("x", "0"),
                ii.setAttribute("y", "0"),
                ii.setAttribute("fill", "#ffffff"),
                ii.setAttribute("opacity", "0"),
                ti.setAttribute(
                  "filter",
                  "url(" + getLocationHref() + "#" + Yr + ")"
                ),
                ti.appendChild(ii),
                (Zr = createNS("use")),
                Zr.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                ti.appendChild(Zr),
                featureSupport.maskType ||
                  (ei.setAttribute("mask-type", "luminance"),
                  Kr.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (Jr = createNS("g")),
                  ti.appendChild(ii),
                  Jr.appendChild(this.layerElement),
                  ti.appendChild(Jr)),
                this.globalData.defs.appendChild(ei);
            }
            this.matteMasks[ze] = Gr;
          }
          return this.matteMasks[ze];
        },
        setMatte: function (ze) {
          this.matteElement &&
            this.matteElement.setAttribute(
              "mask",
              "url(" + getLocationHref() + "#" + ze + ")"
            );
        },
      };
      function HierarchyElement() {}
      HierarchyElement.prototype = {
        initHierarchy: function () {
          (this.hierarchy = []), (this._isParent = !1), this.checkParenting();
        },
        setHierarchy: function (ze) {
          this.hierarchy = ze;
        },
        setAsParent: function () {
          this._isParent = !0;
        },
        checkParenting: function () {
          this.data.parent !== void 0 &&
            this.comp.buildElementParenting(this, this.data.parent, []);
        },
      };
      function RenderableDOMElement() {}
      (function () {
        var Wr = {
          initElement: function (Gr, Yr, Kr) {
            this.initFrame(),
              this.initBaseData(Gr, Yr, Kr),
              this.initTransform(Gr, Yr, Kr),
              this.initHierarchy(),
              this.initRenderable(),
              this.initRendererElement(),
              this.createContainerElements(),
              this.createRenderableComponents(),
              this.createContent(),
              this.hide();
          },
          hide: function () {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var Gr = this.baseElement || this.layerElement;
              (Gr.style.display = "none"), (this.hidden = !0);
            }
          },
          show: function () {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var Gr = this.baseElement || this.layerElement;
                Gr.style.display = "block";
              }
              (this.hidden = !1), (this._isFirstFrame = !0);
            }
          },
          renderFrame: function () {
            this.data.hd ||
              this.hidden ||
              (this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.renderElement(),
              this.renderInnerContent(),
              this._isFirstFrame && (this._isFirstFrame = !1));
          },
          renderInnerContent: function () {},
          prepareFrame: function (Gr) {
            (this._mdf = !1),
              this.prepareRenderableFrame(Gr),
              this.prepareProperties(Gr, this.isInRange),
              this.checkTransparency();
          },
          destroy: function () {
            (this.innerElem = null), this.destroyBaseElement();
          },
        };
        extendPrototype(
          [RenderableElement, createProxyFunction(Wr)],
          RenderableDOMElement
        );
      })();
      function IImageElement(Wr, ze, Gr) {
        (this.assetData = ze.getAssetData(Wr.refId)),
          this.assetData &&
            this.assetData.sid &&
            (this.assetData = ze.slotManager.getProp(this.assetData)),
          this.initElement(Wr, ze, Gr),
          (this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h,
          });
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        IImageElement
      ),
        (IImageElement.prototype.createContent = function () {
          var Wr = this.globalData.getAssetsPath(this.assetData);
          (this.innerElem = createNS("image")),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute(
              "preserveAspectRatio",
              this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio
            ),
            this.innerElem.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "href",
              Wr
            ),
            this.layerElement.appendChild(this.innerElem);
        }),
        (IImageElement.prototype.sourceRectAtTime = function () {
          return this.sourceRect;
        });
      function ProcessedElement(Wr, ze) {
        (this.elem = Wr), (this.pos = ze);
      }
      function IShapeElement() {}
      IShapeElement.prototype = {
        addShapeToModifiers: function (ze) {
          var Gr,
            Yr = this.shapeModifiers.length;
          for (Gr = 0; Gr < Yr; Gr += 1) this.shapeModifiers[Gr].addShape(ze);
        },
        isShapeInAnimatedModifiers: function (ze) {
          for (var Gr = 0, Yr = this.shapeModifiers.length; Gr < Yr; )
            if (this.shapeModifiers[Gr].isAnimatedWithShape(ze)) return !0;
          return !1;
        },
        renderModifiers: function () {
          if (this.shapeModifiers.length) {
            var ze,
              Gr = this.shapes.length;
            for (ze = 0; ze < Gr; ze += 1) this.shapes[ze].sh.reset();
            Gr = this.shapeModifiers.length;
            var Yr;
            for (
              ze = Gr - 1;
              ze >= 0 &&
              ((Yr = this.shapeModifiers[ze].processShapes(this._isFirstFrame)),
              !Yr);
              ze -= 1
            );
          }
        },
        searchProcessedElement: function (ze) {
          for (
            var Gr = this.processedElements, Yr = 0, Kr = Gr.length;
            Yr < Kr;

          ) {
            if (Gr[Yr].elem === ze) return Gr[Yr].pos;
            Yr += 1;
          }
          return 0;
        },
        addProcessedElement: function (ze, Gr) {
          for (var Yr = this.processedElements, Kr = Yr.length; Kr; )
            if (((Kr -= 1), Yr[Kr].elem === ze)) {
              Yr[Kr].pos = Gr;
              return;
            }
          Yr.push(new ProcessedElement(ze, Gr));
        },
        prepareFrame: function (ze) {
          this.prepareRenderableFrame(ze),
            this.prepareProperties(ze, this.isInRange);
        },
      };
      var lineCapEnum = {
          1: "butt",
          2: "round",
          3: "square",
        },
        lineJoinEnum = {
          1: "miter",
          2: "round",
          3: "bevel",
        };
      function SVGShapeData(Wr, ze, Gr) {
        (this.caches = []),
          (this.styles = []),
          (this.transformers = Wr),
          (this.lStr = ""),
          (this.sh = Gr),
          (this.lvl = ze),
          (this._isAnimated = !!Gr.k);
        for (var Yr = 0, Kr = Wr.length; Yr < Kr; ) {
          if (Wr[Yr].mProps.dynamicProperties.length) {
            this._isAnimated = !0;
            break;
          }
          Yr += 1;
        }
      }
      SVGShapeData.prototype.setAsAnimated = function () {
        this._isAnimated = !0;
      };
      function SVGStyleData(Wr, ze) {
        (this.data = Wr),
          (this.type = Wr.ty),
          (this.d = ""),
          (this.lvl = ze),
          (this._mdf = !1),
          (this.closed = Wr.hd === !0),
          (this.pElem = createNS("path")),
          (this.msElem = null);
      }
      SVGStyleData.prototype.reset = function () {
        (this.d = ""), (this._mdf = !1);
      };
      function DashProperty(Wr, ze, Gr, Yr) {
        (this.elem = Wr),
          (this.frameId = -1),
          (this.dataProps = createSizedArray(ze.length)),
          (this.renderer = Gr),
          (this.k = !1),
          (this.dashStr = ""),
          (this.dashArray = createTypedArray(
            "float32",
            ze.length ? ze.length - 1 : 0
          )),
          (this.dashoffset = createTypedArray("float32", 1)),
          this.initDynamicPropertyContainer(Yr);
        var Kr,
          Zr = ze.length || 0,
          Jr;
        for (Kr = 0; Kr < Zr; Kr += 1)
          (Jr = PropertyFactory.getProp(Wr, ze[Kr].v, 0, 0, this)),
            (this.k = Jr.k || this.k),
            (this.dataProps[Kr] = {
              n: ze[Kr].n,
              p: Jr,
            });
        this.k || this.getValue(!0), (this._isAnimated = this.k);
      }
      (DashProperty.prototype.getValue = function (Wr) {
        if (
          !(this.elem.globalData.frameId === this.frameId && !Wr) &&
          ((this.frameId = this.elem.globalData.frameId),
          this.iterateDynamicProperties(),
          (this._mdf = this._mdf || Wr),
          this._mdf)
        ) {
          var ze = 0,
            Gr = this.dataProps.length;
          for (
            this.renderer === "svg" && (this.dashStr = ""), ze = 0;
            ze < Gr;
            ze += 1
          )
            this.dataProps[ze].n !== "o"
              ? this.renderer === "svg"
                ? (this.dashStr += " " + this.dataProps[ze].p.v)
                : (this.dashArray[ze] = this.dataProps[ze].p.v)
              : (this.dashoffset[0] = this.dataProps[ze].p.v);
        }
      }),
        extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(Wr, ze, Gr) {
        this.initDynamicPropertyContainer(Wr),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(Wr, ze.o, 0, 0.01, this)),
          (this.w = PropertyFactory.getProp(Wr, ze.w, 0, null, this)),
          (this.d = new DashProperty(Wr, ze.d || {}, "svg", this)),
          (this.c = PropertyFactory.getProp(Wr, ze.c, 1, 255, this)),
          (this.style = Gr),
          (this._isAnimated = !!this._isAnimated);
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(Wr, ze, Gr) {
        this.initDynamicPropertyContainer(Wr),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(Wr, ze.o, 0, 0.01, this)),
          (this.c = PropertyFactory.getProp(Wr, ze.c, 1, 255, this)),
          (this.style = Gr);
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(Wr, ze, Gr) {
        this.initDynamicPropertyContainer(Wr),
          (this.getValue = this.iterateDynamicProperties),
          (this.style = Gr);
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(Wr, ze, Gr) {
        (this.data = ze), (this.c = createTypedArray("uint8c", ze.p * 4));
        var Yr = ze.k.k[0].s
          ? ze.k.k[0].s.length - ze.p * 4
          : ze.k.k.length - ze.p * 4;
        (this.o = createTypedArray("float32", Yr)),
          (this._cmdf = !1),
          (this._omdf = !1),
          (this._collapsable = this.checkCollapsable()),
          (this._hasOpacity = Yr),
          this.initDynamicPropertyContainer(Gr),
          (this.prop = PropertyFactory.getProp(Wr, ze.k, 1, null, this)),
          (this.k = this.prop.k),
          this.getValue(!0);
      }
      (GradientProperty.prototype.comparePoints = function (Wr, ze) {
        for (var Gr = 0, Yr = this.o.length / 2, Kr; Gr < Yr; ) {
          if (((Kr = Math.abs(Wr[Gr * 4] - Wr[ze * 4 + Gr * 2])), Kr > 0.01))
            return !1;
          Gr += 1;
        }
        return !0;
      }),
        (GradientProperty.prototype.checkCollapsable = function () {
          if (this.o.length / 2 !== this.c.length / 4) return !1;
          if (this.data.k.k[0].s)
            for (var Wr = 0, ze = this.data.k.k.length; Wr < ze; ) {
              if (!this.comparePoints(this.data.k.k[Wr].s, this.data.p))
                return !1;
              Wr += 1;
            }
          else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
          return !0;
        }),
        (GradientProperty.prototype.getValue = function (Wr) {
          if (
            (this.prop.getValue(),
            (this._mdf = !1),
            (this._cmdf = !1),
            (this._omdf = !1),
            this.prop._mdf || Wr)
          ) {
            var ze,
              Gr = this.data.p * 4,
              Yr,
              Kr;
            for (ze = 0; ze < Gr; ze += 1)
              (Yr = ze % 4 === 0 ? 100 : 255),
                (Kr = Math.round(this.prop.v[ze] * Yr)),
                this.c[ze] !== Kr && ((this.c[ze] = Kr), (this._cmdf = !Wr));
            if (this.o.length)
              for (
                Gr = this.prop.v.length, ze = this.data.p * 4;
                ze < Gr;
                ze += 1
              )
                (Yr = ze % 2 === 0 ? 100 : 1),
                  (Kr =
                    ze % 2 === 0
                      ? Math.round(this.prop.v[ze] * 100)
                      : this.prop.v[ze]),
                  this.o[ze - this.data.p * 4] !== Kr &&
                    ((this.o[ze - this.data.p * 4] = Kr), (this._omdf = !Wr));
            this._mdf = !Wr;
          }
        }),
        extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(Wr, ze, Gr) {
        this.initDynamicPropertyContainer(Wr),
          (this.getValue = this.iterateDynamicProperties),
          this.initGradientData(Wr, ze, Gr);
      }
      (SVGGradientFillStyleData.prototype.initGradientData = function (
        Wr,
        ze,
        Gr
      ) {
        (this.o = PropertyFactory.getProp(Wr, ze.o, 0, 0.01, this)),
          (this.s = PropertyFactory.getProp(Wr, ze.s, 1, null, this)),
          (this.e = PropertyFactory.getProp(Wr, ze.e, 1, null, this)),
          (this.h = PropertyFactory.getProp(
            Wr,
            ze.h || {
              k: 0,
            },
            0,
            0.01,
            this
          )),
          (this.a = PropertyFactory.getProp(
            Wr,
            ze.a || {
              k: 0,
            },
            0,
            degToRads,
            this
          )),
          (this.g = new GradientProperty(Wr, ze.g, this)),
          (this.style = Gr),
          (this.stops = []),
          this.setGradientData(Gr.pElem, ze),
          this.setGradientOpacity(ze, Gr),
          (this._isAnimated = !!this._isAnimated);
      }),
        (SVGGradientFillStyleData.prototype.setGradientData = function (
          Wr,
          ze
        ) {
          var Gr = createElementID(),
            Yr = createNS(ze.t === 1 ? "linearGradient" : "radialGradient");
          Yr.setAttribute("id", Gr),
            Yr.setAttribute("spreadMethod", "pad"),
            Yr.setAttribute("gradientUnits", "userSpaceOnUse");
          var Kr = [],
            Zr,
            Jr,
            Qr;
          for (Qr = ze.g.p * 4, Jr = 0; Jr < Qr; Jr += 4)
            (Zr = createNS("stop")), Yr.appendChild(Zr), Kr.push(Zr);
          Wr.setAttribute(
            ze.ty === "gf" ? "fill" : "stroke",
            "url(" + getLocationHref() + "#" + Gr + ")"
          ),
            (this.gf = Yr),
            (this.cst = Kr);
        }),
        (SVGGradientFillStyleData.prototype.setGradientOpacity = function (
          Wr,
          ze
        ) {
          if (this.g._hasOpacity && !this.g._collapsable) {
            var Gr,
              Yr,
              Kr,
              Zr = createNS("mask"),
              Jr = createNS("path");
            Zr.appendChild(Jr);
            var Qr = createElementID(),
              ei = createElementID();
            Zr.setAttribute("id", ei);
            var ti = createNS(Wr.t === 1 ? "linearGradient" : "radialGradient");
            ti.setAttribute("id", Qr),
              ti.setAttribute("spreadMethod", "pad"),
              ti.setAttribute("gradientUnits", "userSpaceOnUse"),
              (Kr = Wr.g.k.k[0].s ? Wr.g.k.k[0].s.length : Wr.g.k.k.length);
            var ri = this.stops;
            for (Yr = Wr.g.p * 4; Yr < Kr; Yr += 2)
              (Gr = createNS("stop")),
                Gr.setAttribute("stop-color", "rgb(255,255,255)"),
                ti.appendChild(Gr),
                ri.push(Gr);
            Jr.setAttribute(
              Wr.ty === "gf" ? "fill" : "stroke",
              "url(" + getLocationHref() + "#" + Qr + ")"
            ),
              Wr.ty === "gs" &&
                (Jr.setAttribute("stroke-linecap", lineCapEnum[Wr.lc || 2]),
                Jr.setAttribute("stroke-linejoin", lineJoinEnum[Wr.lj || 2]),
                Wr.lj === 1 && Jr.setAttribute("stroke-miterlimit", Wr.ml)),
              (this.of = ti),
              (this.ms = Zr),
              (this.ost = ri),
              (this.maskId = ei),
              (ze.msElem = Jr);
          }
        }),
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(Wr, ze, Gr) {
        this.initDynamicPropertyContainer(Wr),
          (this.getValue = this.iterateDynamicProperties),
          (this.w = PropertyFactory.getProp(Wr, ze.w, 0, null, this)),
          (this.d = new DashProperty(Wr, ze.d || {}, "svg", this)),
          this.initGradientData(Wr, ze, Gr),
          (this._isAnimated = !!this._isAnimated);
      }
      extendPrototype(
        [SVGGradientFillStyleData, DynamicPropertyContainer],
        SVGGradientStrokeStyleData
      );
      function ShapeGroupData() {
        (this.it = []), (this.prevViewData = []), (this.gr = createNS("g"));
      }
      function SVGTransformData(Wr, ze, Gr) {
        (this.transform = {
          mProps: Wr,
          op: ze,
          container: Gr,
        }),
          (this.elements = []),
          (this._isAnimated =
            this.transform.mProps.dynamicProperties.length ||
            this.transform.op.effectsSequence.length);
      }
      var buildShapeString = function (ze, Gr, Yr, Kr) {
          if (Gr === 0) return "";
          var Zr = ze.o,
            Jr = ze.i,
            Qr = ze.v,
            ei,
            ti = " M" + Kr.applyToPointStringified(Qr[0][0], Qr[0][1]);
          for (ei = 1; ei < Gr; ei += 1)
            ti +=
              " C" +
              Kr.applyToPointStringified(Zr[ei - 1][0], Zr[ei - 1][1]) +
              " " +
              Kr.applyToPointStringified(Jr[ei][0], Jr[ei][1]) +
              " " +
              Kr.applyToPointStringified(Qr[ei][0], Qr[ei][1]);
          return (
            Yr &&
              Gr &&
              ((ti +=
                " C" +
                Kr.applyToPointStringified(Zr[ei - 1][0], Zr[ei - 1][1]) +
                " " +
                Kr.applyToPointStringified(Jr[0][0], Jr[0][1]) +
                " " +
                Kr.applyToPointStringified(Qr[0][0], Qr[0][1])),
              (ti += "z")),
            ti
          );
        },
        SVGElementsRenderer = (function () {
          var Wr = new Matrix(),
            ze = new Matrix(),
            Gr = {
              createRenderFunction: Yr,
            };
          function Yr(ni) {
            switch (ni.ty) {
              case "fl":
                return Qr;
              case "gf":
                return ti;
              case "gs":
                return ei;
              case "st":
                return ri;
              case "sh":
              case "el":
              case "rc":
              case "sr":
                return Jr;
              case "tr":
                return Kr;
              case "no":
                return Zr;
              default:
                return null;
            }
          }
          function Kr(ni, ii, si) {
            (si || ii.transform.op._mdf) &&
              ii.transform.container.setAttribute("opacity", ii.transform.op.v),
              (si || ii.transform.mProps._mdf) &&
                ii.transform.container.setAttribute(
                  "transform",
                  ii.transform.mProps.v.to2dCSS()
                );
          }
          function Zr() {}
          function Jr(ni, ii, si) {
            var li,
              oi,
              ui,
              ai,
              hi,
              ci,
              fi = ii.styles.length,
              di = ii.lvl,
              pi,
              mi,
              Si,
              yi;
            for (ci = 0; ci < fi; ci += 1) {
              if (((ai = ii.sh._mdf || si), ii.styles[ci].lvl < di)) {
                for (
                  mi = ze.reset(),
                    Si = di - ii.styles[ci].lvl,
                    yi = ii.transformers.length - 1;
                  !ai && Si > 0;

                )
                  (ai = ii.transformers[yi].mProps._mdf || ai),
                    (Si -= 1),
                    (yi -= 1);
                if (ai)
                  for (
                    Si = di - ii.styles[ci].lvl,
                      yi = ii.transformers.length - 1;
                    Si > 0;

                  )
                    mi.multiply(ii.transformers[yi].mProps.v),
                      (Si -= 1),
                      (yi -= 1);
              } else mi = Wr;
              if (((pi = ii.sh.paths), (oi = pi._length), ai)) {
                for (ui = "", li = 0; li < oi; li += 1)
                  (hi = pi.shapes[li]),
                    hi &&
                      hi._length &&
                      (ui += buildShapeString(hi, hi._length, hi.c, mi));
                ii.caches[ci] = ui;
              } else ui = ii.caches[ci];
              (ii.styles[ci].d += ni.hd === !0 ? "" : ui),
                (ii.styles[ci]._mdf = ai || ii.styles[ci]._mdf);
            }
          }
          function Qr(ni, ii, si) {
            var li = ii.style;
            (ii.c._mdf || si) &&
              li.pElem.setAttribute(
                "fill",
                "rgb(" +
                  bmFloor(ii.c.v[0]) +
                  "," +
                  bmFloor(ii.c.v[1]) +
                  "," +
                  bmFloor(ii.c.v[2]) +
                  ")"
              ),
              (ii.o._mdf || si) &&
                li.pElem.setAttribute("fill-opacity", ii.o.v);
          }
          function ei(ni, ii, si) {
            ti(ni, ii, si), ri(ni, ii, si);
          }
          function ti(ni, ii, si) {
            var li = ii.gf,
              oi = ii.g._hasOpacity,
              ui = ii.s.v,
              ai = ii.e.v;
            if (ii.o._mdf || si) {
              var hi = ni.ty === "gf" ? "fill-opacity" : "stroke-opacity";
              ii.style.pElem.setAttribute(hi, ii.o.v);
            }
            if (ii.s._mdf || si) {
              var ci = ni.t === 1 ? "x1" : "cx",
                fi = ci === "x1" ? "y1" : "cy";
              li.setAttribute(ci, ui[0]),
                li.setAttribute(fi, ui[1]),
                oi &&
                  !ii.g._collapsable &&
                  (ii.of.setAttribute(ci, ui[0]),
                  ii.of.setAttribute(fi, ui[1]));
            }
            var di, pi, mi, Si;
            if (ii.g._cmdf || si) {
              di = ii.cst;
              var yi = ii.g.c;
              for (mi = di.length, pi = 0; pi < mi; pi += 1)
                (Si = di[pi]),
                  Si.setAttribute("offset", yi[pi * 4] + "%"),
                  Si.setAttribute(
                    "stop-color",
                    "rgb(" +
                      yi[pi * 4 + 1] +
                      "," +
                      yi[pi * 4 + 2] +
                      "," +
                      yi[pi * 4 + 3] +
                      ")"
                  );
            }
            if (oi && (ii.g._omdf || si)) {
              var Ei = ii.g.o;
              for (
                ii.g._collapsable ? (di = ii.cst) : (di = ii.ost),
                  mi = di.length,
                  pi = 0;
                pi < mi;
                pi += 1
              )
                (Si = di[pi]),
                  ii.g._collapsable ||
                    Si.setAttribute("offset", Ei[pi * 2] + "%"),
                  Si.setAttribute("stop-opacity", Ei[pi * 2 + 1]);
            }
            if (ni.t === 1)
              (ii.e._mdf || si) &&
                (li.setAttribute("x2", ai[0]),
                li.setAttribute("y2", ai[1]),
                oi &&
                  !ii.g._collapsable &&
                  (ii.of.setAttribute("x2", ai[0]),
                  ii.of.setAttribute("y2", ai[1])));
            else {
              var Pi;
              if (
                ((ii.s._mdf || ii.e._mdf || si) &&
                  ((Pi = Math.sqrt(
                    Math.pow(ui[0] - ai[0], 2) + Math.pow(ui[1] - ai[1], 2)
                  )),
                  li.setAttribute("r", Pi),
                  oi && !ii.g._collapsable && ii.of.setAttribute("r", Pi)),
                ii.e._mdf || ii.h._mdf || ii.a._mdf || si)
              ) {
                Pi ||
                  (Pi = Math.sqrt(
                    Math.pow(ui[0] - ai[0], 2) + Math.pow(ui[1] - ai[1], 2)
                  ));
                var Ai = Math.atan2(ai[1] - ui[1], ai[0] - ui[0]),
                  Ri = ii.h.v;
                Ri >= 1 ? (Ri = 0.99) : Ri <= -1 && (Ri = -0.99);
                var wi = Pi * Ri,
                  Ci = Math.cos(Ai + ii.a.v) * wi + ui[0],
                  bi = Math.sin(Ai + ii.a.v) * wi + ui[1];
                li.setAttribute("fx", Ci),
                  li.setAttribute("fy", bi),
                  oi &&
                    !ii.g._collapsable &&
                    (ii.of.setAttribute("fx", Ci),
                    ii.of.setAttribute("fy", bi));
              }
            }
          }
          function ri(ni, ii, si) {
            var li = ii.style,
              oi = ii.d;
            oi &&
              (oi._mdf || si) &&
              oi.dashStr &&
              (li.pElem.setAttribute("stroke-dasharray", oi.dashStr),
              li.pElem.setAttribute("stroke-dashoffset", oi.dashoffset[0])),
              ii.c &&
                (ii.c._mdf || si) &&
                li.pElem.setAttribute(
                  "stroke",
                  "rgb(" +
                    bmFloor(ii.c.v[0]) +
                    "," +
                    bmFloor(ii.c.v[1]) +
                    "," +
                    bmFloor(ii.c.v[2]) +
                    ")"
                ),
              (ii.o._mdf || si) &&
                li.pElem.setAttribute("stroke-opacity", ii.o.v),
              (ii.w._mdf || si) &&
                (li.pElem.setAttribute("stroke-width", ii.w.v),
                li.msElem && li.msElem.setAttribute("stroke-width", ii.w.v));
          }
          return Gr;
        })();
      function SVGShapeElement(Wr, ze, Gr) {
        (this.shapes = []),
          (this.shapesData = Wr.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          this.initElement(Wr, ze, Gr),
          (this.prevViewData = []);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        SVGShapeElement
      ),
        (SVGShapeElement.prototype.initSecondaryElement = function () {}),
        (SVGShapeElement.prototype.identityMatrix = new Matrix()),
        (SVGShapeElement.prototype.buildExpressionInterface = function () {}),
        (SVGShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.layerElement,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes();
        }),
        (SVGShapeElement.prototype.filterUniqueShapes = function () {
          var Wr,
            ze = this.shapes.length,
            Gr,
            Yr,
            Kr = this.stylesList.length,
            Zr,
            Jr = [],
            Qr = !1;
          for (Yr = 0; Yr < Kr; Yr += 1) {
            for (
              Zr = this.stylesList[Yr], Qr = !1, Jr.length = 0, Wr = 0;
              Wr < ze;
              Wr += 1
            )
              (Gr = this.shapes[Wr]),
                Gr.styles.indexOf(Zr) !== -1 &&
                  (Jr.push(Gr), (Qr = Gr._isAnimated || Qr));
            Jr.length > 1 && Qr && this.setShapesAsAnimated(Jr);
          }
        }),
        (SVGShapeElement.prototype.setShapesAsAnimated = function (Wr) {
          var ze,
            Gr = Wr.length;
          for (ze = 0; ze < Gr; ze += 1) Wr[ze].setAsAnimated();
        }),
        (SVGShapeElement.prototype.createStyleElement = function (Wr, ze) {
          var Gr,
            Yr = new SVGStyleData(Wr, ze),
            Kr = Yr.pElem;
          if (Wr.ty === "st") Gr = new SVGStrokeStyleData(this, Wr, Yr);
          else if (Wr.ty === "fl") Gr = new SVGFillStyleData(this, Wr, Yr);
          else if (Wr.ty === "gf" || Wr.ty === "gs") {
            var Zr =
              Wr.ty === "gf"
                ? SVGGradientFillStyleData
                : SVGGradientStrokeStyleData;
            (Gr = new Zr(this, Wr, Yr)),
              this.globalData.defs.appendChild(Gr.gf),
              Gr.maskId &&
                (this.globalData.defs.appendChild(Gr.ms),
                this.globalData.defs.appendChild(Gr.of),
                Kr.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + Gr.maskId + ")"
                ));
          } else Wr.ty === "no" && (Gr = new SVGNoStyleData(this, Wr, Yr));
          return (
            (Wr.ty === "st" || Wr.ty === "gs") &&
              (Kr.setAttribute("stroke-linecap", lineCapEnum[Wr.lc || 2]),
              Kr.setAttribute("stroke-linejoin", lineJoinEnum[Wr.lj || 2]),
              Kr.setAttribute("fill-opacity", "0"),
              Wr.lj === 1 && Kr.setAttribute("stroke-miterlimit", Wr.ml)),
            Wr.r === 2 && Kr.setAttribute("fill-rule", "evenodd"),
            Wr.ln && Kr.setAttribute("id", Wr.ln),
            Wr.cl && Kr.setAttribute("class", Wr.cl),
            Wr.bm && (Kr.style["mix-blend-mode"] = getBlendMode(Wr.bm)),
            this.stylesList.push(Yr),
            this.addToAnimatedContents(Wr, Gr),
            Gr
          );
        }),
        (SVGShapeElement.prototype.createGroupElement = function (Wr) {
          var ze = new ShapeGroupData();
          return (
            Wr.ln && ze.gr.setAttribute("id", Wr.ln),
            Wr.cl && ze.gr.setAttribute("class", Wr.cl),
            Wr.bm && (ze.gr.style["mix-blend-mode"] = getBlendMode(Wr.bm)),
            ze
          );
        }),
        (SVGShapeElement.prototype.createTransformElement = function (Wr, ze) {
          var Gr = TransformPropertyFactory.getTransformProperty(
              this,
              Wr,
              this
            ),
            Yr = new SVGTransformData(Gr, Gr.o, ze);
          return this.addToAnimatedContents(Wr, Yr), Yr;
        }),
        (SVGShapeElement.prototype.createShapeElement = function (Wr, ze, Gr) {
          var Yr = 4;
          Wr.ty === "rc"
            ? (Yr = 5)
            : Wr.ty === "el"
            ? (Yr = 6)
            : Wr.ty === "sr" && (Yr = 7);
          var Kr = ShapePropertyFactory.getShapeProp(this, Wr, Yr, this),
            Zr = new SVGShapeData(ze, Gr, Kr);
          return (
            this.shapes.push(Zr),
            this.addShapeToModifiers(Zr),
            this.addToAnimatedContents(Wr, Zr),
            Zr
          );
        }),
        (SVGShapeElement.prototype.addToAnimatedContents = function (Wr, ze) {
          for (var Gr = 0, Yr = this.animatedContents.length; Gr < Yr; ) {
            if (this.animatedContents[Gr].element === ze) return;
            Gr += 1;
          }
          this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(Wr),
            element: ze,
            data: Wr,
          });
        }),
        (SVGShapeElement.prototype.setElementStyles = function (Wr) {
          var ze = Wr.styles,
            Gr,
            Yr = this.stylesList.length;
          for (Gr = 0; Gr < Yr; Gr += 1)
            this.stylesList[Gr].closed || ze.push(this.stylesList[Gr]);
        }),
        (SVGShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0;
          var Wr,
            ze = this.itemsData.length;
          for (Wr = 0; Wr < ze; Wr += 1)
            this.prevViewData[Wr] = this.itemsData[Wr];
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.layerElement,
              0,
              [],
              !0
            ),
              this.filterUniqueShapes(),
              ze = this.dynamicProperties.length,
              Wr = 0;
            Wr < ze;
            Wr += 1
          )
            this.dynamicProperties[Wr].getValue();
          this.renderModifiers();
        }),
        (SVGShapeElement.prototype.searchShapes = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr,
          Zr,
          Jr
        ) {
          var Qr = [].concat(Zr),
            ei,
            ti = Wr.length - 1,
            ri,
            ni,
            ii = [],
            si = [],
            li,
            oi,
            ui;
          for (ei = ti; ei >= 0; ei -= 1) {
            if (
              ((ui = this.searchProcessedElement(Wr[ei])),
              ui ? (ze[ei] = Gr[ui - 1]) : (Wr[ei]._render = Jr),
              Wr[ei].ty === "fl" ||
                Wr[ei].ty === "st" ||
                Wr[ei].ty === "gf" ||
                Wr[ei].ty === "gs" ||
                Wr[ei].ty === "no")
            )
              ui
                ? (ze[ei].style.closed = !1)
                : (ze[ei] = this.createStyleElement(Wr[ei], Kr)),
                Wr[ei]._render &&
                  ze[ei].style.pElem.parentNode !== Yr &&
                  Yr.appendChild(ze[ei].style.pElem),
                ii.push(ze[ei].style);
            else if (Wr[ei].ty === "gr") {
              if (!ui) ze[ei] = this.createGroupElement(Wr[ei]);
              else
                for (ni = ze[ei].it.length, ri = 0; ri < ni; ri += 1)
                  ze[ei].prevViewData[ri] = ze[ei].it[ri];
              this.searchShapes(
                Wr[ei].it,
                ze[ei].it,
                ze[ei].prevViewData,
                ze[ei].gr,
                Kr + 1,
                Qr,
                Jr
              ),
                Wr[ei]._render &&
                  ze[ei].gr.parentNode !== Yr &&
                  Yr.appendChild(ze[ei].gr);
            } else
              Wr[ei].ty === "tr"
                ? (ui || (ze[ei] = this.createTransformElement(Wr[ei], Yr)),
                  (li = ze[ei].transform),
                  Qr.push(li))
                : Wr[ei].ty === "sh" ||
                  Wr[ei].ty === "rc" ||
                  Wr[ei].ty === "el" ||
                  Wr[ei].ty === "sr"
                ? (ui || (ze[ei] = this.createShapeElement(Wr[ei], Qr, Kr)),
                  this.setElementStyles(ze[ei]))
                : Wr[ei].ty === "tm" ||
                  Wr[ei].ty === "rd" ||
                  Wr[ei].ty === "ms" ||
                  Wr[ei].ty === "pb" ||
                  Wr[ei].ty === "zz" ||
                  Wr[ei].ty === "op"
                ? (ui
                    ? ((oi = ze[ei]), (oi.closed = !1))
                    : ((oi = ShapeModifiers.getModifier(Wr[ei].ty)),
                      oi.init(this, Wr[ei]),
                      (ze[ei] = oi),
                      this.shapeModifiers.push(oi)),
                  si.push(oi))
                : Wr[ei].ty === "rp" &&
                  (ui
                    ? ((oi = ze[ei]), (oi.closed = !0))
                    : ((oi = ShapeModifiers.getModifier(Wr[ei].ty)),
                      (ze[ei] = oi),
                      oi.init(this, Wr, ei, ze),
                      this.shapeModifiers.push(oi),
                      (Jr = !1)),
                  si.push(oi));
            this.addProcessedElement(Wr[ei], ei + 1);
          }
          for (ti = ii.length, ei = 0; ei < ti; ei += 1) ii[ei].closed = !0;
          for (ti = si.length, ei = 0; ei < ti; ei += 1) si[ei].closed = !0;
        }),
        (SVGShapeElement.prototype.renderInnerContent = function () {
          this.renderModifiers();
          var Wr,
            ze = this.stylesList.length;
          for (Wr = 0; Wr < ze; Wr += 1) this.stylesList[Wr].reset();
          for (this.renderShape(), Wr = 0; Wr < ze; Wr += 1)
            (this.stylesList[Wr]._mdf || this._isFirstFrame) &&
              (this.stylesList[Wr].msElem &&
                (this.stylesList[Wr].msElem.setAttribute(
                  "d",
                  this.stylesList[Wr].d
                ),
                (this.stylesList[Wr].d = "M0 0" + this.stylesList[Wr].d)),
              this.stylesList[Wr].pElem.setAttribute(
                "d",
                this.stylesList[Wr].d || "M0 0"
              ));
        }),
        (SVGShapeElement.prototype.renderShape = function () {
          var Wr,
            ze = this.animatedContents.length,
            Gr;
          for (Wr = 0; Wr < ze; Wr += 1)
            (Gr = this.animatedContents[Wr]),
              (this._isFirstFrame || Gr.element._isAnimated) &&
                Gr.data !== !0 &&
                Gr.fn(Gr.data, Gr.element, this._isFirstFrame);
        }),
        (SVGShapeElement.prototype.destroy = function () {
          this.destroyBaseElement(),
            (this.shapesData = null),
            (this.itemsData = null);
        });
      function LetterProps(Wr, ze, Gr, Yr, Kr, Zr) {
        (this.o = Wr),
          (this.sw = ze),
          (this.sc = Gr),
          (this.fc = Yr),
          (this.m = Kr),
          (this.p = Zr),
          (this._mdf = {
            o: !0,
            sw: !!ze,
            sc: !!Gr,
            fc: !!Yr,
            m: !0,
            p: !0,
          });
      }
      LetterProps.prototype.update = function (Wr, ze, Gr, Yr, Kr, Zr) {
        (this._mdf.o = !1),
          (this._mdf.sw = !1),
          (this._mdf.sc = !1),
          (this._mdf.fc = !1),
          (this._mdf.m = !1),
          (this._mdf.p = !1);
        var Jr = !1;
        return (
          this.o !== Wr && ((this.o = Wr), (this._mdf.o = !0), (Jr = !0)),
          this.sw !== ze && ((this.sw = ze), (this._mdf.sw = !0), (Jr = !0)),
          this.sc !== Gr && ((this.sc = Gr), (this._mdf.sc = !0), (Jr = !0)),
          this.fc !== Yr && ((this.fc = Yr), (this._mdf.fc = !0), (Jr = !0)),
          this.m !== Kr && ((this.m = Kr), (this._mdf.m = !0), (Jr = !0)),
          Zr.length &&
            (this.p[0] !== Zr[0] ||
              this.p[1] !== Zr[1] ||
              this.p[4] !== Zr[4] ||
              this.p[5] !== Zr[5] ||
              this.p[12] !== Zr[12] ||
              this.p[13] !== Zr[13]) &&
            ((this.p = Zr), (this._mdf.p = !0), (Jr = !0)),
          Jr
        );
      };
      function TextProperty(Wr, ze) {
        (this._frameId = initialDefaultFrame),
          (this.pv = ""),
          (this.v = ""),
          (this.kf = !1),
          (this._isFirstFrame = !0),
          (this._mdf = !1),
          ze.d && ze.d.sid && (ze.d = Wr.globalData.slotManager.getProp(ze.d)),
          (this.data = ze),
          (this.elem = Wr),
          (this.comp = this.elem.comp),
          (this.keysIndex = 0),
          (this.canResize = !1),
          (this.minimumFontSize = 1),
          (this.effectsSequence = []),
          (this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: !1,
            strokeColorAnim: !1,
            strokeWidthAnim: !1,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: !1,
          }),
          this.copyData(this.currentData, this.data.d.k[0].s),
          this.searchProperty() || this.completeTextData(this.currentData);
      }
      (TextProperty.prototype.defaultBoxWidth = [0, 0]),
        (TextProperty.prototype.copyData = function (Wr, ze) {
          for (var Gr in ze)
            Object.prototype.hasOwnProperty.call(ze, Gr) && (Wr[Gr] = ze[Gr]);
          return Wr;
        }),
        (TextProperty.prototype.setCurrentData = function (Wr) {
          Wr.__complete || this.completeTextData(Wr),
            (this.currentData = Wr),
            (this.currentData.boxWidth =
              this.currentData.boxWidth || this.defaultBoxWidth),
            (this._mdf = !0);
        }),
        (TextProperty.prototype.searchProperty = function () {
          return this.searchKeyframes();
        }),
        (TextProperty.prototype.searchKeyframes = function () {
          return (
            (this.kf = this.data.d.k.length > 1),
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
          );
        }),
        (TextProperty.prototype.addEffect = function (Wr) {
          this.effectsSequence.push(Wr), this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.getValue = function (Wr) {
          if (
            !(
              (this.elem.globalData.frameId === this.frameId ||
                !this.effectsSequence.length) &&
              !Wr
            )
          ) {
            this.currentData.t = this.data.d.k[this.keysIndex].s.t;
            var ze = this.currentData,
              Gr = this.keysIndex;
            if (this.lock) {
              this.setCurrentData(this.currentData);
              return;
            }
            (this.lock = !0), (this._mdf = !1);
            var Yr,
              Kr = this.effectsSequence.length,
              Zr = Wr || this.data.d.k[this.keysIndex].s;
            for (Yr = 0; Yr < Kr; Yr += 1)
              Gr !== this.keysIndex
                ? (Zr = this.effectsSequence[Yr](Zr, Zr.t))
                : (Zr = this.effectsSequence[Yr](this.currentData, Zr.t));
            ze !== Zr && this.setCurrentData(Zr),
              (this.v = this.currentData),
              (this.pv = this.v),
              (this.lock = !1),
              (this.frameId = this.elem.globalData.frameId);
          }
        }),
        (TextProperty.prototype.getKeyframeValue = function () {
          for (
            var Wr = this.data.d.k,
              ze = this.elem.comp.renderedFrame,
              Gr = 0,
              Yr = Wr.length;
            Gr <= Yr - 1 && !(Gr === Yr - 1 || Wr[Gr + 1].t > ze);

          )
            Gr += 1;
          return (
            this.keysIndex !== Gr && (this.keysIndex = Gr),
            this.data.d.k[this.keysIndex].s
          );
        }),
        (TextProperty.prototype.buildFinalText = function (Wr) {
          for (
            var ze = [],
              Gr = 0,
              Yr = Wr.length,
              Kr,
              Zr,
              Jr = !1,
              Qr = !1,
              ei = "";
            Gr < Yr;

          )
            (Jr = Qr),
              (Qr = !1),
              (Kr = Wr.charCodeAt(Gr)),
              (ei = Wr.charAt(Gr)),
              FontManager.isCombinedCharacter(Kr)
                ? (Jr = !0)
                : Kr >= 55296 && Kr <= 56319
                ? FontManager.isRegionalFlag(Wr, Gr)
                  ? (ei = Wr.substr(Gr, 14))
                  : ((Zr = Wr.charCodeAt(Gr + 1)),
                    Zr >= 56320 &&
                      Zr <= 57343 &&
                      (FontManager.isModifier(Kr, Zr)
                        ? ((ei = Wr.substr(Gr, 2)), (Jr = !0))
                        : FontManager.isFlagEmoji(Wr.substr(Gr, 4))
                        ? (ei = Wr.substr(Gr, 4))
                        : (ei = Wr.substr(Gr, 2))))
                : Kr > 56319
                ? ((Zr = Wr.charCodeAt(Gr + 1)),
                  FontManager.isVariationSelector(Kr) && (Jr = !0))
                : FontManager.isZeroWidthJoiner(Kr) && ((Jr = !0), (Qr = !0)),
              Jr ? ((ze[ze.length - 1] += ei), (Jr = !1)) : ze.push(ei),
              (Gr += ei.length);
          return ze;
        }),
        (TextProperty.prototype.completeTextData = function (Wr) {
          Wr.__complete = !0;
          var ze = this.elem.globalData.fontManager,
            Gr = this.data,
            Yr = [],
            Kr,
            Zr,
            Jr,
            Qr = 0,
            ei,
            ti = Gr.m.g,
            ri = 0,
            ni = 0,
            ii = 0,
            si = [],
            li = 0,
            oi = 0,
            ui,
            ai,
            hi = ze.getFontByName(Wr.f),
            ci,
            fi = 0,
            di = getFontProperties(hi);
          (Wr.fWeight = di.weight),
            (Wr.fStyle = di.style),
            (Wr.finalSize = Wr.s),
            (Wr.finalText = this.buildFinalText(Wr.t)),
            (Zr = Wr.finalText.length),
            (Wr.finalLineHeight = Wr.lh);
          var pi = (Wr.tr / 1e3) * Wr.finalSize,
            mi;
          if (Wr.sz)
            for (var Si = !0, yi = Wr.sz[0], Ei = Wr.sz[1], Pi, Ai; Si; ) {
              (Ai = this.buildFinalText(Wr.t)),
                (Pi = 0),
                (li = 0),
                (Zr = Ai.length),
                (pi = (Wr.tr / 1e3) * Wr.finalSize);
              var Ri = -1;
              for (Kr = 0; Kr < Zr; Kr += 1)
                (mi = Ai[Kr].charCodeAt(0)),
                  (Jr = !1),
                  Ai[Kr] === " "
                    ? (Ri = Kr)
                    : (mi === 13 || mi === 3) &&
                      ((li = 0),
                      (Jr = !0),
                      (Pi += Wr.finalLineHeight || Wr.finalSize * 1.2)),
                  ze.chars
                    ? ((ci = ze.getCharData(Ai[Kr], hi.fStyle, hi.fFamily)),
                      (fi = Jr ? 0 : (ci.w * Wr.finalSize) / 100))
                    : (fi = ze.measureText(Ai[Kr], Wr.f, Wr.finalSize)),
                  li + fi > yi && Ai[Kr] !== " "
                    ? (Ri === -1 ? (Zr += 1) : (Kr = Ri),
                      (Pi += Wr.finalLineHeight || Wr.finalSize * 1.2),
                      Ai.splice(Kr, Ri === Kr ? 1 : 0, "\r"),
                      (Ri = -1),
                      (li = 0))
                    : ((li += fi), (li += pi));
              (Pi += (hi.ascent * Wr.finalSize) / 100),
                this.canResize && Wr.finalSize > this.minimumFontSize && Ei < Pi
                  ? ((Wr.finalSize -= 1),
                    (Wr.finalLineHeight = (Wr.finalSize * Wr.lh) / Wr.s))
                  : ((Wr.finalText = Ai),
                    (Zr = Wr.finalText.length),
                    (Si = !1));
            }
          (li = -pi), (fi = 0);
          var wi = 0,
            Ci;
          for (Kr = 0; Kr < Zr; Kr += 1)
            if (
              ((Jr = !1),
              (Ci = Wr.finalText[Kr]),
              (mi = Ci.charCodeAt(0)),
              mi === 13 || mi === 3
                ? ((wi = 0),
                  si.push(li),
                  (oi = li > oi ? li : oi),
                  (li = -2 * pi),
                  (ei = ""),
                  (Jr = !0),
                  (ii += 1))
                : (ei = Ci),
              ze.chars
                ? ((ci = ze.getCharData(
                    Ci,
                    hi.fStyle,
                    ze.getFontByName(Wr.f).fFamily
                  )),
                  (fi = Jr ? 0 : (ci.w * Wr.finalSize) / 100))
                : (fi = ze.measureText(ei, Wr.f, Wr.finalSize)),
              Ci === " " ? (wi += fi + pi) : ((li += fi + pi + wi), (wi = 0)),
              Yr.push({
                l: fi,
                an: fi,
                add: ri,
                n: Jr,
                anIndexes: [],
                val: ei,
                line: ii,
                animatorJustifyOffset: 0,
              }),
              ti == 2)
            ) {
              if (((ri += fi), ei === "" || ei === " " || Kr === Zr - 1)) {
                for ((ei === "" || ei === " ") && (ri -= fi); ni <= Kr; )
                  (Yr[ni].an = ri),
                    (Yr[ni].ind = Qr),
                    (Yr[ni].extra = fi),
                    (ni += 1);
                (Qr += 1), (ri = 0);
              }
            } else if (ti == 3) {
              if (((ri += fi), ei === "" || Kr === Zr - 1)) {
                for (ei === "" && (ri -= fi); ni <= Kr; )
                  (Yr[ni].an = ri),
                    (Yr[ni].ind = Qr),
                    (Yr[ni].extra = fi),
                    (ni += 1);
                (ri = 0), (Qr += 1);
              }
            } else (Yr[Qr].ind = Qr), (Yr[Qr].extra = 0), (Qr += 1);
          if (((Wr.l = Yr), (oi = li > oi ? li : oi), si.push(li), Wr.sz))
            (Wr.boxWidth = Wr.sz[0]), (Wr.justifyOffset = 0);
          else
            switch (((Wr.boxWidth = oi), Wr.j)) {
              case 1:
                Wr.justifyOffset = -Wr.boxWidth;
                break;
              case 2:
                Wr.justifyOffset = -Wr.boxWidth / 2;
                break;
              default:
                Wr.justifyOffset = 0;
            }
          Wr.lineWidths = si;
          var bi = Gr.a,
            Mi,
            gi;
          ai = bi.length;
          var xi,
            Ti,
            vi = [];
          for (ui = 0; ui < ai; ui += 1) {
            for (
              Mi = bi[ui],
                Mi.a.sc && (Wr.strokeColorAnim = !0),
                Mi.a.sw && (Wr.strokeWidthAnim = !0),
                (Mi.a.fc || Mi.a.fh || Mi.a.fs || Mi.a.fb) &&
                  (Wr.fillColorAnim = !0),
                Ti = 0,
                xi = Mi.s.b,
                Kr = 0;
              Kr < Zr;
              Kr += 1
            )
              (gi = Yr[Kr]),
                (gi.anIndexes[ui] = Ti),
                ((xi == 1 && gi.val !== "") ||
                  (xi == 2 && gi.val !== "" && gi.val !== " ") ||
                  (xi == 3 && (gi.n || gi.val == " " || Kr == Zr - 1)) ||
                  (xi == 4 && (gi.n || Kr == Zr - 1))) &&
                  (Mi.s.rn === 1 && vi.push(Ti), (Ti += 1));
            Gr.a[ui].s.totalChars = Ti;
            var Ii = -1,
              Oi;
            if (Mi.s.rn === 1)
              for (Kr = 0; Kr < Zr; Kr += 1)
                (gi = Yr[Kr]),
                  Ii != gi.anIndexes[ui] &&
                    ((Ii = gi.anIndexes[ui]),
                    (Oi = vi.splice(
                      Math.floor(Math.random() * vi.length),
                      1
                    )[0])),
                  (gi.anIndexes[ui] = Oi);
          }
          (Wr.yOffset = Wr.finalLineHeight || Wr.finalSize * 1.2),
            (Wr.ls = Wr.ls || 0),
            (Wr.ascent = (hi.ascent * Wr.finalSize) / 100);
        }),
        (TextProperty.prototype.updateDocumentData = function (Wr, ze) {
          ze = ze === void 0 ? this.keysIndex : ze;
          var Gr = this.copyData({}, this.data.d.k[ze].s);
          (Gr = this.copyData(Gr, Wr)),
            (this.data.d.k[ze].s = Gr),
            this.recalculate(ze),
            this.setCurrentData(Gr),
            this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.recalculate = function (Wr) {
          var ze = this.data.d.k[Wr].s;
          (ze.__complete = !1),
            (this.keysIndex = 0),
            (this._isFirstFrame = !0),
            this.getValue(ze);
        }),
        (TextProperty.prototype.canResizeFont = function (Wr) {
          (this.canResize = Wr),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this);
        }),
        (TextProperty.prototype.setMinimumFontSize = function (Wr) {
          (this.minimumFontSize = Math.floor(Wr) || 1),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this);
        });
      var TextSelectorProp = (function () {
        var Wr = Math.max,
          ze = Math.min,
          Gr = Math.floor;
        function Yr(Zr, Jr) {
          (this._currentTextLength = -1),
            (this.k = !1),
            (this.data = Jr),
            (this.elem = Zr),
            (this.comp = Zr.comp),
            (this.finalS = 0),
            (this.finalE = 0),
            this.initDynamicPropertyContainer(Zr),
            (this.s = PropertyFactory.getProp(
              Zr,
              Jr.s || {
                k: 0,
              },
              0,
              0,
              this
            )),
            "e" in Jr
              ? (this.e = PropertyFactory.getProp(Zr, Jr.e, 0, 0, this))
              : (this.e = {
                  v: 100,
                }),
            (this.o = PropertyFactory.getProp(
              Zr,
              Jr.o || {
                k: 0,
              },
              0,
              0,
              this
            )),
            (this.xe = PropertyFactory.getProp(
              Zr,
              Jr.xe || {
                k: 0,
              },
              0,
              0,
              this
            )),
            (this.ne = PropertyFactory.getProp(
              Zr,
              Jr.ne || {
                k: 0,
              },
              0,
              0,
              this
            )),
            (this.sm = PropertyFactory.getProp(
              Zr,
              Jr.sm || {
                k: 100,
              },
              0,
              0,
              this
            )),
            (this.a = PropertyFactory.getProp(Zr, Jr.a, 0, 0.01, this)),
            this.dynamicProperties.length || this.getValue();
        }
        (Yr.prototype = {
          getMult: function (Jr) {
            this._currentTextLength !==
              this.elem.textProperty.currentData.l.length && this.getValue();
            var Qr = 0,
              ei = 0,
              ti = 1,
              ri = 1;
            this.ne.v > 0 ? (Qr = this.ne.v / 100) : (ei = -this.ne.v / 100),
              this.xe.v > 0
                ? (ti = 1 - this.xe.v / 100)
                : (ri = 1 + this.xe.v / 100);
            var ni = BezierFactory.getBezierEasing(Qr, ei, ti, ri).get,
              ii = 0,
              si = this.finalS,
              li = this.finalE,
              oi = this.data.sh;
            if (oi === 2)
              li === si
                ? (ii = Jr >= li ? 1 : 0)
                : (ii = Wr(0, ze(0.5 / (li - si) + (Jr - si) / (li - si), 1))),
                (ii = ni(ii));
            else if (oi === 3)
              li === si
                ? (ii = Jr >= li ? 0 : 1)
                : (ii =
                    1 - Wr(0, ze(0.5 / (li - si) + (Jr - si) / (li - si), 1))),
                (ii = ni(ii));
            else if (oi === 4)
              li === si
                ? (ii = 0)
                : ((ii = Wr(0, ze(0.5 / (li - si) + (Jr - si) / (li - si), 1))),
                  ii < 0.5 ? (ii *= 2) : (ii = 1 - 2 * (ii - 0.5))),
                (ii = ni(ii));
            else if (oi === 5) {
              if (li === si) ii = 0;
              else {
                var ui = li - si;
                Jr = ze(Wr(0, Jr + 0.5 - si), li - si);
                var ai = -ui / 2 + Jr,
                  hi = ui / 2;
                ii = Math.sqrt(1 - (ai * ai) / (hi * hi));
              }
              ii = ni(ii);
            } else
              oi === 6
                ? (li === si
                    ? (ii = 0)
                    : ((Jr = ze(Wr(0, Jr + 0.5 - si), li - si)),
                      (ii =
                        (1 +
                          Math.cos(Math.PI + (Math.PI * 2 * Jr) / (li - si))) /
                        2)),
                  (ii = ni(ii)))
                : (Jr >= Gr(si) &&
                    (Jr - si < 0
                      ? (ii = Wr(0, ze(ze(li, 1) - (si - Jr), 1)))
                      : (ii = Wr(0, ze(li - Jr, 1)))),
                  (ii = ni(ii)));
            if (this.sm.v !== 100) {
              var ci = this.sm.v * 0.01;
              ci === 0 && (ci = 1e-8);
              var fi = 0.5 - ci * 0.5;
              ii < fi ? (ii = 0) : ((ii = (ii - fi) / ci), ii > 1 && (ii = 1));
            }
            return ii * this.a.v;
          },
          getValue: function (Jr) {
            this.iterateDynamicProperties(),
              (this._mdf = Jr || this._mdf),
              (this._currentTextLength =
                this.elem.textProperty.currentData.l.length || 0),
              Jr && this.data.r === 2 && (this.e.v = this._currentTextLength);
            var Qr = this.data.r === 2 ? 1 : 100 / this.data.totalChars,
              ei = this.o.v / Qr,
              ti = this.s.v / Qr + ei,
              ri = this.e.v / Qr + ei;
            if (ti > ri) {
              var ni = ti;
              (ti = ri), (ri = ni);
            }
            (this.finalS = ti), (this.finalE = ri);
          },
        }),
          extendPrototype([DynamicPropertyContainer], Yr);
        function Kr(Zr, Jr, Qr) {
          return new Yr(Zr, Jr);
        }
        return {
          getTextSelectorProp: Kr,
        };
      })();
      function TextAnimatorDataProperty(Wr, ze, Gr) {
        var Yr = {
            propType: !1,
          },
          Kr = PropertyFactory.getProp,
          Zr = ze.a;
        (this.a = {
          r: Zr.r ? Kr(Wr, Zr.r, 0, degToRads, Gr) : Yr,
          rx: Zr.rx ? Kr(Wr, Zr.rx, 0, degToRads, Gr) : Yr,
          ry: Zr.ry ? Kr(Wr, Zr.ry, 0, degToRads, Gr) : Yr,
          sk: Zr.sk ? Kr(Wr, Zr.sk, 0, degToRads, Gr) : Yr,
          sa: Zr.sa ? Kr(Wr, Zr.sa, 0, degToRads, Gr) : Yr,
          s: Zr.s ? Kr(Wr, Zr.s, 1, 0.01, Gr) : Yr,
          a: Zr.a ? Kr(Wr, Zr.a, 1, 0, Gr) : Yr,
          o: Zr.o ? Kr(Wr, Zr.o, 0, 0.01, Gr) : Yr,
          p: Zr.p ? Kr(Wr, Zr.p, 1, 0, Gr) : Yr,
          sw: Zr.sw ? Kr(Wr, Zr.sw, 0, 0, Gr) : Yr,
          sc: Zr.sc ? Kr(Wr, Zr.sc, 1, 0, Gr) : Yr,
          fc: Zr.fc ? Kr(Wr, Zr.fc, 1, 0, Gr) : Yr,
          fh: Zr.fh ? Kr(Wr, Zr.fh, 0, 0, Gr) : Yr,
          fs: Zr.fs ? Kr(Wr, Zr.fs, 0, 0.01, Gr) : Yr,
          fb: Zr.fb ? Kr(Wr, Zr.fb, 0, 0.01, Gr) : Yr,
          t: Zr.t ? Kr(Wr, Zr.t, 0, 0, Gr) : Yr,
        }),
          (this.s = TextSelectorProp.getTextSelectorProp(Wr, ze.s, Gr)),
          (this.s.t = ze.s.t);
      }
      function TextAnimatorProperty(Wr, ze, Gr) {
        (this._isFirstFrame = !0),
          (this._hasMaskedPath = !1),
          (this._frameId = -1),
          (this._textData = Wr),
          (this._renderType = ze),
          (this._elem = Gr),
          (this._animatorsData = createSizedArray(this._textData.a.length)),
          (this._pathData = {}),
          (this._moreOptions = {
            alignment: {},
          }),
          (this.renderedLetters = []),
          (this.lettersChangedFlag = !1),
          this.initDynamicPropertyContainer(Gr);
      }
      (TextAnimatorProperty.prototype.searchProperties = function () {
        var Wr,
          ze = this._textData.a.length,
          Gr,
          Yr = PropertyFactory.getProp;
        for (Wr = 0; Wr < ze; Wr += 1)
          (Gr = this._textData.a[Wr]),
            (this._animatorsData[Wr] = new TextAnimatorDataProperty(
              this._elem,
              Gr,
              this
            ));
        this._textData.p && "m" in this._textData.p
          ? ((this._pathData = {
              a: Yr(this._elem, this._textData.p.a, 0, 0, this),
              f: Yr(this._elem, this._textData.p.f, 0, 0, this),
              l: Yr(this._elem, this._textData.p.l, 0, 0, this),
              r: Yr(this._elem, this._textData.p.r, 0, 0, this),
              p: Yr(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
            }),
            (this._hasMaskedPath = !0))
          : (this._hasMaskedPath = !1),
          (this._moreOptions.alignment = Yr(
            this._elem,
            this._textData.m.a,
            1,
            0,
            this
          ));
      }),
        (TextAnimatorProperty.prototype.getMeasures = function (Wr, ze) {
          if (
            ((this.lettersChangedFlag = ze),
            !(
              !this._mdf &&
              !this._isFirstFrame &&
              !ze &&
              (!this._hasMaskedPath || !this._pathData.m._mdf)
            ))
          ) {
            this._isFirstFrame = !1;
            var Gr = this._moreOptions.alignment.v,
              Yr = this._animatorsData,
              Kr = this._textData,
              Zr = this.mHelper,
              Jr = this._renderType,
              Qr = this.renderedLetters.length,
              ei,
              ti,
              ri,
              ni,
              ii = Wr.l,
              si,
              li,
              oi,
              ui,
              ai,
              hi,
              ci,
              fi,
              di,
              pi,
              mi,
              Si,
              yi,
              Ei,
              Pi;
            if (this._hasMaskedPath) {
              if (
                ((Pi = this._pathData.m),
                !this._pathData.n || this._pathData._mdf)
              ) {
                var Ai = Pi.v;
                this._pathData.r.v && (Ai = Ai.reverse()),
                  (si = {
                    tLength: 0,
                    segments: [],
                  }),
                  (ni = Ai._length - 1);
                var Ri;
                for (Si = 0, ri = 0; ri < ni; ri += 1)
                  (Ri = bez.buildBezierData(
                    Ai.v[ri],
                    Ai.v[ri + 1],
                    [Ai.o[ri][0] - Ai.v[ri][0], Ai.o[ri][1] - Ai.v[ri][1]],
                    [
                      Ai.i[ri + 1][0] - Ai.v[ri + 1][0],
                      Ai.i[ri + 1][1] - Ai.v[ri + 1][1],
                    ]
                  )),
                    (si.tLength += Ri.segmentLength),
                    si.segments.push(Ri),
                    (Si += Ri.segmentLength);
                (ri = ni),
                  Pi.v.c &&
                    ((Ri = bez.buildBezierData(
                      Ai.v[ri],
                      Ai.v[0],
                      [Ai.o[ri][0] - Ai.v[ri][0], Ai.o[ri][1] - Ai.v[ri][1]],
                      [Ai.i[0][0] - Ai.v[0][0], Ai.i[0][1] - Ai.v[0][1]]
                    )),
                    (si.tLength += Ri.segmentLength),
                    si.segments.push(Ri),
                    (Si += Ri.segmentLength)),
                  (this._pathData.pi = si);
              }
              if (
                ((si = this._pathData.pi),
                (li = this._pathData.f.v),
                (ci = 0),
                (hi = 1),
                (ui = 0),
                (ai = !0),
                (pi = si.segments),
                li < 0 && Pi.v.c)
              )
                for (
                  si.tLength < Math.abs(li) &&
                    (li = -Math.abs(li) % si.tLength),
                    ci = pi.length - 1,
                    di = pi[ci].points,
                    hi = di.length - 1;
                  li < 0;

                )
                  (li += di[hi].partialLength),
                    (hi -= 1),
                    hi < 0 &&
                      ((ci -= 1), (di = pi[ci].points), (hi = di.length - 1));
              (di = pi[ci].points),
                (fi = di[hi - 1]),
                (oi = di[hi]),
                (mi = oi.partialLength);
            }
            (ni = ii.length), (ei = 0), (ti = 0);
            var wi = Wr.finalSize * 1.2 * 0.714,
              Ci = !0,
              bi,
              Mi,
              gi,
              xi,
              Ti;
            xi = Yr.length;
            var vi,
              Ii = -1,
              Oi,
              ki,
              Bi,
              Xi = li,
              an = ci,
              Qi = hi,
              ln = -1,
              yn,
              un,
              Vi,
              rn,
              qi,
              pn,
              vn,
              zi,
              mn = "",
              Sn = this.defaultPropsArray,
              Dn;
            if (Wr.j === 2 || Wr.j === 1) {
              var Cn = 0,
                $n = 0,
                Di = Wr.j === 2 ? -0.5 : -1,
                Li = 0,
                Gi = !0;
              for (ri = 0; ri < ni; ri += 1)
                if (ii[ri].n) {
                  for (Cn && (Cn += $n); Li < ri; )
                    (ii[Li].animatorJustifyOffset = Cn), (Li += 1);
                  (Cn = 0), (Gi = !0);
                } else {
                  for (gi = 0; gi < xi; gi += 1)
                    (bi = Yr[gi].a),
                      bi.t.propType &&
                        (Gi && Wr.j === 2 && ($n += bi.t.v * Di),
                        (Mi = Yr[gi].s),
                        (vi = Mi.getMult(
                          ii[ri].anIndexes[gi],
                          Kr.a[gi].s.totalChars
                        )),
                        vi.length
                          ? (Cn += bi.t.v * vi[0] * Di)
                          : (Cn += bi.t.v * vi * Di));
                  Gi = !1;
                }
              for (Cn && (Cn += $n); Li < ri; )
                (ii[Li].animatorJustifyOffset = Cn), (Li += 1);
            }
            for (ri = 0; ri < ni; ri += 1) {
              if ((Zr.reset(), (yn = 1), ii[ri].n))
                (ei = 0),
                  (ti += Wr.yOffset),
                  (ti += Ci ? 1 : 0),
                  (li = Xi),
                  (Ci = !1),
                  this._hasMaskedPath &&
                    ((ci = an),
                    (hi = Qi),
                    (di = pi[ci].points),
                    (fi = di[hi - 1]),
                    (oi = di[hi]),
                    (mi = oi.partialLength),
                    (ui = 0)),
                  (mn = ""),
                  (zi = ""),
                  (pn = ""),
                  (Dn = ""),
                  (Sn = this.defaultPropsArray);
              else {
                if (this._hasMaskedPath) {
                  if (ln !== ii[ri].line) {
                    switch (Wr.j) {
                      case 1:
                        li += Si - Wr.lineWidths[ii[ri].line];
                        break;
                      case 2:
                        li += (Si - Wr.lineWidths[ii[ri].line]) / 2;
                        break;
                    }
                    ln = ii[ri].line;
                  }
                  Ii !== ii[ri].ind &&
                    (ii[Ii] && (li += ii[Ii].extra),
                    (li += ii[ri].an / 2),
                    (Ii = ii[ri].ind)),
                    (li += Gr[0] * ii[ri].an * 0.005);
                  var Yi = 0;
                  for (gi = 0; gi < xi; gi += 1)
                    (bi = Yr[gi].a),
                      bi.p.propType &&
                        ((Mi = Yr[gi].s),
                        (vi = Mi.getMult(
                          ii[ri].anIndexes[gi],
                          Kr.a[gi].s.totalChars
                        )),
                        vi.length
                          ? (Yi += bi.p.v[0] * vi[0])
                          : (Yi += bi.p.v[0] * vi)),
                      bi.a.propType &&
                        ((Mi = Yr[gi].s),
                        (vi = Mi.getMult(
                          ii[ri].anIndexes[gi],
                          Kr.a[gi].s.totalChars
                        )),
                        vi.length
                          ? (Yi += bi.a.v[0] * vi[0])
                          : (Yi += bi.a.v[0] * vi));
                  for (
                    ai = !0,
                      this._pathData.a.v &&
                        ((li =
                          ii[0].an * 0.5 +
                          ((Si -
                            this._pathData.f.v -
                            ii[0].an * 0.5 -
                            ii[ii.length - 1].an * 0.5) *
                            Ii) /
                            (ni - 1)),
                        (li += this._pathData.f.v));
                    ai;

                  )
                    ui + mi >= li + Yi || !di
                      ? ((yi = (li + Yi - ui) / oi.partialLength),
                        (ki = fi.point[0] + (oi.point[0] - fi.point[0]) * yi),
                        (Bi = fi.point[1] + (oi.point[1] - fi.point[1]) * yi),
                        Zr.translate(
                          -Gr[0] * ii[ri].an * 0.005,
                          -(Gr[1] * wi) * 0.01
                        ),
                        (ai = !1))
                      : di &&
                        ((ui += oi.partialLength),
                        (hi += 1),
                        hi >= di.length &&
                          ((hi = 0),
                          (ci += 1),
                          pi[ci]
                            ? (di = pi[ci].points)
                            : Pi.v.c
                            ? ((hi = 0), (ci = 0), (di = pi[ci].points))
                            : ((ui -= oi.partialLength), (di = null))),
                        di &&
                          ((fi = oi), (oi = di[hi]), (mi = oi.partialLength)));
                  (Oi = ii[ri].an / 2 - ii[ri].add), Zr.translate(-Oi, 0, 0);
                } else
                  (Oi = ii[ri].an / 2 - ii[ri].add),
                    Zr.translate(-Oi, 0, 0),
                    Zr.translate(
                      -Gr[0] * ii[ri].an * 0.005,
                      -Gr[1] * wi * 0.01,
                      0
                    );
                for (gi = 0; gi < xi; gi += 1)
                  (bi = Yr[gi].a),
                    bi.t.propType &&
                      ((Mi = Yr[gi].s),
                      (vi = Mi.getMult(
                        ii[ri].anIndexes[gi],
                        Kr.a[gi].s.totalChars
                      )),
                      (ei !== 0 || Wr.j !== 0) &&
                        (this._hasMaskedPath
                          ? vi.length
                            ? (li += bi.t.v * vi[0])
                            : (li += bi.t.v * vi)
                          : vi.length
                          ? (ei += bi.t.v * vi[0])
                          : (ei += bi.t.v * vi)));
                for (
                  Wr.strokeWidthAnim && (Vi = Wr.sw || 0),
                    Wr.strokeColorAnim &&
                      (Wr.sc
                        ? (un = [Wr.sc[0], Wr.sc[1], Wr.sc[2]])
                        : (un = [0, 0, 0])),
                    Wr.fillColorAnim &&
                      Wr.fc &&
                      (rn = [Wr.fc[0], Wr.fc[1], Wr.fc[2]]),
                    gi = 0;
                  gi < xi;
                  gi += 1
                )
                  (bi = Yr[gi].a),
                    bi.a.propType &&
                      ((Mi = Yr[gi].s),
                      (vi = Mi.getMult(
                        ii[ri].anIndexes[gi],
                        Kr.a[gi].s.totalChars
                      )),
                      vi.length
                        ? Zr.translate(
                            -bi.a.v[0] * vi[0],
                            -bi.a.v[1] * vi[1],
                            bi.a.v[2] * vi[2]
                          )
                        : Zr.translate(
                            -bi.a.v[0] * vi,
                            -bi.a.v[1] * vi,
                            bi.a.v[2] * vi
                          ));
                for (gi = 0; gi < xi; gi += 1)
                  (bi = Yr[gi].a),
                    bi.s.propType &&
                      ((Mi = Yr[gi].s),
                      (vi = Mi.getMult(
                        ii[ri].anIndexes[gi],
                        Kr.a[gi].s.totalChars
                      )),
                      vi.length
                        ? Zr.scale(
                            1 + (bi.s.v[0] - 1) * vi[0],
                            1 + (bi.s.v[1] - 1) * vi[1],
                            1
                          )
                        : Zr.scale(
                            1 + (bi.s.v[0] - 1) * vi,
                            1 + (bi.s.v[1] - 1) * vi,
                            1
                          ));
                for (gi = 0; gi < xi; gi += 1) {
                  if (
                    ((bi = Yr[gi].a),
                    (Mi = Yr[gi].s),
                    (vi = Mi.getMult(
                      ii[ri].anIndexes[gi],
                      Kr.a[gi].s.totalChars
                    )),
                    bi.sk.propType &&
                      (vi.length
                        ? Zr.skewFromAxis(-bi.sk.v * vi[0], bi.sa.v * vi[1])
                        : Zr.skewFromAxis(-bi.sk.v * vi, bi.sa.v * vi)),
                    bi.r.propType &&
                      (vi.length
                        ? Zr.rotateZ(-bi.r.v * vi[2])
                        : Zr.rotateZ(-bi.r.v * vi)),
                    bi.ry.propType &&
                      (vi.length
                        ? Zr.rotateY(bi.ry.v * vi[1])
                        : Zr.rotateY(bi.ry.v * vi)),
                    bi.rx.propType &&
                      (vi.length
                        ? Zr.rotateX(bi.rx.v * vi[0])
                        : Zr.rotateX(bi.rx.v * vi)),
                    bi.o.propType &&
                      (vi.length
                        ? (yn += (bi.o.v * vi[0] - yn) * vi[0])
                        : (yn += (bi.o.v * vi - yn) * vi)),
                    Wr.strokeWidthAnim &&
                      bi.sw.propType &&
                      (vi.length
                        ? (Vi += bi.sw.v * vi[0])
                        : (Vi += bi.sw.v * vi)),
                    Wr.strokeColorAnim && bi.sc.propType)
                  )
                    for (qi = 0; qi < 3; qi += 1)
                      vi.length
                        ? (un[qi] += (bi.sc.v[qi] - un[qi]) * vi[0])
                        : (un[qi] += (bi.sc.v[qi] - un[qi]) * vi);
                  if (Wr.fillColorAnim && Wr.fc) {
                    if (bi.fc.propType)
                      for (qi = 0; qi < 3; qi += 1)
                        vi.length
                          ? (rn[qi] += (bi.fc.v[qi] - rn[qi]) * vi[0])
                          : (rn[qi] += (bi.fc.v[qi] - rn[qi]) * vi);
                    bi.fh.propType &&
                      (vi.length
                        ? (rn = addHueToRGB(rn, bi.fh.v * vi[0]))
                        : (rn = addHueToRGB(rn, bi.fh.v * vi))),
                      bi.fs.propType &&
                        (vi.length
                          ? (rn = addSaturationToRGB(rn, bi.fs.v * vi[0]))
                          : (rn = addSaturationToRGB(rn, bi.fs.v * vi))),
                      bi.fb.propType &&
                        (vi.length
                          ? (rn = addBrightnessToRGB(rn, bi.fb.v * vi[0]))
                          : (rn = addBrightnessToRGB(rn, bi.fb.v * vi)));
                  }
                }
                for (gi = 0; gi < xi; gi += 1)
                  (bi = Yr[gi].a),
                    bi.p.propType &&
                      ((Mi = Yr[gi].s),
                      (vi = Mi.getMult(
                        ii[ri].anIndexes[gi],
                        Kr.a[gi].s.totalChars
                      )),
                      this._hasMaskedPath
                        ? vi.length
                          ? Zr.translate(
                              0,
                              bi.p.v[1] * vi[0],
                              -bi.p.v[2] * vi[1]
                            )
                          : Zr.translate(0, bi.p.v[1] * vi, -bi.p.v[2] * vi)
                        : vi.length
                        ? Zr.translate(
                            bi.p.v[0] * vi[0],
                            bi.p.v[1] * vi[1],
                            -bi.p.v[2] * vi[2]
                          )
                        : Zr.translate(
                            bi.p.v[0] * vi,
                            bi.p.v[1] * vi,
                            -bi.p.v[2] * vi
                          ));
                if (
                  (Wr.strokeWidthAnim && (pn = Vi < 0 ? 0 : Vi),
                  Wr.strokeColorAnim &&
                    (vn =
                      "rgb(" +
                      Math.round(un[0] * 255) +
                      "," +
                      Math.round(un[1] * 255) +
                      "," +
                      Math.round(un[2] * 255) +
                      ")"),
                  Wr.fillColorAnim &&
                    Wr.fc &&
                    (zi =
                      "rgb(" +
                      Math.round(rn[0] * 255) +
                      "," +
                      Math.round(rn[1] * 255) +
                      "," +
                      Math.round(rn[2] * 255) +
                      ")"),
                  this._hasMaskedPath)
                ) {
                  if (
                    (Zr.translate(0, -Wr.ls),
                    Zr.translate(0, Gr[1] * wi * 0.01 + ti, 0),
                    this._pathData.p.v)
                  ) {
                    Ei =
                      (oi.point[1] - fi.point[1]) / (oi.point[0] - fi.point[0]);
                    var Ki = (Math.atan(Ei) * 180) / Math.PI;
                    oi.point[0] < fi.point[0] && (Ki += 180),
                      Zr.rotate((-Ki * Math.PI) / 180);
                  }
                  Zr.translate(ki, Bi, 0),
                    (li -= Gr[0] * ii[ri].an * 0.005),
                    ii[ri + 1] &&
                      Ii !== ii[ri + 1].ind &&
                      ((li += ii[ri].an / 2),
                      (li += Wr.tr * 0.001 * Wr.finalSize));
                } else {
                  switch (
                    (Zr.translate(ei, ti, 0),
                    Wr.ps && Zr.translate(Wr.ps[0], Wr.ps[1] + Wr.ascent, 0),
                    Wr.j)
                  ) {
                    case 1:
                      Zr.translate(
                        ii[ri].animatorJustifyOffset +
                          Wr.justifyOffset +
                          (Wr.boxWidth - Wr.lineWidths[ii[ri].line]),
                        0,
                        0
                      );
                      break;
                    case 2:
                      Zr.translate(
                        ii[ri].animatorJustifyOffset +
                          Wr.justifyOffset +
                          (Wr.boxWidth - Wr.lineWidths[ii[ri].line]) / 2,
                        0,
                        0
                      );
                      break;
                  }
                  Zr.translate(0, -Wr.ls),
                    Zr.translate(Oi, 0, 0),
                    Zr.translate(
                      Gr[0] * ii[ri].an * 0.005,
                      Gr[1] * wi * 0.01,
                      0
                    ),
                    (ei += ii[ri].l + Wr.tr * 0.001 * Wr.finalSize);
                }
                Jr === "html"
                  ? (mn = Zr.toCSS())
                  : Jr === "svg"
                  ? (mn = Zr.to2dCSS())
                  : (Sn = [
                      Zr.props[0],
                      Zr.props[1],
                      Zr.props[2],
                      Zr.props[3],
                      Zr.props[4],
                      Zr.props[5],
                      Zr.props[6],
                      Zr.props[7],
                      Zr.props[8],
                      Zr.props[9],
                      Zr.props[10],
                      Zr.props[11],
                      Zr.props[12],
                      Zr.props[13],
                      Zr.props[14],
                      Zr.props[15],
                    ]),
                  (Dn = yn);
              }
              Qr <= ri
                ? ((Ti = new LetterProps(Dn, pn, vn, zi, mn, Sn)),
                  this.renderedLetters.push(Ti),
                  (Qr += 1),
                  (this.lettersChangedFlag = !0))
                : ((Ti = this.renderedLetters[ri]),
                  (this.lettersChangedFlag =
                    Ti.update(Dn, pn, vn, zi, mn, Sn) ||
                    this.lettersChangedFlag));
            }
          }
        }),
        (TextAnimatorProperty.prototype.getValue = function () {
          this._elem.globalData.frameId !== this._frameId &&
            ((this._frameId = this._elem.globalData.frameId),
            this.iterateDynamicProperties());
        }),
        (TextAnimatorProperty.prototype.mHelper = new Matrix()),
        (TextAnimatorProperty.prototype.defaultPropsArray = []),
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {}
      (ITextElement.prototype.initElement = function (Wr, ze, Gr) {
        (this.lettersChangedFlag = !0),
          this.initFrame(),
          this.initBaseData(Wr, ze, Gr),
          (this.textProperty = new TextProperty(
            this,
            Wr.t,
            this.dynamicProperties
          )),
          (this.textAnimator = new TextAnimatorProperty(
            Wr.t,
            this.renderType,
            this
          )),
          this.initTransform(Wr, ze, Gr),
          this.initHierarchy(),
          this.initRenderable(),
          this.initRendererElement(),
          this.createContainerElements(),
          this.createRenderableComponents(),
          this.createContent(),
          this.hide(),
          this.textAnimator.searchProperties(this.dynamicProperties);
      }),
        (ITextElement.prototype.prepareFrame = function (Wr) {
          (this._mdf = !1),
            this.prepareRenderableFrame(Wr),
            this.prepareProperties(Wr, this.isInRange);
        }),
        (ITextElement.prototype.createPathShape = function (Wr, ze) {
          var Gr,
            Yr = ze.length,
            Kr,
            Zr = "";
          for (Gr = 0; Gr < Yr; Gr += 1)
            ze[Gr].ty === "sh" &&
              ((Kr = ze[Gr].ks.k),
              (Zr += buildShapeString(Kr, Kr.i.length, !0, Wr)));
          return Zr;
        }),
        (ITextElement.prototype.updateDocumentData = function (Wr, ze) {
          this.textProperty.updateDocumentData(Wr, ze);
        }),
        (ITextElement.prototype.canResizeFont = function (Wr) {
          this.textProperty.canResizeFont(Wr);
        }),
        (ITextElement.prototype.setMinimumFontSize = function (Wr) {
          this.textProperty.setMinimumFontSize(Wr);
        }),
        (ITextElement.prototype.applyTextPropertiesToMatrix = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr
        ) {
          switch (
            (Wr.ps && ze.translate(Wr.ps[0], Wr.ps[1] + Wr.ascent, 0),
            ze.translate(0, -Wr.ls, 0),
            Wr.j)
          ) {
            case 1:
              ze.translate(
                Wr.justifyOffset + (Wr.boxWidth - Wr.lineWidths[Gr]),
                0,
                0
              );
              break;
            case 2:
              ze.translate(
                Wr.justifyOffset + (Wr.boxWidth - Wr.lineWidths[Gr]) / 2,
                0,
                0
              );
              break;
          }
          ze.translate(Yr, Kr, 0);
        }),
        (ITextElement.prototype.buildColor = function (Wr) {
          return (
            "rgb(" +
            Math.round(Wr[0] * 255) +
            "," +
            Math.round(Wr[1] * 255) +
            "," +
            Math.round(Wr[2] * 255) +
            ")"
          );
        }),
        (ITextElement.prototype.emptyProp = new LetterProps()),
        (ITextElement.prototype.destroy = function () {}),
        (ITextElement.prototype.validateText = function () {
          (this.textProperty._mdf || this.textProperty._isFirstFrame) &&
            (this.buildNewText(),
            (this.textProperty._isFirstFrame = !1),
            (this.textProperty._mdf = !1));
        });
      var emptyShapeData = {
        shapes: [],
      };
      function SVGTextLottieElement(Wr, ze, Gr) {
        (this.textSpans = []),
          (this.renderType = "svg"),
          this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        SVGTextLottieElement
      ),
        (SVGTextLottieElement.prototype.createContent = function () {
          this.data.singleShape &&
            !this.globalData.fontManager.chars &&
            (this.textContainer = createNS("text"));
        }),
        (SVGTextLottieElement.prototype.buildTextContents = function (Wr) {
          for (var ze = 0, Gr = Wr.length, Yr = [], Kr = ""; ze < Gr; )
            Wr[ze] === String.fromCharCode(13) ||
            Wr[ze] === String.fromCharCode(3)
              ? (Yr.push(Kr), (Kr = ""))
              : (Kr += Wr[ze]),
              (ze += 1);
          return Yr.push(Kr), Yr;
        }),
        (SVGTextLottieElement.prototype.buildShapeData = function (Wr, ze) {
          if (Wr.shapes && Wr.shapes.length) {
            var Gr = Wr.shapes[0];
            if (Gr.it) {
              var Yr = Gr.it[Gr.it.length - 1];
              Yr.s && ((Yr.s.k[0] = ze), (Yr.s.k[1] = ze));
            }
          }
          return Wr;
        }),
        (SVGTextLottieElement.prototype.buildNewText = function () {
          this.addDynamicProperty(this);
          var Wr,
            ze,
            Gr = this.textProperty.currentData;
          (this.renderedLetters = createSizedArray(Gr ? Gr.l.length : 0)),
            Gr.fc
              ? this.layerElement.setAttribute("fill", this.buildColor(Gr.fc))
              : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            Gr.sc &&
              (this.layerElement.setAttribute("stroke", this.buildColor(Gr.sc)),
              this.layerElement.setAttribute("stroke-width", Gr.sw)),
            this.layerElement.setAttribute("font-size", Gr.finalSize);
          var Yr = this.globalData.fontManager.getFontByName(Gr.f);
          if (Yr.fClass) this.layerElement.setAttribute("class", Yr.fClass);
          else {
            this.layerElement.setAttribute("font-family", Yr.fFamily);
            var Kr = Gr.fWeight,
              Zr = Gr.fStyle;
            this.layerElement.setAttribute("font-style", Zr),
              this.layerElement.setAttribute("font-weight", Kr);
          }
          this.layerElement.setAttribute("aria-label", Gr.t);
          var Jr = Gr.l || [],
            Qr = !!this.globalData.fontManager.chars;
          ze = Jr.length;
          var ei,
            ti = this.mHelper,
            ri = "",
            ni = this.data.singleShape,
            ii = 0,
            si = 0,
            li = !0,
            oi = Gr.tr * 0.001 * Gr.finalSize;
          if (ni && !Qr && !Gr.sz) {
            var ui = this.textContainer,
              ai = "start";
            switch (Gr.j) {
              case 1:
                ai = "end";
                break;
              case 2:
                ai = "middle";
                break;
              default:
                ai = "start";
                break;
            }
            ui.setAttribute("text-anchor", ai),
              ui.setAttribute("letter-spacing", oi);
            var hi = this.buildTextContents(Gr.finalText);
            for (
              ze = hi.length, si = Gr.ps ? Gr.ps[1] + Gr.ascent : 0, Wr = 0;
              Wr < ze;
              Wr += 1
            )
              (ei = this.textSpans[Wr].span || createNS("tspan")),
                (ei.textContent = hi[Wr]),
                ei.setAttribute("x", 0),
                ei.setAttribute("y", si),
                (ei.style.display = "inherit"),
                ui.appendChild(ei),
                this.textSpans[Wr] ||
                  (this.textSpans[Wr] = {
                    span: null,
                    glyph: null,
                  }),
                (this.textSpans[Wr].span = ei),
                (si += Gr.finalLineHeight);
            this.layerElement.appendChild(ui);
          } else {
            var ci = this.textSpans.length,
              fi;
            for (Wr = 0; Wr < ze; Wr += 1) {
              if (
                (this.textSpans[Wr] ||
                  (this.textSpans[Wr] = {
                    span: null,
                    childSpan: null,
                    glyph: null,
                  }),
                !Qr || !ni || Wr === 0)
              ) {
                if (
                  ((ei =
                    ci > Wr
                      ? this.textSpans[Wr].span
                      : createNS(Qr ? "g" : "text")),
                  ci <= Wr)
                ) {
                  if (
                    (ei.setAttribute("stroke-linecap", "butt"),
                    ei.setAttribute("stroke-linejoin", "round"),
                    ei.setAttribute("stroke-miterlimit", "4"),
                    (this.textSpans[Wr].span = ei),
                    Qr)
                  ) {
                    var di = createNS("g");
                    ei.appendChild(di), (this.textSpans[Wr].childSpan = di);
                  }
                  (this.textSpans[Wr].span = ei),
                    this.layerElement.appendChild(ei);
                }
                ei.style.display = "inherit";
              }
              if (
                (ti.reset(),
                ni &&
                  (Jr[Wr].n &&
                    ((ii = -oi),
                    (si += Gr.yOffset),
                    (si += li ? 1 : 0),
                    (li = !1)),
                  this.applyTextPropertiesToMatrix(Gr, ti, Jr[Wr].line, ii, si),
                  (ii += Jr[Wr].l || 0),
                  (ii += oi)),
                Qr)
              ) {
                fi = this.globalData.fontManager.getCharData(
                  Gr.finalText[Wr],
                  Yr.fStyle,
                  this.globalData.fontManager.getFontByName(Gr.f).fFamily
                );
                var pi;
                if (fi.t === 1)
                  pi = new SVGCompElement(fi.data, this.globalData, this);
                else {
                  var mi = emptyShapeData;
                  fi.data &&
                    fi.data.shapes &&
                    (mi = this.buildShapeData(fi.data, Gr.finalSize)),
                    (pi = new SVGShapeElement(mi, this.globalData, this));
                }
                if (this.textSpans[Wr].glyph) {
                  var Si = this.textSpans[Wr].glyph;
                  this.textSpans[Wr].childSpan.removeChild(Si.layerElement),
                    Si.destroy();
                }
                (this.textSpans[Wr].glyph = pi),
                  (pi._debug = !0),
                  pi.prepareFrame(0),
                  pi.renderFrame(),
                  this.textSpans[Wr].childSpan.appendChild(pi.layerElement),
                  fi.t === 1 &&
                    this.textSpans[Wr].childSpan.setAttribute(
                      "transform",
                      "scale(" +
                        Gr.finalSize / 100 +
                        "," +
                        Gr.finalSize / 100 +
                        ")"
                    );
              } else
                ni &&
                  ei.setAttribute(
                    "transform",
                    "translate(" + ti.props[12] + "," + ti.props[13] + ")"
                  ),
                  (ei.textContent = Jr[Wr].val),
                  ei.setAttributeNS(
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:space",
                    "preserve"
                  );
            }
            ni && ei && ei.setAttribute("d", ri);
          }
          for (; Wr < this.textSpans.length; )
            (this.textSpans[Wr].span.style.display = "none"), (Wr += 1);
          this._sizeChanged = !0;
        }),
        (SVGTextLottieElement.prototype.sourceRectAtTime = function () {
          if (
            (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged)
          ) {
            this._sizeChanged = !1;
            var Wr = this.layerElement.getBBox();
            this.bbox = {
              top: Wr.y,
              left: Wr.x,
              width: Wr.width,
              height: Wr.height,
            };
          }
          return this.bbox;
        }),
        (SVGTextLottieElement.prototype.getValue = function () {
          var Wr,
            ze = this.textSpans.length,
            Gr;
          for (
            this.renderedFrame = this.comp.renderedFrame, Wr = 0;
            Wr < ze;
            Wr += 1
          )
            (Gr = this.textSpans[Wr].glyph),
              Gr &&
                (Gr.prepareFrame(this.comp.renderedFrame - this.data.st),
                Gr._mdf && (this._mdf = !0));
        }),
        (SVGTextLottieElement.prototype.renderInnerContent = function () {
          if (
            (this.validateText(),
            (!this.data.singleShape || this._mdf) &&
              (this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              ),
              this.lettersChangedFlag || this.textAnimator.lettersChangedFlag))
          ) {
            this._sizeChanged = !0;
            var Wr,
              ze,
              Gr = this.textAnimator.renderedLetters,
              Yr = this.textProperty.currentData.l;
            ze = Yr.length;
            var Kr, Zr, Jr;
            for (Wr = 0; Wr < ze; Wr += 1)
              Yr[Wr].n ||
                ((Kr = Gr[Wr]),
                (Zr = this.textSpans[Wr].span),
                (Jr = this.textSpans[Wr].glyph),
                Jr && Jr.renderFrame(),
                Kr._mdf.m && Zr.setAttribute("transform", Kr.m),
                Kr._mdf.o && Zr.setAttribute("opacity", Kr.o),
                Kr._mdf.sw && Zr.setAttribute("stroke-width", Kr.sw),
                Kr._mdf.sc && Zr.setAttribute("stroke", Kr.sc),
                Kr._mdf.fc && Zr.setAttribute("fill", Kr.fc));
          }
        });
      function ISolidElement(Wr, ze, Gr) {
        this.initElement(Wr, ze, Gr);
      }
      extendPrototype([IImageElement], ISolidElement),
        (ISolidElement.prototype.createContent = function () {
          var Wr = createNS("rect");
          Wr.setAttribute("width", this.data.sw),
            Wr.setAttribute("height", this.data.sh),
            Wr.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(Wr);
        });
      function NullElement(Wr, ze, Gr) {
        this.initFrame(),
          this.initBaseData(Wr, ze, Gr),
          this.initFrame(),
          this.initTransform(Wr, ze, Gr),
          this.initHierarchy();
      }
      (NullElement.prototype.prepareFrame = function (Wr) {
        this.prepareProperties(Wr, !0);
      }),
        (NullElement.prototype.renderFrame = function () {}),
        (NullElement.prototype.getBaseElement = function () {
          return null;
        }),
        (NullElement.prototype.destroy = function () {}),
        (NullElement.prototype.sourceRectAtTime = function () {}),
        (NullElement.prototype.hide = function () {}),
        extendPrototype(
          [BaseElement, TransformElement, HierarchyElement, FrameElement],
          NullElement
        );
      function SVGRendererBase() {}
      extendPrototype([BaseRenderer], SVGRendererBase),
        (SVGRendererBase.prototype.createNull = function (Wr) {
          return new NullElement(Wr, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createShape = function (Wr) {
          return new SVGShapeElement(Wr, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createText = function (Wr) {
          return new SVGTextLottieElement(Wr, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createImage = function (Wr) {
          return new IImageElement(Wr, this.globalData, this);
        }),
        (SVGRendererBase.prototype.createSolid = function (Wr) {
          return new ISolidElement(Wr, this.globalData, this);
        }),
        (SVGRendererBase.prototype.configAnimation = function (Wr) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute(
              "xmlns:xlink",
              "http://www.w3.org/1999/xlink"
            ),
            this.renderConfig.viewBoxSize
              ? this.svgElement.setAttribute(
                  "viewBox",
                  this.renderConfig.viewBoxSize
                )
              : this.svgElement.setAttribute(
                  "viewBox",
                  "0 0 " + Wr.w + " " + Wr.h
                ),
            this.renderConfig.viewBoxOnly ||
              (this.svgElement.setAttribute("width", Wr.w),
              this.svgElement.setAttribute("height", Wr.h),
              (this.svgElement.style.width = "100%"),
              (this.svgElement.style.height = "100%"),
              (this.svgElement.style.transform = "translate3d(0,0,0)"),
              (this.svgElement.style.contentVisibility =
                this.renderConfig.contentVisibility)),
            this.renderConfig.width &&
              this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height &&
              this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className &&
              this.svgElement.setAttribute(
                "class",
                this.renderConfig.className
              ),
            this.renderConfig.id &&
              this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 &&
              this.svgElement.setAttribute(
                "focusable",
                this.renderConfig.focusable
              ),
            this.svgElement.setAttribute(
              "preserveAspectRatio",
              this.renderConfig.preserveAspectRatio
            ),
            this.animationItem.wrapper.appendChild(this.svgElement);
          var ze = this.globalData.defs;
          this.setupGlobalData(Wr, ze),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.data = Wr);
          var Gr = createNS("clipPath"),
            Yr = createNS("rect");
          Yr.setAttribute("width", Wr.w),
            Yr.setAttribute("height", Wr.h),
            Yr.setAttribute("x", 0),
            Yr.setAttribute("y", 0);
          var Kr = createElementID();
          Gr.setAttribute("id", Kr),
            Gr.appendChild(Yr),
            this.layerElement.setAttribute(
              "clip-path",
              "url(" + getLocationHref() + "#" + Kr + ")"
            ),
            ze.appendChild(Gr),
            (this.layers = Wr.layers),
            (this.elements = createSizedArray(Wr.layers.length));
        }),
        (SVGRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.layerElement = null),
            (this.globalData.defs = null);
          var Wr,
            ze = this.layers ? this.layers.length : 0;
          for (Wr = 0; Wr < ze; Wr += 1)
            this.elements[Wr] &&
              this.elements[Wr].destroy &&
              this.elements[Wr].destroy();
          (this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null);
        }),
        (SVGRendererBase.prototype.updateContainerSize = function () {}),
        (SVGRendererBase.prototype.findIndexByInd = function (Wr) {
          var ze = 0,
            Gr = this.layers.length;
          for (ze = 0; ze < Gr; ze += 1)
            if (this.layers[ze].ind === Wr) return ze;
          return -1;
        }),
        (SVGRendererBase.prototype.buildItem = function (Wr) {
          var ze = this.elements;
          if (!(ze[Wr] || this.layers[Wr].ty === 99)) {
            ze[Wr] = !0;
            var Gr = this.createItem(this.layers[Wr]);
            if (
              ((ze[Wr] = Gr),
              getExpressionsPlugin() &&
                (this.layers[Wr].ty === 0 &&
                  this.globalData.projectInterface.registerComposition(Gr),
                Gr.initExpressions()),
              this.appendElementInPos(Gr, Wr),
              this.layers[Wr].tt)
            ) {
              var Yr =
                "tp" in this.layers[Wr]
                  ? this.findIndexByInd(this.layers[Wr].tp)
                  : Wr - 1;
              if (Yr === -1) return;
              if (!this.elements[Yr] || this.elements[Yr] === !0)
                this.buildItem(Yr), this.addPendingElement(Gr);
              else {
                var Kr = ze[Yr],
                  Zr = Kr.getMatte(this.layers[Wr].tt);
                Gr.setMatte(Zr);
              }
            }
          }
        }),
        (SVGRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var Wr = this.pendingElements.pop();
            if ((Wr.checkParenting(), Wr.data.tt))
              for (var ze = 0, Gr = this.elements.length; ze < Gr; ) {
                if (this.elements[ze] === Wr) {
                  var Yr =
                      "tp" in Wr.data
                        ? this.findIndexByInd(Wr.data.tp)
                        : ze - 1,
                    Kr = this.elements[Yr],
                    Zr = Kr.getMatte(this.layers[ze].tt);
                  Wr.setMatte(Zr);
                  break;
                }
                ze += 1;
              }
          }
        }),
        (SVGRendererBase.prototype.renderFrame = function (Wr) {
          if (!(this.renderedFrame === Wr || this.destroyed)) {
            Wr === null ? (Wr = this.renderedFrame) : (this.renderedFrame = Wr),
              (this.globalData.frameNum = Wr),
              (this.globalData.frameId += 1),
              (this.globalData.projectInterface.currentFrame = Wr),
              (this.globalData._mdf = !1);
            var ze,
              Gr = this.layers.length;
            for (
              this.completeLayers || this.checkLayers(Wr), ze = Gr - 1;
              ze >= 0;
              ze -= 1
            )
              (this.completeLayers || this.elements[ze]) &&
                this.elements[ze].prepareFrame(Wr - this.layers[ze].st);
            if (this.globalData._mdf)
              for (ze = 0; ze < Gr; ze += 1)
                (this.completeLayers || this.elements[ze]) &&
                  this.elements[ze].renderFrame();
          }
        }),
        (SVGRendererBase.prototype.appendElementInPos = function (Wr, ze) {
          var Gr = Wr.getBaseElement();
          if (Gr) {
            for (var Yr = 0, Kr; Yr < ze; )
              this.elements[Yr] &&
                this.elements[Yr] !== !0 &&
                this.elements[Yr].getBaseElement() &&
                (Kr = this.elements[Yr].getBaseElement()),
                (Yr += 1);
            Kr
              ? this.layerElement.insertBefore(Gr, Kr)
              : this.layerElement.appendChild(Gr);
          }
        }),
        (SVGRendererBase.prototype.hide = function () {
          this.layerElement.style.display = "none";
        }),
        (SVGRendererBase.prototype.show = function () {
          this.layerElement.style.display = "block";
        });
      function ICompElement() {}
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        ICompElement
      ),
        (ICompElement.prototype.initElement = function (Wr, ze, Gr) {
          this.initFrame(),
            this.initBaseData(Wr, ze, Gr),
            this.initTransform(Wr, ze, Gr),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            (this.data.xt || !ze.progressiveLoad) && this.buildAllItems(),
            this.hide();
        }),
        (ICompElement.prototype.prepareFrame = function (Wr) {
          if (
            ((this._mdf = !1),
            this.prepareRenderableFrame(Wr),
            this.prepareProperties(Wr, this.isInRange),
            !(!this.isInRange && !this.data.xt))
          ) {
            if (this.tm._placeholder) this.renderedFrame = Wr / this.data.sr;
            else {
              var ze = this.tm.v;
              ze === this.data.op && (ze = this.data.op - 1),
                (this.renderedFrame = ze);
            }
            var Gr,
              Yr = this.elements.length;
            for (
              this.completeLayers || this.checkLayers(this.renderedFrame),
                Gr = Yr - 1;
              Gr >= 0;
              Gr -= 1
            )
              (this.completeLayers || this.elements[Gr]) &&
                (this.elements[Gr].prepareFrame(
                  this.renderedFrame - this.layers[Gr].st
                ),
                this.elements[Gr]._mdf && (this._mdf = !0));
          }
        }),
        (ICompElement.prototype.renderInnerContent = function () {
          var Wr,
            ze = this.layers.length;
          for (Wr = 0; Wr < ze; Wr += 1)
            (this.completeLayers || this.elements[Wr]) &&
              this.elements[Wr].renderFrame();
        }),
        (ICompElement.prototype.setElements = function (Wr) {
          this.elements = Wr;
        }),
        (ICompElement.prototype.getElements = function () {
          return this.elements;
        }),
        (ICompElement.prototype.destroyElements = function () {
          var Wr,
            ze = this.layers.length;
          for (Wr = 0; Wr < ze; Wr += 1)
            this.elements[Wr] && this.elements[Wr].destroy();
        }),
        (ICompElement.prototype.destroy = function () {
          this.destroyElements(), this.destroyBaseElement();
        });
      function SVGCompElement(Wr, ze, Gr) {
        (this.layers = Wr.layers),
          (this.supports3d = !0),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(Wr, ze, Gr),
          (this.tm = Wr.tm
            ? PropertyFactory.getProp(this, Wr.tm, 0, ze.frameRate, this)
            : {
                _placeholder: !0,
              });
      }
      extendPrototype(
        [SVGRendererBase, ICompElement, SVGBaseElement],
        SVGCompElement
      ),
        (SVGCompElement.prototype.createComp = function (Wr) {
          return new SVGCompElement(Wr, this.globalData, this);
        });
      function SVGRenderer(Wr, ze) {
        (this.animationItem = Wr),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.svgElement = createNS("svg"));
        var Gr = "";
        if (ze && ze.title) {
          var Yr = createNS("title"),
            Kr = createElementID();
          Yr.setAttribute("id", Kr),
            (Yr.textContent = ze.title),
            this.svgElement.appendChild(Yr),
            (Gr += Kr);
        }
        if (ze && ze.description) {
          var Zr = createNS("desc"),
            Jr = createElementID();
          Zr.setAttribute("id", Jr),
            (Zr.textContent = ze.description),
            this.svgElement.appendChild(Zr),
            (Gr += " " + Jr);
        }
        Gr && this.svgElement.setAttribute("aria-labelledby", Gr);
        var Qr = createNS("defs");
        this.svgElement.appendChild(Qr);
        var ei = createNS("g");
        this.svgElement.appendChild(ei),
          (this.layerElement = ei),
          (this.renderConfig = {
            preserveAspectRatio:
              (ze && ze.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (ze && ze.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (ze && ze.contentVisibility) || "visible",
            progressiveLoad: (ze && ze.progressiveLoad) || !1,
            hideOnTransparent: !(ze && ze.hideOnTransparent === !1),
            viewBoxOnly: (ze && ze.viewBoxOnly) || !1,
            viewBoxSize: (ze && ze.viewBoxSize) || !1,
            className: (ze && ze.className) || "",
            id: (ze && ze.id) || "",
            focusable: ze && ze.focusable,
            filterSize: {
              width: (ze && ze.filterSize && ze.filterSize.width) || "100%",
              height: (ze && ze.filterSize && ze.filterSize.height) || "100%",
              x: (ze && ze.filterSize && ze.filterSize.x) || "0%",
              y: (ze && ze.filterSize && ze.filterSize.y) || "0%",
            },
            width: ze && ze.width,
            height: ze && ze.height,
            runExpressions:
              !ze || ze.runExpressions === void 0 || ze.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            defs: Qr,
            renderConfig: this.renderConfig,
          }),
          (this.elements = []),
          (this.pendingElements = []),
          (this.destroyed = !1),
          (this.rendererType = "svg");
      }
      extendPrototype([SVGRendererBase], SVGRenderer),
        (SVGRenderer.prototype.createComp = function (Wr) {
          return new SVGCompElement(Wr, this.globalData, this);
        });
      function ShapeTransformManager() {
        (this.sequences = {}),
          (this.sequenceList = []),
          (this.transform_key_count = 0);
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function (ze) {
          var Gr,
            Yr = ze.length,
            Kr = "_";
          for (Gr = 0; Gr < Yr; Gr += 1) Kr += ze[Gr].transform.key + "_";
          var Zr = this.sequences[Kr];
          return (
            Zr ||
              ((Zr = {
                transforms: [].concat(ze),
                finalTransform: new Matrix(),
                _mdf: !1,
              }),
              (this.sequences[Kr] = Zr),
              this.sequenceList.push(Zr)),
            Zr
          );
        },
        processSequence: function (ze, Gr) {
          for (
            var Yr = 0, Kr = ze.transforms.length, Zr = Gr;
            Yr < Kr && !Gr;

          ) {
            if (ze.transforms[Yr].transform.mProps._mdf) {
              Zr = !0;
              break;
            }
            Yr += 1;
          }
          if (Zr)
            for (ze.finalTransform.reset(), Yr = Kr - 1; Yr >= 0; Yr -= 1)
              ze.finalTransform.multiply(ze.transforms[Yr].transform.mProps.v);
          ze._mdf = Zr;
        },
        processSequences: function (ze) {
          var Gr,
            Yr = this.sequenceList.length;
          for (Gr = 0; Gr < Yr; Gr += 1)
            this.processSequence(this.sequenceList[Gr], ze);
        },
        getNewKey: function () {
          return (
            (this.transform_key_count += 1), "_" + this.transform_key_count
          );
        },
      };
      var lumaLoader = function () {
        var ze = "__lottie_element_luma_buffer",
          Gr = null,
          Yr = null,
          Kr = null;
        function Zr() {
          var ei = createNS("svg"),
            ti = createNS("filter"),
            ri = createNS("feColorMatrix");
          return (
            ti.setAttribute("id", ze),
            ri.setAttribute("type", "matrix"),
            ri.setAttribute("color-interpolation-filters", "sRGB"),
            ri.setAttribute(
              "values",
              "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"
            ),
            ti.appendChild(ri),
            ei.appendChild(ti),
            ei.setAttribute("id", ze + "_svg"),
            featureSupport.svgLumaHidden && (ei.style.display = "none"),
            ei
          );
        }
        function Jr() {
          Gr ||
            ((Kr = Zr()),
            document.body.appendChild(Kr),
            (Gr = createTag("canvas")),
            (Yr = Gr.getContext("2d")),
            (Yr.filter = "url(#" + ze + ")"),
            (Yr.fillStyle = "rgba(0,0,0,0)"),
            Yr.fillRect(0, 0, 1, 1));
        }
        function Qr(ei) {
          return (
            Gr || Jr(),
            (Gr.width = ei.width),
            (Gr.height = ei.height),
            (Yr.filter = "url(#" + ze + ")"),
            Gr
          );
        }
        return {
          load: Jr,
          get: Qr,
        };
      };
      function createCanvas(Wr, ze) {
        if (featureSupport.offscreenCanvas) return new OffscreenCanvas(Wr, ze);
        var Gr = createTag("canvas");
        return (Gr.width = Wr), (Gr.height = ze), Gr;
      }
      var assetLoader = (function () {
          return {
            loadLumaCanvas: lumaLoader.load,
            getLumaCanvas: lumaLoader.get,
            createCanvas,
          };
        })(),
        registeredEffects = {};
      function CVEffects(Wr) {
        var ze,
          Gr = Wr.data.ef ? Wr.data.ef.length : 0;
        this.filters = [];
        var Yr;
        for (ze = 0; ze < Gr; ze += 1) {
          Yr = null;
          var Kr = Wr.data.ef[ze].ty;
          if (registeredEffects[Kr]) {
            var Zr = registeredEffects[Kr].effect;
            Yr = new Zr(Wr.effectsManager.effectElements[ze], Wr);
          }
          Yr && this.filters.push(Yr);
        }
        this.filters.length && Wr.addRenderableComponent(this);
      }
      (CVEffects.prototype.renderFrame = function (Wr) {
        var ze,
          Gr = this.filters.length;
        for (ze = 0; ze < Gr; ze += 1) this.filters[ze].renderFrame(Wr);
      }),
        (CVEffects.prototype.getEffects = function (Wr) {
          var ze,
            Gr = this.filters.length,
            Yr = [];
          for (ze = 0; ze < Gr; ze += 1)
            this.filters[ze].type === Wr && Yr.push(this.filters[ze]);
          return Yr;
        });
      function registerEffect(Wr, ze) {
        registeredEffects[Wr] = {
          effect: ze,
        };
      }
      function CVMaskElement(Wr, ze) {
        (this.data = Wr),
          (this.element = ze),
          (this.masksProperties = this.data.masksProperties || []),
          (this.viewData = createSizedArray(this.masksProperties.length));
        var Gr,
          Yr = this.masksProperties.length,
          Kr = !1;
        for (Gr = 0; Gr < Yr; Gr += 1)
          this.masksProperties[Gr].mode !== "n" && (Kr = !0),
            (this.viewData[Gr] = ShapePropertyFactory.getShapeProp(
              this.element,
              this.masksProperties[Gr],
              3
            ));
        (this.hasMasks = Kr), Kr && this.element.addRenderableComponent(this);
      }
      (CVMaskElement.prototype.renderFrame = function () {
        if (this.hasMasks) {
          var Wr = this.element.finalTransform.mat,
            ze = this.element.canvasContext,
            Gr,
            Yr = this.masksProperties.length,
            Kr,
            Zr,
            Jr;
          for (ze.beginPath(), Gr = 0; Gr < Yr; Gr += 1)
            if (this.masksProperties[Gr].mode !== "n") {
              this.masksProperties[Gr].inv &&
                (ze.moveTo(0, 0),
                ze.lineTo(this.element.globalData.compSize.w, 0),
                ze.lineTo(
                  this.element.globalData.compSize.w,
                  this.element.globalData.compSize.h
                ),
                ze.lineTo(0, this.element.globalData.compSize.h),
                ze.lineTo(0, 0)),
                (Jr = this.viewData[Gr].v),
                (Kr = Wr.applyToPointArray(Jr.v[0][0], Jr.v[0][1], 0)),
                ze.moveTo(Kr[0], Kr[1]);
              var Qr,
                ei = Jr._length;
              for (Qr = 1; Qr < ei; Qr += 1)
                (Zr = Wr.applyToTriplePoints(Jr.o[Qr - 1], Jr.i[Qr], Jr.v[Qr])),
                  ze.bezierCurveTo(Zr[0], Zr[1], Zr[2], Zr[3], Zr[4], Zr[5]);
              (Zr = Wr.applyToTriplePoints(Jr.o[Qr - 1], Jr.i[0], Jr.v[0])),
                ze.bezierCurveTo(Zr[0], Zr[1], Zr[2], Zr[3], Zr[4], Zr[5]);
            }
          this.element.globalData.renderer.save(!0), ze.clip();
        }
      }),
        (CVMaskElement.prototype.getMaskProperty =
          MaskElement.prototype.getMaskProperty),
        (CVMaskElement.prototype.destroy = function () {
          this.element = null;
        });
      function CVBaseElement() {}
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out",
      };
      (CVBaseElement.prototype = {
        createElements: function () {},
        initRendererElement: function () {},
        createContainerElements: function () {
          if (this.data.tt >= 1) {
            this.buffers = [];
            var ze = this.globalData.canvasContext,
              Gr = assetLoader.createCanvas(ze.canvas.width, ze.canvas.height);
            this.buffers.push(Gr);
            var Yr = assetLoader.createCanvas(
              ze.canvas.width,
              ze.canvas.height
            );
            this.buffers.push(Yr),
              this.data.tt >= 3 &&
                !document._isProxy &&
                assetLoader.loadLumaCanvas();
          }
          (this.canvasContext = this.globalData.canvasContext),
            (this.transformCanvas = this.globalData.transformCanvas),
            (this.renderableEffectsManager = new CVEffects(this)),
            this.searchEffectTransforms();
        },
        createContent: function () {},
        setBlendMode: function () {
          var ze = this.globalData;
          if (ze.blendMode !== this.data.bm) {
            ze.blendMode = this.data.bm;
            var Gr = getBlendMode(this.data.bm);
            ze.canvasContext.globalCompositeOperation = Gr;
          }
        },
        createRenderableComponents: function () {
          (this.maskManager = new CVMaskElement(this.data, this)),
            (this.transformEffects = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            ));
        },
        hideElement: function () {
          !this.hidden &&
            (!this.isInRange || this.isTransparent) &&
            (this.hidden = !0);
        },
        showElement: function () {
          this.isInRange &&
            !this.isTransparent &&
            ((this.hidden = !1),
            (this._isFirstFrame = !0),
            (this.maskManager._isFirstFrame = !0));
        },
        clearCanvas: function (ze) {
          ze.clearRect(
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            this.transformCanvas.w * this.transformCanvas.sx,
            this.transformCanvas.h * this.transformCanvas.sy
          );
        },
        prepareLayer: function () {
          if (this.data.tt >= 1) {
            var ze = this.buffers[0],
              Gr = ze.getContext("2d");
            this.clearCanvas(Gr),
              Gr.drawImage(this.canvasContext.canvas, 0, 0),
              (this.currentTransform = this.canvasContext.getTransform()),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform);
          }
        },
        exitLayer: function () {
          if (this.data.tt >= 1) {
            var ze = this.buffers[1],
              Gr = ze.getContext("2d");
            this.clearCanvas(Gr),
              Gr.drawImage(this.canvasContext.canvas, 0, 0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform);
            var Yr = this.comp.getElementById(
              "tp" in this.data ? this.data.tp : this.data.ind - 1
            );
            if (
              (Yr.renderFrame(!0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.data.tt >= 3 && !document._isProxy)
            ) {
              var Kr = assetLoader.getLumaCanvas(this.canvasContext.canvas),
                Zr = Kr.getContext("2d");
              Zr.drawImage(this.canvasContext.canvas, 0, 0),
                this.clearCanvas(this.canvasContext),
                this.canvasContext.drawImage(Kr, 0, 0);
            }
            (this.canvasContext.globalCompositeOperation =
              operationsMap[this.data.tt]),
              this.canvasContext.drawImage(ze, 0, 0),
              (this.canvasContext.globalCompositeOperation =
                "destination-over"),
              this.canvasContext.drawImage(this.buffers[0], 0, 0),
              this.canvasContext.setTransform(this.currentTransform),
              (this.canvasContext.globalCompositeOperation = "source-over");
          }
        },
        renderFrame: function (ze) {
          if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !ze)) {
            this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.setBlendMode();
            var Gr = this.data.ty === 0;
            this.prepareLayer(),
              this.globalData.renderer.save(Gr),
              this.globalData.renderer.ctxTransform(
                this.finalTransform.localMat.props
              ),
              this.globalData.renderer.ctxOpacity(
                this.finalTransform.localOpacity
              ),
              this.renderInnerContent(),
              this.globalData.renderer.restore(Gr),
              this.exitLayer(),
              this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
              this._isFirstFrame && (this._isFirstFrame = !1);
          }
        },
        destroy: function () {
          (this.canvasContext = null),
            (this.data = null),
            (this.globalData = null),
            this.maskManager.destroy();
        },
        mHelper: new Matrix(),
      }),
        (CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement),
        (CVBaseElement.prototype.show = CVBaseElement.prototype.showElement);
      function CVShapeData(Wr, ze, Gr, Yr) {
        (this.styledShapes = []), (this.tr = [0, 0, 0, 0, 0, 0]);
        var Kr = 4;
        ze.ty === "rc"
          ? (Kr = 5)
          : ze.ty === "el"
          ? (Kr = 6)
          : ze.ty === "sr" && (Kr = 7),
          (this.sh = ShapePropertyFactory.getShapeProp(Wr, ze, Kr, Wr));
        var Zr,
          Jr = Gr.length,
          Qr;
        for (Zr = 0; Zr < Jr; Zr += 1)
          Gr[Zr].closed ||
            ((Qr = {
              transforms: Yr.addTransformSequence(Gr[Zr].transforms),
              trNodes: [],
            }),
            this.styledShapes.push(Qr),
            Gr[Zr].elements.push(Qr));
      }
      CVShapeData.prototype.setAsAnimated =
        SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(Wr, ze, Gr) {
        (this.shapes = []),
          (this.shapesData = Wr.shapes),
          (this.stylesList = []),
          (this.itemsData = []),
          (this.prevViewData = []),
          (this.shapeModifiers = []),
          (this.processedElements = []),
          (this.transformsManager = new ShapeTransformManager()),
          this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVShapeElement
      ),
        (CVShapeElement.prototype.initElement =
          RenderableDOMElement.prototype.initElement),
        (CVShapeElement.prototype.transformHelper = {
          opacity: 1,
          _opMdf: !1,
        }),
        (CVShapeElement.prototype.dashResetter = []),
        (CVShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            !0,
            []
          );
        }),
        (CVShapeElement.prototype.createStyleElement = function (Wr, ze) {
          var Gr = {
              data: Wr,
              type: Wr.ty,
              preTransforms: this.transformsManager.addTransformSequence(ze),
              transforms: [],
              elements: [],
              closed: Wr.hd === !0,
            },
            Yr = {};
          if (
            (Wr.ty === "fl" || Wr.ty === "st"
              ? ((Yr.c = PropertyFactory.getProp(this, Wr.c, 1, 255, this)),
                Yr.c.k ||
                  (Gr.co =
                    "rgb(" +
                    bmFloor(Yr.c.v[0]) +
                    "," +
                    bmFloor(Yr.c.v[1]) +
                    "," +
                    bmFloor(Yr.c.v[2]) +
                    ")"))
              : (Wr.ty === "gf" || Wr.ty === "gs") &&
                ((Yr.s = PropertyFactory.getProp(this, Wr.s, 1, null, this)),
                (Yr.e = PropertyFactory.getProp(this, Wr.e, 1, null, this)),
                (Yr.h = PropertyFactory.getProp(
                  this,
                  Wr.h || {
                    k: 0,
                  },
                  0,
                  0.01,
                  this
                )),
                (Yr.a = PropertyFactory.getProp(
                  this,
                  Wr.a || {
                    k: 0,
                  },
                  0,
                  degToRads,
                  this
                )),
                (Yr.g = new GradientProperty(this, Wr.g, this))),
            (Yr.o = PropertyFactory.getProp(this, Wr.o, 0, 0.01, this)),
            Wr.ty === "st" || Wr.ty === "gs")
          ) {
            if (
              ((Gr.lc = lineCapEnum[Wr.lc || 2]),
              (Gr.lj = lineJoinEnum[Wr.lj || 2]),
              Wr.lj == 1 && (Gr.ml = Wr.ml),
              (Yr.w = PropertyFactory.getProp(this, Wr.w, 0, null, this)),
              Yr.w.k || (Gr.wi = Yr.w.v),
              Wr.d)
            ) {
              var Kr = new DashProperty(this, Wr.d, "canvas", this);
              (Yr.d = Kr),
                Yr.d.k ||
                  ((Gr.da = Yr.d.dashArray), (Gr.do = Yr.d.dashoffset[0]));
            }
          } else Gr.r = Wr.r === 2 ? "evenodd" : "nonzero";
          return this.stylesList.push(Gr), (Yr.style = Gr), Yr;
        }),
        (CVShapeElement.prototype.createGroupElement = function () {
          var Wr = {
            it: [],
            prevViewData: [],
          };
          return Wr;
        }),
        (CVShapeElement.prototype.createTransformElement = function (Wr) {
          var ze = {
            transform: {
              opacity: 1,
              _opMdf: !1,
              key: this.transformsManager.getNewKey(),
              op: PropertyFactory.getProp(this, Wr.o, 0, 0.01, this),
              mProps: TransformPropertyFactory.getTransformProperty(
                this,
                Wr,
                this
              ),
            },
          };
          return ze;
        }),
        (CVShapeElement.prototype.createShapeElement = function (Wr) {
          var ze = new CVShapeData(
            this,
            Wr,
            this.stylesList,
            this.transformsManager
          );
          return this.shapes.push(ze), this.addShapeToModifiers(ze), ze;
        }),
        (CVShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0;
          var Wr,
            ze = this.itemsData.length;
          for (Wr = 0; Wr < ze; Wr += 1)
            this.prevViewData[Wr] = this.itemsData[Wr];
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              !0,
              []
            ),
              ze = this.dynamicProperties.length,
              Wr = 0;
            Wr < ze;
            Wr += 1
          )
            this.dynamicProperties[Wr].getValue();
          this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame);
        }),
        (CVShapeElement.prototype.addTransformToStyleList = function (Wr) {
          var ze,
            Gr = this.stylesList.length;
          for (ze = 0; ze < Gr; ze += 1)
            this.stylesList[ze].closed ||
              this.stylesList[ze].transforms.push(Wr);
        }),
        (CVShapeElement.prototype.removeTransformFromStyleList = function () {
          var Wr,
            ze = this.stylesList.length;
          for (Wr = 0; Wr < ze; Wr += 1)
            this.stylesList[Wr].closed || this.stylesList[Wr].transforms.pop();
        }),
        (CVShapeElement.prototype.closeStyles = function (Wr) {
          var ze,
            Gr = Wr.length;
          for (ze = 0; ze < Gr; ze += 1) Wr[ze].closed = !0;
        }),
        (CVShapeElement.prototype.searchShapes = function (Wr, ze, Gr, Yr, Kr) {
          var Zr,
            Jr = Wr.length - 1,
            Qr,
            ei,
            ti = [],
            ri = [],
            ni,
            ii,
            si,
            li = [].concat(Kr);
          for (Zr = Jr; Zr >= 0; Zr -= 1) {
            if (
              ((ni = this.searchProcessedElement(Wr[Zr])),
              ni ? (ze[Zr] = Gr[ni - 1]) : (Wr[Zr]._shouldRender = Yr),
              Wr[Zr].ty === "fl" ||
                Wr[Zr].ty === "st" ||
                Wr[Zr].ty === "gf" ||
                Wr[Zr].ty === "gs")
            )
              ni
                ? (ze[Zr].style.closed = !1)
                : (ze[Zr] = this.createStyleElement(Wr[Zr], li)),
                ti.push(ze[Zr].style);
            else if (Wr[Zr].ty === "gr") {
              if (!ni) ze[Zr] = this.createGroupElement(Wr[Zr]);
              else
                for (ei = ze[Zr].it.length, Qr = 0; Qr < ei; Qr += 1)
                  ze[Zr].prevViewData[Qr] = ze[Zr].it[Qr];
              this.searchShapes(
                Wr[Zr].it,
                ze[Zr].it,
                ze[Zr].prevViewData,
                Yr,
                li
              );
            } else
              Wr[Zr].ty === "tr"
                ? (ni ||
                    ((si = this.createTransformElement(Wr[Zr])), (ze[Zr] = si)),
                  li.push(ze[Zr]),
                  this.addTransformToStyleList(ze[Zr]))
                : Wr[Zr].ty === "sh" ||
                  Wr[Zr].ty === "rc" ||
                  Wr[Zr].ty === "el" ||
                  Wr[Zr].ty === "sr"
                ? ni || (ze[Zr] = this.createShapeElement(Wr[Zr]))
                : Wr[Zr].ty === "tm" ||
                  Wr[Zr].ty === "rd" ||
                  Wr[Zr].ty === "pb" ||
                  Wr[Zr].ty === "zz" ||
                  Wr[Zr].ty === "op"
                ? (ni
                    ? ((ii = ze[Zr]), (ii.closed = !1))
                    : ((ii = ShapeModifiers.getModifier(Wr[Zr].ty)),
                      ii.init(this, Wr[Zr]),
                      (ze[Zr] = ii),
                      this.shapeModifiers.push(ii)),
                  ri.push(ii))
                : Wr[Zr].ty === "rp" &&
                  (ni
                    ? ((ii = ze[Zr]), (ii.closed = !0))
                    : ((ii = ShapeModifiers.getModifier(Wr[Zr].ty)),
                      (ze[Zr] = ii),
                      ii.init(this, Wr, Zr, ze),
                      this.shapeModifiers.push(ii),
                      (Yr = !1)),
                  ri.push(ii));
            this.addProcessedElement(Wr[Zr], Zr + 1);
          }
          for (
            this.removeTransformFromStyleList(),
              this.closeStyles(ti),
              Jr = ri.length,
              Zr = 0;
            Zr < Jr;
            Zr += 1
          )
            ri[Zr].closed = !0;
        }),
        (CVShapeElement.prototype.renderInnerContent = function () {
          (this.transformHelper.opacity = 1),
            (this.transformHelper._opMdf = !1),
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(
              this.transformHelper,
              this.shapesData,
              this.itemsData,
              !0
            );
        }),
        (CVShapeElement.prototype.renderShapeTransform = function (Wr, ze) {
          (Wr._opMdf || ze.op._mdf || this._isFirstFrame) &&
            ((ze.opacity = Wr.opacity),
            (ze.opacity *= ze.op.v),
            (ze._opMdf = !0));
        }),
        (CVShapeElement.prototype.drawLayer = function () {
          var Wr,
            ze = this.stylesList.length,
            Gr,
            Yr,
            Kr,
            Zr,
            Jr,
            Qr,
            ei = this.globalData.renderer,
            ti = this.globalData.canvasContext,
            ri,
            ni;
          for (Wr = 0; Wr < ze; Wr += 1)
            if (
              ((ni = this.stylesList[Wr]),
              (ri = ni.type),
              !(
                ((ri === "st" || ri === "gs") && ni.wi === 0) ||
                !ni.data._shouldRender ||
                ni.coOp === 0 ||
                this.globalData.currentGlobalAlpha === 0
              ))
            ) {
              for (
                ei.save(),
                  Jr = ni.elements,
                  ri === "st" || ri === "gs"
                    ? (ei.ctxStrokeStyle(ri === "st" ? ni.co : ni.grd),
                      ei.ctxLineWidth(ni.wi),
                      ei.ctxLineCap(ni.lc),
                      ei.ctxLineJoin(ni.lj),
                      ei.ctxMiterLimit(ni.ml || 0))
                    : ei.ctxFillStyle(ri === "fl" ? ni.co : ni.grd),
                  ei.ctxOpacity(ni.coOp),
                  ri !== "st" && ri !== "gs" && ti.beginPath(),
                  ei.ctxTransform(ni.preTransforms.finalTransform.props),
                  Yr = Jr.length,
                  Gr = 0;
                Gr < Yr;
                Gr += 1
              ) {
                for (
                  (ri === "st" || ri === "gs") &&
                    (ti.beginPath(),
                    ni.da &&
                      (ti.setLineDash(ni.da), (ti.lineDashOffset = ni.do))),
                    Qr = Jr[Gr].trNodes,
                    Zr = Qr.length,
                    Kr = 0;
                  Kr < Zr;
                  Kr += 1
                )
                  Qr[Kr].t === "m"
                    ? ti.moveTo(Qr[Kr].p[0], Qr[Kr].p[1])
                    : Qr[Kr].t === "c"
                    ? ti.bezierCurveTo(
                        Qr[Kr].pts[0],
                        Qr[Kr].pts[1],
                        Qr[Kr].pts[2],
                        Qr[Kr].pts[3],
                        Qr[Kr].pts[4],
                        Qr[Kr].pts[5]
                      )
                    : ti.closePath();
                (ri === "st" || ri === "gs") &&
                  (ei.ctxStroke(), ni.da && ti.setLineDash(this.dashResetter));
              }
              ri !== "st" &&
                ri !== "gs" &&
                this.globalData.renderer.ctxFill(ni.r),
                ei.restore();
            }
        }),
        (CVShapeElement.prototype.renderShape = function (Wr, ze, Gr, Yr) {
          var Kr,
            Zr = ze.length - 1,
            Jr;
          for (Jr = Wr, Kr = Zr; Kr >= 0; Kr -= 1)
            ze[Kr].ty === "tr"
              ? ((Jr = Gr[Kr].transform), this.renderShapeTransform(Wr, Jr))
              : ze[Kr].ty === "sh" ||
                ze[Kr].ty === "el" ||
                ze[Kr].ty === "rc" ||
                ze[Kr].ty === "sr"
              ? this.renderPath(ze[Kr], Gr[Kr])
              : ze[Kr].ty === "fl"
              ? this.renderFill(ze[Kr], Gr[Kr], Jr)
              : ze[Kr].ty === "st"
              ? this.renderStroke(ze[Kr], Gr[Kr], Jr)
              : ze[Kr].ty === "gf" || ze[Kr].ty === "gs"
              ? this.renderGradientFill(ze[Kr], Gr[Kr], Jr)
              : ze[Kr].ty === "gr"
              ? this.renderShape(Jr, ze[Kr].it, Gr[Kr].it)
              : ze[Kr].ty;
          Yr && this.drawLayer();
        }),
        (CVShapeElement.prototype.renderStyledShape = function (Wr, ze) {
          if (this._isFirstFrame || ze._mdf || Wr.transforms._mdf) {
            var Gr = Wr.trNodes,
              Yr = ze.paths,
              Kr,
              Zr,
              Jr,
              Qr = Yr._length;
            Gr.length = 0;
            var ei = Wr.transforms.finalTransform;
            for (Jr = 0; Jr < Qr; Jr += 1) {
              var ti = Yr.shapes[Jr];
              if (ti && ti.v) {
                for (Zr = ti._length, Kr = 1; Kr < Zr; Kr += 1)
                  Kr === 1 &&
                    Gr.push({
                      t: "m",
                      p: ei.applyToPointArray(ti.v[0][0], ti.v[0][1], 0),
                    }),
                    Gr.push({
                      t: "c",
                      pts: ei.applyToTriplePoints(
                        ti.o[Kr - 1],
                        ti.i[Kr],
                        ti.v[Kr]
                      ),
                    });
                Zr === 1 &&
                  Gr.push({
                    t: "m",
                    p: ei.applyToPointArray(ti.v[0][0], ti.v[0][1], 0),
                  }),
                  ti.c &&
                    Zr &&
                    (Gr.push({
                      t: "c",
                      pts: ei.applyToTriplePoints(
                        ti.o[Kr - 1],
                        ti.i[0],
                        ti.v[0]
                      ),
                    }),
                    Gr.push({
                      t: "z",
                    }));
              }
            }
            Wr.trNodes = Gr;
          }
        }),
        (CVShapeElement.prototype.renderPath = function (Wr, ze) {
          if (Wr.hd !== !0 && Wr._shouldRender) {
            var Gr,
              Yr = ze.styledShapes.length;
            for (Gr = 0; Gr < Yr; Gr += 1)
              this.renderStyledShape(ze.styledShapes[Gr], ze.sh);
          }
        }),
        (CVShapeElement.prototype.renderFill = function (Wr, ze, Gr) {
          var Yr = ze.style;
          (ze.c._mdf || this._isFirstFrame) &&
            (Yr.co =
              "rgb(" +
              bmFloor(ze.c.v[0]) +
              "," +
              bmFloor(ze.c.v[1]) +
              "," +
              bmFloor(ze.c.v[2]) +
              ")"),
            (ze.o._mdf || Gr._opMdf || this._isFirstFrame) &&
              (Yr.coOp = ze.o.v * Gr.opacity);
        }),
        (CVShapeElement.prototype.renderGradientFill = function (Wr, ze, Gr) {
          var Yr = ze.style,
            Kr;
          if (
            !Yr.grd ||
            ze.g._mdf ||
            ze.s._mdf ||
            ze.e._mdf ||
            (Wr.t !== 1 && (ze.h._mdf || ze.a._mdf))
          ) {
            var Zr = this.globalData.canvasContext,
              Jr = ze.s.v,
              Qr = ze.e.v;
            if (Wr.t === 1)
              Kr = Zr.createLinearGradient(Jr[0], Jr[1], Qr[0], Qr[1]);
            else {
              var ei = Math.sqrt(
                  Math.pow(Jr[0] - Qr[0], 2) + Math.pow(Jr[1] - Qr[1], 2)
                ),
                ti = Math.atan2(Qr[1] - Jr[1], Qr[0] - Jr[0]),
                ri = ze.h.v;
              ri >= 1 ? (ri = 0.99) : ri <= -1 && (ri = -0.99);
              var ni = ei * ri,
                ii = Math.cos(ti + ze.a.v) * ni + Jr[0],
                si = Math.sin(ti + ze.a.v) * ni + Jr[1];
              Kr = Zr.createRadialGradient(ii, si, 0, Jr[0], Jr[1], ei);
            }
            var li,
              oi = Wr.g.p,
              ui = ze.g.c,
              ai = 1;
            for (li = 0; li < oi; li += 1)
              ze.g._hasOpacity &&
                ze.g._collapsable &&
                (ai = ze.g.o[li * 2 + 1]),
                Kr.addColorStop(
                  ui[li * 4] / 100,
                  "rgba(" +
                    ui[li * 4 + 1] +
                    "," +
                    ui[li * 4 + 2] +
                    "," +
                    ui[li * 4 + 3] +
                    "," +
                    ai +
                    ")"
                );
            Yr.grd = Kr;
          }
          Yr.coOp = ze.o.v * Gr.opacity;
        }),
        (CVShapeElement.prototype.renderStroke = function (Wr, ze, Gr) {
          var Yr = ze.style,
            Kr = ze.d;
          Kr &&
            (Kr._mdf || this._isFirstFrame) &&
            ((Yr.da = Kr.dashArray), (Yr.do = Kr.dashoffset[0])),
            (ze.c._mdf || this._isFirstFrame) &&
              (Yr.co =
                "rgb(" +
                bmFloor(ze.c.v[0]) +
                "," +
                bmFloor(ze.c.v[1]) +
                "," +
                bmFloor(ze.c.v[2]) +
                ")"),
            (ze.o._mdf || Gr._opMdf || this._isFirstFrame) &&
              (Yr.coOp = ze.o.v * Gr.opacity),
            (ze.w._mdf || this._isFirstFrame) && (Yr.wi = ze.w.v);
        }),
        (CVShapeElement.prototype.destroy = function () {
          (this.shapesData = null),
            (this.globalData = null),
            (this.canvasContext = null),
            (this.stylesList.length = 0),
            (this.itemsData.length = 0);
        });
      function CVTextElement(Wr, ze, Gr) {
        (this.textSpans = []),
          (this.yOffset = 0),
          (this.fillColorAnim = !1),
          (this.strokeColorAnim = !1),
          (this.strokeWidthAnim = !1),
          (this.stroke = !1),
          (this.fill = !1),
          (this.justifyOffset = 0),
          (this.currentRender = null),
          (this.renderType = "canvas"),
          (this.values = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            sWidth: 0,
            fValue: "",
          }),
          this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
          ITextElement,
        ],
        CVTextElement
      ),
        (CVTextElement.prototype.tHelper =
          createTag("canvas").getContext("2d")),
        (CVTextElement.prototype.buildNewText = function () {
          var Wr = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(Wr.l ? Wr.l.length : 0);
          var ze = !1;
          Wr.fc
            ? ((ze = !0), (this.values.fill = this.buildColor(Wr.fc)))
            : (this.values.fill = "rgba(0,0,0,0)"),
            (this.fill = ze);
          var Gr = !1;
          Wr.sc &&
            ((Gr = !0),
            (this.values.stroke = this.buildColor(Wr.sc)),
            (this.values.sWidth = Wr.sw));
          var Yr = this.globalData.fontManager.getFontByName(Wr.f),
            Kr,
            Zr,
            Jr = Wr.l,
            Qr = this.mHelper;
          (this.stroke = Gr),
            (this.values.fValue =
              Wr.finalSize +
              "px " +
              this.globalData.fontManager.getFontByName(Wr.f).fFamily),
            (Zr = Wr.finalText.length);
          var ei,
            ti,
            ri,
            ni,
            ii,
            si,
            li,
            oi,
            ui,
            ai,
            hi = this.data.singleShape,
            ci = Wr.tr * 0.001 * Wr.finalSize,
            fi = 0,
            di = 0,
            pi = !0,
            mi = 0;
          for (Kr = 0; Kr < Zr; Kr += 1) {
            (ei = this.globalData.fontManager.getCharData(
              Wr.finalText[Kr],
              Yr.fStyle,
              this.globalData.fontManager.getFontByName(Wr.f).fFamily
            )),
              (ti = (ei && ei.data) || {}),
              Qr.reset(),
              hi &&
                Jr[Kr].n &&
                ((fi = -ci), (di += Wr.yOffset), (di += pi ? 1 : 0), (pi = !1)),
              (ii = ti.shapes ? ti.shapes[0].it : []),
              (li = ii.length),
              Qr.scale(Wr.finalSize / 100, Wr.finalSize / 100),
              hi &&
                this.applyTextPropertiesToMatrix(Wr, Qr, Jr[Kr].line, fi, di),
              (ui = createSizedArray(li - 1));
            var Si = 0;
            for (si = 0; si < li; si += 1)
              if (ii[si].ty === "sh") {
                for (
                  ni = ii[si].ks.k.i.length, oi = ii[si].ks.k, ai = [], ri = 1;
                  ri < ni;
                  ri += 1
                )
                  ri === 1 &&
                    ai.push(
                      Qr.applyToX(oi.v[0][0], oi.v[0][1], 0),
                      Qr.applyToY(oi.v[0][0], oi.v[0][1], 0)
                    ),
                    ai.push(
                      Qr.applyToX(oi.o[ri - 1][0], oi.o[ri - 1][1], 0),
                      Qr.applyToY(oi.o[ri - 1][0], oi.o[ri - 1][1], 0),
                      Qr.applyToX(oi.i[ri][0], oi.i[ri][1], 0),
                      Qr.applyToY(oi.i[ri][0], oi.i[ri][1], 0),
                      Qr.applyToX(oi.v[ri][0], oi.v[ri][1], 0),
                      Qr.applyToY(oi.v[ri][0], oi.v[ri][1], 0)
                    );
                ai.push(
                  Qr.applyToX(oi.o[ri - 1][0], oi.o[ri - 1][1], 0),
                  Qr.applyToY(oi.o[ri - 1][0], oi.o[ri - 1][1], 0),
                  Qr.applyToX(oi.i[0][0], oi.i[0][1], 0),
                  Qr.applyToY(oi.i[0][0], oi.i[0][1], 0),
                  Qr.applyToX(oi.v[0][0], oi.v[0][1], 0),
                  Qr.applyToY(oi.v[0][0], oi.v[0][1], 0)
                ),
                  (ui[Si] = ai),
                  (Si += 1);
              }
            hi && ((fi += Jr[Kr].l), (fi += ci)),
              this.textSpans[mi]
                ? (this.textSpans[mi].elem = ui)
                : (this.textSpans[mi] = {
                    elem: ui,
                  }),
              (mi += 1);
          }
        }),
        (CVTextElement.prototype.renderInnerContent = function () {
          this.validateText();
          var Wr = this.canvasContext;
          (Wr.font = this.values.fValue),
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape ||
              this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              );
          var ze,
            Gr,
            Yr,
            Kr,
            Zr,
            Jr,
            Qr = this.textAnimator.renderedLetters,
            ei = this.textProperty.currentData.l;
          Gr = ei.length;
          var ti,
            ri = null,
            ni = null,
            ii = null,
            si,
            li,
            oi = this.globalData.renderer;
          for (ze = 0; ze < Gr; ze += 1)
            if (!ei[ze].n) {
              if (
                ((ti = Qr[ze]),
                ti && (oi.save(), oi.ctxTransform(ti.p), oi.ctxOpacity(ti.o)),
                this.fill)
              ) {
                for (
                  ti && ti.fc
                    ? ri !== ti.fc && (oi.ctxFillStyle(ti.fc), (ri = ti.fc))
                    : ri !== this.values.fill &&
                      ((ri = this.values.fill),
                      oi.ctxFillStyle(this.values.fill)),
                    si = this.textSpans[ze].elem,
                    Kr = si.length,
                    this.globalData.canvasContext.beginPath(),
                    Yr = 0;
                  Yr < Kr;
                  Yr += 1
                )
                  for (
                    li = si[Yr],
                      Jr = li.length,
                      this.globalData.canvasContext.moveTo(li[0], li[1]),
                      Zr = 2;
                    Zr < Jr;
                    Zr += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      li[Zr],
                      li[Zr + 1],
                      li[Zr + 2],
                      li[Zr + 3],
                      li[Zr + 4],
                      li[Zr + 5]
                    );
                this.globalData.canvasContext.closePath(), oi.ctxFill();
              }
              if (this.stroke) {
                for (
                  ti && ti.sw
                    ? ii !== ti.sw && ((ii = ti.sw), oi.ctxLineWidth(ti.sw))
                    : ii !== this.values.sWidth &&
                      ((ii = this.values.sWidth),
                      oi.ctxLineWidth(this.values.sWidth)),
                    ti && ti.sc
                      ? ni !== ti.sc && ((ni = ti.sc), oi.ctxStrokeStyle(ti.sc))
                      : ni !== this.values.stroke &&
                        ((ni = this.values.stroke),
                        oi.ctxStrokeStyle(this.values.stroke)),
                    si = this.textSpans[ze].elem,
                    Kr = si.length,
                    this.globalData.canvasContext.beginPath(),
                    Yr = 0;
                  Yr < Kr;
                  Yr += 1
                )
                  for (
                    li = si[Yr],
                      Jr = li.length,
                      this.globalData.canvasContext.moveTo(li[0], li[1]),
                      Zr = 2;
                    Zr < Jr;
                    Zr += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      li[Zr],
                      li[Zr + 1],
                      li[Zr + 2],
                      li[Zr + 3],
                      li[Zr + 4],
                      li[Zr + 5]
                    );
                this.globalData.canvasContext.closePath(), oi.ctxStroke();
              }
              ti && this.globalData.renderer.restore();
            }
        });
      function CVImageElement(Wr, ze, Gr) {
        (this.assetData = ze.getAssetData(Wr.refId)),
          (this.img = ze.imageLoader.getAsset(this.assetData)),
          this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVImageElement
      ),
        (CVImageElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVImageElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVImageElement.prototype.createContent = function () {
          if (
            this.img.width &&
            (this.assetData.w !== this.img.width ||
              this.assetData.h !== this.img.height)
          ) {
            var Wr = createTag("canvas");
            (Wr.width = this.assetData.w), (Wr.height = this.assetData.h);
            var ze = Wr.getContext("2d"),
              Gr = this.img.width,
              Yr = this.img.height,
              Kr = Gr / Yr,
              Zr = this.assetData.w / this.assetData.h,
              Jr,
              Qr,
              ei =
                this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio;
            (Kr > Zr && ei === "xMidYMid slice") ||
            (Kr < Zr && ei !== "xMidYMid slice")
              ? ((Qr = Yr), (Jr = Qr * Zr))
              : ((Jr = Gr), (Qr = Jr / Zr)),
              ze.drawImage(
                this.img,
                (Gr - Jr) / 2,
                (Yr - Qr) / 2,
                Jr,
                Qr,
                0,
                0,
                this.assetData.w,
                this.assetData.h
              ),
              (this.img = Wr);
          }
        }),
        (CVImageElement.prototype.renderInnerContent = function () {
          this.canvasContext.drawImage(this.img, 0, 0);
        }),
        (CVImageElement.prototype.destroy = function () {
          this.img = null;
        });
      function CVSolidElement(Wr, ze, Gr) {
        this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVSolidElement
      ),
        (CVSolidElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVSolidElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVSolidElement.prototype.renderInnerContent = function () {
          this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(
              0,
              0,
              this.data.sw,
              this.data.sh
            );
        });
      function CanvasRendererBase() {}
      extendPrototype([BaseRenderer], CanvasRendererBase),
        (CanvasRendererBase.prototype.createShape = function (Wr) {
          return new CVShapeElement(Wr, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createText = function (Wr) {
          return new CVTextElement(Wr, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createImage = function (Wr) {
          return new CVImageElement(Wr, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createSolid = function (Wr) {
          return new CVSolidElement(Wr, this.globalData, this);
        }),
        (CanvasRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (CanvasRendererBase.prototype.ctxTransform = function (Wr) {
          (Wr[0] === 1 &&
            Wr[1] === 0 &&
            Wr[4] === 0 &&
            Wr[5] === 1 &&
            Wr[12] === 0 &&
            Wr[13] === 0) ||
            this.canvasContext.transform(
              Wr[0],
              Wr[1],
              Wr[4],
              Wr[5],
              Wr[12],
              Wr[13]
            );
        }),
        (CanvasRendererBase.prototype.ctxOpacity = function (Wr) {
          this.canvasContext.globalAlpha *= Wr < 0 ? 0 : Wr;
        }),
        (CanvasRendererBase.prototype.ctxFillStyle = function (Wr) {
          this.canvasContext.fillStyle = Wr;
        }),
        (CanvasRendererBase.prototype.ctxStrokeStyle = function (Wr) {
          this.canvasContext.strokeStyle = Wr;
        }),
        (CanvasRendererBase.prototype.ctxLineWidth = function (Wr) {
          this.canvasContext.lineWidth = Wr;
        }),
        (CanvasRendererBase.prototype.ctxLineCap = function (Wr) {
          this.canvasContext.lineCap = Wr;
        }),
        (CanvasRendererBase.prototype.ctxLineJoin = function (Wr) {
          this.canvasContext.lineJoin = Wr;
        }),
        (CanvasRendererBase.prototype.ctxMiterLimit = function (Wr) {
          this.canvasContext.miterLimit = Wr;
        }),
        (CanvasRendererBase.prototype.ctxFill = function (Wr) {
          this.canvasContext.fill(Wr);
        }),
        (CanvasRendererBase.prototype.ctxFillRect = function (Wr, ze, Gr, Yr) {
          this.canvasContext.fillRect(Wr, ze, Gr, Yr);
        }),
        (CanvasRendererBase.prototype.ctxStroke = function () {
          this.canvasContext.stroke();
        }),
        (CanvasRendererBase.prototype.reset = function () {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          this.contextData.reset();
        }),
        (CanvasRendererBase.prototype.save = function () {
          this.canvasContext.save();
        }),
        (CanvasRendererBase.prototype.restore = function (Wr) {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          Wr && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(Wr);
        }),
        (CanvasRendererBase.prototype.configAnimation = function (Wr) {
          if (this.animationItem.wrapper) {
            this.animationItem.container = createTag("canvas");
            var ze = this.animationItem.container.style;
            (ze.width = "100%"), (ze.height = "100%");
            var Gr = "0px 0px 0px";
            (ze.transformOrigin = Gr),
              (ze.mozTransformOrigin = Gr),
              (ze.webkitTransformOrigin = Gr),
              (ze["-webkit-transform"] = Gr),
              (ze.contentVisibility = this.renderConfig.contentVisibility),
              this.animationItem.wrapper.appendChild(
                this.animationItem.container
              ),
              (this.canvasContext =
                this.animationItem.container.getContext("2d")),
              this.renderConfig.className &&
                this.animationItem.container.setAttribute(
                  "class",
                  this.renderConfig.className
                ),
              this.renderConfig.id &&
                this.animationItem.container.setAttribute(
                  "id",
                  this.renderConfig.id
                );
          } else this.canvasContext = this.renderConfig.context;
          this.contextData.setContext(this.canvasContext),
            (this.data = Wr),
            (this.layers = Wr.layers),
            (this.transformCanvas = {
              w: Wr.w,
              h: Wr.h,
              sx: 0,
              sy: 0,
              tx: 0,
              ty: 0,
            }),
            this.setupGlobalData(Wr, document.body),
            (this.globalData.canvasContext = this.canvasContext),
            (this.globalData.renderer = this),
            (this.globalData.isDashed = !1),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.globalData.transformCanvas = this.transformCanvas),
            (this.elements = createSizedArray(Wr.layers.length)),
            this.updateContainerSize();
        }),
        (CanvasRendererBase.prototype.updateContainerSize = function (Wr, ze) {
          this.reset();
          var Gr, Yr;
          Wr
            ? ((Gr = Wr),
              (Yr = ze),
              (this.canvasContext.canvas.width = Gr),
              (this.canvasContext.canvas.height = Yr))
            : (this.animationItem.wrapper && this.animationItem.container
                ? ((Gr = this.animationItem.wrapper.offsetWidth),
                  (Yr = this.animationItem.wrapper.offsetHeight))
                : ((Gr = this.canvasContext.canvas.width),
                  (Yr = this.canvasContext.canvas.height)),
              (this.canvasContext.canvas.width = Gr * this.renderConfig.dpr),
              (this.canvasContext.canvas.height = Yr * this.renderConfig.dpr));
          var Kr, Zr;
          if (
            this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 ||
            this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1
          ) {
            var Jr = this.renderConfig.preserveAspectRatio.split(" "),
              Qr = Jr[1] || "meet",
              ei = Jr[0] || "xMidYMid",
              ti = ei.substr(0, 4),
              ri = ei.substr(4);
            (Kr = Gr / Yr),
              (Zr = this.transformCanvas.w / this.transformCanvas.h),
              (Zr > Kr && Qr === "meet") || (Zr < Kr && Qr === "slice")
                ? ((this.transformCanvas.sx =
                    Gr / (this.transformCanvas.w / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    Gr / (this.transformCanvas.w / this.renderConfig.dpr)))
                : ((this.transformCanvas.sx =
                    Yr / (this.transformCanvas.h / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    Yr / (this.transformCanvas.h / this.renderConfig.dpr))),
              ti === "xMid" &&
              ((Zr < Kr && Qr === "meet") || (Zr > Kr && Qr === "slice"))
                ? (this.transformCanvas.tx =
                    ((Gr -
                      this.transformCanvas.w * (Yr / this.transformCanvas.h)) /
                      2) *
                    this.renderConfig.dpr)
                : ti === "xMax" &&
                  ((Zr < Kr && Qr === "meet") || (Zr > Kr && Qr === "slice"))
                ? (this.transformCanvas.tx =
                    (Gr -
                      this.transformCanvas.w * (Yr / this.transformCanvas.h)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.tx = 0),
              ri === "YMid" &&
              ((Zr > Kr && Qr === "meet") || (Zr < Kr && Qr === "slice"))
                ? (this.transformCanvas.ty =
                    ((Yr -
                      this.transformCanvas.h * (Gr / this.transformCanvas.w)) /
                      2) *
                    this.renderConfig.dpr)
                : ri === "YMax" &&
                  ((Zr > Kr && Qr === "meet") || (Zr < Kr && Qr === "slice"))
                ? (this.transformCanvas.ty =
                    (Yr -
                      this.transformCanvas.h * (Gr / this.transformCanvas.w)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.ty = 0);
          } else
            this.renderConfig.preserveAspectRatio === "none"
              ? ((this.transformCanvas.sx =
                  Gr / (this.transformCanvas.w / this.renderConfig.dpr)),
                (this.transformCanvas.sy =
                  Yr / (this.transformCanvas.h / this.renderConfig.dpr)),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0))
              : ((this.transformCanvas.sx = this.renderConfig.dpr),
                (this.transformCanvas.sy = this.renderConfig.dpr),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0));
          (this.transformCanvas.props = [
            this.transformCanvas.sx,
            0,
            0,
            0,
            0,
            this.transformCanvas.sy,
            0,
            0,
            0,
            0,
            1,
            0,
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            0,
            1,
          ]),
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(
              0,
              0,
              this.transformCanvas.w,
              this.transformCanvas.h
            ),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0);
        }),
        (CanvasRendererBase.prototype.destroy = function () {
          this.renderConfig.clearCanvas &&
            this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = "");
          var Wr,
            ze = this.layers ? this.layers.length : 0;
          for (Wr = ze - 1; Wr >= 0; Wr -= 1)
            this.elements[Wr] &&
              this.elements[Wr].destroy &&
              this.elements[Wr].destroy();
          (this.elements.length = 0),
            (this.globalData.canvasContext = null),
            (this.animationItem.container = null),
            (this.destroyed = !0);
        }),
        (CanvasRendererBase.prototype.renderFrame = function (Wr, ze) {
          if (
            !(
              (this.renderedFrame === Wr &&
                this.renderConfig.clearCanvas === !0 &&
                !ze) ||
              this.destroyed ||
              Wr === -1
            )
          ) {
            (this.renderedFrame = Wr),
              (this.globalData.frameNum =
                Wr - this.animationItem._isFirstFrame),
              (this.globalData.frameId += 1),
              (this.globalData._mdf = !this.renderConfig.clearCanvas || ze),
              (this.globalData.projectInterface.currentFrame = Wr);
            var Gr,
              Yr = this.layers.length;
            for (
              this.completeLayers || this.checkLayers(Wr), Gr = Yr - 1;
              Gr >= 0;
              Gr -= 1
            )
              (this.completeLayers || this.elements[Gr]) &&
                this.elements[Gr].prepareFrame(Wr - this.layers[Gr].st);
            if (this.globalData._mdf) {
              for (
                this.renderConfig.clearCanvas === !0
                  ? this.canvasContext.clearRect(
                      0,
                      0,
                      this.transformCanvas.w,
                      this.transformCanvas.h
                    )
                  : this.save(),
                  Gr = Yr - 1;
                Gr >= 0;
                Gr -= 1
              )
                (this.completeLayers || this.elements[Gr]) &&
                  this.elements[Gr].renderFrame();
              this.renderConfig.clearCanvas !== !0 && this.restore();
            }
          }
        }),
        (CanvasRendererBase.prototype.buildItem = function (Wr) {
          var ze = this.elements;
          if (!(ze[Wr] || this.layers[Wr].ty === 99)) {
            var Gr = this.createItem(this.layers[Wr], this, this.globalData);
            (ze[Wr] = Gr), Gr.initExpressions();
          }
        }),
        (CanvasRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var Wr = this.pendingElements.pop();
            Wr.checkParenting();
          }
        }),
        (CanvasRendererBase.prototype.hide = function () {
          this.animationItem.container.style.display = "none";
        }),
        (CanvasRendererBase.prototype.show = function () {
          this.animationItem.container.style.display = "block";
        });
      function CanvasContext() {
        (this.opacity = -1),
          (this.transform = createTypedArray("float32", 16)),
          (this.fillStyle = ""),
          (this.strokeStyle = ""),
          (this.lineWidth = ""),
          (this.lineCap = ""),
          (this.lineJoin = ""),
          (this.miterLimit = ""),
          (this.id = Math.random());
      }
      function CVContextData() {
        (this.stack = []), (this.cArrPos = 0), (this.cTr = new Matrix());
        var Wr,
          ze = 15;
        for (Wr = 0; Wr < ze; Wr += 1) {
          var Gr = new CanvasContext();
          this.stack[Wr] = Gr;
        }
        (this._length = ze),
          (this.nativeContext = null),
          (this.transformMat = new Matrix()),
          (this.currentOpacity = 1),
          (this.currentFillStyle = ""),
          (this.appliedFillStyle = ""),
          (this.currentStrokeStyle = ""),
          (this.appliedStrokeStyle = ""),
          (this.currentLineWidth = ""),
          (this.appliedLineWidth = ""),
          (this.currentLineCap = ""),
          (this.appliedLineCap = ""),
          (this.currentLineJoin = ""),
          (this.appliedLineJoin = ""),
          (this.appliedMiterLimit = ""),
          (this.currentMiterLimit = "");
      }
      (CVContextData.prototype.duplicate = function () {
        var Wr = this._length * 2,
          ze = 0;
        for (ze = this._length; ze < Wr; ze += 1)
          this.stack[ze] = new CanvasContext();
        this._length = Wr;
      }),
        (CVContextData.prototype.reset = function () {
          (this.cArrPos = 0),
            this.cTr.reset(),
            (this.stack[this.cArrPos].opacity = 1);
        }),
        (CVContextData.prototype.restore = function (Wr) {
          this.cArrPos -= 1;
          var ze = this.stack[this.cArrPos],
            Gr = ze.transform,
            Yr,
            Kr = this.cTr.props;
          for (Yr = 0; Yr < 16; Yr += 1) Kr[Yr] = Gr[Yr];
          if (Wr) {
            this.nativeContext.restore();
            var Zr = this.stack[this.cArrPos + 1];
            (this.appliedFillStyle = Zr.fillStyle),
              (this.appliedStrokeStyle = Zr.strokeStyle),
              (this.appliedLineWidth = Zr.lineWidth),
              (this.appliedLineCap = Zr.lineCap),
              (this.appliedLineJoin = Zr.lineJoin),
              (this.appliedMiterLimit = Zr.miterLimit);
          }
          this.nativeContext.setTransform(
            Gr[0],
            Gr[1],
            Gr[4],
            Gr[5],
            Gr[12],
            Gr[13]
          ),
            (Wr || (ze.opacity !== -1 && this.currentOpacity !== ze.opacity)) &&
              ((this.nativeContext.globalAlpha = ze.opacity),
              (this.currentOpacity = ze.opacity)),
            (this.currentFillStyle = ze.fillStyle),
            (this.currentStrokeStyle = ze.strokeStyle),
            (this.currentLineWidth = ze.lineWidth),
            (this.currentLineCap = ze.lineCap),
            (this.currentLineJoin = ze.lineJoin),
            (this.currentMiterLimit = ze.miterLimit);
        }),
        (CVContextData.prototype.save = function (Wr) {
          Wr && this.nativeContext.save();
          var ze = this.cTr.props;
          this._length <= this.cArrPos && this.duplicate();
          var Gr = this.stack[this.cArrPos],
            Yr;
          for (Yr = 0; Yr < 16; Yr += 1) Gr.transform[Yr] = ze[Yr];
          this.cArrPos += 1;
          var Kr = this.stack[this.cArrPos];
          (Kr.opacity = Gr.opacity),
            (Kr.fillStyle = Gr.fillStyle),
            (Kr.strokeStyle = Gr.strokeStyle),
            (Kr.lineWidth = Gr.lineWidth),
            (Kr.lineCap = Gr.lineCap),
            (Kr.lineJoin = Gr.lineJoin),
            (Kr.miterLimit = Gr.miterLimit);
        }),
        (CVContextData.prototype.setOpacity = function (Wr) {
          this.stack[this.cArrPos].opacity = Wr;
        }),
        (CVContextData.prototype.setContext = function (Wr) {
          this.nativeContext = Wr;
        }),
        (CVContextData.prototype.fillStyle = function (Wr) {
          this.stack[this.cArrPos].fillStyle !== Wr &&
            ((this.currentFillStyle = Wr),
            (this.stack[this.cArrPos].fillStyle = Wr));
        }),
        (CVContextData.prototype.strokeStyle = function (Wr) {
          this.stack[this.cArrPos].strokeStyle !== Wr &&
            ((this.currentStrokeStyle = Wr),
            (this.stack[this.cArrPos].strokeStyle = Wr));
        }),
        (CVContextData.prototype.lineWidth = function (Wr) {
          this.stack[this.cArrPos].lineWidth !== Wr &&
            ((this.currentLineWidth = Wr),
            (this.stack[this.cArrPos].lineWidth = Wr));
        }),
        (CVContextData.prototype.lineCap = function (Wr) {
          this.stack[this.cArrPos].lineCap !== Wr &&
            ((this.currentLineCap = Wr),
            (this.stack[this.cArrPos].lineCap = Wr));
        }),
        (CVContextData.prototype.lineJoin = function (Wr) {
          this.stack[this.cArrPos].lineJoin !== Wr &&
            ((this.currentLineJoin = Wr),
            (this.stack[this.cArrPos].lineJoin = Wr));
        }),
        (CVContextData.prototype.miterLimit = function (Wr) {
          this.stack[this.cArrPos].miterLimit !== Wr &&
            ((this.currentMiterLimit = Wr),
            (this.stack[this.cArrPos].miterLimit = Wr));
        }),
        (CVContextData.prototype.transform = function (Wr) {
          this.transformMat.cloneFromProps(Wr);
          var ze = this.cTr;
          this.transformMat.multiply(ze),
            ze.cloneFromProps(this.transformMat.props);
          var Gr = ze.props;
          this.nativeContext.setTransform(
            Gr[0],
            Gr[1],
            Gr[4],
            Gr[5],
            Gr[12],
            Gr[13]
          );
        }),
        (CVContextData.prototype.opacity = function (Wr) {
          var ze = this.stack[this.cArrPos].opacity;
          (ze *= Wr < 0 ? 0 : Wr),
            this.stack[this.cArrPos].opacity !== ze &&
              (this.currentOpacity !== Wr &&
                ((this.nativeContext.globalAlpha = Wr),
                (this.currentOpacity = Wr)),
              (this.stack[this.cArrPos].opacity = ze));
        }),
        (CVContextData.prototype.fill = function (Wr) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fill(Wr);
        }),
        (CVContextData.prototype.fillRect = function (Wr, ze, Gr, Yr) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fillRect(Wr, ze, Gr, Yr);
        }),
        (CVContextData.prototype.stroke = function () {
          this.appliedStrokeStyle !== this.currentStrokeStyle &&
            ((this.appliedStrokeStyle = this.currentStrokeStyle),
            (this.nativeContext.strokeStyle = this.appliedStrokeStyle)),
            this.appliedLineWidth !== this.currentLineWidth &&
              ((this.appliedLineWidth = this.currentLineWidth),
              (this.nativeContext.lineWidth = this.appliedLineWidth)),
            this.appliedLineCap !== this.currentLineCap &&
              ((this.appliedLineCap = this.currentLineCap),
              (this.nativeContext.lineCap = this.appliedLineCap)),
            this.appliedLineJoin !== this.currentLineJoin &&
              ((this.appliedLineJoin = this.currentLineJoin),
              (this.nativeContext.lineJoin = this.appliedLineJoin)),
            this.appliedMiterLimit !== this.currentMiterLimit &&
              ((this.appliedMiterLimit = this.currentMiterLimit),
              (this.nativeContext.miterLimit = this.appliedMiterLimit)),
            this.nativeContext.stroke();
        });
      function CVCompElement(Wr, ze, Gr) {
        (this.completeLayers = !1),
          (this.layers = Wr.layers),
          (this.pendingElements = []),
          (this.elements = createSizedArray(this.layers.length)),
          this.initElement(Wr, ze, Gr),
          (this.tm = Wr.tm
            ? PropertyFactory.getProp(this, Wr.tm, 0, ze.frameRate, this)
            : {
                _placeholder: !0,
              });
      }
      extendPrototype(
        [CanvasRendererBase, ICompElement, CVBaseElement],
        CVCompElement
      ),
        (CVCompElement.prototype.renderInnerContent = function () {
          var Wr = this.canvasContext;
          Wr.beginPath(),
            Wr.moveTo(0, 0),
            Wr.lineTo(this.data.w, 0),
            Wr.lineTo(this.data.w, this.data.h),
            Wr.lineTo(0, this.data.h),
            Wr.lineTo(0, 0),
            Wr.clip();
          var ze,
            Gr = this.layers.length;
          for (ze = Gr - 1; ze >= 0; ze -= 1)
            (this.completeLayers || this.elements[ze]) &&
              this.elements[ze].renderFrame();
        }),
        (CVCompElement.prototype.destroy = function () {
          var Wr,
            ze = this.layers.length;
          for (Wr = ze - 1; Wr >= 0; Wr -= 1)
            this.elements[Wr] && this.elements[Wr].destroy();
          (this.layers = null), (this.elements = null);
        }),
        (CVCompElement.prototype.createComp = function (Wr) {
          return new CVCompElement(Wr, this.globalData, this);
        });
      function CanvasRenderer(Wr, ze) {
        (this.animationItem = Wr),
          (this.renderConfig = {
            clearCanvas: ze && ze.clearCanvas !== void 0 ? ze.clearCanvas : !0,
            context: (ze && ze.context) || null,
            progressiveLoad: (ze && ze.progressiveLoad) || !1,
            preserveAspectRatio:
              (ze && ze.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (ze && ze.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (ze && ze.contentVisibility) || "visible",
            className: (ze && ze.className) || "",
            id: (ze && ze.id) || "",
            runExpressions:
              !ze || ze.runExpressions === void 0 || ze.runExpressions,
          }),
          (this.renderConfig.dpr = (ze && ze.dpr) || 1),
          this.animationItem.wrapper &&
            (this.renderConfig.dpr =
              (ze && ze.dpr) || window.devicePixelRatio || 1),
          (this.renderedFrame = -1),
          (this.globalData = {
            frameNum: -1,
            _mdf: !1,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1,
          }),
          (this.contextData = new CVContextData()),
          (this.elements = []),
          (this.pendingElements = []),
          (this.transformMat = new Matrix()),
          (this.completeLayers = !1),
          (this.rendererType = "canvas"),
          this.renderConfig.clearCanvas &&
            ((this.ctxTransform = this.contextData.transform.bind(
              this.contextData
            )),
            (this.ctxOpacity = this.contextData.opacity.bind(this.contextData)),
            (this.ctxFillStyle = this.contextData.fillStyle.bind(
              this.contextData
            )),
            (this.ctxStrokeStyle = this.contextData.strokeStyle.bind(
              this.contextData
            )),
            (this.ctxLineWidth = this.contextData.lineWidth.bind(
              this.contextData
            )),
            (this.ctxLineCap = this.contextData.lineCap.bind(this.contextData)),
            (this.ctxLineJoin = this.contextData.lineJoin.bind(
              this.contextData
            )),
            (this.ctxMiterLimit = this.contextData.miterLimit.bind(
              this.contextData
            )),
            (this.ctxFill = this.contextData.fill.bind(this.contextData)),
            (this.ctxFillRect = this.contextData.fillRect.bind(
              this.contextData
            )),
            (this.ctxStroke = this.contextData.stroke.bind(this.contextData)),
            (this.save = this.contextData.save.bind(this.contextData)));
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer),
        (CanvasRenderer.prototype.createComp = function (Wr) {
          return new CVCompElement(Wr, this.globalData, this);
        });
      function HBaseElement() {}
      (HBaseElement.prototype = {
        checkBlendMode: function () {},
        initRendererElement: function () {
          (this.baseElement = createTag(this.data.tg || "div")),
            this.data.hasMask
              ? ((this.svgElement = createNS("svg")),
                (this.layerElement = createNS("g")),
                (this.maskedElement = this.layerElement),
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement))
              : (this.layerElement = this.baseElement),
            styleDiv(this.baseElement);
        },
        createContainerElements: function () {
          (this.renderableEffectsManager = new CVEffects(this)),
            (this.transformedElement = this.baseElement),
            (this.maskedElement = this.layerElement),
            this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.bm !== 0 && this.setBlendMode();
        },
        renderElement: function () {
          var ze = this.transformedElement ? this.transformedElement.style : {};
          if (this.finalTransform._matMdf) {
            var Gr = this.finalTransform.mat.toCSS();
            (ze.transform = Gr), (ze.webkitTransform = Gr);
          }
          this.finalTransform._opMdf &&
            (ze.opacity = this.finalTransform.mProp.o.v);
        },
        renderFrame: function () {
          this.data.hd ||
            this.hidden ||
            (this.renderTransform(),
            this.renderRenderable(),
            this.renderElement(),
            this.renderInnerContent(),
            this._isFirstFrame && (this._isFirstFrame = !1));
        },
        destroy: function () {
          (this.layerElement = null),
            (this.transformedElement = null),
            this.matteElement && (this.matteElement = null),
            this.maskManager &&
              (this.maskManager.destroy(), (this.maskManager = null));
        },
        createRenderableComponents: function () {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function () {},
        setMatte: function () {},
      }),
        (HBaseElement.prototype.getBaseElement =
          SVGBaseElement.prototype.getBaseElement),
        (HBaseElement.prototype.destroyBaseElement =
          HBaseElement.prototype.destroy),
        (HBaseElement.prototype.buildElementParenting =
          BaseRenderer.prototype.buildElementParenting);
      function HSolidElement(Wr, ze, Gr) {
        this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        HSolidElement
      ),
        (HSolidElement.prototype.createContent = function () {
          var Wr;
          this.data.hasMask
            ? ((Wr = createNS("rect")),
              Wr.setAttribute("width", this.data.sw),
              Wr.setAttribute("height", this.data.sh),
              Wr.setAttribute("fill", this.data.sc),
              this.svgElement.setAttribute("width", this.data.sw),
              this.svgElement.setAttribute("height", this.data.sh))
            : ((Wr = createTag("div")),
              (Wr.style.width = this.data.sw + "px"),
              (Wr.style.height = this.data.sh + "px"),
              (Wr.style.backgroundColor = this.data.sc)),
            this.layerElement.appendChild(Wr);
        });
      function HShapeElement(Wr, ze, Gr) {
        (this.shapes = []),
          (this.shapesData = Wr.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          (this.shapesContainer = createNS("g")),
          this.initElement(Wr, ze, Gr),
          (this.prevViewData = []),
          (this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0,
          });
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HSolidElement,
          SVGShapeElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HShapeElement
      ),
        (HShapeElement.prototype._renderShapeFrame =
          HShapeElement.prototype.renderInnerContent),
        (HShapeElement.prototype.createContent = function () {
          var Wr;
          if (((this.baseElement.style.fontSize = 0), this.data.hasMask))
            this.layerElement.appendChild(this.shapesContainer),
              (Wr = this.svgElement);
          else {
            Wr = createNS("svg");
            var ze = this.comp.data ? this.comp.data : this.globalData.compSize;
            Wr.setAttribute("width", ze.w),
              Wr.setAttribute("height", ze.h),
              Wr.appendChild(this.shapesContainer),
              this.layerElement.appendChild(Wr);
          }
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.shapesContainer,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes(),
            (this.shapeCont = Wr);
        }),
        (HShapeElement.prototype.getTransformedPoint = function (Wr, ze) {
          var Gr,
            Yr = Wr.length;
          for (Gr = 0; Gr < Yr; Gr += 1)
            ze = Wr[Gr].mProps.v.applyToPointArray(ze[0], ze[1], 0);
          return ze;
        }),
        (HShapeElement.prototype.calculateShapeBoundingBox = function (Wr, ze) {
          var Gr = Wr.sh.v,
            Yr = Wr.transformers,
            Kr,
            Zr = Gr._length,
            Jr,
            Qr,
            ei,
            ti;
          if (!(Zr <= 1)) {
            for (Kr = 0; Kr < Zr - 1; Kr += 1)
              (Jr = this.getTransformedPoint(Yr, Gr.v[Kr])),
                (Qr = this.getTransformedPoint(Yr, Gr.o[Kr])),
                (ei = this.getTransformedPoint(Yr, Gr.i[Kr + 1])),
                (ti = this.getTransformedPoint(Yr, Gr.v[Kr + 1])),
                this.checkBounds(Jr, Qr, ei, ti, ze);
            Gr.c &&
              ((Jr = this.getTransformedPoint(Yr, Gr.v[Kr])),
              (Qr = this.getTransformedPoint(Yr, Gr.o[Kr])),
              (ei = this.getTransformedPoint(Yr, Gr.i[0])),
              (ti = this.getTransformedPoint(Yr, Gr.v[0])),
              this.checkBounds(Jr, Qr, ei, ti, ze));
          }
        }),
        (HShapeElement.prototype.checkBounds = function (Wr, ze, Gr, Yr, Kr) {
          this.getBoundsOfCurve(Wr, ze, Gr, Yr);
          var Zr = this.shapeBoundingBox;
          (Kr.x = bmMin(Zr.left, Kr.x)),
            (Kr.xMax = bmMax(Zr.right, Kr.xMax)),
            (Kr.y = bmMin(Zr.top, Kr.y)),
            (Kr.yMax = bmMax(Zr.bottom, Kr.yMax));
        }),
        (HShapeElement.prototype.shapeBoundingBox = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
        }),
        (HShapeElement.prototype.tempBoundingBox = {
          x: 0,
          xMax: 0,
          y: 0,
          yMax: 0,
          width: 0,
          height: 0,
        }),
        (HShapeElement.prototype.getBoundsOfCurve = function (Wr, ze, Gr, Yr) {
          for (
            var Kr = [
                [Wr[0], Yr[0]],
                [Wr[1], Yr[1]],
              ],
              Zr,
              Jr,
              Qr,
              ei,
              ti,
              ri,
              ni,
              ii = 0;
            ii < 2;
            ++ii
          )
            (Jr = 6 * Wr[ii] - 12 * ze[ii] + 6 * Gr[ii]),
              (Zr = -3 * Wr[ii] + 9 * ze[ii] - 9 * Gr[ii] + 3 * Yr[ii]),
              (Qr = 3 * ze[ii] - 3 * Wr[ii]),
              (Jr |= 0),
              (Zr |= 0),
              (Qr |= 0),
              (Zr === 0 && Jr === 0) ||
                (Zr === 0
                  ? ((ei = -Qr / Jr),
                    ei > 0 &&
                      ei < 1 &&
                      Kr[ii].push(this.calculateF(ei, Wr, ze, Gr, Yr, ii)))
                  : ((ti = Jr * Jr - 4 * Qr * Zr),
                    ti >= 0 &&
                      ((ri = (-Jr + bmSqrt(ti)) / (2 * Zr)),
                      ri > 0 &&
                        ri < 1 &&
                        Kr[ii].push(this.calculateF(ri, Wr, ze, Gr, Yr, ii)),
                      (ni = (-Jr - bmSqrt(ti)) / (2 * Zr)),
                      ni > 0 &&
                        ni < 1 &&
                        Kr[ii].push(this.calculateF(ni, Wr, ze, Gr, Yr, ii)))));
          (this.shapeBoundingBox.left = bmMin.apply(null, Kr[0])),
            (this.shapeBoundingBox.top = bmMin.apply(null, Kr[1])),
            (this.shapeBoundingBox.right = bmMax.apply(null, Kr[0])),
            (this.shapeBoundingBox.bottom = bmMax.apply(null, Kr[1]));
        }),
        (HShapeElement.prototype.calculateF = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr,
          Zr
        ) {
          return (
            bmPow(1 - Wr, 3) * ze[Zr] +
            3 * bmPow(1 - Wr, 2) * Wr * Gr[Zr] +
            3 * (1 - Wr) * bmPow(Wr, 2) * Yr[Zr] +
            bmPow(Wr, 3) * Kr[Zr]
          );
        }),
        (HShapeElement.prototype.calculateBoundingBox = function (Wr, ze) {
          var Gr,
            Yr = Wr.length;
          for (Gr = 0; Gr < Yr; Gr += 1)
            Wr[Gr] && Wr[Gr].sh
              ? this.calculateShapeBoundingBox(Wr[Gr], ze)
              : Wr[Gr] && Wr[Gr].it
              ? this.calculateBoundingBox(Wr[Gr].it, ze)
              : Wr[Gr] &&
                Wr[Gr].style &&
                Wr[Gr].w &&
                this.expandStrokeBoundingBox(Wr[Gr].w, ze);
        }),
        (HShapeElement.prototype.expandStrokeBoundingBox = function (Wr, ze) {
          var Gr = 0;
          if (Wr.keyframes) {
            for (var Yr = 0; Yr < Wr.keyframes.length; Yr += 1) {
              var Kr = Wr.keyframes[Yr].s;
              Kr > Gr && (Gr = Kr);
            }
            Gr *= Wr.mult;
          } else Gr = Wr.v * Wr.mult;
          (ze.x -= Gr), (ze.xMax += Gr), (ze.y -= Gr), (ze.yMax += Gr);
        }),
        (HShapeElement.prototype.currentBoxContains = function (Wr) {
          return (
            this.currentBBox.x <= Wr.x &&
            this.currentBBox.y <= Wr.y &&
            this.currentBBox.width + this.currentBBox.x >= Wr.x + Wr.width &&
            this.currentBBox.height + this.currentBBox.y >= Wr.y + Wr.height
          );
        }),
        (HShapeElement.prototype.renderInnerContent = function () {
          if (
            (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf))
          ) {
            var Wr = this.tempBoundingBox,
              ze = 999999;
            if (
              ((Wr.x = ze),
              (Wr.xMax = -ze),
              (Wr.y = ze),
              (Wr.yMax = -ze),
              this.calculateBoundingBox(this.itemsData, Wr),
              (Wr.width = Wr.xMax < Wr.x ? 0 : Wr.xMax - Wr.x),
              (Wr.height = Wr.yMax < Wr.y ? 0 : Wr.yMax - Wr.y),
              this.currentBoxContains(Wr))
            )
              return;
            var Gr = !1;
            if (
              (this.currentBBox.w !== Wr.width &&
                ((this.currentBBox.w = Wr.width),
                this.shapeCont.setAttribute("width", Wr.width),
                (Gr = !0)),
              this.currentBBox.h !== Wr.height &&
                ((this.currentBBox.h = Wr.height),
                this.shapeCont.setAttribute("height", Wr.height),
                (Gr = !0)),
              Gr || this.currentBBox.x !== Wr.x || this.currentBBox.y !== Wr.y)
            ) {
              (this.currentBBox.w = Wr.width),
                (this.currentBBox.h = Wr.height),
                (this.currentBBox.x = Wr.x),
                (this.currentBBox.y = Wr.y),
                this.shapeCont.setAttribute(
                  "viewBox",
                  this.currentBBox.x +
                    " " +
                    this.currentBBox.y +
                    " " +
                    this.currentBBox.w +
                    " " +
                    this.currentBBox.h
                );
              var Yr = this.shapeCont.style,
                Kr =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
              (Yr.transform = Kr), (Yr.webkitTransform = Kr);
            }
          }
        });
      function HTextElement(Wr, ze, Gr) {
        (this.textSpans = []),
          (this.textPaths = []),
          (this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0,
          }),
          (this.renderType = "svg"),
          (this.isMasked = !1),
          this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        HTextElement
      ),
        (HTextElement.prototype.createContent = function () {
          if (((this.isMasked = this.checkMasks()), this.isMasked)) {
            (this.renderType = "svg"),
              (this.compW = this.comp.data.w),
              (this.compH = this.comp.data.h),
              this.svgElement.setAttribute("width", this.compW),
              this.svgElement.setAttribute("height", this.compH);
            var Wr = createNS("g");
            this.maskedElement.appendChild(Wr), (this.innerElem = Wr);
          } else
            (this.renderType = "html"), (this.innerElem = this.layerElement);
          this.checkParenting();
        }),
        (HTextElement.prototype.buildNewText = function () {
          var Wr = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(Wr.l ? Wr.l.length : 0);
          var ze = this.innerElem.style,
            Gr = Wr.fc ? this.buildColor(Wr.fc) : "rgba(0,0,0,0)";
          (ze.fill = Gr),
            (ze.color = Gr),
            Wr.sc &&
              ((ze.stroke = this.buildColor(Wr.sc)),
              (ze.strokeWidth = Wr.sw + "px"));
          var Yr = this.globalData.fontManager.getFontByName(Wr.f);
          if (!this.globalData.fontManager.chars)
            if (
              ((ze.fontSize = Wr.finalSize + "px"),
              (ze.lineHeight = Wr.finalSize + "px"),
              Yr.fClass)
            )
              this.innerElem.className = Yr.fClass;
            else {
              ze.fontFamily = Yr.fFamily;
              var Kr = Wr.fWeight,
                Zr = Wr.fStyle;
              (ze.fontStyle = Zr), (ze.fontWeight = Kr);
            }
          var Jr,
            Qr,
            ei = Wr.l;
          Qr = ei.length;
          var ti,
            ri,
            ni,
            ii = this.mHelper,
            si,
            li = "",
            oi = 0;
          for (Jr = 0; Jr < Qr; Jr += 1) {
            if (
              (this.globalData.fontManager.chars
                ? (this.textPaths[oi]
                    ? (ti = this.textPaths[oi])
                    : ((ti = createNS("path")),
                      ti.setAttribute("stroke-linecap", lineCapEnum[1]),
                      ti.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                      ti.setAttribute("stroke-miterlimit", "4")),
                  this.isMasked ||
                    (this.textSpans[oi]
                      ? ((ri = this.textSpans[oi]), (ni = ri.children[0]))
                      : ((ri = createTag("div")),
                        (ri.style.lineHeight = 0),
                        (ni = createNS("svg")),
                        ni.appendChild(ti),
                        styleDiv(ri))))
                : this.isMasked
                ? (ti = this.textPaths[oi]
                    ? this.textPaths[oi]
                    : createNS("text"))
                : this.textSpans[oi]
                ? ((ri = this.textSpans[oi]), (ti = this.textPaths[oi]))
                : ((ri = createTag("span")),
                  styleDiv(ri),
                  (ti = createTag("span")),
                  styleDiv(ti),
                  ri.appendChild(ti)),
              this.globalData.fontManager.chars)
            ) {
              var ui = this.globalData.fontManager.getCharData(
                  Wr.finalText[Jr],
                  Yr.fStyle,
                  this.globalData.fontManager.getFontByName(Wr.f).fFamily
                ),
                ai;
              if (
                (ui ? (ai = ui.data) : (ai = null),
                ii.reset(),
                ai &&
                  ai.shapes &&
                  ai.shapes.length &&
                  ((si = ai.shapes[0].it),
                  ii.scale(Wr.finalSize / 100, Wr.finalSize / 100),
                  (li = this.createPathShape(ii, si)),
                  ti.setAttribute("d", li)),
                this.isMasked)
              )
                this.innerElem.appendChild(ti);
              else {
                if ((this.innerElem.appendChild(ri), ai && ai.shapes)) {
                  document.body.appendChild(ni);
                  var hi = ni.getBBox();
                  ni.setAttribute("width", hi.width + 2),
                    ni.setAttribute("height", hi.height + 2),
                    ni.setAttribute(
                      "viewBox",
                      hi.x -
                        1 +
                        " " +
                        (hi.y - 1) +
                        " " +
                        (hi.width + 2) +
                        " " +
                        (hi.height + 2)
                    );
                  var ci = ni.style,
                    fi = "translate(" + (hi.x - 1) + "px," + (hi.y - 1) + "px)";
                  (ci.transform = fi),
                    (ci.webkitTransform = fi),
                    (ei[Jr].yOffset = hi.y - 1);
                } else
                  ni.setAttribute("width", 1), ni.setAttribute("height", 1);
                ri.appendChild(ni);
              }
            } else if (
              ((ti.textContent = ei[Jr].val),
              ti.setAttributeNS(
                "http://www.w3.org/XML/1998/namespace",
                "xml:space",
                "preserve"
              ),
              this.isMasked)
            )
              this.innerElem.appendChild(ti);
            else {
              this.innerElem.appendChild(ri);
              var di = ti.style,
                pi = "translate3d(0," + -Wr.finalSize / 1.2 + "px,0)";
              (di.transform = pi), (di.webkitTransform = pi);
            }
            this.isMasked
              ? (this.textSpans[oi] = ti)
              : (this.textSpans[oi] = ri),
              (this.textSpans[oi].style.display = "block"),
              (this.textPaths[oi] = ti),
              (oi += 1);
          }
          for (; oi < this.textSpans.length; )
            (this.textSpans[oi].style.display = "none"), (oi += 1);
        }),
        (HTextElement.prototype.renderInnerContent = function () {
          this.validateText();
          var Wr;
          if (this.data.singleShape) {
            if (!this._isFirstFrame && !this.lettersChangedFlag) return;
            if (this.isMasked && this.finalTransform._matMdf) {
              this.svgElement.setAttribute(
                "viewBox",
                -this.finalTransform.mProp.p.v[0] +
                  " " +
                  -this.finalTransform.mProp.p.v[1] +
                  " " +
                  this.compW +
                  " " +
                  this.compH
              ),
                (Wr = this.svgElement.style);
              var ze =
                "translate(" +
                -this.finalTransform.mProp.p.v[0] +
                "px," +
                -this.finalTransform.mProp.p.v[1] +
                "px)";
              (Wr.transform = ze), (Wr.webkitTransform = ze);
            }
          }
          if (
            (this.textAnimator.getMeasures(
              this.textProperty.currentData,
              this.lettersChangedFlag
            ),
            !(
              !this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag
            ))
          ) {
            var Gr,
              Yr,
              Kr = 0,
              Zr = this.textAnimator.renderedLetters,
              Jr = this.textProperty.currentData.l;
            Yr = Jr.length;
            var Qr, ei, ti;
            for (Gr = 0; Gr < Yr; Gr += 1)
              Jr[Gr].n
                ? (Kr += 1)
                : ((ei = this.textSpans[Gr]),
                  (ti = this.textPaths[Gr]),
                  (Qr = Zr[Kr]),
                  (Kr += 1),
                  Qr._mdf.m &&
                    (this.isMasked
                      ? ei.setAttribute("transform", Qr.m)
                      : ((ei.style.webkitTransform = Qr.m),
                        (ei.style.transform = Qr.m))),
                  (ei.style.opacity = Qr.o),
                  Qr.sw && Qr._mdf.sw && ti.setAttribute("stroke-width", Qr.sw),
                  Qr.sc && Qr._mdf.sc && ti.setAttribute("stroke", Qr.sc),
                  Qr.fc &&
                    Qr._mdf.fc &&
                    (ti.setAttribute("fill", Qr.fc), (ti.style.color = Qr.fc)));
            if (
              this.innerElem.getBBox &&
              !this.hidden &&
              (this._isFirstFrame || this._mdf)
            ) {
              var ri = this.innerElem.getBBox();
              this.currentBBox.w !== ri.width &&
                ((this.currentBBox.w = ri.width),
                this.svgElement.setAttribute("width", ri.width)),
                this.currentBBox.h !== ri.height &&
                  ((this.currentBBox.h = ri.height),
                  this.svgElement.setAttribute("height", ri.height));
              var ni = 1;
              if (
                this.currentBBox.w !== ri.width + ni * 2 ||
                this.currentBBox.h !== ri.height + ni * 2 ||
                this.currentBBox.x !== ri.x - ni ||
                this.currentBBox.y !== ri.y - ni
              ) {
                (this.currentBBox.w = ri.width + ni * 2),
                  (this.currentBBox.h = ri.height + ni * 2),
                  (this.currentBBox.x = ri.x - ni),
                  (this.currentBBox.y = ri.y - ni),
                  this.svgElement.setAttribute(
                    "viewBox",
                    this.currentBBox.x +
                      " " +
                      this.currentBBox.y +
                      " " +
                      this.currentBBox.w +
                      " " +
                      this.currentBBox.h
                  ),
                  (Wr = this.svgElement.style);
                var ii =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
                (Wr.transform = ii), (Wr.webkitTransform = ii);
              }
            }
          }
        });
      function HCameraElement(Wr, ze, Gr) {
        this.initFrame(), this.initBaseData(Wr, ze, Gr), this.initHierarchy();
        var Yr = PropertyFactory.getProp;
        if (
          ((this.pe = Yr(this, Wr.pe, 0, 0, this)),
          Wr.ks.p.s
            ? ((this.px = Yr(this, Wr.ks.p.x, 1, 0, this)),
              (this.py = Yr(this, Wr.ks.p.y, 1, 0, this)),
              (this.pz = Yr(this, Wr.ks.p.z, 1, 0, this)))
            : (this.p = Yr(this, Wr.ks.p, 1, 0, this)),
          Wr.ks.a && (this.a = Yr(this, Wr.ks.a, 1, 0, this)),
          Wr.ks.or.k.length && Wr.ks.or.k[0].to)
        ) {
          var Kr,
            Zr = Wr.ks.or.k.length;
          for (Kr = 0; Kr < Zr; Kr += 1)
            (Wr.ks.or.k[Kr].to = null), (Wr.ks.or.k[Kr].ti = null);
        }
        (this.or = Yr(this, Wr.ks.or, 1, degToRads, this)),
          (this.or.sh = !0),
          (this.rx = Yr(this, Wr.ks.rx, 0, degToRads, this)),
          (this.ry = Yr(this, Wr.ks.ry, 0, degToRads, this)),
          (this.rz = Yr(this, Wr.ks.rz, 0, degToRads, this)),
          (this.mat = new Matrix()),
          (this._prevMat = new Matrix()),
          (this._isFirstFrame = !0),
          (this.finalTransform = {
            mProp: this,
          });
      }
      extendPrototype(
        [BaseElement, FrameElement, HierarchyElement],
        HCameraElement
      ),
        (HCameraElement.prototype.setup = function () {
          var Wr,
            ze = this.comp.threeDElements.length,
            Gr,
            Yr,
            Kr;
          for (Wr = 0; Wr < ze; Wr += 1)
            if (((Gr = this.comp.threeDElements[Wr]), Gr.type === "3d")) {
              (Yr = Gr.perspectiveElem.style), (Kr = Gr.container.style);
              var Zr = this.pe.v + "px",
                Jr = "0px 0px 0px",
                Qr = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              (Yr.perspective = Zr),
                (Yr.webkitPerspective = Zr),
                (Kr.transformOrigin = Jr),
                (Kr.mozTransformOrigin = Jr),
                (Kr.webkitTransformOrigin = Jr),
                (Yr.transform = Qr),
                (Yr.webkitTransform = Qr);
            }
        }),
        (HCameraElement.prototype.createElements = function () {}),
        (HCameraElement.prototype.hide = function () {}),
        (HCameraElement.prototype.renderFrame = function () {
          var Wr = this._isFirstFrame,
            ze,
            Gr;
          if (this.hierarchy)
            for (Gr = this.hierarchy.length, ze = 0; ze < Gr; ze += 1)
              Wr = this.hierarchy[ze].finalTransform.mProp._mdf || Wr;
          if (
            Wr ||
            this.pe._mdf ||
            (this.p && this.p._mdf) ||
            (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
            this.rx._mdf ||
            this.ry._mdf ||
            this.rz._mdf ||
            this.or._mdf ||
            (this.a && this.a._mdf)
          ) {
            if ((this.mat.reset(), this.hierarchy))
              for (Gr = this.hierarchy.length - 1, ze = Gr; ze >= 0; ze -= 1) {
                var Yr = this.hierarchy[ze].finalTransform.mProp;
                this.mat.translate(-Yr.p.v[0], -Yr.p.v[1], Yr.p.v[2]),
                  this.mat
                    .rotateX(-Yr.or.v[0])
                    .rotateY(-Yr.or.v[1])
                    .rotateZ(Yr.or.v[2]),
                  this.mat.rotateX(-Yr.rx.v).rotateY(-Yr.ry.v).rotateZ(Yr.rz.v),
                  this.mat.scale(1 / Yr.s.v[0], 1 / Yr.s.v[1], 1 / Yr.s.v[2]),
                  this.mat.translate(Yr.a.v[0], Yr.a.v[1], Yr.a.v[2]);
              }
            if (
              (this.p
                ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2])
                : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
              this.a)
            ) {
              var Kr;
              this.p
                ? (Kr = [
                    this.p.v[0] - this.a.v[0],
                    this.p.v[1] - this.a.v[1],
                    this.p.v[2] - this.a.v[2],
                  ])
                : (Kr = [
                    this.px.v - this.a.v[0],
                    this.py.v - this.a.v[1],
                    this.pz.v - this.a.v[2],
                  ]);
              var Zr = Math.sqrt(
                  Math.pow(Kr[0], 2) + Math.pow(Kr[1], 2) + Math.pow(Kr[2], 2)
                ),
                Jr = [Kr[0] / Zr, Kr[1] / Zr, Kr[2] / Zr],
                Qr = Math.sqrt(Jr[2] * Jr[2] + Jr[0] * Jr[0]),
                ei = Math.atan2(Jr[1], Qr),
                ti = Math.atan2(Jr[0], -Jr[2]);
              this.mat.rotateY(ti).rotateX(-ei);
            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
              this.mat
                .rotateX(-this.or.v[0])
                .rotateY(-this.or.v[1])
                .rotateZ(this.or.v[2]),
              this.mat.translate(
                this.globalData.compSize.w / 2,
                this.globalData.compSize.h / 2,
                0
              ),
              this.mat.translate(0, 0, this.pe.v);
            var ri = !this._prevMat.equals(this.mat);
            if ((ri || this.pe._mdf) && this.comp.threeDElements) {
              Gr = this.comp.threeDElements.length;
              var ni, ii, si;
              for (ze = 0; ze < Gr; ze += 1)
                if (((ni = this.comp.threeDElements[ze]), ni.type === "3d")) {
                  if (ri) {
                    var li = this.mat.toCSS();
                    (si = ni.container.style),
                      (si.transform = li),
                      (si.webkitTransform = li);
                  }
                  this.pe._mdf &&
                    ((ii = ni.perspectiveElem.style),
                    (ii.perspective = this.pe.v + "px"),
                    (ii.webkitPerspective = this.pe.v + "px"));
                }
              this.mat.clone(this._prevMat);
            }
          }
          this._isFirstFrame = !1;
        }),
        (HCameraElement.prototype.prepareFrame = function (Wr) {
          this.prepareProperties(Wr, !0);
        }),
        (HCameraElement.prototype.destroy = function () {}),
        (HCameraElement.prototype.getBaseElement = function () {
          return null;
        });
      function HImageElement(Wr, ze, Gr) {
        (this.assetData = ze.getAssetData(Wr.refId)),
          this.initElement(Wr, ze, Gr);
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HSolidElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HImageElement
      ),
        (HImageElement.prototype.createContent = function () {
          var Wr = this.globalData.getAssetsPath(this.assetData),
            ze = new Image();
          this.data.hasMask
            ? ((this.imageElem = createNS("image")),
              this.imageElem.setAttribute("width", this.assetData.w + "px"),
              this.imageElem.setAttribute("height", this.assetData.h + "px"),
              this.imageElem.setAttributeNS(
                "http://www.w3.org/1999/xlink",
                "href",
                Wr
              ),
              this.layerElement.appendChild(this.imageElem),
              this.baseElement.setAttribute("width", this.assetData.w),
              this.baseElement.setAttribute("height", this.assetData.h))
            : this.layerElement.appendChild(ze),
            (ze.crossOrigin = "anonymous"),
            (ze.src = Wr),
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln);
        });
      function HybridRendererBase(Wr, ze) {
        (this.animationItem = Wr),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (ze && ze.className) || "",
            imagePreserveAspectRatio:
              (ze && ze.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(ze && ze.hideOnTransparent === !1),
            filterSize: {
              width: (ze && ze.filterSize && ze.filterSize.width) || "400%",
              height: (ze && ze.filterSize && ze.filterSize.height) || "400%",
              x: (ze && ze.filterSize && ze.filterSize.x) || "-100%",
              y: (ze && ze.filterSize && ze.filterSize.y) || "-100%",
            },
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html");
      }
      extendPrototype([BaseRenderer], HybridRendererBase),
        (HybridRendererBase.prototype.buildItem =
          SVGRenderer.prototype.buildItem),
        (HybridRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var Wr = this.pendingElements.pop();
            Wr.checkParenting();
          }
        }),
        (HybridRendererBase.prototype.appendElementInPos = function (Wr, ze) {
          var Gr = Wr.getBaseElement();
          if (Gr) {
            var Yr = this.layers[ze];
            if (!Yr.ddd || !this.supports3d)
              if (this.threeDElements) this.addTo3dContainer(Gr, ze);
              else {
                for (var Kr = 0, Zr, Jr, Qr; Kr < ze; )
                  this.elements[Kr] &&
                    this.elements[Kr] !== !0 &&
                    this.elements[Kr].getBaseElement &&
                    ((Jr = this.elements[Kr]),
                    (Qr = this.layers[Kr].ddd
                      ? this.getThreeDContainerByPos(Kr)
                      : Jr.getBaseElement()),
                    (Zr = Qr || Zr)),
                    (Kr += 1);
                Zr
                  ? (!Yr.ddd || !this.supports3d) &&
                    this.layerElement.insertBefore(Gr, Zr)
                  : (!Yr.ddd || !this.supports3d) &&
                    this.layerElement.appendChild(Gr);
              }
            else this.addTo3dContainer(Gr, ze);
          }
        }),
        (HybridRendererBase.prototype.createShape = function (Wr) {
          return this.supports3d
            ? new HShapeElement(Wr, this.globalData, this)
            : new SVGShapeElement(Wr, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createText = function (Wr) {
          return this.supports3d
            ? new HTextElement(Wr, this.globalData, this)
            : new SVGTextLottieElement(Wr, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createCamera = function (Wr) {
          return (
            (this.camera = new HCameraElement(Wr, this.globalData, this)),
            this.camera
          );
        }),
        (HybridRendererBase.prototype.createImage = function (Wr) {
          return this.supports3d
            ? new HImageElement(Wr, this.globalData, this)
            : new IImageElement(Wr, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createSolid = function (Wr) {
          return this.supports3d
            ? new HSolidElement(Wr, this.globalData, this)
            : new ISolidElement(Wr, this.globalData, this);
        }),
        (HybridRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (HybridRendererBase.prototype.getThreeDContainerByPos = function (Wr) {
          for (var ze = 0, Gr = this.threeDElements.length; ze < Gr; ) {
            if (
              this.threeDElements[ze].startPos <= Wr &&
              this.threeDElements[ze].endPos >= Wr
            )
              return this.threeDElements[ze].perspectiveElem;
            ze += 1;
          }
          return null;
        }),
        (HybridRendererBase.prototype.createThreeDContainer = function (
          Wr,
          ze
        ) {
          var Gr = createTag("div"),
            Yr,
            Kr;
          styleDiv(Gr);
          var Zr = createTag("div");
          if ((styleDiv(Zr), ze === "3d")) {
            (Yr = Gr.style),
              (Yr.width = this.globalData.compSize.w + "px"),
              (Yr.height = this.globalData.compSize.h + "px");
            var Jr = "50% 50%";
            (Yr.webkitTransformOrigin = Jr),
              (Yr.mozTransformOrigin = Jr),
              (Yr.transformOrigin = Jr),
              (Kr = Zr.style);
            var Qr = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            (Kr.transform = Qr), (Kr.webkitTransform = Qr);
          }
          Gr.appendChild(Zr);
          var ei = {
            container: Zr,
            perspectiveElem: Gr,
            startPos: Wr,
            endPos: Wr,
            type: ze,
          };
          return this.threeDElements.push(ei), ei;
        }),
        (HybridRendererBase.prototype.build3dContainers = function () {
          var Wr,
            ze = this.layers.length,
            Gr,
            Yr = "";
          for (Wr = 0; Wr < ze; Wr += 1)
            this.layers[Wr].ddd && this.layers[Wr].ty !== 3
              ? (Yr !== "3d" &&
                  ((Yr = "3d"), (Gr = this.createThreeDContainer(Wr, "3d"))),
                (Gr.endPos = Math.max(Gr.endPos, Wr)))
              : (Yr !== "2d" &&
                  ((Yr = "2d"), (Gr = this.createThreeDContainer(Wr, "2d"))),
                (Gr.endPos = Math.max(Gr.endPos, Wr)));
          for (ze = this.threeDElements.length, Wr = ze - 1; Wr >= 0; Wr -= 1)
            this.resizerElem.appendChild(
              this.threeDElements[Wr].perspectiveElem
            );
        }),
        (HybridRendererBase.prototype.addTo3dContainer = function (Wr, ze) {
          for (var Gr = 0, Yr = this.threeDElements.length; Gr < Yr; ) {
            if (ze <= this.threeDElements[Gr].endPos) {
              for (var Kr = this.threeDElements[Gr].startPos, Zr; Kr < ze; )
                this.elements[Kr] &&
                  this.elements[Kr].getBaseElement &&
                  (Zr = this.elements[Kr].getBaseElement()),
                  (Kr += 1);
              Zr
                ? this.threeDElements[Gr].container.insertBefore(Wr, Zr)
                : this.threeDElements[Gr].container.appendChild(Wr);
              break;
            }
            Gr += 1;
          }
        }),
        (HybridRendererBase.prototype.configAnimation = function (Wr) {
          var ze = createTag("div"),
            Gr = this.animationItem.wrapper,
            Yr = ze.style;
          (Yr.width = Wr.w + "px"),
            (Yr.height = Wr.h + "px"),
            (this.resizerElem = ze),
            styleDiv(ze),
            (Yr.transformStyle = "flat"),
            (Yr.mozTransformStyle = "flat"),
            (Yr.webkitTransformStyle = "flat"),
            this.renderConfig.className &&
              ze.setAttribute("class", this.renderConfig.className),
            Gr.appendChild(ze),
            (Yr.overflow = "hidden");
          var Kr = createNS("svg");
          Kr.setAttribute("width", "1"),
            Kr.setAttribute("height", "1"),
            styleDiv(Kr),
            this.resizerElem.appendChild(Kr);
          var Zr = createNS("defs");
          Kr.appendChild(Zr),
            (this.data = Wr),
            this.setupGlobalData(Wr, Kr),
            (this.globalData.defs = Zr),
            (this.layers = Wr.layers),
            (this.layerElement = this.resizerElem),
            this.build3dContainers(),
            this.updateContainerSize();
        }),
        (HybridRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.animationItem.container = null),
            (this.globalData.defs = null);
          var Wr,
            ze = this.layers ? this.layers.length : 0;
          for (Wr = 0; Wr < ze; Wr += 1)
            this.elements[Wr] &&
              this.elements[Wr].destroy &&
              this.elements[Wr].destroy();
          (this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null);
        }),
        (HybridRendererBase.prototype.updateContainerSize = function () {
          var Wr = this.animationItem.wrapper.offsetWidth,
            ze = this.animationItem.wrapper.offsetHeight,
            Gr = Wr / ze,
            Yr = this.globalData.compSize.w / this.globalData.compSize.h,
            Kr,
            Zr,
            Jr,
            Qr;
          Yr > Gr
            ? ((Kr = Wr / this.globalData.compSize.w),
              (Zr = Wr / this.globalData.compSize.w),
              (Jr = 0),
              (Qr =
                (ze -
                  this.globalData.compSize.h *
                    (Wr / this.globalData.compSize.w)) /
                2))
            : ((Kr = ze / this.globalData.compSize.h),
              (Zr = ze / this.globalData.compSize.h),
              (Jr =
                (Wr -
                  this.globalData.compSize.w *
                    (ze / this.globalData.compSize.h)) /
                2),
              (Qr = 0));
          var ei = this.resizerElem.style;
          (ei.webkitTransform =
            "matrix3d(" +
            Kr +
            ",0,0,0,0," +
            Zr +
            ",0,0,0,0,1,0," +
            Jr +
            "," +
            Qr +
            ",0,1)"),
            (ei.transform = ei.webkitTransform);
        }),
        (HybridRendererBase.prototype.renderFrame =
          SVGRenderer.prototype.renderFrame),
        (HybridRendererBase.prototype.hide = function () {
          this.resizerElem.style.display = "none";
        }),
        (HybridRendererBase.prototype.show = function () {
          this.resizerElem.style.display = "block";
        }),
        (HybridRendererBase.prototype.initItems = function () {
          if ((this.buildAllItems(), this.camera)) this.camera.setup();
          else {
            var Wr = this.globalData.compSize.w,
              ze = this.globalData.compSize.h,
              Gr,
              Yr = this.threeDElements.length;
            for (Gr = 0; Gr < Yr; Gr += 1) {
              var Kr = this.threeDElements[Gr].perspectiveElem.style;
              (Kr.webkitPerspective =
                Math.sqrt(Math.pow(Wr, 2) + Math.pow(ze, 2)) + "px"),
                (Kr.perspective = Kr.webkitPerspective);
            }
          }
        }),
        (HybridRendererBase.prototype.searchExtraCompositions = function (Wr) {
          var ze,
            Gr = Wr.length,
            Yr = createTag("div");
          for (ze = 0; ze < Gr; ze += 1)
            if (Wr[ze].xt) {
              var Kr = this.createComp(Wr[ze], Yr, this.globalData.comp, null);
              Kr.initExpressions(),
                this.globalData.projectInterface.registerComposition(Kr);
            }
        });
      function HCompElement(Wr, ze, Gr) {
        (this.layers = Wr.layers),
          (this.supports3d = !Wr.hasMask),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(Wr, ze, Gr),
          (this.tm = Wr.tm
            ? PropertyFactory.getProp(this, Wr.tm, 0, ze.frameRate, this)
            : {
                _placeholder: !0,
              });
      }
      extendPrototype(
        [HybridRendererBase, ICompElement, HBaseElement],
        HCompElement
      ),
        (HCompElement.prototype._createBaseContainerElements =
          HCompElement.prototype.createContainerElements),
        (HCompElement.prototype.createContainerElements = function () {
          this._createBaseContainerElements(),
            this.data.hasMask
              ? (this.svgElement.setAttribute("width", this.data.w),
                this.svgElement.setAttribute("height", this.data.h),
                (this.transformedElement = this.baseElement))
              : (this.transformedElement = this.layerElement);
        }),
        (HCompElement.prototype.addTo3dContainer = function (Wr, ze) {
          for (var Gr = 0, Yr; Gr < ze; )
            this.elements[Gr] &&
              this.elements[Gr].getBaseElement &&
              (Yr = this.elements[Gr].getBaseElement()),
              (Gr += 1);
          Yr
            ? this.layerElement.insertBefore(Wr, Yr)
            : this.layerElement.appendChild(Wr);
        }),
        (HCompElement.prototype.createComp = function (Wr) {
          return this.supports3d
            ? new HCompElement(Wr, this.globalData, this)
            : new SVGCompElement(Wr, this.globalData, this);
        });
      function HybridRenderer(Wr, ze) {
        (this.animationItem = Wr),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (ze && ze.className) || "",
            imagePreserveAspectRatio:
              (ze && ze.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(ze && ze.hideOnTransparent === !1),
            filterSize: {
              width: (ze && ze.filterSize && ze.filterSize.width) || "400%",
              height: (ze && ze.filterSize && ze.filterSize.height) || "400%",
              x: (ze && ze.filterSize && ze.filterSize.x) || "-100%",
              y: (ze && ze.filterSize && ze.filterSize.y) || "-100%",
            },
            runExpressions:
              !ze || ze.runExpressions === void 0 || ze.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html");
      }
      extendPrototype([HybridRendererBase], HybridRenderer),
        (HybridRenderer.prototype.createComp = function (Wr) {
          return this.supports3d
            ? new HCompElement(Wr, this.globalData, this)
            : new SVGCompElement(Wr, this.globalData, this);
        });
      var CompExpressionInterface = (function () {
        return function (Wr) {
          function ze(Gr) {
            for (var Yr = 0, Kr = Wr.layers.length; Yr < Kr; ) {
              if (Wr.layers[Yr].nm === Gr || Wr.layers[Yr].ind === Gr)
                return Wr.elements[Yr].layerInterface;
              Yr += 1;
            }
            return null;
          }
          return (
            Object.defineProperty(ze, "_name", {
              value: Wr.data.nm,
            }),
            (ze.layer = ze),
            (ze.pixelAspect = 1),
            (ze.height = Wr.data.h || Wr.globalData.compSize.h),
            (ze.width = Wr.data.w || Wr.globalData.compSize.w),
            (ze.pixelAspect = 1),
            (ze.frameDuration = 1 / Wr.globalData.frameRate),
            (ze.displayStartTime = 0),
            (ze.numLayers = Wr.layers.length),
            ze
          );
        };
      })();
      function _typeof$2(Wr) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$2 = function (Gr) {
                return typeof Gr;
              })
            : (_typeof$2 = function (Gr) {
                return Gr &&
                  typeof Symbol == "function" &&
                  Gr.constructor === Symbol &&
                  Gr !== Symbol.prototype
                  ? "symbol"
                  : typeof Gr;
              }),
          _typeof$2(Wr)
        );
      }
      function seedRandom(Wr, ze) {
        var Gr = this,
          Yr = 256,
          Kr = 6,
          Zr = 52,
          Jr = "random",
          Qr = ze.pow(Yr, Kr),
          ei = ze.pow(2, Zr),
          ti = ei * 2,
          ri = Yr - 1,
          ni;
        function ii(ci, fi, di) {
          var pi = [];
          fi =
            fi === !0
              ? {
                  entropy: !0,
                }
              : fi || {};
          var mi = ui(
              oi(fi.entropy ? [ci, hi(Wr)] : ci === null ? ai() : ci, 3),
              pi
            ),
            Si = new si(pi),
            yi = function () {
              for (var Pi = Si.g(Kr), Ai = Qr, Ri = 0; Pi < ei; )
                (Pi = (Pi + Ri) * Yr), (Ai *= Yr), (Ri = Si.g(1));
              for (; Pi >= ti; ) (Pi /= 2), (Ai /= 2), (Ri >>>= 1);
              return (Pi + Ri) / Ai;
            };
          return (
            (yi.int32 = function () {
              return Si.g(4) | 0;
            }),
            (yi.quick = function () {
              return Si.g(4) / 4294967296;
            }),
            (yi.double = yi),
            ui(hi(Si.S), Wr),
            (
              fi.pass ||
              di ||
              function (Ei, Pi, Ai, Ri) {
                return (
                  Ri &&
                    (Ri.S && li(Ri, Si),
                    (Ei.state = function () {
                      return li(Si, {});
                    })),
                  Ai ? ((ze[Jr] = Ei), Pi) : Ei
                );
              }
            )(yi, mi, "global" in fi ? fi.global : this == ze, fi.state)
          );
        }
        ze["seed" + Jr] = ii;
        function si(ci) {
          var fi,
            di = ci.length,
            pi = this,
            mi = 0,
            Si = (pi.i = pi.j = 0),
            yi = (pi.S = []);
          for (di || (ci = [di++]); mi < Yr; ) yi[mi] = mi++;
          for (mi = 0; mi < Yr; mi++)
            (yi[mi] = yi[(Si = ri & (Si + ci[mi % di] + (fi = yi[mi])))]),
              (yi[Si] = fi);
          pi.g = function (Ei) {
            for (var Pi, Ai = 0, Ri = pi.i, wi = pi.j, Ci = pi.S; Ei--; )
              (Pi = Ci[(Ri = ri & (Ri + 1))]),
                (Ai =
                  Ai * Yr +
                  Ci[
                    ri & ((Ci[Ri] = Ci[(wi = ri & (wi + Pi))]) + (Ci[wi] = Pi))
                  ]);
            return (pi.i = Ri), (pi.j = wi), Ai;
          };
        }
        function li(ci, fi) {
          return (fi.i = ci.i), (fi.j = ci.j), (fi.S = ci.S.slice()), fi;
        }
        function oi(ci, fi) {
          var di = [],
            pi = _typeof$2(ci),
            mi;
          if (fi && pi == "object")
            for (mi in ci)
              try {
                di.push(oi(ci[mi], fi - 1));
              } catch (Si) {}
          return di.length ? di : pi == "string" ? ci : ci + "\0";
        }
        function ui(ci, fi) {
          for (var di = ci + "", pi, mi = 0; mi < di.length; )
            fi[ri & mi] = ri & ((pi ^= fi[ri & mi] * 19) + di.charCodeAt(mi++));
          return hi(fi);
        }
        function ai() {
          try {
            var ci = new Uint8Array(Yr);
            return (Gr.crypto || Gr.msCrypto).getRandomValues(ci), hi(ci);
          } catch (pi) {
            var fi = Gr.navigator,
              di = fi && fi.plugins;
            return [+new Date(), Gr, di, Gr.screen, hi(Wr)];
          }
        }
        function hi(ci) {
          return String.fromCharCode.apply(0, ci);
        }
        ui(ze.random(), Wr);
      }
      function initialize$2(Wr) {
        seedRandom([], Wr);
      }
      var propTypes = {
        SHAPE: "shape",
      };
      function _typeof$1(Wr) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$1 = function (Gr) {
                return typeof Gr;
              })
            : (_typeof$1 = function (Gr) {
                return Gr &&
                  typeof Symbol == "function" &&
                  Gr.constructor === Symbol &&
                  Gr !== Symbol.prototype
                  ? "symbol"
                  : typeof Gr;
              }),
          _typeof$1(Wr)
        );
      }
      var ExpressionManager = (function () {
          var ob = {},
            Math = BMMath,
            window = null,
            document = null,
            XMLHttpRequest = null,
            fetch = null,
            frames = null,
            _lottieGlobal = {};
          initialize$2(BMMath);
          function resetFrame() {
            _lottieGlobal = {};
          }
          function $bm_isInstanceOfArray(Wr) {
            return Wr.constructor === Array || Wr.constructor === Float32Array;
          }
          function isNumerable(Wr, ze) {
            return (
              Wr === "number" ||
              ze instanceof Number ||
              Wr === "boolean" ||
              Wr === "string"
            );
          }
          function $bm_neg(Wr) {
            var ze = _typeof$1(Wr);
            if (ze === "number" || Wr instanceof Number || ze === "boolean")
              return -Wr;
            if ($bm_isInstanceOfArray(Wr)) {
              var Gr,
                Yr = Wr.length,
                Kr = [];
              for (Gr = 0; Gr < Yr; Gr += 1) Kr[Gr] = -Wr[Gr];
              return Kr;
            }
            return Wr.propType ? Wr.v : -Wr;
          }
          var easeInBez = BezierFactory.getBezierEasing(
              0.333,
              0,
              0.833,
              0.833,
              "easeIn"
            ).get,
            easeOutBez = BezierFactory.getBezierEasing(
              0.167,
              0.167,
              0.667,
              1,
              "easeOut"
            ).get,
            easeInOutBez = BezierFactory.getBezierEasing(
              0.33,
              0,
              0.667,
              1,
              "easeInOut"
            ).get;
          function sum(Wr, ze) {
            var Gr = _typeof$1(Wr),
              Yr = _typeof$1(ze);
            if (
              (isNumerable(Gr, Wr) && isNumerable(Yr, ze)) ||
              Gr === "string" ||
              Yr === "string"
            )
              return Wr + ze;
            if ($bm_isInstanceOfArray(Wr) && isNumerable(Yr, ze))
              return (Wr = Wr.slice(0)), (Wr[0] += ze), Wr;
            if (isNumerable(Gr, Wr) && $bm_isInstanceOfArray(ze))
              return (ze = ze.slice(0)), (ze[0] = Wr + ze[0]), ze;
            if ($bm_isInstanceOfArray(Wr) && $bm_isInstanceOfArray(ze)) {
              for (
                var Kr = 0, Zr = Wr.length, Jr = ze.length, Qr = [];
                Kr < Zr || Kr < Jr;

              )
                (typeof Wr[Kr] == "number" || Wr[Kr] instanceof Number) &&
                (typeof ze[Kr] == "number" || ze[Kr] instanceof Number)
                  ? (Qr[Kr] = Wr[Kr] + ze[Kr])
                  : (Qr[Kr] = ze[Kr] === void 0 ? Wr[Kr] : Wr[Kr] || ze[Kr]),
                  (Kr += 1);
              return Qr;
            }
            return 0;
          }
          var add = sum;
          function sub(Wr, ze) {
            var Gr = _typeof$1(Wr),
              Yr = _typeof$1(ze);
            if (isNumerable(Gr, Wr) && isNumerable(Yr, ze))
              return (
                Gr === "string" && (Wr = parseInt(Wr, 10)),
                Yr === "string" && (ze = parseInt(ze, 10)),
                Wr - ze
              );
            if ($bm_isInstanceOfArray(Wr) && isNumerable(Yr, ze))
              return (Wr = Wr.slice(0)), (Wr[0] -= ze), Wr;
            if (isNumerable(Gr, Wr) && $bm_isInstanceOfArray(ze))
              return (ze = ze.slice(0)), (ze[0] = Wr - ze[0]), ze;
            if ($bm_isInstanceOfArray(Wr) && $bm_isInstanceOfArray(ze)) {
              for (
                var Kr = 0, Zr = Wr.length, Jr = ze.length, Qr = [];
                Kr < Zr || Kr < Jr;

              )
                (typeof Wr[Kr] == "number" || Wr[Kr] instanceof Number) &&
                (typeof ze[Kr] == "number" || ze[Kr] instanceof Number)
                  ? (Qr[Kr] = Wr[Kr] - ze[Kr])
                  : (Qr[Kr] = ze[Kr] === void 0 ? Wr[Kr] : Wr[Kr] || ze[Kr]),
                  (Kr += 1);
              return Qr;
            }
            return 0;
          }
          function mul(Wr, ze) {
            var Gr = _typeof$1(Wr),
              Yr = _typeof$1(ze),
              Kr;
            if (isNumerable(Gr, Wr) && isNumerable(Yr, ze)) return Wr * ze;
            var Zr, Jr;
            if ($bm_isInstanceOfArray(Wr) && isNumerable(Yr, ze)) {
              for (
                Jr = Wr.length, Kr = createTypedArray("float32", Jr), Zr = 0;
                Zr < Jr;
                Zr += 1
              )
                Kr[Zr] = Wr[Zr] * ze;
              return Kr;
            }
            if (isNumerable(Gr, Wr) && $bm_isInstanceOfArray(ze)) {
              for (
                Jr = ze.length, Kr = createTypedArray("float32", Jr), Zr = 0;
                Zr < Jr;
                Zr += 1
              )
                Kr[Zr] = Wr * ze[Zr];
              return Kr;
            }
            return 0;
          }
          function div(Wr, ze) {
            var Gr = _typeof$1(Wr),
              Yr = _typeof$1(ze),
              Kr;
            if (isNumerable(Gr, Wr) && isNumerable(Yr, ze)) return Wr / ze;
            var Zr, Jr;
            if ($bm_isInstanceOfArray(Wr) && isNumerable(Yr, ze)) {
              for (
                Jr = Wr.length, Kr = createTypedArray("float32", Jr), Zr = 0;
                Zr < Jr;
                Zr += 1
              )
                Kr[Zr] = Wr[Zr] / ze;
              return Kr;
            }
            if (isNumerable(Gr, Wr) && $bm_isInstanceOfArray(ze)) {
              for (
                Jr = ze.length, Kr = createTypedArray("float32", Jr), Zr = 0;
                Zr < Jr;
                Zr += 1
              )
                Kr[Zr] = Wr / ze[Zr];
              return Kr;
            }
            return 0;
          }
          function mod(Wr, ze) {
            return (
              typeof Wr == "string" && (Wr = parseInt(Wr, 10)),
              typeof ze == "string" && (ze = parseInt(ze, 10)),
              Wr % ze
            );
          }
          var $bm_sum = sum,
            $bm_sub = sub,
            $bm_mul = mul,
            $bm_div = div,
            $bm_mod = mod;
          function clamp(Wr, ze, Gr) {
            if (ze > Gr) {
              var Yr = Gr;
              (Gr = ze), (ze = Yr);
            }
            return Math.min(Math.max(Wr, ze), Gr);
          }
          function radiansToDegrees(Wr) {
            return Wr / degToRads;
          }
          var radians_to_degrees = radiansToDegrees;
          function degreesToRadians(Wr) {
            return Wr * degToRads;
          }
          var degrees_to_radians = radiansToDegrees,
            helperLengthArray = [0, 0, 0, 0, 0, 0];
          function length(Wr, ze) {
            if (typeof Wr == "number" || Wr instanceof Number)
              return (ze = ze || 0), Math.abs(Wr - ze);
            ze || (ze = helperLengthArray);
            var Gr,
              Yr = Math.min(Wr.length, ze.length),
              Kr = 0;
            for (Gr = 0; Gr < Yr; Gr += 1) Kr += Math.pow(ze[Gr] - Wr[Gr], 2);
            return Math.sqrt(Kr);
          }
          function normalize(Wr) {
            return div(Wr, length(Wr));
          }
          function rgbToHsl(Wr) {
            var ze = Wr[0],
              Gr = Wr[1],
              Yr = Wr[2],
              Kr = Math.max(ze, Gr, Yr),
              Zr = Math.min(ze, Gr, Yr),
              Jr,
              Qr,
              ei = (Kr + Zr) / 2;
            if (Kr === Zr) (Jr = 0), (Qr = 0);
            else {
              var ti = Kr - Zr;
              switch (
                ((Qr = ei > 0.5 ? ti / (2 - Kr - Zr) : ti / (Kr + Zr)), Kr)
              ) {
                case ze:
                  Jr = (Gr - Yr) / ti + (Gr < Yr ? 6 : 0);
                  break;
                case Gr:
                  Jr = (Yr - ze) / ti + 2;
                  break;
                case Yr:
                  Jr = (ze - Gr) / ti + 4;
                  break;
              }
              Jr /= 6;
            }
            return [Jr, Qr, ei, Wr[3]];
          }
          function hue2rgb(Wr, ze, Gr) {
            return (
              Gr < 0 && (Gr += 1),
              Gr > 1 && (Gr -= 1),
              Gr < 1 / 6
                ? Wr + (ze - Wr) * 6 * Gr
                : Gr < 1 / 2
                ? ze
                : Gr < 2 / 3
                ? Wr + (ze - Wr) * (2 / 3 - Gr) * 6
                : Wr
            );
          }
          function hslToRgb(Wr) {
            var ze = Wr[0],
              Gr = Wr[1],
              Yr = Wr[2],
              Kr,
              Zr,
              Jr;
            if (Gr === 0) (Kr = Yr), (Jr = Yr), (Zr = Yr);
            else {
              var Qr = Yr < 0.5 ? Yr * (1 + Gr) : Yr + Gr - Yr * Gr,
                ei = 2 * Yr - Qr;
              (Kr = hue2rgb(ei, Qr, ze + 1 / 3)),
                (Zr = hue2rgb(ei, Qr, ze)),
                (Jr = hue2rgb(ei, Qr, ze - 1 / 3));
            }
            return [Kr, Zr, Jr, Wr[3]];
          }
          function linear(Wr, ze, Gr, Yr, Kr) {
            if (
              ((Yr === void 0 || Kr === void 0) &&
                ((Yr = ze), (Kr = Gr), (ze = 0), (Gr = 1)),
              Gr < ze)
            ) {
              var Zr = Gr;
              (Gr = ze), (ze = Zr);
            }
            if (Wr <= ze) return Yr;
            if (Wr >= Gr) return Kr;
            var Jr = Gr === ze ? 0 : (Wr - ze) / (Gr - ze);
            if (!Yr.length) return Yr + (Kr - Yr) * Jr;
            var Qr,
              ei = Yr.length,
              ti = createTypedArray("float32", ei);
            for (Qr = 0; Qr < ei; Qr += 1)
              ti[Qr] = Yr[Qr] + (Kr[Qr] - Yr[Qr]) * Jr;
            return ti;
          }
          function random(Wr, ze) {
            if (
              (ze === void 0 &&
                (Wr === void 0
                  ? ((Wr = 0), (ze = 1))
                  : ((ze = Wr), (Wr = void 0))),
              ze.length)
            ) {
              var Gr,
                Yr = ze.length;
              Wr || (Wr = createTypedArray("float32", Yr));
              var Kr = createTypedArray("float32", Yr),
                Zr = BMMath.random();
              for (Gr = 0; Gr < Yr; Gr += 1)
                Kr[Gr] = Wr[Gr] + Zr * (ze[Gr] - Wr[Gr]);
              return Kr;
            }
            Wr === void 0 && (Wr = 0);
            var Jr = BMMath.random();
            return Wr + Jr * (ze - Wr);
          }
          function createPath(Wr, ze, Gr, Yr) {
            var Kr,
              Zr = Wr.length,
              Jr = shapePool.newElement();
            Jr.setPathData(!!Yr, Zr);
            var Qr = [0, 0],
              ei,
              ti;
            for (Kr = 0; Kr < Zr; Kr += 1)
              (ei = ze && ze[Kr] ? ze[Kr] : Qr),
                (ti = Gr && Gr[Kr] ? Gr[Kr] : Qr),
                Jr.setTripleAt(
                  Wr[Kr][0],
                  Wr[Kr][1],
                  ti[0] + Wr[Kr][0],
                  ti[1] + Wr[Kr][1],
                  ei[0] + Wr[Kr][0],
                  ei[1] + Wr[Kr][1],
                  Kr,
                  !0
                );
            return Jr;
          }
          function initiateExpression(elem, data, property) {
            function noOp(Wr) {
              return Wr;
            }
            if (!elem.globalData.renderConfig.runExpressions) return noOp;
            var val = data.x,
              needsVelocity = /velocity(?![\w\d])/.test(val),
              _needsRandom = val.indexOf("random") !== -1,
              elemType = elem.data.ty,
              transform,
              $bm_transform,
              content,
              effect,
              thisProperty = property;
            (thisProperty.valueAtTime = thisProperty.getValueAtTime),
              Object.defineProperty(thisProperty, "value", {
                get: function () {
                  return thisProperty.v;
                },
              }),
              (elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate),
              (elem.comp.displayStartTime = 0);
            var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
              outPoint = elem.data.op / elem.comp.globalData.frameRate,
              width = elem.data.sw ? elem.data.sw : 0,
              height = elem.data.sh ? elem.data.sh : 0,
              name = elem.data.nm,
              loopIn,
              loop_in,
              loopOut,
              loop_out,
              smooth,
              toWorld,
              fromWorld,
              fromComp,
              toComp,
              fromCompToSurface,
              position,
              rotation,
              anchorPoint,
              scale,
              thisLayer,
              thisComp,
              mask,
              valueAtTime,
              velocityAtTime,
              scoped_bm_rt,
              expression_function = eval(
                "[function _expression_function(){" +
                  val +
                  ";scoped_bm_rt=$bm_rt}]"
              )[0],
              numKeys = property.kf ? data.k.length : 0,
              active = !this.data || this.data.hd !== !0,
              wiggle = function Wr(ze, Gr) {
                var Yr,
                  Kr,
                  Zr = this.pv.length ? this.pv.length : 1,
                  Jr = createTypedArray("float32", Zr);
                ze = 5;
                var Qr = Math.floor(time * ze);
                for (Yr = 0, Kr = 0; Yr < Qr; ) {
                  for (Kr = 0; Kr < Zr; Kr += 1)
                    Jr[Kr] += -Gr + Gr * 2 * BMMath.random();
                  Yr += 1;
                }
                var ei = time * ze,
                  ti = ei - Math.floor(ei),
                  ri = createTypedArray("float32", Zr);
                if (Zr > 1) {
                  for (Kr = 0; Kr < Zr; Kr += 1)
                    ri[Kr] =
                      this.pv[Kr] +
                      Jr[Kr] +
                      (-Gr + Gr * 2 * BMMath.random()) * ti;
                  return ri;
                }
                return this.pv + Jr[0] + (-Gr + Gr * 2 * BMMath.random()) * ti;
              }.bind(this);
            thisProperty.loopIn &&
              ((loopIn = thisProperty.loopIn.bind(thisProperty)),
              (loop_in = loopIn)),
              thisProperty.loopOut &&
                ((loopOut = thisProperty.loopOut.bind(thisProperty)),
                (loop_out = loopOut)),
              thisProperty.smooth &&
                (smooth = thisProperty.smooth.bind(thisProperty));
            function loopInDuration(Wr, ze) {
              return loopIn(Wr, ze, !0);
            }
            function loopOutDuration(Wr, ze) {
              return loopOut(Wr, ze, !0);
            }
            this.getValueAtTime &&
              (valueAtTime = this.getValueAtTime.bind(this)),
              this.getVelocityAtTime &&
                (velocityAtTime = this.getVelocityAtTime.bind(this));
            var comp = elem.comp.globalData.projectInterface.bind(
              elem.comp.globalData.projectInterface
            );
            function lookAt(Wr, ze) {
              var Gr = [ze[0] - Wr[0], ze[1] - Wr[1], ze[2] - Wr[2]],
                Yr =
                  Math.atan2(Gr[0], Math.sqrt(Gr[1] * Gr[1] + Gr[2] * Gr[2])) /
                  degToRads,
                Kr = -Math.atan2(Gr[1], Gr[2]) / degToRads;
              return [Kr, Yr, 0];
            }
            function easeOut(Wr, ze, Gr, Yr, Kr) {
              return applyEase(easeOutBez, Wr, ze, Gr, Yr, Kr);
            }
            function easeIn(Wr, ze, Gr, Yr, Kr) {
              return applyEase(easeInBez, Wr, ze, Gr, Yr, Kr);
            }
            function ease(Wr, ze, Gr, Yr, Kr) {
              return applyEase(easeInOutBez, Wr, ze, Gr, Yr, Kr);
            }
            function applyEase(Wr, ze, Gr, Yr, Kr, Zr) {
              Kr === void 0
                ? ((Kr = Gr), (Zr = Yr))
                : (ze = (ze - Gr) / (Yr - Gr)),
                ze > 1 ? (ze = 1) : ze < 0 && (ze = 0);
              var Jr = Wr(ze);
              if ($bm_isInstanceOfArray(Kr)) {
                var Qr,
                  ei = Kr.length,
                  ti = createTypedArray("float32", ei);
                for (Qr = 0; Qr < ei; Qr += 1)
                  ti[Qr] = (Zr[Qr] - Kr[Qr]) * Jr + Kr[Qr];
                return ti;
              }
              return (Zr - Kr) * Jr + Kr;
            }
            function nearestKey(Wr) {
              var ze,
                Gr = data.k.length,
                Yr,
                Kr;
              if (!data.k.length || typeof data.k[0] == "number")
                (Yr = 0), (Kr = 0);
              else if (
                ((Yr = -1),
                (Wr *= elem.comp.globalData.frameRate),
                Wr < data.k[0].t)
              )
                (Yr = 1), (Kr = data.k[0].t);
              else {
                for (ze = 0; ze < Gr - 1; ze += 1)
                  if (Wr === data.k[ze].t) {
                    (Yr = ze + 1), (Kr = data.k[ze].t);
                    break;
                  } else if (Wr > data.k[ze].t && Wr < data.k[ze + 1].t) {
                    Wr - data.k[ze].t > data.k[ze + 1].t - Wr
                      ? ((Yr = ze + 2), (Kr = data.k[ze + 1].t))
                      : ((Yr = ze + 1), (Kr = data.k[ze].t));
                    break;
                  }
                Yr === -1 && ((Yr = ze + 1), (Kr = data.k[ze].t));
              }
              var Zr = {};
              return (
                (Zr.index = Yr),
                (Zr.time = Kr / elem.comp.globalData.frameRate),
                Zr
              );
            }
            function key(Wr) {
              var ze, Gr, Yr;
              if (!data.k.length || typeof data.k[0] == "number")
                throw new Error("The property has no keyframe at index " + Wr);
              (Wr -= 1),
                (ze = {
                  time: data.k[Wr].t / elem.comp.globalData.frameRate,
                  value: [],
                });
              var Kr = Object.prototype.hasOwnProperty.call(data.k[Wr], "s")
                ? data.k[Wr].s
                : data.k[Wr - 1].e;
              for (Yr = Kr.length, Gr = 0; Gr < Yr; Gr += 1)
                (ze[Gr] = Kr[Gr]), (ze.value[Gr] = Kr[Gr]);
              return ze;
            }
            function framesToTime(Wr, ze) {
              return ze || (ze = elem.comp.globalData.frameRate), Wr / ze;
            }
            function timeToFrames(Wr, ze) {
              return (
                !Wr && Wr !== 0 && (Wr = time),
                ze || (ze = elem.comp.globalData.frameRate),
                Wr * ze
              );
            }
            function seedRandom(Wr) {
              BMMath.seedrandom(randSeed + Wr);
            }
            function sourceRectAtTime() {
              return elem.sourceRectAtTime();
            }
            function substring(Wr, ze) {
              return typeof value == "string"
                ? ze === void 0
                  ? value.substring(Wr)
                  : value.substring(Wr, ze)
                : "";
            }
            function substr(Wr, ze) {
              return typeof value == "string"
                ? ze === void 0
                  ? value.substr(Wr)
                  : value.substr(Wr, ze)
                : "";
            }
            function posterizeTime(Wr) {
              (time = Wr === 0 ? 0 : Math.floor(time * Wr) / Wr),
                (value = valueAtTime(time));
            }
            var time,
              velocity,
              value,
              text,
              textIndex,
              textTotal,
              selectorValue,
              index = elem.data.ind,
              hasParent = !!(elem.hierarchy && elem.hierarchy.length),
              parent,
              randSeed = Math.floor(Math.random() * 1e6),
              globalData = elem.globalData;
            function executeExpression(Wr) {
              return (
                (value = Wr),
                this.frameExpressionId === elem.globalData.frameId &&
                this.propType !== "textSelector"
                  ? value
                  : (this.propType === "textSelector" &&
                      ((textIndex = this.textIndex),
                      (textTotal = this.textTotal),
                      (selectorValue = this.selectorValue)),
                    thisLayer ||
                      ((text = elem.layerInterface.text),
                      (thisLayer = elem.layerInterface),
                      (thisComp = elem.comp.compInterface),
                      (toWorld = thisLayer.toWorld.bind(thisLayer)),
                      (fromWorld = thisLayer.fromWorld.bind(thisLayer)),
                      (fromComp = thisLayer.fromComp.bind(thisLayer)),
                      (toComp = thisLayer.toComp.bind(thisLayer)),
                      (mask = thisLayer.mask
                        ? thisLayer.mask.bind(thisLayer)
                        : null),
                      (fromCompToSurface = fromComp)),
                    transform ||
                      ((transform = elem.layerInterface(
                        "ADBE Transform Group"
                      )),
                      ($bm_transform = transform),
                      transform && (anchorPoint = transform.anchorPoint)),
                    elemType === 4 &&
                      !content &&
                      (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    (hasParent = !!(elem.hierarchy && elem.hierarchy.length)),
                    hasParent &&
                      !parent &&
                      (parent = elem.hierarchy[0].layerInterface),
                    (time =
                      this.comp.renderedFrame / this.comp.globalData.frameRate),
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    (this.frameExpressionId = elem.globalData.frameId),
                    (scoped_bm_rt =
                      scoped_bm_rt.propType === propTypes.SHAPE
                        ? scoped_bm_rt.v
                        : scoped_bm_rt),
                    scoped_bm_rt)
              );
            }
            return (
              (executeExpression.__preventDeadCodeRemoval = [
                $bm_transform,
                anchorPoint,
                time,
                velocity,
                inPoint,
                outPoint,
                width,
                height,
                name,
                loop_in,
                loop_out,
                smooth,
                toComp,
                fromCompToSurface,
                toWorld,
                fromWorld,
                mask,
                position,
                rotation,
                scale,
                thisComp,
                numKeys,
                active,
                wiggle,
                loopInDuration,
                loopOutDuration,
                comp,
                lookAt,
                easeOut,
                easeIn,
                ease,
                nearestKey,
                key,
                text,
                textIndex,
                textTotal,
                selectorValue,
                framesToTime,
                timeToFrames,
                sourceRectAtTime,
                substring,
                substr,
                posterizeTime,
                index,
                globalData,
              ]),
              executeExpression
            );
          }
          return (
            (ob.initiateExpression = initiateExpression),
            (ob.__preventDeadCodeRemoval = [
              window,
              document,
              XMLHttpRequest,
              fetch,
              frames,
              $bm_neg,
              add,
              $bm_sum,
              $bm_sub,
              $bm_mul,
              $bm_div,
              $bm_mod,
              clamp,
              radians_to_degrees,
              degreesToRadians,
              degrees_to_radians,
              normalize,
              rgbToHsl,
              hslToRgb,
              linear,
              random,
              createPath,
              _lottieGlobal,
            ]),
            (ob.resetFrame = resetFrame),
            ob
          );
        })(),
        Expressions = (function () {
          var Wr = {};
          (Wr.initExpressions = ze),
            (Wr.resetFrame = ExpressionManager.resetFrame);
          function ze(Gr) {
            var Yr = 0,
              Kr = [];
            function Zr() {
              Yr += 1;
            }
            function Jr() {
              (Yr -= 1), Yr === 0 && ei();
            }
            function Qr(ti) {
              Kr.indexOf(ti) === -1 && Kr.push(ti);
            }
            function ei() {
              var ti,
                ri = Kr.length;
              for (ti = 0; ti < ri; ti += 1) Kr[ti].release();
              Kr.length = 0;
            }
            (Gr.renderer.compInterface = CompExpressionInterface(Gr.renderer)),
              Gr.renderer.globalData.projectInterface.registerComposition(
                Gr.renderer
              ),
              (Gr.renderer.globalData.pushExpression = Zr),
              (Gr.renderer.globalData.popExpression = Jr),
              (Gr.renderer.globalData.registerExpressionProperty = Qr);
          }
          return Wr;
        })(),
        MaskManagerInterface = (function () {
          function Wr(Gr, Yr) {
            (this._mask = Gr), (this._data = Yr);
          }
          Object.defineProperty(Wr.prototype, "maskPath", {
            get: function () {
              return (
                this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
              );
            },
          }),
            Object.defineProperty(Wr.prototype, "maskOpacity", {
              get: function () {
                return (
                  this._mask.op.k && this._mask.op.getValue(),
                  this._mask.op.v * 100
                );
              },
            });
          var ze = function (Yr) {
            var Kr = createSizedArray(Yr.viewData.length),
              Zr,
              Jr = Yr.viewData.length;
            for (Zr = 0; Zr < Jr; Zr += 1)
              Kr[Zr] = new Wr(Yr.viewData[Zr], Yr.masksProperties[Zr]);
            var Qr = function (ti) {
              for (Zr = 0; Zr < Jr; ) {
                if (Yr.masksProperties[Zr].nm === ti) return Kr[Zr];
                Zr += 1;
              }
              return null;
            };
            return Qr;
          };
          return ze;
        })(),
        ExpressionPropertyInterface = (function () {
          var Wr = {
              pv: 0,
              v: 0,
              mult: 1,
            },
            ze = {
              pv: [0, 0, 0],
              v: [0, 0, 0],
              mult: 1,
            };
          function Gr(Jr, Qr, ei) {
            Object.defineProperty(Jr, "velocity", {
              get: function () {
                return Qr.getVelocityAtTime(Qr.comp.currentFrame);
              },
            }),
              (Jr.numKeys = Qr.keyframes ? Qr.keyframes.length : 0),
              (Jr.key = function (ti) {
                if (!Jr.numKeys) return 0;
                var ri = "";
                "s" in Qr.keyframes[ti - 1]
                  ? (ri = Qr.keyframes[ti - 1].s)
                  : "e" in Qr.keyframes[ti - 2]
                  ? (ri = Qr.keyframes[ti - 2].e)
                  : (ri = Qr.keyframes[ti - 2].s);
                var ni =
                  ei === "unidimensional"
                    ? new Number(ri)
                    : Object.assign({}, ri);
                return (
                  (ni.time =
                    Qr.keyframes[ti - 1].t / Qr.elem.comp.globalData.frameRate),
                  (ni.value = ei === "unidimensional" ? ri[0] : ri),
                  ni
                );
              }),
              (Jr.valueAtTime = Qr.getValueAtTime),
              (Jr.speedAtTime = Qr.getSpeedAtTime),
              (Jr.velocityAtTime = Qr.getVelocityAtTime),
              (Jr.propertyGroup = Qr.propertyGroup);
          }
          function Yr(Jr) {
            (!Jr || !("pv" in Jr)) && (Jr = Wr);
            var Qr = 1 / Jr.mult,
              ei = Jr.pv * Qr,
              ti = new Number(ei);
            return (
              (ti.value = ei),
              Gr(ti, Jr, "unidimensional"),
              function () {
                return (
                  Jr.k && Jr.getValue(),
                  (ei = Jr.v * Qr),
                  ti.value !== ei &&
                    ((ti = new Number(ei)),
                    (ti.value = ei),
                    Gr(ti, Jr, "unidimensional")),
                  ti
                );
              }
            );
          }
          function Kr(Jr) {
            (!Jr || !("pv" in Jr)) && (Jr = ze);
            var Qr = 1 / Jr.mult,
              ei = (Jr.data && Jr.data.l) || Jr.pv.length,
              ti = createTypedArray("float32", ei),
              ri = createTypedArray("float32", ei);
            return (
              (ti.value = ri),
              Gr(ti, Jr, "multidimensional"),
              function () {
                Jr.k && Jr.getValue();
                for (var ni = 0; ni < ei; ni += 1)
                  (ri[ni] = Jr.v[ni] * Qr), (ti[ni] = ri[ni]);
                return ti;
              }
            );
          }
          function Zr() {
            return Wr;
          }
          return function (Jr) {
            return Jr
              ? Jr.propType === "unidimensional"
                ? Yr(Jr)
                : Kr(Jr)
              : Zr;
          };
        })(),
        TransformExpressionInterface = (function () {
          return function (Wr) {
            function ze(Jr) {
              switch (Jr) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                  return ze.scale;
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                  return ze.rotation;
                case "ADBE Rotate X":
                  return ze.xRotation;
                case "ADBE Rotate Y":
                  return ze.yRotation;
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                  return ze.position;
                case "ADBE Position_0":
                  return ze.xPosition;
                case "ADBE Position_1":
                  return ze.yPosition;
                case "ADBE Position_2":
                  return ze.zPosition;
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                  return ze.anchorPoint;
                case "opacity":
                case "Opacity":
                case 11:
                  return ze.opacity;
                default:
                  return null;
              }
            }
            Object.defineProperty(ze, "rotation", {
              get: ExpressionPropertyInterface(Wr.r || Wr.rz),
            }),
              Object.defineProperty(ze, "zRotation", {
                get: ExpressionPropertyInterface(Wr.rz || Wr.r),
              }),
              Object.defineProperty(ze, "xRotation", {
                get: ExpressionPropertyInterface(Wr.rx),
              }),
              Object.defineProperty(ze, "yRotation", {
                get: ExpressionPropertyInterface(Wr.ry),
              }),
              Object.defineProperty(ze, "scale", {
                get: ExpressionPropertyInterface(Wr.s),
              });
            var Gr, Yr, Kr, Zr;
            return (
              Wr.p
                ? (Zr = ExpressionPropertyInterface(Wr.p))
                : ((Gr = ExpressionPropertyInterface(Wr.px)),
                  (Yr = ExpressionPropertyInterface(Wr.py)),
                  Wr.pz && (Kr = ExpressionPropertyInterface(Wr.pz))),
              Object.defineProperty(ze, "position", {
                get: function () {
                  return Wr.p ? Zr() : [Gr(), Yr(), Kr ? Kr() : 0];
                },
              }),
              Object.defineProperty(ze, "xPosition", {
                get: ExpressionPropertyInterface(Wr.px),
              }),
              Object.defineProperty(ze, "yPosition", {
                get: ExpressionPropertyInterface(Wr.py),
              }),
              Object.defineProperty(ze, "zPosition", {
                get: ExpressionPropertyInterface(Wr.pz),
              }),
              Object.defineProperty(ze, "anchorPoint", {
                get: ExpressionPropertyInterface(Wr.a),
              }),
              Object.defineProperty(ze, "opacity", {
                get: ExpressionPropertyInterface(Wr.o),
              }),
              Object.defineProperty(ze, "skew", {
                get: ExpressionPropertyInterface(Wr.sk),
              }),
              Object.defineProperty(ze, "skewAxis", {
                get: ExpressionPropertyInterface(Wr.sa),
              }),
              Object.defineProperty(ze, "orientation", {
                get: ExpressionPropertyInterface(Wr.or),
              }),
              ze
            );
          };
        })(),
        LayerExpressionInterface = (function () {
          function Wr(ti) {
            var ri = new Matrix();
            if (ti !== void 0) {
              var ni = this._elem.finalTransform.mProp.getValueAtTime(ti);
              ni.clone(ri);
            } else {
              var ii = this._elem.finalTransform.mProp;
              ii.applyToMatrix(ri);
            }
            return ri;
          }
          function ze(ti, ri) {
            var ni = this.getMatrix(ri);
            return (
              (ni.props[12] = 0),
              (ni.props[13] = 0),
              (ni.props[14] = 0),
              this.applyPoint(ni, ti)
            );
          }
          function Gr(ti, ri) {
            var ni = this.getMatrix(ri);
            return this.applyPoint(ni, ti);
          }
          function Yr(ti, ri) {
            var ni = this.getMatrix(ri);
            return (
              (ni.props[12] = 0),
              (ni.props[13] = 0),
              (ni.props[14] = 0),
              this.invertPoint(ni, ti)
            );
          }
          function Kr(ti, ri) {
            var ni = this.getMatrix(ri);
            return this.invertPoint(ni, ti);
          }
          function Zr(ti, ri) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var ni,
                ii = this._elem.hierarchy.length;
              for (ni = 0; ni < ii; ni += 1)
                this._elem.hierarchy[ni].finalTransform.mProp.applyToMatrix(ti);
            }
            return ti.applyToPointArray(ri[0], ri[1], ri[2] || 0);
          }
          function Jr(ti, ri) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var ni,
                ii = this._elem.hierarchy.length;
              for (ni = 0; ni < ii; ni += 1)
                this._elem.hierarchy[ni].finalTransform.mProp.applyToMatrix(ti);
            }
            return ti.inversePoint(ri);
          }
          function Qr(ti) {
            var ri = new Matrix();
            if (
              (ri.reset(),
              this._elem.finalTransform.mProp.applyToMatrix(ri),
              this._elem.hierarchy && this._elem.hierarchy.length)
            ) {
              var ni,
                ii = this._elem.hierarchy.length;
              for (ni = 0; ni < ii; ni += 1)
                this._elem.hierarchy[ni].finalTransform.mProp.applyToMatrix(ri);
              return ri.inversePoint(ti);
            }
            return ri.inversePoint(ti);
          }
          function ei() {
            return [1, 1, 1, 1];
          }
          return function (ti) {
            var ri;
            function ni(oi) {
              si.mask = new MaskManagerInterface(oi, ti);
            }
            function ii(oi) {
              si.effect = oi;
            }
            function si(oi) {
              switch (oi) {
                case "ADBE Root Vectors Group":
                case "Contents":
                case 2:
                  return si.shapeInterface;
                case 1:
                case 6:
                case "Transform":
                case "transform":
                case "ADBE Transform Group":
                  return ri;
                case 4:
                case "ADBE Effect Parade":
                case "effects":
                case "Effects":
                  return si.effect;
                case "ADBE Text Properties":
                  return si.textInterface;
                default:
                  return null;
              }
            }
            (si.getMatrix = Wr),
              (si.invertPoint = Jr),
              (si.applyPoint = Zr),
              (si.toWorld = Gr),
              (si.toWorldVec = ze),
              (si.fromWorld = Kr),
              (si.fromWorldVec = Yr),
              (si.toComp = Gr),
              (si.fromComp = Qr),
              (si.sampleImage = ei),
              (si.sourceRectAtTime = ti.sourceRectAtTime.bind(ti)),
              (si._elem = ti),
              (ri = TransformExpressionInterface(ti.finalTransform.mProp));
            var li = getDescriptor(ri, "anchorPoint");
            return (
              Object.defineProperties(si, {
                hasParent: {
                  get: function () {
                    return ti.hierarchy.length;
                  },
                },
                parent: {
                  get: function () {
                    return ti.hierarchy[0].layerInterface;
                  },
                },
                rotation: getDescriptor(ri, "rotation"),
                scale: getDescriptor(ri, "scale"),
                position: getDescriptor(ri, "position"),
                opacity: getDescriptor(ri, "opacity"),
                anchorPoint: li,
                anchor_point: li,
                transform: {
                  get: function () {
                    return ri;
                  },
                },
                active: {
                  get: function () {
                    return ti.isInRange;
                  },
                },
              }),
              (si.startTime = ti.data.st),
              (si.index = ti.data.ind),
              (si.source = ti.data.refId),
              (si.height = ti.data.ty === 0 ? ti.data.h : 100),
              (si.width = ti.data.ty === 0 ? ti.data.w : 100),
              (si.inPoint = ti.data.ip / ti.comp.globalData.frameRate),
              (si.outPoint = ti.data.op / ti.comp.globalData.frameRate),
              (si._name = ti.data.nm),
              (si.registerMaskInterface = ni),
              (si.registerEffectsInterface = ii),
              si
            );
          };
        })(),
        propertyGroupFactory = (function () {
          return function (Wr, ze) {
            return function (Gr) {
              return (Gr = Gr === void 0 ? 1 : Gr), Gr <= 0 ? Wr : ze(Gr - 1);
            };
          };
        })(),
        PropertyInterface = (function () {
          return function (Wr, ze) {
            var Gr = {
              _name: Wr,
            };
            function Yr(Kr) {
              return (Kr = Kr === void 0 ? 1 : Kr), Kr <= 0 ? Gr : ze(Kr - 1);
            }
            return Yr;
          };
        })(),
        EffectsExpressionInterface = (function () {
          var Wr = {
            createEffectsInterface: ze,
          };
          function ze(Kr, Zr) {
            if (Kr.effectsManager) {
              var Jr = [],
                Qr = Kr.data.ef,
                ei,
                ti = Kr.effectsManager.effectElements.length;
              for (ei = 0; ei < ti; ei += 1)
                Jr.push(
                  Gr(Qr[ei], Kr.effectsManager.effectElements[ei], Zr, Kr)
                );
              var ri = Kr.data.ef || [],
                ni = function (si) {
                  for (ei = 0, ti = ri.length; ei < ti; ) {
                    if (
                      si === ri[ei].nm ||
                      si === ri[ei].mn ||
                      si === ri[ei].ix
                    )
                      return Jr[ei];
                    ei += 1;
                  }
                  return null;
                };
              return (
                Object.defineProperty(ni, "numProperties", {
                  get: function () {
                    return ri.length;
                  },
                }),
                ni
              );
            }
            return null;
          }
          function Gr(Kr, Zr, Jr, Qr) {
            function ei(si) {
              for (var li = Kr.ef, oi = 0, ui = li.length; oi < ui; ) {
                if (si === li[oi].nm || si === li[oi].mn || si === li[oi].ix)
                  return li[oi].ty === 5 ? ri[oi] : ri[oi]();
                oi += 1;
              }
              throw new Error();
            }
            var ti = propertyGroupFactory(ei, Jr),
              ri = [],
              ni,
              ii = Kr.ef.length;
            for (ni = 0; ni < ii; ni += 1)
              Kr.ef[ni].ty === 5
                ? ri.push(
                    Gr(
                      Kr.ef[ni],
                      Zr.effectElements[ni],
                      Zr.effectElements[ni].propertyGroup,
                      Qr
                    )
                  )
                : ri.push(Yr(Zr.effectElements[ni], Kr.ef[ni].ty, Qr, ti));
            return (
              Kr.mn === "ADBE Color Control" &&
                Object.defineProperty(ei, "color", {
                  get: function () {
                    return ri[0]();
                  },
                }),
              Object.defineProperties(ei, {
                numProperties: {
                  get: function () {
                    return Kr.np;
                  },
                },
                _name: {
                  value: Kr.nm,
                },
                propertyGroup: {
                  value: ti,
                },
              }),
              (ei.enabled = Kr.en !== 0),
              (ei.active = ei.enabled),
              ei
            );
          }
          function Yr(Kr, Zr, Jr, Qr) {
            var ei = ExpressionPropertyInterface(Kr.p);
            function ti() {
              return Zr === 10 ? Jr.comp.compInterface(Kr.p.v) : ei();
            }
            return (
              Kr.p.setGroupProperty &&
                Kr.p.setGroupProperty(PropertyInterface("", Qr)),
              ti
            );
          }
          return Wr;
        })(),
        ShapePathInterface = (function () {
          return function (ze, Gr, Yr) {
            var Kr = Gr.sh;
            function Zr(Qr) {
              return Qr === "Shape" ||
                Qr === "shape" ||
                Qr === "Path" ||
                Qr === "path" ||
                Qr === "ADBE Vector Shape" ||
                Qr === 2
                ? Zr.path
                : null;
            }
            var Jr = propertyGroupFactory(Zr, Yr);
            return (
              Kr.setGroupProperty(PropertyInterface("Path", Jr)),
              Object.defineProperties(Zr, {
                path: {
                  get: function () {
                    return Kr.k && Kr.getValue(), Kr;
                  },
                },
                shape: {
                  get: function () {
                    return Kr.k && Kr.getValue(), Kr;
                  },
                },
                _name: {
                  value: ze.nm,
                },
                ix: {
                  value: ze.ix,
                },
                propertyIndex: {
                  value: ze.ix,
                },
                mn: {
                  value: ze.mn,
                },
                propertyGroup: {
                  value: Yr,
                },
              }),
              Zr
            );
          };
        })(),
        ShapeExpressionInterface = (function () {
          function Wr(li, oi, ui) {
            var ai = [],
              hi,
              ci = li ? li.length : 0;
            for (hi = 0; hi < ci; hi += 1)
              li[hi].ty === "gr"
                ? ai.push(Gr(li[hi], oi[hi], ui))
                : li[hi].ty === "fl"
                ? ai.push(Yr(li[hi], oi[hi], ui))
                : li[hi].ty === "st"
                ? ai.push(Jr(li[hi], oi[hi], ui))
                : li[hi].ty === "tm"
                ? ai.push(Qr(li[hi], oi[hi], ui))
                : li[hi].ty === "tr" ||
                  (li[hi].ty === "el"
                    ? ai.push(ti(li[hi], oi[hi], ui))
                    : li[hi].ty === "sr"
                    ? ai.push(ri(li[hi], oi[hi], ui))
                    : li[hi].ty === "sh"
                    ? ai.push(ShapePathInterface(li[hi], oi[hi], ui))
                    : li[hi].ty === "rc"
                    ? ai.push(ni(li[hi], oi[hi], ui))
                    : li[hi].ty === "rd"
                    ? ai.push(ii(li[hi], oi[hi], ui))
                    : li[hi].ty === "rp"
                    ? ai.push(si(li[hi], oi[hi], ui))
                    : li[hi].ty === "gf"
                    ? ai.push(Kr(li[hi], oi[hi], ui))
                    : ai.push(Zr(li[hi], oi[hi])));
            return ai;
          }
          function ze(li, oi, ui) {
            var ai,
              hi = function (di) {
                for (var pi = 0, mi = ai.length; pi < mi; ) {
                  if (
                    ai[pi]._name === di ||
                    ai[pi].mn === di ||
                    ai[pi].propertyIndex === di ||
                    ai[pi].ix === di ||
                    ai[pi].ind === di
                  )
                    return ai[pi];
                  pi += 1;
                }
                return typeof di == "number" ? ai[di - 1] : null;
              };
            (hi.propertyGroup = propertyGroupFactory(hi, ui)),
              (ai = Wr(li.it, oi.it, hi.propertyGroup)),
              (hi.numProperties = ai.length);
            var ci = ei(
              li.it[li.it.length - 1],
              oi.it[oi.it.length - 1],
              hi.propertyGroup
            );
            return (
              (hi.transform = ci),
              (hi.propertyIndex = li.cix),
              (hi._name = li.nm),
              hi
            );
          }
          function Gr(li, oi, ui) {
            var ai = function (di) {
              switch (di) {
                case "ADBE Vectors Group":
                case "Contents":
                case 2:
                  return ai.content;
                default:
                  return ai.transform;
              }
            };
            ai.propertyGroup = propertyGroupFactory(ai, ui);
            var hi = ze(li, oi, ai.propertyGroup),
              ci = ei(
                li.it[li.it.length - 1],
                oi.it[oi.it.length - 1],
                ai.propertyGroup
              );
            return (
              (ai.content = hi),
              (ai.transform = ci),
              Object.defineProperty(ai, "_name", {
                get: function () {
                  return li.nm;
                },
              }),
              (ai.numProperties = li.np),
              (ai.propertyIndex = li.ix),
              (ai.nm = li.nm),
              (ai.mn = li.mn),
              ai
            );
          }
          function Yr(li, oi, ui) {
            function ai(hi) {
              return hi === "Color" || hi === "color"
                ? ai.color
                : hi === "Opacity" || hi === "opacity"
                ? ai.opacity
                : null;
            }
            return (
              Object.defineProperties(ai, {
                color: {
                  get: ExpressionPropertyInterface(oi.c),
                },
                opacity: {
                  get: ExpressionPropertyInterface(oi.o),
                },
                _name: {
                  value: li.nm,
                },
                mn: {
                  value: li.mn,
                },
              }),
              oi.c.setGroupProperty(PropertyInterface("Color", ui)),
              oi.o.setGroupProperty(PropertyInterface("Opacity", ui)),
              ai
            );
          }
          function Kr(li, oi, ui) {
            function ai(hi) {
              return hi === "Start Point" || hi === "start point"
                ? ai.startPoint
                : hi === "End Point" || hi === "end point"
                ? ai.endPoint
                : hi === "Opacity" || hi === "opacity"
                ? ai.opacity
                : null;
            }
            return (
              Object.defineProperties(ai, {
                startPoint: {
                  get: ExpressionPropertyInterface(oi.s),
                },
                endPoint: {
                  get: ExpressionPropertyInterface(oi.e),
                },
                opacity: {
                  get: ExpressionPropertyInterface(oi.o),
                },
                type: {
                  get: function () {
                    return "a";
                  },
                },
                _name: {
                  value: li.nm,
                },
                mn: {
                  value: li.mn,
                },
              }),
              oi.s.setGroupProperty(PropertyInterface("Start Point", ui)),
              oi.e.setGroupProperty(PropertyInterface("End Point", ui)),
              oi.o.setGroupProperty(PropertyInterface("Opacity", ui)),
              ai
            );
          }
          function Zr() {
            function li() {
              return null;
            }
            return li;
          }
          function Jr(li, oi, ui) {
            var ai = propertyGroupFactory(mi, ui),
              hi = propertyGroupFactory(pi, ai);
            function ci(Si) {
              Object.defineProperty(pi, li.d[Si].nm, {
                get: ExpressionPropertyInterface(oi.d.dataProps[Si].p),
              });
            }
            var fi,
              di = li.d ? li.d.length : 0,
              pi = {};
            for (fi = 0; fi < di; fi += 1)
              ci(fi), oi.d.dataProps[fi].p.setGroupProperty(hi);
            function mi(Si) {
              return Si === "Color" || Si === "color"
                ? mi.color
                : Si === "Opacity" || Si === "opacity"
                ? mi.opacity
                : Si === "Stroke Width" || Si === "stroke width"
                ? mi.strokeWidth
                : null;
            }
            return (
              Object.defineProperties(mi, {
                color: {
                  get: ExpressionPropertyInterface(oi.c),
                },
                opacity: {
                  get: ExpressionPropertyInterface(oi.o),
                },
                strokeWidth: {
                  get: ExpressionPropertyInterface(oi.w),
                },
                dash: {
                  get: function () {
                    return pi;
                  },
                },
                _name: {
                  value: li.nm,
                },
                mn: {
                  value: li.mn,
                },
              }),
              oi.c.setGroupProperty(PropertyInterface("Color", ai)),
              oi.o.setGroupProperty(PropertyInterface("Opacity", ai)),
              oi.w.setGroupProperty(PropertyInterface("Stroke Width", ai)),
              mi
            );
          }
          function Qr(li, oi, ui) {
            function ai(ci) {
              return ci === li.e.ix || ci === "End" || ci === "end"
                ? ai.end
                : ci === li.s.ix
                ? ai.start
                : ci === li.o.ix
                ? ai.offset
                : null;
            }
            var hi = propertyGroupFactory(ai, ui);
            return (
              (ai.propertyIndex = li.ix),
              oi.s.setGroupProperty(PropertyInterface("Start", hi)),
              oi.e.setGroupProperty(PropertyInterface("End", hi)),
              oi.o.setGroupProperty(PropertyInterface("Offset", hi)),
              (ai.propertyIndex = li.ix),
              (ai.propertyGroup = ui),
              Object.defineProperties(ai, {
                start: {
                  get: ExpressionPropertyInterface(oi.s),
                },
                end: {
                  get: ExpressionPropertyInterface(oi.e),
                },
                offset: {
                  get: ExpressionPropertyInterface(oi.o),
                },
                _name: {
                  value: li.nm,
                },
              }),
              (ai.mn = li.mn),
              ai
            );
          }
          function ei(li, oi, ui) {
            function ai(ci) {
              return li.a.ix === ci || ci === "Anchor Point"
                ? ai.anchorPoint
                : li.o.ix === ci || ci === "Opacity"
                ? ai.opacity
                : li.p.ix === ci || ci === "Position"
                ? ai.position
                : li.r.ix === ci ||
                  ci === "Rotation" ||
                  ci === "ADBE Vector Rotation"
                ? ai.rotation
                : li.s.ix === ci || ci === "Scale"
                ? ai.scale
                : (li.sk && li.sk.ix === ci) || ci === "Skew"
                ? ai.skew
                : (li.sa && li.sa.ix === ci) || ci === "Skew Axis"
                ? ai.skewAxis
                : null;
            }
            var hi = propertyGroupFactory(ai, ui);
            return (
              oi.transform.mProps.o.setGroupProperty(
                PropertyInterface("Opacity", hi)
              ),
              oi.transform.mProps.p.setGroupProperty(
                PropertyInterface("Position", hi)
              ),
              oi.transform.mProps.a.setGroupProperty(
                PropertyInterface("Anchor Point", hi)
              ),
              oi.transform.mProps.s.setGroupProperty(
                PropertyInterface("Scale", hi)
              ),
              oi.transform.mProps.r.setGroupProperty(
                PropertyInterface("Rotation", hi)
              ),
              oi.transform.mProps.sk &&
                (oi.transform.mProps.sk.setGroupProperty(
                  PropertyInterface("Skew", hi)
                ),
                oi.transform.mProps.sa.setGroupProperty(
                  PropertyInterface("Skew Angle", hi)
                )),
              oi.transform.op.setGroupProperty(
                PropertyInterface("Opacity", hi)
              ),
              Object.defineProperties(ai, {
                opacity: {
                  get: ExpressionPropertyInterface(oi.transform.mProps.o),
                },
                position: {
                  get: ExpressionPropertyInterface(oi.transform.mProps.p),
                },
                anchorPoint: {
                  get: ExpressionPropertyInterface(oi.transform.mProps.a),
                },
                scale: {
                  get: ExpressionPropertyInterface(oi.transform.mProps.s),
                },
                rotation: {
                  get: ExpressionPropertyInterface(oi.transform.mProps.r),
                },
                skew: {
                  get: ExpressionPropertyInterface(oi.transform.mProps.sk),
                },
                skewAxis: {
                  get: ExpressionPropertyInterface(oi.transform.mProps.sa),
                },
                _name: {
                  value: li.nm,
                },
              }),
              (ai.ty = "tr"),
              (ai.mn = li.mn),
              (ai.propertyGroup = ui),
              ai
            );
          }
          function ti(li, oi, ui) {
            function ai(fi) {
              return li.p.ix === fi
                ? ai.position
                : li.s.ix === fi
                ? ai.size
                : null;
            }
            var hi = propertyGroupFactory(ai, ui);
            ai.propertyIndex = li.ix;
            var ci = oi.sh.ty === "tm" ? oi.sh.prop : oi.sh;
            return (
              ci.s.setGroupProperty(PropertyInterface("Size", hi)),
              ci.p.setGroupProperty(PropertyInterface("Position", hi)),
              Object.defineProperties(ai, {
                size: {
                  get: ExpressionPropertyInterface(ci.s),
                },
                position: {
                  get: ExpressionPropertyInterface(ci.p),
                },
                _name: {
                  value: li.nm,
                },
              }),
              (ai.mn = li.mn),
              ai
            );
          }
          function ri(li, oi, ui) {
            function ai(fi) {
              return li.p.ix === fi
                ? ai.position
                : li.r.ix === fi
                ? ai.rotation
                : li.pt.ix === fi
                ? ai.points
                : li.or.ix === fi || fi === "ADBE Vector Star Outer Radius"
                ? ai.outerRadius
                : li.os.ix === fi
                ? ai.outerRoundness
                : li.ir &&
                  (li.ir.ix === fi || fi === "ADBE Vector Star Inner Radius")
                ? ai.innerRadius
                : li.is && li.is.ix === fi
                ? ai.innerRoundness
                : null;
            }
            var hi = propertyGroupFactory(ai, ui),
              ci = oi.sh.ty === "tm" ? oi.sh.prop : oi.sh;
            return (
              (ai.propertyIndex = li.ix),
              ci.or.setGroupProperty(PropertyInterface("Outer Radius", hi)),
              ci.os.setGroupProperty(PropertyInterface("Outer Roundness", hi)),
              ci.pt.setGroupProperty(PropertyInterface("Points", hi)),
              ci.p.setGroupProperty(PropertyInterface("Position", hi)),
              ci.r.setGroupProperty(PropertyInterface("Rotation", hi)),
              li.ir &&
                (ci.ir.setGroupProperty(PropertyInterface("Inner Radius", hi)),
                ci.is.setGroupProperty(
                  PropertyInterface("Inner Roundness", hi)
                )),
              Object.defineProperties(ai, {
                position: {
                  get: ExpressionPropertyInterface(ci.p),
                },
                rotation: {
                  get: ExpressionPropertyInterface(ci.r),
                },
                points: {
                  get: ExpressionPropertyInterface(ci.pt),
                },
                outerRadius: {
                  get: ExpressionPropertyInterface(ci.or),
                },
                outerRoundness: {
                  get: ExpressionPropertyInterface(ci.os),
                },
                innerRadius: {
                  get: ExpressionPropertyInterface(ci.ir),
                },
                innerRoundness: {
                  get: ExpressionPropertyInterface(ci.is),
                },
                _name: {
                  value: li.nm,
                },
              }),
              (ai.mn = li.mn),
              ai
            );
          }
          function ni(li, oi, ui) {
            function ai(fi) {
              return li.p.ix === fi
                ? ai.position
                : li.r.ix === fi
                ? ai.roundness
                : li.s.ix === fi ||
                  fi === "Size" ||
                  fi === "ADBE Vector Rect Size"
                ? ai.size
                : null;
            }
            var hi = propertyGroupFactory(ai, ui),
              ci = oi.sh.ty === "tm" ? oi.sh.prop : oi.sh;
            return (
              (ai.propertyIndex = li.ix),
              ci.p.setGroupProperty(PropertyInterface("Position", hi)),
              ci.s.setGroupProperty(PropertyInterface("Size", hi)),
              ci.r.setGroupProperty(PropertyInterface("Rotation", hi)),
              Object.defineProperties(ai, {
                position: {
                  get: ExpressionPropertyInterface(ci.p),
                },
                roundness: {
                  get: ExpressionPropertyInterface(ci.r),
                },
                size: {
                  get: ExpressionPropertyInterface(ci.s),
                },
                _name: {
                  value: li.nm,
                },
              }),
              (ai.mn = li.mn),
              ai
            );
          }
          function ii(li, oi, ui) {
            function ai(fi) {
              return li.r.ix === fi || fi === "Round Corners 1"
                ? ai.radius
                : null;
            }
            var hi = propertyGroupFactory(ai, ui),
              ci = oi;
            return (
              (ai.propertyIndex = li.ix),
              ci.rd.setGroupProperty(PropertyInterface("Radius", hi)),
              Object.defineProperties(ai, {
                radius: {
                  get: ExpressionPropertyInterface(ci.rd),
                },
                _name: {
                  value: li.nm,
                },
              }),
              (ai.mn = li.mn),
              ai
            );
          }
          function si(li, oi, ui) {
            function ai(fi) {
              return li.c.ix === fi || fi === "Copies"
                ? ai.copies
                : li.o.ix === fi || fi === "Offset"
                ? ai.offset
                : null;
            }
            var hi = propertyGroupFactory(ai, ui),
              ci = oi;
            return (
              (ai.propertyIndex = li.ix),
              ci.c.setGroupProperty(PropertyInterface("Copies", hi)),
              ci.o.setGroupProperty(PropertyInterface("Offset", hi)),
              Object.defineProperties(ai, {
                copies: {
                  get: ExpressionPropertyInterface(ci.c),
                },
                offset: {
                  get: ExpressionPropertyInterface(ci.o),
                },
                _name: {
                  value: li.nm,
                },
              }),
              (ai.mn = li.mn),
              ai
            );
          }
          return function (li, oi, ui) {
            var ai;
            function hi(fi) {
              if (typeof fi == "number")
                return (
                  (fi = fi === void 0 ? 1 : fi), fi === 0 ? ui : ai[fi - 1]
                );
              for (var di = 0, pi = ai.length; di < pi; ) {
                if (ai[di]._name === fi) return ai[di];
                di += 1;
              }
              return null;
            }
            function ci() {
              return ui;
            }
            return (
              (hi.propertyGroup = propertyGroupFactory(hi, ci)),
              (ai = Wr(li, oi, hi.propertyGroup)),
              (hi.numProperties = ai.length),
              (hi._name = "Contents"),
              hi
            );
          };
        })(),
        TextExpressionInterface = (function () {
          return function (Wr) {
            var ze;
            function Gr(Yr) {
              switch (Yr) {
                case "ADBE Text Document":
                  return Gr.sourceText;
                default:
                  return null;
              }
            }
            return (
              Object.defineProperty(Gr, "sourceText", {
                get: function () {
                  Wr.textProperty.getValue();
                  var Kr = Wr.textProperty.currentData.t;
                  return (
                    (!ze || Kr !== ze.value) &&
                      ((ze = new String(Kr)),
                      (ze.value = Kr || new String(Kr)),
                      Object.defineProperty(ze, "style", {
                        get: function () {
                          return {
                            fillColor: Wr.textProperty.currentData.fc,
                          };
                        },
                      })),
                    ze
                  );
                },
              }),
              Gr
            );
          };
        })();
      function _typeof(Wr) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof = function (Gr) {
                return typeof Gr;
              })
            : (_typeof = function (Gr) {
                return Gr &&
                  typeof Symbol == "function" &&
                  Gr.constructor === Symbol &&
                  Gr !== Symbol.prototype
                  ? "symbol"
                  : typeof Gr;
              }),
          _typeof(Wr)
        );
      }
      var FootageInterface = (function () {
          var Wr = function (Yr) {
              var Kr = "",
                Zr = Yr.getFootageData();
              function Jr() {
                return (Kr = ""), (Zr = Yr.getFootageData()), Qr;
              }
              function Qr(ei) {
                if (Zr[ei])
                  return (
                    (Kr = ei), (Zr = Zr[ei]), _typeof(Zr) === "object" ? Qr : Zr
                  );
                var ti = ei.indexOf(Kr);
                if (ti !== -1) {
                  var ri = parseInt(ei.substr(ti + Kr.length), 10);
                  return (Zr = Zr[ri]), _typeof(Zr) === "object" ? Qr : Zr;
                }
                return "";
              }
              return Jr;
            },
            ze = function (Yr) {
              function Kr(Zr) {
                return Zr === "Outline" ? Kr.outlineInterface() : null;
              }
              return (Kr._name = "Outline"), (Kr.outlineInterface = Wr(Yr)), Kr;
            };
          return function (Gr) {
            function Yr(Kr) {
              return Kr === "Data" ? Yr.dataInterface : null;
            }
            return (Yr._name = "Data"), (Yr.dataInterface = ze(Gr)), Yr;
          };
        })(),
        interfaces = {
          layer: LayerExpressionInterface,
          effects: EffectsExpressionInterface,
          comp: CompExpressionInterface,
          shape: ShapeExpressionInterface,
          text: TextExpressionInterface,
          footage: FootageInterface,
        };
      function getInterface(Wr) {
        return interfaces[Wr] || null;
      }
      var expressionHelpers = (function () {
        function Wr(Jr, Qr, ei) {
          Qr.x &&
            ((ei.k = !0),
            (ei.x = !0),
            (ei.initiateExpression = ExpressionManager.initiateExpression),
            ei.effectsSequence.push(
              ei.initiateExpression(Jr, Qr, ei).bind(ei)
            ));
        }
        function ze(Jr) {
          return (
            (Jr *= this.elem.globalData.frameRate),
            (Jr -= this.offsetTime),
            Jr !== this._cachingAtTime.lastFrame &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastFrame < Jr
                  ? this._cachingAtTime.lastIndex
                  : 0),
              (this._cachingAtTime.value = this.interpolateValue(
                Jr,
                this._cachingAtTime
              )),
              (this._cachingAtTime.lastFrame = Jr)),
            this._cachingAtTime.value
          );
        }
        function Gr(Jr) {
          var Qr = -0.01,
            ei = this.getValueAtTime(Jr),
            ti = this.getValueAtTime(Jr + Qr),
            ri = 0;
          if (ei.length) {
            var ni;
            for (ni = 0; ni < ei.length; ni += 1)
              ri += Math.pow(ti[ni] - ei[ni], 2);
            ri = Math.sqrt(ri) * 100;
          } else ri = 0;
          return ri;
        }
        function Yr(Jr) {
          if (this.vel !== void 0) return this.vel;
          var Qr = -0.001,
            ei = this.getValueAtTime(Jr),
            ti = this.getValueAtTime(Jr + Qr),
            ri;
          if (ei.length) {
            ri = createTypedArray("float32", ei.length);
            var ni;
            for (ni = 0; ni < ei.length; ni += 1)
              ri[ni] = (ti[ni] - ei[ni]) / Qr;
          } else ri = (ti - ei) / Qr;
          return ri;
        }
        function Kr() {
          return this.pv;
        }
        function Zr(Jr) {
          this.propertyGroup = Jr;
        }
        return {
          searchExpressions: Wr,
          getSpeedAtTime: Gr,
          getVelocityAtTime: Yr,
          getValueAtTime: ze,
          getStaticValueAtTime: Kr,
          setGroupProperty: Zr,
        };
      })();
      function addPropertyDecorator() {
        function Wr(ii, si, li) {
          if (!this.k || !this.keyframes) return this.pv;
          ii = ii ? ii.toLowerCase() : "";
          var oi = this.comp.renderedFrame,
            ui = this.keyframes,
            ai = ui[ui.length - 1].t;
          if (oi <= ai) return this.pv;
          var hi, ci;
          li
            ? (si
                ? (hi = Math.abs(ai - this.elem.comp.globalData.frameRate * si))
                : (hi = Math.max(0, ai - this.elem.data.ip)),
              (ci = ai - hi))
            : ((!si || si > ui.length - 1) && (si = ui.length - 1),
              (ci = ui[ui.length - 1 - si].t),
              (hi = ai - ci));
          var fi, di, pi;
          if (ii === "pingpong") {
            var mi = Math.floor((oi - ci) / hi);
            if (mi % 2 !== 0)
              return this.getValueAtTime(
                (hi - ((oi - ci) % hi) + ci) / this.comp.globalData.frameRate,
                0
              );
          } else if (ii === "offset") {
            var Si = this.getValueAtTime(
                ci / this.comp.globalData.frameRate,
                0
              ),
              yi = this.getValueAtTime(ai / this.comp.globalData.frameRate, 0),
              Ei = this.getValueAtTime(
                (((oi - ci) % hi) + ci) / this.comp.globalData.frameRate,
                0
              ),
              Pi = Math.floor((oi - ci) / hi);
            if (this.pv.length) {
              for (
                pi = new Array(Si.length), di = pi.length, fi = 0;
                fi < di;
                fi += 1
              )
                pi[fi] = (yi[fi] - Si[fi]) * Pi + Ei[fi];
              return pi;
            }
            return (yi - Si) * Pi + Ei;
          } else if (ii === "continue") {
            var Ai = this.getValueAtTime(
                ai / this.comp.globalData.frameRate,
                0
              ),
              Ri = this.getValueAtTime(
                (ai - 0.001) / this.comp.globalData.frameRate,
                0
              );
            if (this.pv.length) {
              for (
                pi = new Array(Ai.length), di = pi.length, fi = 0;
                fi < di;
                fi += 1
              )
                pi[fi] =
                  Ai[fi] +
                  ((Ai[fi] - Ri[fi]) *
                    ((oi - ai) / this.comp.globalData.frameRate)) /
                    5e-4;
              return pi;
            }
            return Ai + (Ai - Ri) * ((oi - ai) / 0.001);
          }
          return this.getValueAtTime(
            (((oi - ci) % hi) + ci) / this.comp.globalData.frameRate,
            0
          );
        }
        function ze(ii, si, li) {
          if (!this.k) return this.pv;
          ii = ii ? ii.toLowerCase() : "";
          var oi = this.comp.renderedFrame,
            ui = this.keyframes,
            ai = ui[0].t;
          if (oi >= ai) return this.pv;
          var hi, ci;
          li
            ? (si
                ? (hi = Math.abs(this.elem.comp.globalData.frameRate * si))
                : (hi = Math.max(0, this.elem.data.op - ai)),
              (ci = ai + hi))
            : ((!si || si > ui.length - 1) && (si = ui.length - 1),
              (ci = ui[si].t),
              (hi = ci - ai));
          var fi, di, pi;
          if (ii === "pingpong") {
            var mi = Math.floor((ai - oi) / hi);
            if (mi % 2 === 0)
              return this.getValueAtTime(
                (((ai - oi) % hi) + ai) / this.comp.globalData.frameRate,
                0
              );
          } else if (ii === "offset") {
            var Si = this.getValueAtTime(
                ai / this.comp.globalData.frameRate,
                0
              ),
              yi = this.getValueAtTime(ci / this.comp.globalData.frameRate, 0),
              Ei = this.getValueAtTime(
                (hi - ((ai - oi) % hi) + ai) / this.comp.globalData.frameRate,
                0
              ),
              Pi = Math.floor((ai - oi) / hi) + 1;
            if (this.pv.length) {
              for (
                pi = new Array(Si.length), di = pi.length, fi = 0;
                fi < di;
                fi += 1
              )
                pi[fi] = Ei[fi] - (yi[fi] - Si[fi]) * Pi;
              return pi;
            }
            return Ei - (yi - Si) * Pi;
          } else if (ii === "continue") {
            var Ai = this.getValueAtTime(
                ai / this.comp.globalData.frameRate,
                0
              ),
              Ri = this.getValueAtTime(
                (ai + 0.001) / this.comp.globalData.frameRate,
                0
              );
            if (this.pv.length) {
              for (
                pi = new Array(Ai.length), di = pi.length, fi = 0;
                fi < di;
                fi += 1
              )
                pi[fi] = Ai[fi] + ((Ai[fi] - Ri[fi]) * (ai - oi)) / 0.001;
              return pi;
            }
            return Ai + ((Ai - Ri) * (ai - oi)) / 0.001;
          }
          return this.getValueAtTime(
            (hi - (((ai - oi) % hi) + ai)) / this.comp.globalData.frameRate,
            0
          );
        }
        function Gr(ii, si) {
          if (!this.k) return this.pv;
          if (((ii = (ii || 0.4) * 0.5), (si = Math.floor(si || 5)), si <= 1))
            return this.pv;
          var li = this.comp.renderedFrame / this.comp.globalData.frameRate,
            oi = li - ii,
            ui = li + ii,
            ai = si > 1 ? (ui - oi) / (si - 1) : 1,
            hi = 0,
            ci = 0,
            fi;
          this.pv.length
            ? (fi = createTypedArray("float32", this.pv.length))
            : (fi = 0);
          for (var di; hi < si; ) {
            if (((di = this.getValueAtTime(oi + hi * ai)), this.pv.length))
              for (ci = 0; ci < this.pv.length; ci += 1) fi[ci] += di[ci];
            else fi += di;
            hi += 1;
          }
          if (this.pv.length)
            for (ci = 0; ci < this.pv.length; ci += 1) fi[ci] /= si;
          else fi /= si;
          return fi;
        }
        function Yr(ii) {
          this._transformCachingAtTime ||
            (this._transformCachingAtTime = {
              v: new Matrix(),
            });
          var si = this._transformCachingAtTime.v;
          if (
            (si.cloneFromProps(this.pre.props), this.appliedTransformations < 1)
          ) {
            var li = this.a.getValueAtTime(ii);
            si.translate(
              -li[0] * this.a.mult,
              -li[1] * this.a.mult,
              li[2] * this.a.mult
            );
          }
          if (this.appliedTransformations < 2) {
            var oi = this.s.getValueAtTime(ii);
            si.scale(
              oi[0] * this.s.mult,
              oi[1] * this.s.mult,
              oi[2] * this.s.mult
            );
          }
          if (this.sk && this.appliedTransformations < 3) {
            var ui = this.sk.getValueAtTime(ii),
              ai = this.sa.getValueAtTime(ii);
            si.skewFromAxis(-ui * this.sk.mult, ai * this.sa.mult);
          }
          if (this.r && this.appliedTransformations < 4) {
            var hi = this.r.getValueAtTime(ii);
            si.rotate(-hi * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var ci = this.rz.getValueAtTime(ii),
              fi = this.ry.getValueAtTime(ii),
              di = this.rx.getValueAtTime(ii),
              pi = this.or.getValueAtTime(ii);
            si.rotateZ(-ci * this.rz.mult)
              .rotateY(fi * this.ry.mult)
              .rotateX(di * this.rx.mult)
              .rotateZ(-pi[2] * this.or.mult)
              .rotateY(pi[1] * this.or.mult)
              .rotateX(pi[0] * this.or.mult);
          }
          if (this.data.p && this.data.p.s) {
            var mi = this.px.getValueAtTime(ii),
              Si = this.py.getValueAtTime(ii);
            if (this.data.p.z) {
              var yi = this.pz.getValueAtTime(ii);
              si.translate(
                mi * this.px.mult,
                Si * this.py.mult,
                -yi * this.pz.mult
              );
            } else si.translate(mi * this.px.mult, Si * this.py.mult, 0);
          } else {
            var Ei = this.p.getValueAtTime(ii);
            si.translate(
              Ei[0] * this.p.mult,
              Ei[1] * this.p.mult,
              -Ei[2] * this.p.mult
            );
          }
          return si;
        }
        function Kr() {
          return this.v.clone(new Matrix());
        }
        var Zr = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function (ii, si, li) {
          var oi = Zr(ii, si, li);
          return (
            oi.dynamicProperties.length
              ? (oi.getValueAtTime = Yr.bind(oi))
              : (oi.getValueAtTime = Kr.bind(oi)),
            (oi.setGroupProperty = expressionHelpers.setGroupProperty),
            oi
          );
        };
        var Jr = PropertyFactory.getProp;
        PropertyFactory.getProp = function (ii, si, li, oi, ui) {
          var ai = Jr(ii, si, li, oi, ui);
          ai.kf
            ? (ai.getValueAtTime = expressionHelpers.getValueAtTime.bind(ai))
            : (ai.getValueAtTime =
                expressionHelpers.getStaticValueAtTime.bind(ai)),
            (ai.setGroupProperty = expressionHelpers.setGroupProperty),
            (ai.loopOut = Wr),
            (ai.loopIn = ze),
            (ai.smooth = Gr),
            (ai.getVelocityAtTime =
              expressionHelpers.getVelocityAtTime.bind(ai)),
            (ai.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(ai)),
            (ai.numKeys = si.a === 1 ? si.k.length : 0),
            (ai.propertyIndex = si.ix);
          var hi = 0;
          return (
            li !== 0 &&
              (hi = createTypedArray(
                "float32",
                si.a === 1 ? si.k[0].s.length : si.k.length
              )),
            (ai._cachingAtTime = {
              lastFrame: initialDefaultFrame,
              lastIndex: 0,
              value: hi,
            }),
            expressionHelpers.searchExpressions(ii, si, ai),
            ai.k && ui.addDynamicProperty(ai),
            ai
          );
        };
        function Qr(ii) {
          return (
            this._cachingAtTime ||
              (this._cachingAtTime = {
                shapeValue: shapePool.clone(this.pv),
                lastIndex: 0,
                lastTime: initialDefaultFrame,
              }),
            (ii *= this.elem.globalData.frameRate),
            (ii -= this.offsetTime),
            ii !== this._cachingAtTime.lastTime &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastTime < ii
                  ? this._caching.lastIndex
                  : 0),
              (this._cachingAtTime.lastTime = ii),
              this.interpolateShape(
                ii,
                this._cachingAtTime.shapeValue,
                this._cachingAtTime
              )),
            this._cachingAtTime.shapeValue
          );
        }
        var ei = ShapePropertyFactory.getConstructorFunction(),
          ti = ShapePropertyFactory.getKeyframedConstructorFunction();
        function ri() {}
        (ri.prototype = {
          vertices: function (si, li) {
            this.k && this.getValue();
            var oi = this.v;
            li !== void 0 && (oi = this.getValueAtTime(li, 0));
            var ui,
              ai = oi._length,
              hi = oi[si],
              ci = oi.v,
              fi = createSizedArray(ai);
            for (ui = 0; ui < ai; ui += 1)
              si === "i" || si === "o"
                ? (fi[ui] = [hi[ui][0] - ci[ui][0], hi[ui][1] - ci[ui][1]])
                : (fi[ui] = [hi[ui][0], hi[ui][1]]);
            return fi;
          },
          points: function (si) {
            return this.vertices("v", si);
          },
          inTangents: function (si) {
            return this.vertices("i", si);
          },
          outTangents: function (si) {
            return this.vertices("o", si);
          },
          isClosed: function () {
            return this.v.c;
          },
          pointOnPath: function (si, li) {
            var oi = this.v;
            li !== void 0 && (oi = this.getValueAtTime(li, 0)),
              this._segmentsLength ||
                (this._segmentsLength = bez.getSegmentsLength(oi));
            for (
              var ui = this._segmentsLength,
                ai = ui.lengths,
                hi = ui.totalLength * si,
                ci = 0,
                fi = ai.length,
                di = 0,
                pi;
              ci < fi;

            ) {
              if (di + ai[ci].addedLength > hi) {
                var mi = ci,
                  Si = oi.c && ci === fi - 1 ? 0 : ci + 1,
                  yi = (hi - di) / ai[ci].addedLength;
                pi = bez.getPointInSegment(
                  oi.v[mi],
                  oi.v[Si],
                  oi.o[mi],
                  oi.i[Si],
                  yi,
                  ai[ci]
                );
                break;
              } else di += ai[ci].addedLength;
              ci += 1;
            }
            return (
              pi ||
                (pi = oi.c
                  ? [oi.v[0][0], oi.v[0][1]]
                  : [oi.v[oi._length - 1][0], oi.v[oi._length - 1][1]]),
              pi
            );
          },
          vectorOnPath: function (si, li, oi) {
            si == 1 ? (si = this.v.c) : si == 0 && (si = 0.999);
            var ui = this.pointOnPath(si, li),
              ai = this.pointOnPath(si + 0.001, li),
              hi = ai[0] - ui[0],
              ci = ai[1] - ui[1],
              fi = Math.sqrt(Math.pow(hi, 2) + Math.pow(ci, 2));
            if (fi === 0) return [0, 0];
            var di =
              oi === "tangent" ? [hi / fi, ci / fi] : [-ci / fi, hi / fi];
            return di;
          },
          tangentOnPath: function (si, li) {
            return this.vectorOnPath(si, li, "tangent");
          },
          normalOnPath: function (si, li) {
            return this.vectorOnPath(si, li, "normal");
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime,
        }),
          extendPrototype([ri], ei),
          extendPrototype([ri], ti),
          (ti.prototype.getValueAtTime = Qr),
          (ti.prototype.initiateExpression =
            ExpressionManager.initiateExpression);
        var ni = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function (ii, si, li, oi, ui) {
          var ai = ni(ii, si, li, oi, ui);
          return (
            (ai.propertyIndex = si.ix),
            (ai.lock = !1),
            li === 3
              ? expressionHelpers.searchExpressions(ii, si.pt, ai)
              : li === 4 && expressionHelpers.searchExpressions(ii, si.ks, ai),
            ai.k && ii.addDynamicProperty(ai),
            ai
          );
        };
      }
      function initialize$1() {
        addPropertyDecorator();
      }
      function addDecorator() {
        function Wr() {
          return this.data.d.x
            ? ((this.calculateExpression =
                ExpressionManager.initiateExpression.bind(this)(
                  this.elem,
                  this.data.d,
                  this
                )),
              this.addEffect(this.getExpressionValue.bind(this)),
              !0)
            : null;
        }
        (TextProperty.prototype.getExpressionValue = function (ze, Gr) {
          var Yr = this.calculateExpression(Gr);
          if (ze.t !== Yr) {
            var Kr = {};
            return (
              this.copyData(Kr, ze),
              (Kr.t = Yr.toString()),
              (Kr.__complete = !1),
              Kr
            );
          }
          return ze;
        }),
          (TextProperty.prototype.searchProperty = function () {
            var ze = this.searchKeyframes(),
              Gr = this.searchExpressions();
            return (this.kf = ze || Gr), this.kf;
          }),
          (TextProperty.prototype.searchExpressions = Wr);
      }
      function initialize() {
        addDecorator();
      }
      function SVGComposableEffect() {}
      SVGComposableEffect.prototype = {
        createMergeNode: function Wr(ze, Gr) {
          var Yr = createNS("feMerge");
          Yr.setAttribute("result", ze);
          var Kr, Zr;
          for (Zr = 0; Zr < Gr.length; Zr += 1)
            (Kr = createNS("feMergeNode")),
              Kr.setAttribute("in", Gr[Zr]),
              Yr.appendChild(Kr),
              Yr.appendChild(Kr);
          return Yr;
        },
      };
      var linearFilterValue =
        "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(Wr, ze, Gr, Yr, Kr) {
        this.filterManager = ze;
        var Zr = createNS("feColorMatrix");
        Zr.setAttribute("type", "matrix"),
          Zr.setAttribute("color-interpolation-filters", "linearRGB"),
          Zr.setAttribute("values", linearFilterValue + " 1 0"),
          (this.linearFilter = Zr),
          Zr.setAttribute("result", Yr + "_tint_1"),
          Wr.appendChild(Zr),
          (Zr = createNS("feColorMatrix")),
          Zr.setAttribute("type", "matrix"),
          Zr.setAttribute("color-interpolation-filters", "sRGB"),
          Zr.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          Zr.setAttribute("result", Yr + "_tint_2"),
          Wr.appendChild(Zr),
          (this.matrixFilter = Zr);
        var Jr = this.createMergeNode(Yr, [Kr, Yr + "_tint_1", Yr + "_tint_2"]);
        Wr.appendChild(Jr);
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter),
        (SVGTintFilter.prototype.renderFrame = function (Wr) {
          if (Wr || this.filterManager._mdf) {
            var ze = this.filterManager.effectElements[0].p.v,
              Gr = this.filterManager.effectElements[1].p.v,
              Yr = this.filterManager.effectElements[2].p.v / 100;
            this.linearFilter.setAttribute(
              "values",
              linearFilterValue + " " + Yr + " 0"
            ),
              this.matrixFilter.setAttribute(
                "values",
                Gr[0] -
                  ze[0] +
                  " 0 0 0 " +
                  ze[0] +
                  " " +
                  (Gr[1] - ze[1]) +
                  " 0 0 0 " +
                  ze[1] +
                  " " +
                  (Gr[2] - ze[2]) +
                  " 0 0 0 " +
                  ze[2] +
                  " 0 0 0 1 0"
              );
          }
        });
      function SVGFillFilter(Wr, ze, Gr, Yr) {
        this.filterManager = ze;
        var Kr = createNS("feColorMatrix");
        Kr.setAttribute("type", "matrix"),
          Kr.setAttribute("color-interpolation-filters", "sRGB"),
          Kr.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          Kr.setAttribute("result", Yr),
          Wr.appendChild(Kr),
          (this.matrixFilter = Kr);
      }
      SVGFillFilter.prototype.renderFrame = function (Wr) {
        if (Wr || this.filterManager._mdf) {
          var ze = this.filterManager.effectElements[2].p.v,
            Gr = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute(
            "values",
            "0 0 0 0 " +
              ze[0] +
              " 0 0 0 0 " +
              ze[1] +
              " 0 0 0 0 " +
              ze[2] +
              " 0 0 0 " +
              Gr +
              " 0"
          );
        }
      };
      function SVGStrokeEffect(Wr, ze, Gr) {
        (this.initialized = !1),
          (this.filterManager = ze),
          (this.elem = Gr),
          (this.paths = []);
      }
      (SVGStrokeEffect.prototype.initialize = function () {
        var Wr =
            this.elem.layerElement.children ||
            this.elem.layerElement.childNodes,
          ze,
          Gr,
          Yr,
          Kr;
        for (
          this.filterManager.effectElements[1].p.v === 1
            ? ((Kr = this.elem.maskManager.masksProperties.length), (Yr = 0))
            : ((Yr = this.filterManager.effectElements[0].p.v - 1),
              (Kr = Yr + 1)),
            Gr = createNS("g"),
            Gr.setAttribute("fill", "none"),
            Gr.setAttribute("stroke-linecap", "round"),
            Gr.setAttribute("stroke-dashoffset", 1),
            Yr;
          Yr < Kr;
          Yr += 1
        )
          (ze = createNS("path")),
            Gr.appendChild(ze),
            this.paths.push({
              p: ze,
              m: Yr,
            });
        if (this.filterManager.effectElements[10].p.v === 3) {
          var Zr = createNS("mask"),
            Jr = createElementID();
          Zr.setAttribute("id", Jr),
            Zr.setAttribute("mask-type", "alpha"),
            Zr.appendChild(Gr),
            this.elem.globalData.defs.appendChild(Zr);
          var Qr = createNS("g");
          for (
            Qr.setAttribute(
              "mask",
              "url(" + getLocationHref() + "#" + Jr + ")"
            );
            Wr[0];

          )
            Qr.appendChild(Wr[0]);
          this.elem.layerElement.appendChild(Qr),
            (this.masker = Zr),
            Gr.setAttribute("stroke", "#fff");
        } else if (
          this.filterManager.effectElements[10].p.v === 1 ||
          this.filterManager.effectElements[10].p.v === 2
        ) {
          if (this.filterManager.effectElements[10].p.v === 2)
            for (
              Wr =
                this.elem.layerElement.children ||
                this.elem.layerElement.childNodes;
              Wr.length;

            )
              this.elem.layerElement.removeChild(Wr[0]);
          this.elem.layerElement.appendChild(Gr),
            this.elem.layerElement.removeAttribute("mask"),
            Gr.setAttribute("stroke", "#fff");
        }
        (this.initialized = !0), (this.pathMasker = Gr);
      }),
        (SVGStrokeEffect.prototype.renderFrame = function (Wr) {
          this.initialized || this.initialize();
          var ze,
            Gr = this.paths.length,
            Yr,
            Kr;
          for (ze = 0; ze < Gr; ze += 1)
            if (
              this.paths[ze].m !== -1 &&
              ((Yr = this.elem.maskManager.viewData[this.paths[ze].m]),
              (Kr = this.paths[ze].p),
              (Wr || this.filterManager._mdf || Yr.prop._mdf) &&
                Kr.setAttribute("d", Yr.lastPath),
              Wr ||
                this.filterManager.effectElements[9].p._mdf ||
                this.filterManager.effectElements[4].p._mdf ||
                this.filterManager.effectElements[7].p._mdf ||
                this.filterManager.effectElements[8].p._mdf ||
                Yr.prop._mdf)
            ) {
              var Zr;
              if (
                this.filterManager.effectElements[7].p.v !== 0 ||
                this.filterManager.effectElements[8].p.v !== 100
              ) {
                var Jr =
                    Math.min(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  Qr =
                    Math.max(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  ei = Kr.getTotalLength();
                Zr = "0 0 0 " + ei * Jr + " ";
                var ti = ei * (Qr - Jr),
                  ri =
                    1 +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01,
                  ni = Math.floor(ti / ri),
                  ii;
                for (ii = 0; ii < ni; ii += 1)
                  Zr +=
                    "1 " +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01 +
                    " ";
                Zr += "0 " + ei * 10 + " 0 0";
              } else
                Zr =
                  "1 " +
                  this.filterManager.effectElements[4].p.v *
                    2 *
                    this.filterManager.effectElements[9].p.v *
                    0.01;
              Kr.setAttribute("stroke-dasharray", Zr);
            }
          if (
            ((Wr || this.filterManager.effectElements[4].p._mdf) &&
              this.pathMasker.setAttribute(
                "stroke-width",
                this.filterManager.effectElements[4].p.v * 2
              ),
            (Wr || this.filterManager.effectElements[6].p._mdf) &&
              this.pathMasker.setAttribute(
                "opacity",
                this.filterManager.effectElements[6].p.v
              ),
            (this.filterManager.effectElements[10].p.v === 1 ||
              this.filterManager.effectElements[10].p.v === 2) &&
              (Wr || this.filterManager.effectElements[3].p._mdf))
          ) {
            var si = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute(
              "stroke",
              "rgb(" +
                bmFloor(si[0] * 255) +
                "," +
                bmFloor(si[1] * 255) +
                "," +
                bmFloor(si[2] * 255) +
                ")"
            );
          }
        });
      function SVGTritoneFilter(Wr, ze, Gr, Yr) {
        this.filterManager = ze;
        var Kr = createNS("feColorMatrix");
        Kr.setAttribute("type", "matrix"),
          Kr.setAttribute("color-interpolation-filters", "linearRGB"),
          Kr.setAttribute(
            "values",
            "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
          ),
          Wr.appendChild(Kr);
        var Zr = createNS("feComponentTransfer");
        Zr.setAttribute("color-interpolation-filters", "sRGB"),
          Zr.setAttribute("result", Yr),
          (this.matrixFilter = Zr);
        var Jr = createNS("feFuncR");
        Jr.setAttribute("type", "table"),
          Zr.appendChild(Jr),
          (this.feFuncR = Jr);
        var Qr = createNS("feFuncG");
        Qr.setAttribute("type", "table"),
          Zr.appendChild(Qr),
          (this.feFuncG = Qr);
        var ei = createNS("feFuncB");
        ei.setAttribute("type", "table"),
          Zr.appendChild(ei),
          (this.feFuncB = ei),
          Wr.appendChild(Zr);
      }
      SVGTritoneFilter.prototype.renderFrame = function (Wr) {
        if (Wr || this.filterManager._mdf) {
          var ze = this.filterManager.effectElements[0].p.v,
            Gr = this.filterManager.effectElements[1].p.v,
            Yr = this.filterManager.effectElements[2].p.v,
            Kr = Yr[0] + " " + Gr[0] + " " + ze[0],
            Zr = Yr[1] + " " + Gr[1] + " " + ze[1],
            Jr = Yr[2] + " " + Gr[2] + " " + ze[2];
          this.feFuncR.setAttribute("tableValues", Kr),
            this.feFuncG.setAttribute("tableValues", Zr),
            this.feFuncB.setAttribute("tableValues", Jr);
        }
      };
      function SVGProLevelsFilter(Wr, ze, Gr, Yr) {
        this.filterManager = ze;
        var Kr = this.filterManager.effectElements,
          Zr = createNS("feComponentTransfer");
        (Kr[10].p.k ||
          Kr[10].p.v !== 0 ||
          Kr[11].p.k ||
          Kr[11].p.v !== 1 ||
          Kr[12].p.k ||
          Kr[12].p.v !== 1 ||
          Kr[13].p.k ||
          Kr[13].p.v !== 0 ||
          Kr[14].p.k ||
          Kr[14].p.v !== 1) &&
          (this.feFuncR = this.createFeFunc("feFuncR", Zr)),
          (Kr[17].p.k ||
            Kr[17].p.v !== 0 ||
            Kr[18].p.k ||
            Kr[18].p.v !== 1 ||
            Kr[19].p.k ||
            Kr[19].p.v !== 1 ||
            Kr[20].p.k ||
            Kr[20].p.v !== 0 ||
            Kr[21].p.k ||
            Kr[21].p.v !== 1) &&
            (this.feFuncG = this.createFeFunc("feFuncG", Zr)),
          (Kr[24].p.k ||
            Kr[24].p.v !== 0 ||
            Kr[25].p.k ||
            Kr[25].p.v !== 1 ||
            Kr[26].p.k ||
            Kr[26].p.v !== 1 ||
            Kr[27].p.k ||
            Kr[27].p.v !== 0 ||
            Kr[28].p.k ||
            Kr[28].p.v !== 1) &&
            (this.feFuncB = this.createFeFunc("feFuncB", Zr)),
          (Kr[31].p.k ||
            Kr[31].p.v !== 0 ||
            Kr[32].p.k ||
            Kr[32].p.v !== 1 ||
            Kr[33].p.k ||
            Kr[33].p.v !== 1 ||
            Kr[34].p.k ||
            Kr[34].p.v !== 0 ||
            Kr[35].p.k ||
            Kr[35].p.v !== 1) &&
            (this.feFuncA = this.createFeFunc("feFuncA", Zr)),
          (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) &&
            (Zr.setAttribute("color-interpolation-filters", "sRGB"),
            Wr.appendChild(Zr)),
          (Kr[3].p.k ||
            Kr[3].p.v !== 0 ||
            Kr[4].p.k ||
            Kr[4].p.v !== 1 ||
            Kr[5].p.k ||
            Kr[5].p.v !== 1 ||
            Kr[6].p.k ||
            Kr[6].p.v !== 0 ||
            Kr[7].p.k ||
            Kr[7].p.v !== 1) &&
            ((Zr = createNS("feComponentTransfer")),
            Zr.setAttribute("color-interpolation-filters", "sRGB"),
            Zr.setAttribute("result", Yr),
            Wr.appendChild(Zr),
            (this.feFuncRComposed = this.createFeFunc("feFuncR", Zr)),
            (this.feFuncGComposed = this.createFeFunc("feFuncG", Zr)),
            (this.feFuncBComposed = this.createFeFunc("feFuncB", Zr)));
      }
      (SVGProLevelsFilter.prototype.createFeFunc = function (Wr, ze) {
        var Gr = createNS(Wr);
        return Gr.setAttribute("type", "table"), ze.appendChild(Gr), Gr;
      }),
        (SVGProLevelsFilter.prototype.getTableValue = function (
          Wr,
          ze,
          Gr,
          Yr,
          Kr
        ) {
          for (
            var Zr = 0,
              Jr = 256,
              Qr,
              ei = Math.min(Wr, ze),
              ti = Math.max(Wr, ze),
              ri = Array.call(null, {
                length: Jr,
              }),
              ni,
              ii = 0,
              si = Kr - Yr,
              li = ze - Wr;
            Zr <= 256;

          )
            (Qr = Zr / 256),
              Qr <= ei
                ? (ni = li < 0 ? Kr : Yr)
                : Qr >= ti
                ? (ni = li < 0 ? Yr : Kr)
                : (ni = Yr + si * Math.pow((Qr - Wr) / li, 1 / Gr)),
              (ri[ii] = ni),
              (ii += 1),
              (Zr += 256 / (Jr - 1));
          return ri.join(" ");
        }),
        (SVGProLevelsFilter.prototype.renderFrame = function (Wr) {
          if (Wr || this.filterManager._mdf) {
            var ze,
              Gr = this.filterManager.effectElements;
            this.feFuncRComposed &&
              (Wr ||
                Gr[3].p._mdf ||
                Gr[4].p._mdf ||
                Gr[5].p._mdf ||
                Gr[6].p._mdf ||
                Gr[7].p._mdf) &&
              ((ze = this.getTableValue(
                Gr[3].p.v,
                Gr[4].p.v,
                Gr[5].p.v,
                Gr[6].p.v,
                Gr[7].p.v
              )),
              this.feFuncRComposed.setAttribute("tableValues", ze),
              this.feFuncGComposed.setAttribute("tableValues", ze),
              this.feFuncBComposed.setAttribute("tableValues", ze)),
              this.feFuncR &&
                (Wr ||
                  Gr[10].p._mdf ||
                  Gr[11].p._mdf ||
                  Gr[12].p._mdf ||
                  Gr[13].p._mdf ||
                  Gr[14].p._mdf) &&
                ((ze = this.getTableValue(
                  Gr[10].p.v,
                  Gr[11].p.v,
                  Gr[12].p.v,
                  Gr[13].p.v,
                  Gr[14].p.v
                )),
                this.feFuncR.setAttribute("tableValues", ze)),
              this.feFuncG &&
                (Wr ||
                  Gr[17].p._mdf ||
                  Gr[18].p._mdf ||
                  Gr[19].p._mdf ||
                  Gr[20].p._mdf ||
                  Gr[21].p._mdf) &&
                ((ze = this.getTableValue(
                  Gr[17].p.v,
                  Gr[18].p.v,
                  Gr[19].p.v,
                  Gr[20].p.v,
                  Gr[21].p.v
                )),
                this.feFuncG.setAttribute("tableValues", ze)),
              this.feFuncB &&
                (Wr ||
                  Gr[24].p._mdf ||
                  Gr[25].p._mdf ||
                  Gr[26].p._mdf ||
                  Gr[27].p._mdf ||
                  Gr[28].p._mdf) &&
                ((ze = this.getTableValue(
                  Gr[24].p.v,
                  Gr[25].p.v,
                  Gr[26].p.v,
                  Gr[27].p.v,
                  Gr[28].p.v
                )),
                this.feFuncB.setAttribute("tableValues", ze)),
              this.feFuncA &&
                (Wr ||
                  Gr[31].p._mdf ||
                  Gr[32].p._mdf ||
                  Gr[33].p._mdf ||
                  Gr[34].p._mdf ||
                  Gr[35].p._mdf) &&
                ((ze = this.getTableValue(
                  Gr[31].p.v,
                  Gr[32].p.v,
                  Gr[33].p.v,
                  Gr[34].p.v,
                  Gr[35].p.v
                )),
                this.feFuncA.setAttribute("tableValues", ze));
          }
        });
      function SVGDropShadowEffect(Wr, ze, Gr, Yr, Kr) {
        var Zr = ze.container.globalData.renderConfig.filterSize,
          Jr = ze.data.fs || Zr;
        Wr.setAttribute("x", Jr.x || Zr.x),
          Wr.setAttribute("y", Jr.y || Zr.y),
          Wr.setAttribute("width", Jr.width || Zr.width),
          Wr.setAttribute("height", Jr.height || Zr.height),
          (this.filterManager = ze);
        var Qr = createNS("feGaussianBlur");
        Qr.setAttribute("in", "SourceAlpha"),
          Qr.setAttribute("result", Yr + "_drop_shadow_1"),
          Qr.setAttribute("stdDeviation", "0"),
          (this.feGaussianBlur = Qr),
          Wr.appendChild(Qr);
        var ei = createNS("feOffset");
        ei.setAttribute("dx", "25"),
          ei.setAttribute("dy", "0"),
          ei.setAttribute("in", Yr + "_drop_shadow_1"),
          ei.setAttribute("result", Yr + "_drop_shadow_2"),
          (this.feOffset = ei),
          Wr.appendChild(ei);
        var ti = createNS("feFlood");
        ti.setAttribute("flood-color", "#00ff00"),
          ti.setAttribute("flood-opacity", "1"),
          ti.setAttribute("result", Yr + "_drop_shadow_3"),
          (this.feFlood = ti),
          Wr.appendChild(ti);
        var ri = createNS("feComposite");
        ri.setAttribute("in", Yr + "_drop_shadow_3"),
          ri.setAttribute("in2", Yr + "_drop_shadow_2"),
          ri.setAttribute("operator", "in"),
          ri.setAttribute("result", Yr + "_drop_shadow_4"),
          Wr.appendChild(ri);
        var ni = this.createMergeNode(Yr, [Yr + "_drop_shadow_4", Kr]);
        Wr.appendChild(ni);
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        (SVGDropShadowEffect.prototype.renderFrame = function (Wr) {
          if (Wr || this.filterManager._mdf) {
            if (
              ((Wr || this.filterManager.effectElements[4].p._mdf) &&
                this.feGaussianBlur.setAttribute(
                  "stdDeviation",
                  this.filterManager.effectElements[4].p.v / 4
                ),
              Wr || this.filterManager.effectElements[0].p._mdf)
            ) {
              var ze = this.filterManager.effectElements[0].p.v;
              this.feFlood.setAttribute(
                "flood-color",
                rgbToHex(
                  Math.round(ze[0] * 255),
                  Math.round(ze[1] * 255),
                  Math.round(ze[2] * 255)
                )
              );
            }
            if (
              ((Wr || this.filterManager.effectElements[1].p._mdf) &&
                this.feFlood.setAttribute(
                  "flood-opacity",
                  this.filterManager.effectElements[1].p.v / 255
                ),
              Wr ||
                this.filterManager.effectElements[2].p._mdf ||
                this.filterManager.effectElements[3].p._mdf)
            ) {
              var Gr = this.filterManager.effectElements[3].p.v,
                Yr =
                  (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                Kr = Gr * Math.cos(Yr),
                Zr = Gr * Math.sin(Yr);
              this.feOffset.setAttribute("dx", Kr),
                this.feOffset.setAttribute("dy", Zr);
            }
          }
        });
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(Wr, ze, Gr) {
        (this.initialized = !1),
          (this.filterManager = ze),
          (this.filterElem = Wr),
          (this.elem = Gr),
          (Gr.matteElement = createNS("g")),
          Gr.matteElement.appendChild(Gr.layerElement),
          Gr.matteElement.appendChild(Gr.transformedElement),
          (Gr.baseElement = Gr.matteElement);
      }
      (SVGMatte3Effect.prototype.findSymbol = function (Wr) {
        for (var ze = 0, Gr = _svgMatteSymbols.length; ze < Gr; ) {
          if (_svgMatteSymbols[ze] === Wr) return _svgMatteSymbols[ze];
          ze += 1;
        }
        return null;
      }),
        (SVGMatte3Effect.prototype.replaceInParent = function (Wr, ze) {
          var Gr = Wr.layerElement.parentNode;
          if (Gr) {
            for (
              var Yr = Gr.children, Kr = 0, Zr = Yr.length;
              Kr < Zr && Yr[Kr] !== Wr.layerElement;

            )
              Kr += 1;
            var Jr;
            Kr <= Zr - 2 && (Jr = Yr[Kr + 1]);
            var Qr = createNS("use");
            Qr.setAttribute("href", "#" + ze),
              Jr ? Gr.insertBefore(Qr, Jr) : Gr.appendChild(Qr);
          }
        }),
        (SVGMatte3Effect.prototype.setElementAsMask = function (Wr, ze) {
          if (!this.findSymbol(ze)) {
            var Gr = createElementID(),
              Yr = createNS("mask");
            Yr.setAttribute("id", ze.layerId),
              Yr.setAttribute("mask-type", "alpha"),
              _svgMatteSymbols.push(ze);
            var Kr = Wr.globalData.defs;
            Kr.appendChild(Yr);
            var Zr = createNS("symbol");
            Zr.setAttribute("id", Gr),
              this.replaceInParent(ze, Gr),
              Zr.appendChild(ze.layerElement),
              Kr.appendChild(Zr);
            var Jr = createNS("use");
            Jr.setAttribute("href", "#" + Gr),
              Yr.appendChild(Jr),
              (ze.data.hd = !1),
              ze.show();
          }
          Wr.setMatte(ze.layerId);
        }),
        (SVGMatte3Effect.prototype.initialize = function () {
          for (
            var Wr = this.filterManager.effectElements[0].p.v,
              ze = this.elem.comp.elements,
              Gr = 0,
              Yr = ze.length;
            Gr < Yr;

          )
            ze[Gr] &&
              ze[Gr].data.ind === Wr &&
              this.setElementAsMask(this.elem, ze[Gr]),
              (Gr += 1);
          this.initialized = !0;
        }),
        (SVGMatte3Effect.prototype.renderFrame = function () {
          this.initialized || this.initialize();
        });
      function SVGGaussianBlurEffect(Wr, ze, Gr, Yr) {
        Wr.setAttribute("x", "-100%"),
          Wr.setAttribute("y", "-100%"),
          Wr.setAttribute("width", "300%"),
          Wr.setAttribute("height", "300%"),
          (this.filterManager = ze);
        var Kr = createNS("feGaussianBlur");
        Kr.setAttribute("result", Yr),
          Wr.appendChild(Kr),
          (this.feGaussianBlur = Kr);
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function (Wr) {
        if (Wr || this.filterManager._mdf) {
          var ze = 0.3,
            Gr = this.filterManager.effectElements[0].p.v * ze,
            Yr = this.filterManager.effectElements[1].p.v,
            Kr = Yr == 3 ? 0 : Gr,
            Zr = Yr == 2 ? 0 : Gr;
          this.feGaussianBlur.setAttribute("stdDeviation", Kr + " " + Zr);
          var Jr =
            this.filterManager.effectElements[2].p.v == 1
              ? "wrap"
              : "duplicate";
          this.feGaussianBlur.setAttribute("edgeMode", Jr);
        }
      };
      function TransformEffect() {}
      (TransformEffect.prototype.init = function (Wr) {
        (this.effectsManager = Wr),
          (this.type = effectTypes.TRANSFORM_EFFECT),
          (this.matrix = new Matrix()),
          (this.opacity = -1),
          (this._mdf = !1),
          (this._opMdf = !1);
      }),
        (TransformEffect.prototype.renderFrame = function (Wr) {
          if (
            ((this._opMdf = !1),
            (this._mdf = !1),
            Wr || this.effectsManager._mdf)
          ) {
            var ze = this.effectsManager.effectElements,
              Gr = ze[0].p.v,
              Yr = ze[1].p.v,
              Kr = ze[2].p.v === 1,
              Zr = ze[3].p.v,
              Jr = Kr ? Zr : ze[4].p.v,
              Qr = ze[5].p.v,
              ei = ze[6].p.v,
              ti = ze[7].p.v;
            this.matrix.reset(),
              this.matrix.translate(-Gr[0], -Gr[1], Gr[2]),
              this.matrix.scale(Jr * 0.01, Zr * 0.01, 1),
              this.matrix.rotate(-ti * degToRads),
              this.matrix.skewFromAxis(-Qr * degToRads, (ei + 90) * degToRads),
              this.matrix.translate(Yr[0], Yr[1], 0),
              (this._mdf = !0),
              this.opacity !== ze[8].p.v &&
                ((this.opacity = ze[8].p.v), (this._opMdf = !0));
          }
        });
      function SVGTransformEffect(Wr, ze) {
        this.init(ze);
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(Wr) {
        this.init(Wr);
      }
      return (
        extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
      );
    });
})(lottie$1, lottieExports);
const lottie = lottieExports,
  lottieUrl = "/dist/assets/Logo-v2-31d667ba.json";
gsapWithCSS.registerPlugin(ScrollTrigger);
let loadingAnimplayed = !1;
function forceScrollTop() {
  window.scrollTo(0, 0),
    typeof lenis$1 < "u" &&
      (lenis$1.scrollTo("top", {
        immediate: !0,
      }),
      lenis$1.blockScroll());
}
function loadingAnimation() {
  return new Promise((Wr) => {
    loadingAnimplayed = !0;
    const ze = document.getElementById("loader"),
      Gr = document.getElementById("loader__lottie");
    let Yr = lottie.loadAnimation({
      container: Gr,
      renderer: "svg",
      loop: !1,
      autoplay: !1,
      path: lottieUrl,
    });
    Yr.addEventListener("DOMLoaded", () => {
      Yr.play(),
        gsapWithCSS.to(
          ze,
          {
            backgroundColor: "rgba(0, 0, 0, 0)",
            ease: "none",
            duration: 0.3,
          },
          0
        );
    }),
      gsapWithCSS.ticker.add(forceScrollTop);
    const Kr = gsapWithCSS.timeline({
      paused: !0,
      onComplete: () => {
        (ze.played = !0), (ze.style.display = "none");
      },
    });
    Kr.to(
      Gr,
      {
        y: "150%",
        scale: 2,
        ease: "expo.in",
        duration: 1.5,
        onComplete: () => lenis$1.unblockScroll(),
      },
      0
    ),
      Kr.to(
        Gr,
        {
          opacity: 0,
          ease: "power2.in",
          duration: 0.2,
        },
        1.8
      ),
      Kr.fromTo(
        uSize,
        {
          value: 0.03,
        },
        {
          value: 0.2,
          ease: "power3.inOut",
          duration: 2.7,
        },
        0
      ),
      Kr.to(
        uOffset.value,
        {
          x: "-=.16",
          y: "+=.3",
          ease: "power2.out",
          duration: 2.2,
        },
        0
      ),
      Kr.fromTo(
        uColorMixer,
        {
          value: 1,
        },
        {
          value: 0,
          ease: "power2.inOut",
          duration: 3,
        },
        0
      ),
      Yr.addEventListener("enterFrame", (Zr) => {
        if (Zr.currentTime > 27 && !Kr.isActive()) {
          gsapWithCSS.ticker.remove(forceScrollTop), Kr.play();
          const Jr = document.querySelector(".js-home-banner-title.a--text").tl,
            Qr = document.querySelector(".cookiefirst-root > div > div"),
            ei = document.querySelectorAll(".js-slice-wrapper");
          Jr.progress() == 0 &&
            setTimeout(() => {
              Jr.play(),
                Qr && Qr.tl && Qr.tl.play(),
                ei.length > 0 &&
                  gsapWithCSS.utils.toArray(ei).forEach((ti) => {
                    ti.tl && ti.tl.play();
                  });
            }, 1e3);
        }
      });
  });
}
gsapWithCSS.registerPlugin(ScrollTrigger);
const homeBanner = () => {
  const Wr = document.querySelectorAll(".js-slice-wrapper"),
    ze = document.querySelector(".js-home-banner"),
    Gr = document.querySelector(".js-home-banner-content"),
    Yr = document.querySelector(".js-home-banner-text"),
    Kr = document.querySelector(".js-webgl-wrapper");
  let Zr = 0.8,
    Jr = !1;
  config.loadingAnim && !loadingAnimplayed && (Jr = !0);
  const Qr = document.querySelector(".js-home-banner-title.a--text");
  if (Qr) {
    let ei = Qr.getAttribute("data-reveal");
    ei && (Zr = parseFloat(ei)),
      (Qr.tl = gsapWithCSS.timeline({
        paused: Jr,
        defaults: {
          delay: parseFloat(Zr),
          duration: 1,
        },
      })),
      Qr.tl.fromTo(
        Qr.querySelectorAll(".line"),
        {
          y: "115%",
        },
        {
          y: 0,
          stagger: 0.08,
          ease: "power3.out",
        },
        0
      ),
      Qr.tl.fromTo(
        ".js-home-banner-text-reveal.is--mobile",
        {
          opacity: 0,
        },
        {
          opacity: 1,
          ease: "none",
        },
        0.5
      );
  }
  if (
    (setTimeout(() => {
      const ei = document.querySelector(".cookiefirst-root > div > div");
      ei &&
        ((ei.tl = gsapWithCSS.timeline({
          paused: Jr,
          defaults: {
            delay: 0.8,
            duration: 1,
          },
        })),
        ei.tl.fromTo(
          ei,
          {
            y: "115%",
            opacity: 0,
          },
          {
            y: 0,
            opacity: 1,
            delay: 2.5,
            ease: "power3.out",
          }
        ));
    }, 600),
    Wr.length > 0 &&
      gsapWithCSS.utils.toArray(Wr).forEach((ei, ti) => {
        const ri = ei.closest(".a--text");
        let ni = 0;
        if (ri) {
          let si = ri.getAttribute("data-reveal");
          si && (ni = si);
        }
        var ii = gsapWithCSS.timeline({
          paused: Jr,
        });
        ii.fromTo(
          ei,
          {
            maxWidth: 0,
          },
          {
            maxWidth: ei.offsetWidth,
            duration: 1.6,
            ease: "power3.inOut",
            delay: 0.4 + ti * 0.07,
          }
        ),
          ii.delay(parseFloat(ni)),
          (ei.tl = ii);
      }),
    Yr)
  ) {
    let ei = Yr.getAttribute("data-reveal"),
      ti = Zr + parseFloat(ei);
    gsapWithCSS.fromTo(
      Yr,
      {
        x: "-102%",
      },
      {
        x: 0,
        duration: 1.5,
        ease: "expo.inOut",
        delay: parseFloat(ti),
      }
    );
  }
  if (ze && Kr) {
    const ei = ze.getBoundingClientRect().height,
      ti = ze.querySelector(".js-dark-overlay");
    gsapWithCSS.to(Gr, {
      scrollTrigger: {
        trigger: ze,
        scrub: !0,
        start: "top top",
        end: () => `+=${ei}`,
      },
      y: "-10%",
      duration: 0.8,
      ease: "0.25, 1, 0.5, 1",
    }),
      gsapWithCSS.to(ti, {
        scrollTrigger: {
          trigger: ze,
          scrub: !0,
          start: "top top",
          end: () => `+=${ei}`,
        },
        y: "20%",
        duration: 0.8,
        ease: "0.25, 1, 0.5, 1",
      }),
      gsapWithCSS.to(ti, {
        scrollTrigger: {
          trigger: ze,
          scrub: !0,
          start: "45% top",
          end: () => `+=${ei / 2}`,
        },
        opacity: 0.8,
        ease: "none",
      });
  }
};
gsapWithCSS.registerPlugin(ScrollTrigger);
const home = {
  namespace: "home",
  tweens: [],
  loops: [],
  webglText: !1,
  beforeEnter() {
    const Wr = document.querySelector(".js-header");
    homeBanner(),
      setTimeout(() => {
        Wr.classList.add("is--light");
      }, 500);
  },
  afterEnter({ next: Wr }) {
    setTimeout(() => {
      preloadImages(Wr.container);
    }, 2e3);
  },
  afterLeave() {
    for (let Wr = 0; Wr < this.tweens.length; Wr++) this.tweens[Wr].kill();
    this.tweens = [];
    for (let Wr = 0; Wr < this.loops.length; Wr++)
      gsapWithCSS.ticker.remove(this.loops[Wr]);
    this.loops = [];
  },
};
function preloadImages(Wr) {
  const ze = Wr.querySelectorAll("[preload-image]");
  for (let Gr = 0; Gr < ze.length; Gr++) {
    const Yr = new Image();
    Yr.src = ze[Gr].getAttribute("preload-image");
  }
}
const composer = new EffectComposer(renderer),
  context = composer.renderer.getContext();
composer.multisampling = Math.min(4, context.getParameter(context.MAX_SAMPLES));
const resize = () => {
  const Wr = canvas$1.offsetWidth,
    ze = canvas$1.offsetHeight;
  composer.setSize(Wr, ze);
};
window.addEventListener("resize", resize);
const compose = (Wr) => {
  composer.removeAllPasses();
  for (const ze of Wr) composer.addPass(ze);
};
gsapWithCSS.registerPlugin(ScrollTrigger);
let mesh;
function createGradient() {
  const Wr = debug();
  function ze(fi, di) {
    compose(passes),
      mesh || (mesh = new Mesh(new PlaneGeometry(2, 2), material)),
      scene.add(mesh),
      di && (debug$1.mount(), Wr.mount());
  }
  function Gr() {
    scene.remove(mesh), debug$1.unmount(), Wr.unmount();
  }
  function Yr(fi) {
    renderer.render(scene, camera), composer.render(fi);
  }
  function Kr() {
    return mesh.material.uniforms.uSize.value;
  }
  function Zr() {
    return mesh.material.uniforms.uOffset.value;
  }
  function Jr() {
    return mesh.material.uniforms.uSpeed.value;
  }
  function Qr() {
    return mesh.material.uniforms.uColor1.value.getHex();
  }
  function ei() {
    return mesh.material.uniforms.uColor2.value.getHex();
  }
  function ti() {
    return mesh.material.uniforms.uColor3.value.getHex();
  }
  function ri() {
    return mesh.material.uniforms.uColor4.value.getHex();
  }
  function ni() {
    return grainEffect.uniforms.get("uIntensity").value;
  }
  function ii(fi) {
    mesh.material.uniforms.uSize.value = fi;
  }
  function si(fi) {
    mesh.material.uniforms.uOffset.value = fi;
  }
  function li(fi) {
    mesh.material.uniforms.uSpeed.value = fi;
  }
  function oi(fi, di, pi) {
    !di && !pi
      ? mesh.material.uniforms.uColor1.value.set(fi)
      : mesh.material.uniforms.uColor1.value.set(fi, di, pi);
  }
  function ui(fi, di, pi) {
    !di && !pi
      ? mesh.material.uniforms.uColor2.value.set(fi)
      : mesh.material.uniforms.uColor2.value.set(fi, di, pi);
  }
  function ai(fi, di, pi) {
    !di && !pi
      ? mesh.material.uniforms.uColor3.value.set(fi)
      : mesh.material.uniforms.uColor3.value.set(fi, di, pi);
  }
  function hi(fi, di, pi) {
    !di && !pi
      ? mesh.material.uniforms.uColor4.value.set(fi)
      : mesh.material.uniforms.uColor4.value.set(fi, di, pi);
  }
  function ci(fi) {
    grainEffect.uniforms.get("uIntensity").value = fi;
  }
  return {
    mount: ze,
    unmount: Gr,
    render: Yr,
    getSize: Kr,
    getOffset: Zr,
    getSpeed: Jr,
    getColor1: Qr,
    getColor2: ei,
    getColor3: ti,
    getColor4: ri,
    getGrainIntensity: ni,
    setSize: ii,
    setOffset: si,
    setSpeed: li,
    setColor1: oi,
    setColor2: ui,
    setColor3: ai,
    setColor4: hi,
    setGrainIntensity: ci,
  };
}
function canvas(Wr = !1) {
  let ze,
    Gr = {
      gradient: createGradient(),
    };
  function Yr(Qr, ei) {
    ze && ze.unmount(), (ze = Gr[Qr]), ze.mount(ei, Wr);
  }
  function Kr() {
    return ze;
  }
  function Zr() {
    ze && ze.unmount();
  }
  function Jr(Qr) {
    ze && ze.render(Qr);
  }
  return {
    setEffect: Yr,
    getEffect: Kr,
    stop: Zr,
    render: Jr,
  };
}
const isEmpty = function (Wr) {
    return Wr && Object.keys(Wr).length === 0 && Wr.constructor === Object;
  },
  t = function (Wr, ze = {}) {
    return (
      window.FormieTranslations && (Wr = window.FormieTranslations[Wr] || Wr),
      Wr.replace(/{([a-zA-Z0-9]+)}/g, (Gr, Yr) => (ze[Yr] ? ze[Yr] : Gr))
    );
  },
  waitForElement = function (Wr, ze) {
    return (
      (ze = ze || document),
      new Promise((Gr) => {
        if (ze.querySelector(Wr)) return Gr(ze.querySelector(Wr));
        const Yr = new MutationObserver((Kr) => {
          ze.querySelector(Wr) && (Yr.disconnect(), Gr(ze.querySelector(Wr)));
        });
        Yr.observe(ze, {
          childList: !0,
          subtree: !0,
        });
      })
    );
  };
/*!
 * formbouncerjs v1.4.6
 * A lightweight form validation script that augments native HTML5 form validation elements and attributes.
 * (c) 2020 Chris Ferdinandi
 * MIT License
 * http://github.com/cferdinandi/bouncer
 */
const Bouncer = function (Wr, ze) {
  var Gr = {
      fieldClass: "error",
      errorClass: "error-message",
      fieldPrefix: "bouncer-field_",
      errorPrefix: "bouncer-error_",
      patterns: {
        email:
          /^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*(\.\w{2,})+$/,
        url: /^(?:(?:https?|HTTPS?|ftp|FTP):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)(?:\.(?:[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)*(?:\.(?:[a-zA-Z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/,
        number: /^(?:[-+]?[0-9]*[.,]?[0-9]+)$/,
        color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,
        date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))/,
        time: /^(?:(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]))$/,
        month: /^(?:(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])))$/,
      },
      customValidations: {},
      messageAfterField: !0,
      messageCustom: "data-bouncer-message",
      messageTarget: "data-bouncer-target",
      disableSubmit: !1,
      validateOnBlur: !0,
      validateOnSubmit: !0,
      emitEvents: !0,
    },
    Yr = function (vi, Ii) {
      Array.prototype.forEach.call(vi, Ii);
    },
    Kr = function () {
      var vi = {};
      return (
        Yr(arguments, (Ii) => {
          for (var Oi in Ii) {
            if (!Ii.hasOwnProperty(Oi)) return;
            Object.prototype.toString.call(Ii[Oi]) === "[object Object]"
              ? (vi[Oi] = Kr(vi[Oi], Ii[Oi]))
              : (vi[Oi] = Ii[Oi]);
          }
        }),
        vi
      );
    },
    Zr = function (vi, Ii, Oi) {
      if (typeof window.CustomEvent == "function") {
        var ki = new CustomEvent(Ii, {
          bubbles: !0,
          detail: Oi || {},
        });
        vi.dispatchEvent(ki);
      }
    },
    Jr = function (vi) {
      vi.setAttribute("novalidate", !0);
    },
    Qr = function (vi) {
      vi.removeAttribute("novalidate");
    },
    ei = function (vi) {
      if (!vi.hasAttribute("required")) return !1;
      if (vi.type === "checkbox") {
        var Ii = vi.form.querySelectorAll(
          '[name="' + ui(vi.name) + '"]:not([type="hidden"])'
        );
        if (Ii.length) {
          var Oi = Array.prototype.filter.call(Ii, (Bi) => Bi.checked).length;
          return !Oi;
        }
        return !vi.checked;
      }
      if (vi.type === "hidden") return !1;
      var { length: ki } = vi.value;
      return (
        vi.type === "radio" &&
          (ki = Array.prototype.filter.call(
            vi.form.querySelectorAll('[name="' + ui(vi.name) + '"]'),
            (Bi) => Bi.checked
          ).length),
        ki < 1
      );
    },
    ti = function (vi, Ii) {
      var Oi = vi.getAttribute("pattern");
      return (
        (Oi = Oi ? new RegExp("^(?:" + Oi + ")$") : Ii.patterns[vi.type]),
        !Oi || !vi.value || vi.value.length < 1 ? !1 : !vi.value.match(Oi)
      );
    },
    ri = function (vi) {
      if (!vi.value || vi.value.length < 1) return !1;
      var Ii = vi.getAttribute("max"),
        Oi = vi.getAttribute("min"),
        ki = parseFloat(vi.value);
      return Ii && ki > Ii ? "over" : Oi && ki < Oi ? "under" : !1;
    },
    ni = function (vi) {
      if (!vi.value || vi.value.length < 1) return !1;
      var Ii = vi.getAttribute("maxlength"),
        Oi = vi.getAttribute("minlength"),
        { length: ki } = vi.value;
      return Ii && ki > Ii ? "over" : Oi && ki < Oi ? "under" : !1;
    },
    ii = function (vi, Ii) {
      return {
        missingValue: ei(vi),
        patternMismatch: ti(vi, Ii),
        outOfRange: ri(vi),
        wrongLength: ni(vi),
      };
    },
    si = function (vi, Ii, Oi, ki) {
      for (var Bi in Oi) Oi.hasOwnProperty(Bi) && (Ii[Bi] = Oi[Bi](vi, ki));
      return Ii;
    },
    li = function (vi) {
      for (var Ii in vi) if (vi[Ii]) return !0;
      return !1;
    },
    oi = function (vi, Ii) {
      var Oi = ii(vi, Ii);
      return (
        (Oi = si(vi, Oi, Ii.customValidations, Ii)),
        {
          valid: !li(Oi),
          errors: Oi,
        }
      );
    },
    ui = function (vi) {
      for (
        var Ii = String(vi),
          { length: Oi } = Ii,
          ki = -1,
          Bi,
          Xi = "",
          an = Ii.charCodeAt(0);
        ++ki < Oi;

      ) {
        if (((Bi = Ii.charCodeAt(ki)), Bi === 0))
          throw new InvalidCharacterError(
            "Invalid character: the input contains U+0000."
          );
        if (
          (Bi >= 1 && Bi <= 31) ||
          Bi == 127 ||
          (ki === 0 && Bi >= 48 && Bi <= 57) ||
          (ki === 1 && Bi >= 48 && Bi <= 57 && an === 45)
        ) {
          Xi += "\\" + Bi.toString(16) + " ";
          continue;
        }
        if (
          Bi >= 128 ||
          Bi === 45 ||
          Bi === 95 ||
          (Bi >= 48 && Bi <= 57) ||
          (Bi >= 65 && Bi <= 90) ||
          (Bi >= 97 && Bi <= 122)
        ) {
          Xi += Ii.charAt(ki);
          continue;
        }
        Xi += "\\" + Ii.charAt(ki);
      }
      return Xi;
    },
    ai = function (vi, Ii, Oi) {
      var ki = vi.name ? vi.name : vi.id;
      return (
        !ki &&
          Oi &&
          ((ki = Ii.fieldPrefix + Math.floor(Math.random() * 999)),
          (vi.id = ki)),
        ki
      );
    },
    hi = function (vi) {
      if (vi.type === "radio" && vi.name) {
        var Ii = vi.form.querySelectorAll('[name="' + ui(vi.name) + '"]');
        vi = Ii[Ii.length - 1];
      }
      return (
        (vi.type === "checkbox" || vi.type === "radio") &&
          (vi = vi.closest("[data-field-handle]").firstChild),
        vi
      );
    },
    ci = function (vi, Ii, Oi) {
      var ki = vi.getAttribute(Oi.messageTarget);
      if (ki) {
        var Bi = vi.form.querySelector(ki);
        if (Bi)
          return Bi.firstChild || Bi.appendChild(document.createTextNode(""));
      }
      return Oi.messageAfterField
        ? (Ii || (Ii = vi),
          Ii.nextSibling ||
            Ii.parentNode.appendChild(document.createTextNode("")),
          Ii.nextSibling)
        : Ii;
    },
    fi = function (vi, Ii) {
      var Oi = document.createElement("div");
      (Oi.className = Ii.errorClass),
        Oi.setAttribute("data-error-message", ""),
        (Oi.id = Ii.errorPrefix + ai(vi, Ii, !0)),
        Oi.setAttribute("aria-live", "polite"),
        Oi.setAttribute("aria-atomic", !0);
      var ki = hi(vi),
        Bi = ci(vi, ki, Ii);
      return Bi.parentNode.insertBefore(Oi, Bi), Oi;
    },
    di = function (vi, Ii, Oi) {
      var { messages: ki } = Oi;
      if (Ii.missingValue)
        return ki.missingValue[vi.type] || ki.missingValue.default;
      if (Ii.outOfRange)
        return ki.outOfRange[Ii.outOfRange]
          .replace("{max}", vi.getAttribute("max"))
          .replace("{min}", vi.getAttribute("min"))
          .replace("{length}", vi.value.length);
      if (Ii.wrongLength)
        return ki.wrongLength[Ii.wrongLength]
          .replace("{maxLength}", vi.getAttribute("maxlength"))
          .replace("{minLength}", vi.getAttribute("minlength"))
          .replace("{length}", vi.value.length);
      if (Ii.patternMismatch) {
        var Bi = vi.getAttribute(Oi.messageCustom);
        return Bi || ki.patternMismatch[vi.type] || ki.patternMismatch.default;
      }
      for (var Xi in Oi.customValidations)
        if (Oi.customValidations.hasOwnProperty(Xi) && Ii[Xi] && ki[Xi])
          return ki[Xi];
      return Ii.customMessage ? Ii.customMessage : ki.fallback;
    },
    pi = function (vi, Ii, Oi) {
      vi.classList.add(Oi.fieldClass),
        vi.setAttribute("aria-describedby", Ii.id),
        vi.setAttribute("aria-invalid", !0);
      var ki = vi.closest("[data-field-handle]");
      ki && ki.classList.add(Oi.fieldClass);
    },
    mi = function (vi, Ii, Oi) {
      vi.type === "radio" &&
        vi.name &&
        Array.prototype.forEach.call(
          document.querySelectorAll('[name="' + vi.name + '"]'),
          (ki) => {
            pi(ki, Ii, Oi);
          }
        ),
        pi(vi, Ii, Oi);
    },
    Si = function (vi, Ii, Oi) {
      var ki =
          vi.form.querySelector("#" + ui(Oi.errorPrefix + ai(vi, Oi))) ||
          fi(vi, Oi),
        Bi = di(vi, Ii, Oi);
      (ki.textContent = typeof Bi == "function" ? Bi(vi, Oi) : Bi),
        mi(vi, ki, Oi),
        Oi.emitEvents &&
          Zr(vi, "bouncerShowError", {
            errors: Ii,
          });
    },
    yi = function (vi, Ii) {
      vi.classList.remove(Ii.fieldClass),
        vi.removeAttribute("aria-describedby"),
        vi.removeAttribute("aria-invalid");
      var Oi = vi.closest("[data-field-handle]");
      Oi && Oi.classList.remove(Ii.fieldClass);
    },
    Ei = function (vi, Ii) {
      if (vi.type === "radio" && vi.name) {
        Array.prototype.forEach.call(
          document.querySelectorAll('[name="' + vi.name + '"]'),
          (Oi) => {
            yi(Oi, Ii);
          }
        );
        return;
      }
      yi(vi, Ii);
    },
    Pi = function (vi, Ii) {
      var Oi = vi.form.querySelector("#" + ui(Ii.errorPrefix + ai(vi, Ii)));
      Oi &&
        (Oi.parentNode.removeChild(Oi),
        Ei(vi, Ii),
        Ii.emitEvents && Zr(vi, "bouncerRemoveError"));
    },
    Ai = function (vi, Ii) {
      Yr(vi.querySelectorAll("input, select, textarea"), (Oi) => {
        Pi(Oi, Ii);
      });
    },
    Ri = {},
    wi;
  (Ri.showError = function (vi, Ii, Oi) {
    var ki = Kr(wi, Oi || {});
    return Si(vi, Ii, ki);
  }),
    (Ri.removeError = function (vi, Ii) {
      var Oi = Kr(wi, Ii || {});
      return Pi(vi, Oi);
    }),
    (Ri.validate = function (vi, Ii) {
      if (
        !(
          vi.disabled ||
          vi.readOnly ||
          vi.type === "reset" ||
          vi.type === "submit" ||
          vi.type === "button"
        )
      ) {
        var Oi = Kr(wi, Ii || {}),
          ki = oi(vi, Oi);
        if (ki.valid) {
          Pi(vi, Oi);
          return;
        }
        return Si(vi, ki.errors, Oi), ki;
      }
    }),
    (Ri.validateAll = function (vi) {
      return Array.prototype.filter.call(
        vi.querySelectorAll("input, select, textarea"),
        (Ii) => {
          var Oi = Ri.validate(Ii);
          return Oi && !Oi.valid;
        }
      );
    });
  var Ci = function (vi) {
      !vi.target.form ||
        !vi.target.form.isSameNode(Wr) ||
        (vi.target.type !== "file" &&
          (vi.target.type === "checkbox" ||
            vi.target.type === "radio" ||
            Ri.validate(vi.target)));
    },
    bi = function (vi) {
      !vi.target.form ||
        !vi.target.form.isSameNode(Wr) ||
        (vi.target.type !== "file" &&
          vi.target.type !== "checkbox" &&
          vi.target.type !== "radio") ||
        Ri.validate(vi.target);
    },
    Mi = function (vi) {
      !vi.target.form ||
        !vi.target.form.isSameNode(Wr) ||
        (vi.target.classList.contains(wi.fieldClass) &&
          (vi.target.type === "checkbox" ||
            vi.target.type === "radio" ||
            Ri.validate(vi.target)));
    },
    gi = function (vi) {
      !vi.target.form ||
        !vi.target.form.isSameNode(Wr) ||
        (vi.target.classList.contains(wi.fieldClass) &&
          (vi.target.type === "checkbox" ||
            vi.target.type === "radio" ||
            Ri.validate(vi.target)));
    },
    xi = function (vi) {
      if (vi.target.isSameNode(Wr)) {
        vi.preventDefault();
        var Ii = Ri.validateAll(vi.target);
        if (Ii.length > 0) {
          Ii[0].focus(),
            Zr(vi.target, "bouncerFormInvalid", {
              errors: Ii,
            });
          return;
        }
        wi.disableSubmit || vi.target.submit(),
          wi.emitEvents && Zr(vi.target, "bouncerFormValid");
      }
    };
  Ri.destroy = function () {
    wi.validateOnBlur &&
      (document.removeEventListener("blur", Ci, !0),
      document.removeEventListener("input", Mi, !1),
      document.removeEventListener("change", bi, !1),
      document.removeEventListener("click", gi, !1)),
      wi.validateOnSubmit && document.removeEventListener("submit", xi, !1),
      Ai(Wr, wi),
      Qr(Wr),
      wi.emitEvents &&
        Zr(document, "bouncerDestroyed", {
          settings: wi,
        }),
      (wi = null);
  };
  var Ti = function () {
    (wi = Kr(Gr, ze || {})),
      Jr(Wr),
      wi.validateOnBlur &&
        (document.addEventListener("blur", Ci, !0),
        document.addEventListener("input", Mi, !1),
        document.addEventListener("change", bi, !1),
        document.addEventListener("click", gi, !1)),
      wi.validateOnSubmit && document.addEventListener("submit", xi, !1),
      wi.emitEvents &&
        Zr(document, "bouncerInitialized", {
          settings: wi,
        });
  };
  return Ti(), Ri;
};
class FormieFormTheme {
  constructor(ze, Gr = {}) {
    (this.$form = ze),
      (this.config = Gr),
      (this.settings = Gr.settings),
      (this.validationOnSubmit = !!this.settings.validationOnSubmit),
      (this.validationOnFocus = !!this.settings.validationOnFocus),
      this.setCurrentPage(this.settings.currentPageId),
      this.$form &&
        ((this.$form.formTheme = this),
        (this.form = this.$form.form),
        (this.loadingClass = this.form.getClasses("loading")),
        (this.tabErrorClass = this.form.getClasses("tabError")),
        (this.tabActiveClass = this.form.getClasses("tabActive")),
        (this.tabCompleteClass = this.form.getClasses("tabComplete")),
        (this.errorMessageClass = this.form.getClasses("errorMessage")),
        (this.successMessageClass = this.form.getClasses("successMessage")),
        (this.alertClass = this.form.getClasses("alert")),
        (this.alertErrorClass = this.form.getClasses("alertError")),
        (this.alertSuccessClass = this.form.getClasses("alertSuccess")),
        (this.tabClass = this.form.getClasses("tab")),
        this.initValidator(),
        this.hideSuccess(),
        this.addSubmitEventListener(),
        this.updateFormHash(),
        this.settings.enableUnloadWarning && this.addFormUnloadEventListener(),
        this.settings.submitMethod === "ajax" && this.formTabEventListener());
  }
  initValidator() {
    const ze = {
        fieldClass: "fui-error",
        errorClass: this.form.getClasses("fieldError"),
        fieldPrefix: "fui-field-",
        errorPrefix: "fui-error-",
        messageAfterField: !0,
        messageCustom: "data-fui-message",
        messageTarget: "data-fui-target",
        validateOnBlur: this.validationOnFocus,
        validateOnSubmit: !1,
        disableSubmit: !1,
        customValidations: {},
        messages: {
          missingValue: {
            checkbox: t("This field is required."),
            radio: t("Please select a value."),
            select: t("Please select a value."),
            "select-multiple": t("Please select at least one value."),
            default: t("Please fill out this field."),
          },
          patternMismatch: {
            email: t("Please enter a valid email address."),
            url: t("Please enter a URL."),
            number: t("Please enter a number"),
            color: t("Please match the following format: #rrggbb"),
            date: t("Please use the YYYY-MM-DD format"),
            time: t("Please use the 24-hour time format. Ex. 23:00"),
            month: t("Please use the YYYY-MM format"),
            default: t("Please match the requested format."),
          },
          outOfRange: {
            over: t("Please select a value that is no more than {max}."),
            under: t("Please select a value that is no less than {min}."),
          },
          wrongLength: {
            over: t(
              "Please shorten this text to no more than {maxLength} characters. You are currently using {length} characters."
            ),
            under: t(
              "Please lengthen this text to {minLength} characters or more. You are currently using {length} characters."
            ),
          },
          fallback: t("There was an error with this field."),
        },
      },
      Gr = new CustomEvent("registerFormieValidation", {
        bubbles: !0,
        detail: {
          validatorSettings: ze,
        },
      });
    setTimeout(() => {
      this.$form.dispatchEvent(Gr),
        (this.validator = new Bouncer(this.$form, Gr.detail.validatorSettings));
    }, 500),
      this.form.addEventListener(this.$form, "bouncerRemoveError", (Yr) => {
        this.submitDebounce || this.validate(!1);
      }),
      this.form.addEventListener(
        this.$form,
        "bouncerShowError",
        (Yr) => {
          let Kr = null;
          const Zr = Yr.target,
            Jr = Zr.closest("[data-field-type]"),
            Qr = Zr.parentNode.querySelector("[data-error-message]");
          if (
            (Qr &&
              Qr.parentNode.parentNode &&
              Qr.parentNode.parentNode.appendChild(Qr),
            Yr.detail &&
              Yr.detail.errors &&
              (Yr.detail.errors.missingValue || Yr.detail.errors.serverMessage))
          ) {
            const ei = Zr.parentNode.querySelector("[data-fui-message]");
            if (
              (ei && (Kr = ei.getAttribute("data-fui-message")),
              Yr.detail.errors.serverMessage &&
                (Kr = Yr.detail.errors.serverMessage),
              Jr)
            ) {
              const ti = Jr.querySelector("[data-error-message]");
              ti && Kr && (ti.textContent = Kr);
            }
          }
        },
        !1
      );
  }
  addSubmitEventListener() {
    this.$form.querySelectorAll('[type="submit"]').forEach((Gr) => {
      this.form.addEventListener(Gr, "click", (Yr) => {
        (this.$submitBtn = Yr.target),
          (this.originalButtonText = this.$submitBtn.textContent.trim());
        const Kr =
          this.$submitBtn.getAttribute("data-submit-action") || "submit";
        this.updateSubmitAction(Kr);
      });
    }),
      this.form.addEventListener(
        this.$form,
        "onBeforeFormieSubmit",
        this.onBeforeSubmit.bind(this)
      ),
      this.form.addEventListener(
        this.$form,
        "onFormieValidate",
        this.onValidate.bind(this)
      ),
      this.form.addEventListener(
        this.$form,
        "onFormieSubmit",
        this.onSubmit.bind(this)
      ),
      this.form.addEventListener(
        this.$form,
        "onFormieSubmitError",
        this.onSubmitError.bind(this)
      );
  }
  onBeforeSubmit(ze) {
    this.beforeSubmit(), (this.submitHandler = ze.detail.submitHandler);
  }
  onValidate(ze) {
    this.validate() ||
      (this.onFormError(), (ze.detail.invalid = !0), ze.preventDefault());
  }
  onSubmit(ze) {
    ze.preventDefault(),
      this.settings.submitMethod === "ajax"
        ? this.ajaxSubmit()
        : ((!this.settings.enableBackSubmission &&
            this.form.submitAction === "back") ||
            this.updateFormHash(),
          this.form.submitAction === "submit" && this.triggerJsEvents(),
          this.$form.submit());
  }
  onSubmitError(ze) {
    this.onFormError();
  }
  addFormUnloadEventListener() {
    this.form.addEventListener(window, "beforeunload", (ze) => {
      if (this.savedFormHash !== this.hashForm())
        return (
          ze.preventDefault(),
          (ze.returnValue = t("Are you sure you want to leave?"))
        );
    });
  }
  formTabEventListener() {
    this.$form.querySelectorAll("[data-fui-page-tab-anchor]").forEach((Gr) => {
      this.form.addEventListener(Gr, "click", (Yr) => {
        Yr.preventDefault();
        const Kr = Yr.target.getAttribute("data-fui-page-index"),
          Zr = Yr.target.getAttribute("data-fui-page-id");
        this.togglePage({
          nextPageIndex: Kr,
          nextPageId: Zr,
          totalPages: this.settings.pages.length,
        });
        const Jr = new XMLHttpRequest();
        Jr.open("GET", Yr.target.getAttribute("href"), !0),
          Jr.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
          Jr.setRequestHeader("Accept", "application/json"),
          Jr.setRequestHeader("Cache-Control", "no-cache"),
          Jr.send();
      });
    });
  }
  hashForm() {
    const ze = {},
      Gr = new FormData(this.$form),
      Yr = [
        "g-recaptcha-response",
        "h-captcha-response",
        "CRAFT_CSRF_TOKEN",
        "__JSCHK",
        "__DUP",
        "beesknees",
        "cf-turnstile-response",
        "frc-captcha-solution",
        "submitAction",
      ];
    for (const Kr of Gr.entries())
      Yr.filter((Jr) => Kr[0].startsWith(Jr)).length || (ze[Kr[0]] = Kr[1]);
    return JSON.stringify(ze);
  }
  updateFormHash() {
    this.savedFormHash = this.hashForm();
  }
  validate(ze = !0) {
    if (!this.validationOnSubmit || this.form.submitAction !== "submit")
      return !0;
    let Gr = this.$form;
    this.$currentPage && (Gr = this.$currentPage);
    const Yr = this.validator.validateAll(Gr);
    return (
      Yr.length > 0 && ze && Yr[0].focus(),
      Yr.length === 0 && this.removeFormAlert(),
      (this.submitDebounce = !0),
      setTimeout(() => {
        this.submitDebounce = !1;
      }, 500),
      !Yr.length
    );
  }
  hideSuccess() {
    const ze = this.$form.parentNode.querySelector(
      `.${this.successMessageClass}`
    );
    if (ze && this.settings.submitActionMessageTimeout) {
      const Gr = parseInt(this.settings.submitActionMessageTimeout, 10) * 1e3;
      setTimeout(() => {
        ze.remove();
      }, Gr);
    }
  }
  addLoading() {
    this.$submitBtn &&
      (this.$submitBtn.setAttribute("disabled", !0),
      this.settings.loadingIndicator === "spinner" &&
        this.$submitBtn.classList.add(this.loadingClass),
      this.settings.loadingIndicator === "text" &&
        (this.$submitBtn.textContent = this.settings.loadingIndicatorText));
  }
  removeLoading() {
    this.$submitBtn &&
      (this.$submitBtn.removeAttribute("disabled"),
      this.settings.loadingIndicator === "spinner" &&
        this.$submitBtn.classList.remove(this.loadingClass),
      this.settings.loadingIndicator === "text" &&
        (this.$submitBtn.textContent = this.originalButtonText));
  }
  onFormError(ze) {
    ze
      ? this.showFormAlert(ze, "error")
      : this.showFormAlert(this.settings.errorMessage, "error"),
      this.removeLoading();
  }
  showFormAlert(ze, Gr) {
    let Yr = this.$form.parentNode.querySelector("[data-fui-alert]");
    (ze = ze.replace(/<p[^>]*>/g, "").replace(/<\/p>/g, "")),
      Yr
        ? Yr.innerHTML !== this.decodeHtml(ze) &&
          (Yr.innerHTML = `${Yr.innerHTML}<br>${ze}`)
        : ((Yr = document.createElement("div")),
          (Yr.className = this.alertClass),
          Yr.setAttribute("role", "alert"),
          Yr.setAttribute("data-fui-alert", "true"),
          (Yr.innerHTML = ze),
          this.form.applyThemeConfig(Yr, "alert", !1),
          Gr == "error"
            ? (this.form.applyThemeConfig(Yr, "alertError", !1),
              (Yr.className += ` ${this.alertErrorClass} ${this.alertClass}-${this.settings.errorMessagePosition}`),
              this.settings.errorMessagePosition == "bottom-form"
                ? this.$submitBtn.parentNode.parentNode.insertBefore(
                    Yr,
                    this.$submitBtn.parentNode
                  )
                : this.settings.errorMessagePosition == "top-form" &&
                  this.$form.parentNode.insertBefore(Yr, this.$form))
            : (this.form.applyThemeConfig(Yr, "alertSuccess", !1),
              (Yr.className += ` ${this.alertSuccessClass} ${this.alertClass}-${this.settings.submitActionMessagePosition}`),
              this.settings.submitActionMessagePosition == "bottom-form"
                ? this.settings.submitActionFormHide
                  ? this.$form.parentNode.insertBefore(Yr, this.$form)
                  : this.$submitBtn.parentNode
                  ? this.$submitBtn.parentNode.parentNode.insertBefore(
                      Yr,
                      this.$submitBtn.parentNode
                    )
                  : this.$form.parentNode.insertBefore(
                      Yr,
                      this.$form.nextSibling
                    )
                : this.settings.submitActionMessagePosition == "top-form" &&
                  this.$form.parentNode.insertBefore(Yr, this.$form)));
  }
  showTabErrors(ze) {
    Object.keys(ze).forEach((Gr, Yr) => {
      const Kr = this.$form.parentNode.querySelector(
        `[data-fui-page-id="${Gr}"]`
      );
      Kr && Kr.parentNode.classList.add(this.tabErrorClass);
    });
  }
  decodeHtml(ze) {
    const Gr = document.createElement("textarea");
    return (Gr.innerHTML = ze), Gr.value;
  }
  removeFormAlert() {
    const ze = this.$form.parentNode.querySelector(`.${this.alertClass}`);
    ze && ze.remove();
  }
  removeTabErrors() {
    this.$form.parentNode
      .querySelectorAll("[data-fui-page-tab]")
      .forEach((Gr) => {
        Gr.classList.remove(this.tabErrorClass);
      });
  }
  beforeSubmit() {
    Array.prototype.filter.call(
      this.$form.querySelectorAll("input, select, textarea"),
      (ze) => {
        this.validator.removeError(ze);
      }
    ),
      this.removeFormAlert(),
      this.removeTabErrors(),
      (!this.settings.enableBackSubmission &&
        this.form.submitAction === "back") ||
        this.addLoading();
  }
  ajaxSubmit() {
    const ze = new FormData(this.$form),
      Gr = this.$form.getAttribute("method"),
      Yr = this.$form.getAttribute("action"),
      Kr = new XMLHttpRequest();
    Kr.open(Gr || "POST", Yr || window.location.href, !0),
      Kr.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
      Kr.setRequestHeader("Accept", "application/json"),
      Kr.setRequestHeader("Cache-Control", "no-cache"),
      (Kr.timeout = (this.settings.ajaxTimeout || 10) * 1e3),
      this.beforeSubmit(),
      (Kr.ontimeout = () => {
        this.onAjaxError(t("The request timed out."));
      }),
      (Kr.onerror = (Zr) => {
        this.onAjaxError(
          t("The request encountered a network error. Please try again.")
        );
      }),
      (Kr.onload = () => {
        if (Kr.status >= 200 && Kr.status < 300)
          try {
            const Zr = JSON.parse(Kr.responseText);
            Zr.errors
              ? this.onAjaxError(Zr.errorMessage, Zr)
              : this.onAjaxSuccess(Zr);
          } catch (Zr) {
            this.onAjaxError(
              t("Unable to parse response `{e}`.", {
                e: Zr,
              })
            );
          }
        else this.onAjaxError(`${Kr.status}: ${Kr.statusText}`);
      }),
      Kr.send(ze);
  }
  afterAjaxSubmit(ze) {
    this.updateSubmitAction("submit"),
      this.updateSubmissionInput(ze),
      ze.events &&
        Array.isArray(ze.events) &&
        ze.events.length &&
        (this.removeFormAlert(),
        ze.events.forEach((Gr) => {
          this.$form.dispatchEvent(
            new CustomEvent(Gr.event, {
              bubbles: !0,
              detail: {
                data: Gr.data,
              },
            })
          );
        }));
  }
  onAjaxError(ze, Gr = {}) {
    const Yr = Gr.errors || {},
      Kr = Gr.pageFieldErrors || {};
    this.onFormError(ze),
      this.showTabErrors(Kr),
      this.submitHandler.formSubmitError(Gr),
      this.afterAjaxSubmit(Gr),
      Object.keys(Yr).forEach((Zr, Jr) => {
        const [Qr] = Yr[Zr];
        let ei = Zr.split(".");
        ei = ei.join("][");
        let ti = this.$form.querySelector(`[name="fields[${ei}]"]`);
        if (
          (ti || (ti = this.$form.querySelector(`[name="fields[${ei}][]"]`)),
          !ti && Zr.includes("["))
        ) {
          const ri = Zr.match(/\[(.*?)\]/)[1] || null;
          let ni = `fields[${Zr.replace(/\./g, "][")
            .replace("]]", "]")
            .replace(/\[.*?\]/, "][rows][.*][fields]")}]`;
          ni = ni.replace(/\[/g, "\\[").replace(/\]/g, "\\]");
          const ii = this.querySelectorAllRegex(new RegExp(ni), "name");
          ii.length && ii[ri] && (ti = ii[ri]);
        }
        ti &&
          (this.validator.showError(ti, {
            serverMessage: Qr,
          }),
          Jr === 0 && ti.focus());
      }),
      this.togglePage(Gr, !1);
  }
  onAjaxSuccess(ze) {
    if (
      (this.submitHandler.formAfterSubmit(ze),
      this.afterAjaxSubmit(ze),
      this.updateFormHash(),
      this.form.submitAction === "submit" && this.triggerJsEvents(),
      ze.nextPageId)
    ) {
      this.removeLoading(), this.togglePage(ze);
      return;
    }
    if (ze.redirectCallback) {
      ze.redirectCallback();
      return;
    }
    if (ze.redirectUrl) {
      this.settings.submitActionTab === "new-tab"
        ? (this.resetForm(), ze.redirectTarget.open(ze.redirectUrl, "_blank"))
        : (ze.redirectTarget.location.href = ze.redirectUrl);
      return;
    }
    if (
      (this.removeLoading(),
      ze.totalPages > 1 &&
        (this.settings.submitActionMessagePosition == "top-form"
          ? this.togglePage({
              nextPageIndex: 0,
              nextPageId: this.settings.pages[0].id,
              totalPages: this.settings.pages.length,
            })
          : (this.$submitBtn && this.$submitBtn.remove(),
            this.$form
              .querySelectorAll('[data-submit-action="back"]')
              .forEach((Yr) => {
                Yr.remove();
              }))),
      this.settings.submitAction === "message")
    ) {
      const Gr = ze.submitActionMessage || this.settings.submitActionMessage;
      this.showFormAlert(Gr, "success"),
        this.hideSuccess(),
        this.settings.submitActionFormHide &&
          (this.$form.style.display = "none"),
        this.settings.scrollToTop && this.scrollToForm();
    }
    this.resetForm(),
      this.removeHiddenInput("submissionId"),
      this.updateFormHash();
  }
  updateSubmitAction(ze) {
    ze || (ze = "submit"),
      (this.form.submitAction = ze),
      this.updateOrCreateHiddenInput("submitAction", ze);
  }
  updateSubmissionInput(ze) {
    !ze.submissionId ||
      !ze.nextPageId ||
      this.updateOrCreateHiddenInput("submissionId", ze.submissionId);
  }
  updateOrCreateHiddenInput(ze, Gr) {
    let Yr = this.$form.querySelector(`[name="${ze}"][type="hidden"]`);
    Yr ||
      ((Yr = document.createElement("input")),
      Yr.setAttribute("type", "hidden"),
      Yr.setAttribute("name", ze),
      this.$form.appendChild(Yr)),
      Yr.setAttribute("value", Gr);
  }
  resetForm() {
    this.$form.reset(),
      this.$form.querySelectorAll('[type="checkbox"]').forEach((ze) => {
        ze.removeAttribute("checked");
      });
  }
  removeHiddenInput(ze) {
    const Gr = this.$form.querySelector(`[name="${ze}"][type="hidden"]`);
    Gr && Gr.parentNode.removeChild(Gr);
  }
  togglePage(ze, Gr = !0) {
    this.$form.dispatchEvent(
      new CustomEvent("onFormiePageToggle", {
        bubbles: !0,
        detail: {
          data: ze,
        },
      })
    );
    const Yr = this.$form.querySelectorAll("[data-fui-page]");
    ze.nextPageId &&
      Yr.forEach((Jr) => {
        Jr.id === `${this.getPageId(ze.nextPageId)}`
          ? Jr.removeAttribute("data-fui-page-hidden")
          : Jr.setAttribute("data-fui-page-hidden", !0);
      });
    const Kr = this.$form.querySelector("[data-fui-progress-bar]");
    if (Kr && ze.nextPageIndex >= 0) {
      const Jr = parseInt(ze.nextPageIndex, 10) + 1,
        Qr = Math.round((Jr / ze.totalPages) * 100);
      (Kr.style.width = `${Qr}%`),
        Kr.setAttribute("aria-valuenow", Qr),
        (Kr.textContent = `${Qr}%`);
    }
    const Zr = this.$form.querySelectorAll("[data-fui-page-tab]");
    if (ze.nextPageId) {
      Zr.forEach((Qr) => {
        Qr.id === `${this.tabClass}-${ze.nextPageId}`
          ? Qr.classList.add(this.tabActiveClass)
          : Qr.classList.remove(this.tabActiveClass);
      });
      let Jr = !0;
      Zr.forEach((Qr) => {
        Qr.classList.contains(this.tabActiveClass) && (Jr = !1),
          Jr
            ? Qr.classList.add(this.tabCompleteClass)
            : Qr.classList.remove(this.tabCompleteClass);
      }),
        this.setCurrentPage(ze.nextPageId);
    }
    this.settings.scrollToTop && this.scrollToForm();
  }
  setCurrentPage(ze) {
    (this.settings.currentPageId = ze),
      (this.$currentPage = this.$form.querySelector(`#${this.getPageId(ze)}`));
  }
  getCurrentPage() {
    return this.settings.pages.find(
      (ze) => ze.id == this.settings.currentPageId
    );
  }
  getCurrentPageIndex() {
    const ze = this.getCurrentPage();
    return ze ? this.settings.pages.indexOf(ze) : 0;
  }
  getPageId(ze) {
    return `${this.config.formHashId}-p-${ze}`;
  }
  scrollToForm() {
    const ze = (
        document.documentElement.style["scroll-padding-top"] || "0px"
      ).replace("px", ""),
      Gr = (
        document.documentElement.style["scroll-margin-top"] || "0px"
      ).replace("px", "");
    window.scrollTo({
      top:
        this.$form.parentNode.getBoundingClientRect().top +
        window.pageYOffset -
        100 -
        ze -
        Gr,
      behavior: "smooth",
    });
  }
  triggerJsEvents() {
    const ze = this.getCurrentPage();
    if (ze && ze.settings.enableJsEvents) {
      const Gr = {};
      ze.settings.jsGtmEventOptions.forEach((Yr) => {
        Gr[Yr.label] = Yr.value;
      }),
        (window.dataLayer = window.dataLayer || []),
        window.dataLayer.push(Gr);
    }
  }
  querySelectorAllRegex(ze, Gr) {
    const Yr = [];
    for (const Kr of this.$form.querySelectorAll(`[${Gr}]`))
      ze.test(Kr.getAttribute(Gr)) && Yr.push(Kr);
    return Yr;
  }
}
class FormieFormBase {
  constructor(ze, Gr = {}) {
    (this.$form = ze),
      (this.config = Gr),
      (this.settings = Gr.settings),
      (this.listeners = {}),
      this.$form &&
        ((this.$form.form = this),
        this.settings.outputJsTheme &&
          (this.formTheme = new FormieFormTheme(this.$form, this.config)),
        this.registerFieldEvents(this.$form),
        this.addEventListener(
          this.$form,
          "submit",
          (Yr) => {
            Yr.preventDefault();
            const Kr = this.eventObject("onBeforeFormieSubmit", {
              submitHandler: this,
            });
            this.$form.dispatchEvent(Kr) &&
              setTimeout(() => {
                !this.validate() ||
                  !this.afterValidate() ||
                  (this.validateCaptchas() &&
                    this.validatePayment() &&
                    this.submitForm());
              }, 300);
          },
          !1
        ));
  }
  validate() {
    const ze = this.eventObject("onFormieValidate", {
      submitHandler: this,
    });
    return this.$form.dispatchEvent(ze);
  }
  afterValidate() {
    const ze = this.eventObject("onAfterFormieValidate", {
      submitHandler: this,
    });
    return this.$form.dispatchEvent(ze);
  }
  validateCaptchas() {
    const ze = this.eventObject("onFormieCaptchaValidate", {
      submitHandler: this,
    });
    return this.$form.dispatchEvent(ze);
  }
  validatePayment() {
    const ze = this.eventObject("onFormiePaymentValidate", {
      submitHandler: this,
    });
    return this.$form.dispatchEvent(ze);
  }
  submitForm() {
    const ze = this.eventObject("onFormieSubmit", {
      submitHandler: this,
    });
    this.$form.dispatchEvent(ze) &&
      (this.settings.submitMethod === "ajax"
        ? this.formAfterSubmit()
        : this.$form.submit());
  }
  formAfterSubmit(ze = {}) {
    (ze.redirectTarget = ze.redirectTarget || window),
      this.$form.dispatchEvent(
        new CustomEvent("onAfterFormieSubmit", {
          bubbles: !0,
          detail: ze,
        })
      ),
      ze.nextPageId || this.config.Formie.refreshFormTokens(this);
  }
  formSubmitError(ze = {}) {
    this.$form.dispatchEvent(
      new CustomEvent("onFormieSubmitError", {
        bubbles: !0,
        detail: ze,
      })
    );
  }
  formDestroy(ze = {}) {
    this.$form.dispatchEvent(
      new CustomEvent("onFormieDestroy", {
        bubbles: !0,
        detail: ze,
      })
    );
  }
  registerFieldEvents(ze) {
    ze.querySelectorAll("[data-field-type]").forEach((Yr) => {
      const Kr = Yr.querySelector("input, select");
      Kr &&
        (this.addEventListener(Kr, "input", (Zr) => {
          Yr.dispatchEvent(
            new CustomEvent("input", {
              bubbles: !1,
              detail: {
                input: Zr.target,
              },
            })
          );
        }),
        this.addEventListener(Kr, "focus", (Zr) => {
          Yr.dispatchEvent(
            new CustomEvent("focus", {
              bubbles: !1,
              detail: {
                input: Zr.target,
              },
            })
          );
        }),
        this.addEventListener(Kr, "blur", (Zr) => {
          Yr.dispatchEvent(
            new CustomEvent("blur", {
              bubbles: !1,
              detail: {
                input: Zr.target,
              },
            })
          );
        }),
        Yr.dispatchEvent(
          new CustomEvent("init", {
            bubbles: !1,
            detail: {
              input: Kr,
            },
          })
        ));
    });
  }
  addEventListener(ze, Gr, Yr) {
    this.listeners[Gr] = {
      element: ze,
      func: Yr,
    };
    const Kr = Gr.split(".")[0];
    ze.addEventListener(Kr, this.listeners[Gr].func);
  }
  removeEventListener(ze) {
    const Gr = this.listeners[ze] || {};
    if (Gr && Gr.element && Gr.func) {
      const Yr = ze.split(".")[0];
      Gr.element.removeEventListener(Yr, Gr.func), delete this.listeners[ze];
    }
  }
  eventObject(ze, Gr) {
    return new CustomEvent(ze, {
      bubbles: !0,
      cancelable: !0,
      detail: Gr,
    });
  }
  getThemeConfigAttributes(ze) {
    return (this.settings.themeConfig || {})[ze] || {};
  }
  getClasses(ze) {
    return this.getThemeConfigAttributes(ze).class || [];
  }
  applyThemeConfig(ze, Gr, Yr = !0) {
    const Kr = this.getThemeConfigAttributes(Gr);
    Kr &&
      Object.entries(Kr).forEach(([Zr, Jr]) => {
        (Zr === "class" && !Yr) || ze.setAttribute(Zr, Jr);
      });
  }
}
class Formie {
  constructor() {
    this.forms = [];
  }
  initForms() {
    (this.$forms = document.querySelectorAll("form[data-fui-form]") || []),
      this.$forms.length ||
        (this.$forms = document.querySelectorAll("div[data-fui-form]") || []),
      this.$forms.forEach((ze) => {
        this.initForm(ze);
      }),
      document.dispatchEvent(
        new CustomEvent("onFormieInit", {
          bubbles: !0,
          detail: {
            formie: this,
          },
        })
      );
  }
  async initForm(ze, Gr = {}) {
    if (
      (isEmpty(Gr) && (Gr = JSON.parse(ze.getAttribute("data-fui-form"))),
      isEmpty(Gr))
    ) {
      console.error(
        "Unable to parse `data-fui-form` form attribute for config. Ensure this attribute exists on your form and contains valid JSON."
      );
      return;
    }
    const Yr = this.getFormByHashId(Gr.formHashId);
    Yr && (await this.destroyForm(Yr));
    const Kr = Gr.registeredJs || [];
    Gr.Formie = this;
    const Zr = new FormieFormBase(ze, Gr);
    if (
      (this.forms.push(Zr),
      (Zr.fieldConfigs = this.parseFieldConfig(ze, ze)),
      Kr.length)
    ) {
      if (document.querySelector(`[data-fui-scripts="${Gr.formHashId}"]`)) {
        console.warn(
          `Formie scripts already loaded for form #${Gr.formHashId}.`
        );
        return;
      }
      (Zr.$registeredJs = document.createElement("div")),
        Zr.$registeredJs.setAttribute("data-fui-scripts", Gr.formHashId),
        document.body.appendChild(Zr.$registeredJs),
        Kr.forEach((Jr) => {
          const Qr = document.createElement("script");
          Jr.src &&
            ((Qr.src = Jr.src),
            (Qr.defer = !0),
            (Qr.onload = () => {
              if (Jr.module) {
                const ei = Zr.fieldConfigs[Jr.module];
                ei &&
                  Array.isArray(ei) &&
                  ei.length &&
                  ei.forEach((ti) => {
                    this.initJsClass(Jr.module, ti);
                  }),
                  Jr.settings &&
                    this.initJsClass(Jr.module, {
                      $form: ze,
                      ...Jr.settings,
                    }),
                  Jr.module === "FormieConditions" &&
                    this.initJsClass(Jr.module, {
                      $form: ze,
                    });
              }
            })),
            Zr.$registeredJs.appendChild(Qr);
        });
    }
  }
  initJsClass(ze, Gr) {
    const Yr = window[ze];
    Yr && new Yr(Gr);
  }
  parseFieldConfig(ze, Gr) {
    const Yr = {};
    return (
      ze.querySelectorAll("[data-field-config]").forEach((Kr) => {
        let Zr = JSON.parse(Kr.getAttribute("data-field-config"));
        Array.isArray(Zr) || (Zr = [Zr]),
          Zr.forEach((Jr) => {
            Yr[Jr.module] || (Yr[Jr.module] = []),
              Yr[Jr.module].push({
                $form: Gr,
                $field: Kr,
                ...Jr,
              });
          });
      }),
      Yr
    );
  }
  getForm(ze) {
    return this.forms.find((Gr) => Gr.$form == ze);
  }
  getFormById(ze) {
    return this.forms.find((Gr) => {
      if (Gr.config) return Gr.config.formId == ze;
    });
  }
  getFormByHashId(ze) {
    return this.forms.find((Gr) => {
      if (Gr.config) return Gr.config.formHashId == ze;
    });
  }
  getFormByHandle(ze) {
    return this.forms.find((Gr) => {
      if (Gr.config) return Gr.config.formHandle == ze;
    });
  }
  async destroyForm(ze) {
    let Gr;
    if (
      (ze instanceof FormieFormBase
        ? (Gr = ze.$form)
        : ((Gr = ze), (ze = this.getForm(Gr))),
      !ze || !Gr)
    )
      return;
    const Yr = this.forms.indexOf(ze);
    Yr !== -1 &&
      (ze.$registeredJs &&
        ze.$registeredJs.parentNode &&
        ze.$registeredJs.parentNode.removeChild(ze.$registeredJs),
      ze.formDestroy({
        form: ze,
      }),
      isEmpty(ze.listeners) ||
        Object.keys(ze.listeners).forEach((Kr) => {
          ze.removeEventListener(Kr);
        }),
      ze.formTheme &&
        ze.formTheme.validator &&
        ze.formTheme.validator.destroy(),
      this.forms.splice(Yr, 1));
  }
  refreshForCache(ze, Gr) {
    const Yr = this.getFormByHashId(ze);
    if (!Yr) {
      console.error(`Unable to find form "${ze}".`);
      return;
    }
    this.refreshFormTokens(Yr, Gr);
  }
  refreshFormTokens(ze, Gr) {
    const { formHashId: Yr, formHandle: Kr } = ze.config;
    fetch(`/actions/formie/forms/refresh-tokens?form=${Kr}`)
      .then((Zr) => Zr.json())
      .then((Zr) => {
        const { $form: Jr } = ze;
        if (Zr.csrf.param) {
          const Qr = Jr.querySelector(`input[name="${Zr.csrf.param}"]`);
          Qr
            ? ((Qr.value = Zr.csrf.token),
              console.log(`${Yr}: Refreshed CSRF input %o.`, Zr.csrf))
            : console.error(
                `${Yr}: Unable to locate CSRF input for "${Zr.csrf.param}".`
              );
        } else
          console.error(
            `${Yr}: Missing CSRF token information in cache-refresh response.`
          );
        Zr.captchas &&
          Object.entries(Zr.captchas).forEach(([Qr, ei]) => {
            waitForElement(`input[name="${ei.sessionKey}"]`, Jr).then((ti) => {
              ei.value &&
                ((ti.value = ei.value),
                console.log(`${Yr}: Refreshed "${Qr}" captcha input %o.`, ei));
            }),
              setTimeout(() => {
                Jr.querySelector(`input[name="${ei.sessionKey}"]`) ||
                  console.error(
                    `${Yr}: Unable to locate captcha input for "${Qr}".`
                  );
              }, 1e4);
          }),
          ze.formTheme && ze.formTheme.updateFormHash(),
          Gr && Gr(Zr);
      });
  }
}
window.Formie = Formie;
gsapWithCSS.registerPlugin(ScrollTrigger);
window.Formie = new Formie();
let canvasManager;
class App {
  init() {
    document.body.classList.add("loaded"),
      this.initPageTransitions(),
      config.webgl.enable
        ? this.initWebGL()
        : (document.querySelector(".webgl canvas").style.background =
            "#2e61c8"),
      hour(),
      menu(),
      listenScroll(),
      new FeaturedProject(document);
  }
  initWebGL() {
    (canvasManager = canvas(!1)),
      gsapWithCSS.ticker.add((Gr, Yr) => {
        canvasManager.render(Yr);
      });
  }
  initComponents(ze) {
    header$1(),
      buttonCursor(ze),
      ze.querySelector(".js-images-trail-container") && imagesTrail(),
      medias(ze),
      gallery(ze),
      projectCarousel(ze);
  }
  initPageTransitions() {
    const ze = this;
    let Gr = 0;
    const Yr = document.querySelector(".js-header"),
      Kr = document.querySelector(".webgl-wrapper");
    ct.hooks.once(({ next: Zr }) => {
      Zr.namespace == "culture" && PresetManager.culture();
    }),
      ct.hooks.before(() => {
        document.body.classList.add("is-animating");
      }),
      ct.hooks.beforeLeave((Zr) => {
        removeRevealText(Zr.current.container);
        let Jr = lenis$1.scroll;
        (Gr = Jr),
          (Zr.current.container.style.transform = "translateY(-" + Jr + "px)"),
          lenis$1.scrollTo("top", {
            immediate: !0,
          }),
          ScrollTrigger.killAll();
      }),
      ct.hooks.beforeEnter((Zr) => {
        document.documentElement.setAttribute("data-page", Zr.next.namespace),
          canvasManager && canvasManager.setEffect("gradient", {}),
          lenis$1.stop(),
          setTimeout(() => {
            Yr.classList.remove("is--light");
          }, 500),
          revealText(Zr.next.container),
          reveal(".js-a-container", ".js-a-element"),
          setTimeout(() => {
            linesList(Zr.next.container);
          }, 500),
          sliceImage(Zr.next.container),
          splitWord(Zr.next.container),
          manifesto(Zr.next.container),
          projectThumbnail(Zr.next.container),
          footer(Zr.next.container);
      }),
      ct.hooks.leave(() => {
        document.body.style.pointerEvents = "none";
      }),
      ct.hooks.enter((Zr) => {
        new FeaturedProject(Zr.next.container);
      }),
      ct.hooks.afterEnter((Zr) => {
        document.body.classList.remove("hide-animation"),
          Zr.next.namespace !== "case-study" && lenis$1.start(),
          setTimeout(() => {
            document.body.style.pointerEvents = "";
          }, 300),
          document.querySelector(".js-form") && formFields(),
          setTimeout(() => {
            playground(Zr.next.container);
          }, 1e3);
      }),
      ct.hooks.after((Zr) => {
        document.body.classList.remove("is-animating"),
          (Zr.next.container.style.zIndex = ""),
          (Kr.style.zIndex = ""),
          document.querySelector("main").removeAttribute("data-anim-delay");
        const Qr = Zr.next.container.getAttribute("data-barba-alternate-url");
        if (Qr) {
          const ei = document.querySelector("div.lang > a");
          ei && (ei.href = Qr);
        }
        lenis$1.resize();
      }),
      ct.init({
        timeout: null,
        views: [
          home,
          {
            namespace: "case-study",
            beforeEnter() {
              document.body.classList.add("hide-animation"), caseStudyHeader();
            },
          },
          {
            namespace: "project-listing",
            beforeEnter(Zr) {
              htmx_minExports.process(Zr.next.container);
            },
            afterEnter(Zr) {
              projectFilters(Zr.next.container);
            },
          },
          {
            namespace: "archives",
            beforeEnter(Zr) {
              htmx_minExports.process(Zr.next.container);
            },
            afterEnter(Zr) {
              projectFilters(Zr.next.container);
            },
          },
          {
            namespace: "agency",
            afterEnter({ next: Zr }) {
              setTimeout(() => {
                listImage(), awards(), team(Zr.container), leadership();
              }, 1e3);
            },
          },
          {
            namespace: "culture",
            beforeEnter() {
              setTimeout(() => {
                Yr.classList.add("is--light");
              }, 500),
                setTimeout(() => {
                  PresetManager.culture(!0);
                }, 2e3);
            },
            afterEnter() {
              cultureAnimations(), overlappingSections(), overlappingImages();
            },
            beforeLeave() {
              PresetManager.normal(!0);
            },
          },
          {
            namespace: "collections",
            afterEnter(Zr) {
              collections(Zr.next.container);
            },
          },
          {
            namespace: "expertise",
            beforeEnter() {
              setTimeout(() => {
                Yr.classList.add("is--light");
              }, 500);
            },
            afterEnter(Zr) {
              projectFilters(Zr.next.container);
            },
          },
          {
            namespace: "pages-custom",
            beforeEnter() {
              setTimeout(() => {
                document.querySelector(".js-header-title") &&
                  Yr.classList.add("is--light");
              }, 500);
            },
            afterEnter() {
              setTimeout(() => {
                listImage();
              }, 1e3);
            },
          },
          {
            namespace: "contact",
            beforeEnter() {
              setTimeout(() => {
                Yr.classList.add("is--light");
              }, 500),
                window.Formie &&
                  ct.history.previous !== null &&
                  window.Formie.initForms();
            },
            afterEnter(Zr) {
              const Jr = Number(
                document.querySelector("main").getAttribute("data-anim-delay")
              );
              contact(Zr.next.container, Jr);
            },
            beforeLeave() {
              gsapWithCSS.killTweensOf(".js-header-menu"),
                gsapWithCSS.to(document.querySelector(".js-header-menu"), {
                  y: 0,
                  duration: 1.5,
                });
            },
          },
          {
            namespace: "404",
            beforeEnter() {
              setTimeout(() => {
                Yr.classList.add("is--light");
              }, 500);
            },
          },
        ],
        transitions: [
          {
            name: "default-transition",
            sync: !0,
            leave(Zr) {
              return new Promise((Jr) => {
                document.body.classList.contains("menu-is-active")
                  ? setTimeout(Jr, 0)
                  : (horizontalClip(Zr.current.container, 1, Gr),
                    Zr.next.namespace !== "home" &&
                      Zr.next.namespace !== "culture" &&
                      Zr.next.namespace !== "expertise" &&
                      Zr.next.namespace !== "contact" &&
                      !Zr.next.container.querySelector(".js-header-title") &&
                      horizontalClip(Kr, 1, 0),
                    setTimeout(Jr, 2e3));
              });
            },
            beforeEnter({ next: Zr }) {
              (Zr.container.style.zIndex = -1),
                Zr.namespace == "home" && (Kr.style.zIndex = -1);
            },
            enter({ next: Zr }) {
              this.async()(), ze.initComponents(Zr.container);
            },
            afterEnter() {
              ScrollTrigger.refresh();
            },
            once({ next: Zr }) {
              ze.initComponents(Zr.container),
                Zr.namespace != "home" &&
                  (document.getElementById("loader").style.display = "none"),
                Zr.namespace == "home" &&
                  (config.loadingAnim && !loadingAnimplayed
                    ? loadingAnimation().then(() => {})
                    : (document.getElementById("loader").style.display =
                        "none")),
                (document.body.style.opacity = 1),
                (config.loadingAnim = !1);
            },
          },
          {
            name: "case-study-transition",
            sync: !0,
            to: {
              namespace: ["case-study"],
            },
            leave(Zr) {
              return new Promise((Jr) => {
                gsapWithCSS.to(
                  Zr.current.container.querySelector(".main-wrapper"),
                  {
                    x: "-30%",
                    duration: 10,
                    ease: "power3.inOut",
                    delay: 0.3,
                  }
                ),
                  setTimeout(Jr, 2e3);
              });
            },
            enter({ next: Zr }) {
              this.async()(), ze.initComponents(Zr.container);
            },
            afterEnter() {
              ScrollTrigger.refresh();
            },
            once({ next: Zr }) {
              ze.initComponents(Zr.container),
                Zr.namespace != "home" &&
                  (document.getElementById("loader").style.display = "none"),
                (document.body.style.opacity = 1),
                (config.loadingAnim = !1);
            },
          },
        ],
      });
  }
}
const App$1 = new App();
App$1.init();
export { __vite_legacy_guard };
//# sourceMappingURL=app-462404a9.js.map
